import OreIdContext from '../core/IOreidContext';
import { Observable } from '../utils/observable';
import { AccountName, ChainAccount, ChainNetwork, ExternalWalletType } from '../common/models';
import { NewAccountOptions, NewAccountWithOreIdResult } from '../core/models';
import { UserData, UserPermissionData, UserPermissionForChainAccount, WalletPermission } from './models';
import { AccessTokenHelper } from '../auth/accessTokenHelper';
export declare type SubscriberUser = (values: User) => void;
export declare class User extends Observable<SubscriberUser> {
    constructor(args: {
        oreIdContext: OreIdContext;
        accessTokenHelper: AccessTokenHelper;
        accountName: AccountName;
    });
    private _accountName;
    private _accessTokenHelper;
    private _oreIdContext;
    /** User's basic information and blockchain accounts (aka permissions) */
    private _userSourceData;
    private get accessToken();
    /** User's OreID (accountName) */
    get accountName(): AccountName;
    /** User's personal info (e.g. name, email, picture) */
    get data(): UserData;
    /** Whether user's data has been retrieved with getData() */
    get hasData(): boolean;
    private setUserSourceData;
    /** Return Blockchain accounts associated with the user's OreId account */
    private getChainAccounts;
    /** Whether we have a valid access token for the current user */
    get isLoggedIn(): boolean;
    /** runs when accessTokenHelper changes */
    private onUpdateAccessTokenHelper;
    /** throw if user data hasn't been retrieved yet */
    private assertUserHasData;
    /** throw if user hasn't have a valid email (i.e. user.email) */
    private assertUserHasValidEmail;
    /** Get the user info from ORE ID API for a given user account and (usually) save the user into localStorage 'cache'
     *  Must have a valid accessToken to retrieve user
     */
    getData(forceRefresh?: boolean): Promise<UserData>;
    /** Clears user's accessToken and user profile data */
    logout(): void;
    /** Request OREID to create a new blockchain account in an existing user's wallet
     *  This is an advanced feature - it most cases, blockchain accounts will be created automatically upon first login
     */
    /** Returns a fully formed url to redirect the user's browser to create a new chain account using ORE ID
     *  This function calls the /new-account web endpoint
     *  Returns: Callback returns new chainAccount name */
    getNewChainAccountUrl(newAccountOptions: NewAccountOptions): Promise<NewAccountWithOreIdResult>;
    /** Delete a test user
     * Test users are created by setting isTestUser:true on first authentication)
     */
    deleteTestUser(): Promise<import("../api").ApiDeleteTestUserResult>;
    /** If the user hasn't already setup their wallet, this will prompt the setup on their next interactive authentication
     * Used to turn-off the delayWalletSetup for a user's account
     * delayWalletSetup is enabled by passing delayWalletSetup:true for a user's first authentication (e.g. popup.auth(delayWalletSetup:true))
     * Delayed Wallet Setup allows a user to login without creating blockchain accounts right away
     * Call this function (to disable delayWalletSetup) just before the user needs a blockchain account (e.g. before signing a transaction)
     */
    disableDelayedWalletSetup(): Promise<import("../api/endpoints/updateDelayWalletSetup").CallApiUpdateDelayWalletSetupResult>;
    /** Send a code to the user's primary email (user.email) - in order to verify the user has access to it
     *  After sending the code, use checkVerificationCodeForEmail() to verify that the user received the code */
    sendVerificationCodeToEmail(): Promise<import("../api").ApiMessageResult>;
    /** Confirm that the code matches the last one just sent to the email by sendVerificationCodeToEmail() */
    checkVerificationCodeForEmail({ code }: {
        code: string;
    }): Promise<import("../api").ApiMessageResult>;
    /** Map permission from server data to local UserPermission object */
    mapUserPermission(permission: UserPermissionData): UserPermissionForChainAccount;
    /** returns the UserPermissins a chainNetwork/chainAccount
     * if defaultOnly = true, returns the single default permission for the chainAccount
     */
    getPermissionForChainAccount(chainAccount: ChainAccount, chainNetwork: ChainNetwork): UserPermissionForChainAccount[];
    getDefaultPermissionForChainAccount(chainAccount: ChainAccount, chainNetwork: ChainNetwork): UserPermissionForChainAccount[];
    /** Update permissions for user's ORE Account if any */
    updatePermissionsIfNecessary(args: {
        chainAccount: ChainAccount;
        permissions: WalletPermission[];
        chainNetwork: ChainNetwork;
        walletType: ExternalWalletType;
    }): Promise<void>;
    /** for all walletPermissions not already in the user's OreID wallet, add it by calling the api (addPermission) */
    addWalletPermissionsToOreIdAccount(args: {
        chainAccount: ChainAccount;
        chainNetwork: ChainNetwork;
        permissions: WalletPermission[];
        walletType: ExternalWalletType;
    }): Promise<void>;
}
