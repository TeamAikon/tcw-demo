{"version":3,"file":"index.js","sources":["../src/api/models.ts","../src/common/models.ts","../src/wallets/models.ts","../src/core/models.ts","../src/webWidget/models.ts","../src/utils/helpers.ts","../src/api/helpers.ts","../src/api/endpoints/addPermission.ts","../src/api/endpoints/appToken.ts","../src/api/endpoints/canAutoSign.ts","../src/api/endpoints/convertOauth.ts","../src/api/endpoints/custodialMigrateAccount.ts","../src/api/endpoints/custodialNewAccount.ts","../src/api/endpoints/custodialSignString.ts","../src/api/endpoints/deleteTestUser.ts","../src/api/endpoints/getConfig.ts","../src/api/endpoints/getUser.ts","../src/api/endpoints/loginUserWithToken.ts","../src/api/endpoints/newUserWithToken.ts","../src/api/endpoints/passwordLessSendCode.ts","../src/api/endpoints/passwordLessVerifyCode.ts","../src/api/endpoints/signTransaction.ts","../src/core/urlGenerators.ts","../src/utils/chainUtils.ts","../src/transit/transitProviders.ts","../src/transit/TransitHelper.ts","../src/ual/ualProviders.ts","../src/ual/UalHelper.ts","../src/utils/observable.ts","../src/api/endpoints/updateDelayWalletSetup.ts","../src/user/user.ts","../src/auth/accessTokenHelper.ts","../src/auth/auth.ts","../src/constants.ts","../src/transaction/transaction.ts","../src/utils/hmac.ts","../src/utils/localState.ts","../src/utils/storage.ts","../src/core/Settings.ts","../src/wallets/WalletHelper.ts","../src/core/oreId.ts","../src/plugins/models.ts"],"sourcesContent":["import { AccountName, AccountType, ChainAccount, ChainNetwork } from '../common/models'\n\nexport enum RequestType {\n  Get = 'get',\n  Post = 'put',\n}\n\nexport enum ApiEndpoint {\n  AddPermission = 'account/add-permission',\n  AppToken = 'app-token',\n  CanAutoSign = 'transaction/can-auto-sign',\n  ConvertOauthTokens = 'account/convert-oauth',\n  CustodialMigrateAccount = 'custodial/migrate-account',\n  CustodialNewAccount = 'custodial/new-user',\n  CustodialSignString = 'custodial/sign-string',\n  DeleteTestUser = 'account/delete-test-user',\n  CustodialSign = 'custodial/sign',\n  GetUser = 'account/user',\n  GetConfig = 'services/config',\n  LoginUserWithToken = 'account/login-user-with-token',\n  NewUserWithToken = 'account/new-user-with-token',\n  PasswordLessSendCode = 'account/login-passwordless-send-code',\n  PasswordLessVerifyCode = 'account/login-passwordless-verify-code',\n  TransactionSign = 'transaction/sign',\n  UpdateDelayWalletSetup = 'account/update-delay-wallet-setup',\n}\n\n/** Typical API Response (when no data returned) */\nexport type ApiMessageResult = {\n  message?: string\n  error?: string\n  processId?: string\n  success?: string\n}\n\nexport type ApiResultWithErrorCode = {\n  message?: string\n  processId?: string\n  errorCode?: string\n  errorMessage?: string\n}\n\n// API params\n\nexport type CustodialMigrateAccountParams = {\n  account: AccountName\n  chainAccount: ChainAccount\n  chainNetwork: ChainNetwork\n  toType: AccountType\n  userPassword: string\n}\n\nexport type CustodialMigrateAccountApiBodyParams = {\n  account: AccountName\n  chain_account: ChainAccount\n  chain_network: ChainNetwork\n  to_type: AccountType\n  user_password: string\n}\n","export type ProcessId = string\nexport type AppAccessToken = string\nexport type AccountName = string\nexport type ChainAccount = string\nexport type PublicKey = string\nexport type PermissionName = string\nexport type Color = string\n\nexport enum ConfigType {\n  Chains = 'chains',\n}\n\n/** Flavor of chain network */\nexport enum ChainPlatformType {\n  algorand = 'algorand',\n  eos = 'eos',\n  ethereum = 'ethereum',\n  ore = 'ore',\n}\n\n/** Named chain network */\nexport enum ChainNetwork {\n  // Algo\n  AlgoMain = 'algo_main',\n  AlgoBeta = 'algo_beta',\n  AlgoTest = 'algo_test',\n  // AVALANCHE\n  AvalancheC_Main = 'avalanchec_main',\n  AvalancheC_Fuji = 'avalanchec_fuji',\n  // Dsp/EOS\n  DspEosKylin1 = 'kylin-dsp-1.liquidapps.io',\n  DspEosKylin2 = 'kylin-dsp-2.liquidapps.io',\n  DspMoonlighting = 'eos_moon_blockstartdsp_com',\n  DspMoonlightingTest = 'eos_moontest_blockstartdsp_com',\n  // DOS\n  DosMain = 'dos_main',\n  DosTest = 'dos_test',\n  // ETH\n  EthMain = 'eth_main',\n  EthRopsten = 'eth_ropsten',\n  EthRinkeby = 'eth_rinkeby',\n  EthGoerli = 'eth_goerli',\n  // EOS\n  EosMain = 'eos_main',\n  EosKylin = 'eos_kylin',\n  EosJungle = 'eos_jungle',\n  MigrateEosMain = 'migrate_eos_main',\n  // ORE\n  OreMain = 'ore_main',\n  OreTest = 'ore_test',\n  // Polygon\n  PolygonMain = 'polygon_main',\n  PolygonMumbai = 'polygon_mumbai',\n  // TELOS\n  TelosMain = 'telos_main',\n  TelosTest = 'telos_test',\n  // TELOS EVM\n  TelosEvmMain = 'telosevm_main',\n  TelosEvmTest = 'telosevm_test',\n  // UX\n  UxMain = 'ux_main',\n  // UxTest = 'ux_test', (there is no test network) - this is left here as a placeholder\n  // WAX\n  WaxMain = 'wax_main',\n  WaxTest = 'wax_test',\n}\n\n/** Physical structure of account */\nexport enum AccountType {\n  Native = 'native',\n  Pending = 'pending',\n  VirtualLiquid = 'liquid',\n  VirtualNested = 'nested',\n}\n\nexport enum LoginProvider {\n  Custodial = 'custodial',\n  Apple = 'apple',\n  Email = 'email',\n  Facebook = 'facebook',\n  Github = 'github',\n  Google = 'google',\n  Instagram = 'instagram',\n  Kakao = 'kakao',\n  Line = 'line',\n  LinkedIn = 'linkedin',\n  Phone = 'phone',\n  Twitch = 'twitch',\n  Twitter = 'twitter',\n}\n\nexport enum ExternalWalletType {\n  AlgoSigner = 'algosigner',\n  Anchor = 'anchor',\n  Keycat = 'keycat',\n  Ledger = 'ledger',\n  Lynx = 'lynx',\n  Meetone = 'meetone',\n  Metro = 'metro',\n  Portis = 'portis',\n  Scatter = 'scatter',\n  SimpleEos = 'simpleos',\n  TokenPocket = 'tokenpocket',\n  WalletConnect = 'walletconnect',\n  Web3 = 'web3',\n  WhaleVault = 'whalevault',\n  Wombat = 'wombat',\n}\n\n/** All auth providers - including OreId login types (eg 'Facebook') and wallets (eg 'Scatter') */\nexport enum AuthProvider {\n  // ORE ID LoginProvider\n  Custodial = 'custodial',\n  Apple = 'apple',\n  Email = 'email',\n  Facebook = 'facebook',\n  Github = 'github',\n  Google = 'google',\n  Instagram = 'instagram',\n  Kakao = 'kakao',\n  Line = 'line',\n  LinkedIn = 'linkedin',\n  Phone = 'phone',\n  Twitch = 'twitch',\n  Twitter = 'twitter',\n  // ExternalWalletType\n  AlgoSigner = 'algosigner',\n  Anchor = 'anchor',\n  Keycat = 'keycat',\n  Ledger = 'ledger',\n  Lynx = 'lynx',\n  Meetone = 'meetone',\n  Metro = 'metro',\n  Portis = 'portis',\n  Scatter = 'scatter',\n  SimpleEos = 'simpleos',\n  TokenPocket = 'tokenpocket',\n  WalletConnect = 'walletconnect',\n  Web3 = 'web3',\n  WhaleVault = 'whalevault',\n  Wombat = 'wombat',\n  // placeholder for signing - meaning non an external wallet\n  OreId = 'oreid',\n}\n\nexport enum ApiKeyUsedFor {\n  AccountMigration = 'accountMigration',\n  Airdrop = 'airdrop',\n  AdminAccess = 'adminAccess',\n  AutoSigning = 'autoSigning',\n  ChangePassword = 'changePassword',\n  CreateUser = 'createUser',\n  ProxySigning = 'proxySigning',\n  TokenFunding = 'tokenFunding',\n}\n\n/** type returned by oreid sevice config endpoint for chains */\nexport type SettingChainNetwork = {\n  blockExplorerAccountUrl: string\n  blockExplorerTxUrl: string\n  chainCommunicationSettings: any\n  createBridgeContract: string\n  defaultTransactionSettings?: any\n  /** Url of monitor */\n  dfuseNetwork?: string\n  hosts: SettingChainNetworkHost[]\n  isTestNetwork: boolean\n  monitorConfig?: {\n    dfuseSupported: boolean\n    endpoint: string\n  }\n  name: string\n  logoUrl: string\n  network: ChainNetwork\n  type: ChainPlatformType\n}\n\nexport type SettingChainNetworkHost = {\n  chainId: string\n  /** fork name used to designate a major version */\n  forkName?: string\n  host: string\n  port: number\n  protocol: 'https' | 'http'\n}\n\n// Chain specific\n\nexport type AlgorandMultiSigOptions = {\n  version: number\n  threshold: number\n  addrs: string[]\n}\n\n/** helper type to index a JSON object */\nexport interface Lookup {\n  [key: string]: any\n}\n\nexport type JSONArray = Array<JSONValue>\n\nexport type JSONValue = string | number | boolean | Function | JSONObject | JSONArray\n\nexport interface JSONObject {\n  [x: string]: JSONValue\n}\n","import { ExternalWalletType, ChainPlatformType } from '../common/models'\n\nexport enum ExternalWalletInterface {\n  Transit = 'transit',\n  Ual = 'ual',\n}\n\nexport type WalletProviderAttributes = {\n  providerName: ExternalWalletType\n  chainType: ChainPlatformType\n  providerId: string\n  requiresLogin: boolean\n  supportsDiscovery: boolean\n  supportsSignArbitrary: boolean\n  requiresLogoutLoginToDiscover: boolean\n  requiresDiscoverToLogin: boolean\n  defaultDiscoveryPathIndexList?: number[]\n  helpText: {\n    login: string\n    sign: string\n    discover: string\n    versionsRequired: string\n  }\n  logoUrl: string\n}\n","import { Request, Response } from 'express' // NOTE: We are only using types here - Express library won't be emitted in the build here\nimport { LoginOptions } from '../auth/models'\nimport {\n  AccountName,\n  AccountType,\n  AlgorandMultiSigOptions,\n  AppAccessToken,\n  AuthProvider,\n  ChainAccount,\n  ChainNetwork,\n  ExternalWalletType,\n  ProcessId,\n  PublicKey,\n} from '../common/models'\nimport { UserData } from '../user/models'\n\nexport enum RecoverAccountAction {\n  Republic = 'republic',\n}\n\n/** For creating a new chainAccount in an existing wallet */\nexport type NewAccountOptions = {\n  account: AccountName // existing wallet account name (ore account)\n  accountOptions?: CreateOnChainAccountsOptions\n  accountType: AccountType\n  chainNetwork?: ChainNetwork\n  provider?: AuthProvider // TODO: confirm if we need this\n  state?: string\n}\n\nexport type DiscoverOptions = {\n  walletType: ExternalWalletType\n  chainNetwork?: ChainNetwork\n  oreAccount?: ChainAccount\n  discoveryPathIndexList?: number[]\n}\n\nexport type AuthResult = {\n  account?: AccountName\n  accessToken?: string\n  idToken?: string\n  errors?: string[]\n  processId?: ProcessId\n  state?: string\n}\n\nexport type NewAccountResult = {\n  chainAccount?: string\n  errors?: string[]\n  processId?: ProcessId\n  state?: string\n}\n\nexport type SignResult = {\n  signedTransaction?: string\n  transactionId: string\n  errors?: string[]\n  processId?: ProcessId\n  state?: string\n}\n\n// Todo: implement passwordReset flow/url\nexport type PasswordResetOptions = {\n  provider: AuthProvider\n  chainAccount?: ChainAccount\n  chainNetwork?: ChainNetwork\n  state?: string\n  currentAccountPassword?: string // if the user's current password is known, it can be passed in to appAccessToken request\n}\n\nexport type GetRecoverAccountUrlResult = string\n\nexport type LoginWithOreIdResult = {\n  accessToken?: string\n  loginUrl?: string\n  errors?: string\n  processId?: ProcessId\n}\n\nexport type NewAccountWithOreIdResult = {\n  newAccountUrl: string\n  errors?: string\n}\n\nexport type SignWithOreIdResult = {\n  processId?: ProcessId\n  signedTransaction?: string\n  transactionId?: string\n  signUrl?: string\n  errors?: string\n}\n\nexport type SignStringParams = {\n  account: AccountName\n  walletType: ExternalWalletType\n  chainAccount?: ChainAccount\n  chainNetwork: ChainNetwork\n  string: string\n  message: string\n  metadata?: any\n}\n\nexport type SignStringResult = {\n  signedString: string\n}\n\n// Function Params\n\nexport type GetOreIdNewChainAccountUrlParams = NewAccountOptions & {\n  callbackUrl: string\n  backgroundColor?: string\n}\n\nexport type GetOreIdAuthUrlParams = LoginOptions & {\n  callbackUrl: string\n  backgroundColor?: string\n}\n\nexport type GetOreIdRecoverAccountUrlParams = LoginOptions & {\n  account: AccountName\n  backgroundColor?: string\n  callbackUrl: string\n  recoverAction?: RecoverAccountAction\n  overrideAppAccessToken?: AppAccessToken\n}\n\nexport type AppAccessTokenMetadata = {\n  paramsNewAccount?: NewAccountAppTokenParams\n  newAccountPassword?: string\n  currentAccountPassword?: string\n  secrets?: {\n    type: string\n    value: string\n  }[]\n}\n\n/** params for calling new-account service web endpoint (sent via AppAccessToken request) */\nexport type NewAccountAppTokenParams = {\n  account: AccountName // wallet account (ore account name)\n  accountType: AccountType\n  chainNetwork?: ChainNetwork // chainNetwork to create new account on\n  accountOptions: CreateOnChainAccountsOptions\n}\n\nexport type CreateOnChainAccountsOptions = {\n  keys?: {\n    publicKeys: {\n      owner?: PublicKey\n      active: PublicKey\n    }\n  }\n  multisigOptions?: AlgorandMultiSigOptions // || future multisig option types\n}\n\ntype ParamsForRequest = {\n  appId?: string\n  accessToken?: string\n  chainAccount?: string\n  idToken?: string\n  processId?: ProcessId\n  state?: string\n  signedTransaction?: string\n  transactionId?: string\n  user?: UserData\n}\n\ntype ParamsForResponse = {\n  myField?: string\n}\n\nexport type RequestWithParams = Request & ParamsForRequest\nexport type ResponseWithParams = Response & ParamsForResponse\n\n/** Generic SignatureProvider interface */\nexport interface SignatureProvider {\n  /** Public keys associated with the private keys that the `SignatureProvider` holds */\n  getAvailableKeys: () => Promise<string[]>\n  /** Sign a transaction */\n  sign: (args: SignatureProviderArgs) => Promise<SignatureProviderSignResult>\n}\n\n/** SignatureProvider params for sign() function */\nexport interface SignatureProviderArgs {\n  /** Chain transaction is for */\n  chainId: string\n  /** Public keys associated with the private keys needed to sign the transaction */\n  requiredKeys: string[]\n  /** Transaction to sign */\n  serializedTransaction: Uint8Array\n  /** ABIs for all contracts with actions included in `serializedTransaction` */\n  abis: BinaryAbi[]\n}\n\n/** Results from external wallet signTransction() - e.g. via Transit or UAL */\nexport interface SignatureProviderSignResult {\n  signatures: string[]\n  serializedTransaction: Uint8Array\n}\n\n/** Structure for the raw form of ABIs */\nexport interface BinaryAbi {\n  /** account which has deployed the ABI */\n  accountName: string\n  /** abi in binary form */\n  abi: Uint8Array\n}\n","/* eslint-disable @typescript-eslint/indent */\n\nimport { AuthProvider } from '../common/models'\n\n// IMPORTANT: These types are copied from oreid-service webwidget code\n\n/** version of widget served by server that matches these types */\nexport const WidgetVersion = '1'\n\n/** Subset of OreIdOptions used by widget */\nexport type WebWidgetOreIdOptions = {\n  accessToken?: string\n  appId: string\n  backgroundColor?: string\n  oreIdUrl?: string\n  setBusyCallback?: (isBusy: boolean) => void\n  eosTransitWalletProviders?: any[] // TODO: remove these from being passed to webwidget\n}\n\nexport type WebWidgetOnSuccess = ({ data }: { data?: any }) => void\nexport type WebWidgetOnError = (error: Error) => void\n\nexport type WebWidgetProps = {\n  oreIdOptions: WebWidgetOreIdOptions\n  action: {\n    name: WebWidgetAction | string\n    params: WebWidgetActionParams\n  } | null\n  /** callback on success */\n  onSuccess: WebWidgetOnSuccess\n  /** callback if error - error message is a delimited string of error codes and/or an error message */\n  onError: WebWidgetOnError\n  /** source url for request (e.g. https://yourapp.com) */\n  origin: string\n  timeout?: number\n  /** the time of the request (Epoch time) */\n  timestamp?: number\n  /** the signture of the request body */\n  signature?: string\n}\n\n/** Actions supported by widget */\nexport enum WebWidgetAction {\n  Auth = 'auth',\n  Logout = 'logout',\n  NewChainAccount = 'newChainAccount',\n  RecoverAccount = 'recoverAccount',\n  Sign = 'sign',\n  Buy = 'buy',\n  KeyExport = 'keyExport',\n}\n\n/** Alternative method to sign a transaction or string (chain specific) */\nexport enum SignStringMethod {\n  // Sign String methods\n  EthereumPersonalSign = 'ethereum.personal-sign',\n  EthereumSignTypedData = 'ethereum.sign-typed-data',\n  EthereumSign = 'ethereum.eth-sign',\n}\n\n/** params for Logout action */\nexport type WebWidgetLogoutParams = {\n  /** comma seperated list of login providers e.g. 'google, facebook' or 'all' */\n  providers?: string\n}\n\n/** valid action param types */\nexport type WebWidgetActionParams =\n  | WebWidgetAuthParams\n  | WebWidgetLogoutParams\n  | WebWidgetNewChainAccountParams\n  | WebWidgetRecoverAccountParams\n  | WebWidgetSignParams\n  | any\n\n/** params for Auth action */\nexport type WebWidgetAuthParams = {\n  /** Login provider (e.g. google, email) */\n  provider?: AuthProvider\n  /** user's idToken - can be from a 3rd-party (e.g. Google) - can be used to create a new user account */\n  idToken?: string\n  /** passwordless login - email to login with (and to send a verification code to) */\n  email?: string\n  /** passwordless login - phone to login with (and to send a verification code to) */\n  phone?: string\n  /** whether we should link this login attempt to an existing user */\n  linkToAccount?: boolean\n  /** whether we should skip creation of blockchain accounts for a new user */\n  delayWalletSetup?: boolean\n}\n\nexport type WebWidgetBuyParams = {\n  /** Blockchain account (usually the account signing the transaction) */\n  chainAccount: string\n  /** A valid chain network name (e.g. eth_main) */\n  chainNetwork: string\n  /** allowed chain networks for buying */\n  limitToChains?: string[]\n  /** allowed symbols to be bought */\n  limitToSymbols?: string[]\n  /** when true, accepts test credit card number  */\n  useTestMode?: boolean\n}\n\n/** params for New Account action - to create a new blockchain account 'within' a user's OreID account */\nexport type WebWidgetNewChainAccountParams = {\n  /** User's OreID account (aka wallet account name) */\n  account: string\n  /** Optional JSON object of account creation options (blockchain-specific) */\n  accountOptions?: any\n  /** Type of blockchain account to create - usually 'native' */\n  accountType: string\n  /** A valid chain network name (e.g. eth_main) */\n  chainNetwork: string\n}\n\n/** params for Recover Account action */\nexport type WebWidgetRecoverAccountParams = {\n  /** User's OreID account (aka wallet account name) */\n  account: string\n  /** Login provider (e.g. email) - forces user to haved logged-in using this provider before recovery */\n  provider?: string\n  /** Type of account recovery requested */\n  recoverAction?: string\n}\n\n/** params for Sign action */\nexport type WebWidgetSignParams = {\n  /** User's OreID account (aka wallet account name) */\n  account: string\n  /** Blockchain account (usually the account signing the transaction) */\n  chainAccount?: string\n  /** A valid chain network name (e.g. eth_main) */\n  chainNetwork: string\n  /** The maximum number of seconds for which the transaction will be valid (depends on blockchain-specific limits) */\n  expireSeconds?: number\n  /** A base64, stringified, JSON object of the transaction to sign - which already includes one or more signatures */\n  encodedSignedTransaction?: string\n  /** A base64, stringified, JSON object of the transaction to sign (format depends on blockchain type) */\n  encodedTransaction?: string\n  /** Optional - provided instead of transaction - OreID must have this transaction saved in its database (only applies to special situations) */\n  transactionRecordId?: string\n  /** Optional params for signing */\n  signOptions?: {\n    /** Whether an option is displayed to the user to sign with a key in an external wallet (e.g. Metamask) */\n    allowChainAccountSelection?: boolean\n    /** Whether signed transaction should be automatically sent to the chain */\n    broadcast?: boolean\n    /** Comma seperated string of accounts for which OreID should add signatures - only valid for accounts managed by OreId */\n    multisigChainAccounts?: string\n    /** Prevents the use of auto sign functionality while signing the transaction */\n    preventAutosign?: boolean\n    /** whether the complete signed transaction should be returned */\n    returnSignedTransaction?: boolean\n    /** optional signMethod - uses default method if not provided */\n    // signMethod?: SignTransactionMethod  // Expected to be used for ERC-712, etc.\n  }\n  /** populated if signing a string instead of a transaction */\n  stringToSign?: string\n  signStringMethod?: SignStringMethod\n}\n\nexport type WebWidgetKeyExportParams = {}\n\n/** Result for Auth action */\nexport type WebWidgetAuthResult = {\n  /** User's OreID account (aka wallet account name) */\n  account: string\n  /** user's accessToken signed by ORE ID (in JWT format) */\n  accessToken?: string\n  /** user's idToken signed by ORE ID (in JWT format) */\n  idToken?: string\n}\n\nexport type WebWidgetBuyResult = {\n  /** uid for tracking buy requested */\n  requesteId: string\n  /** operation success */\n  success: boolean\n  /** error code if any */\n  errorCode?: string\n  /** error message if any */\n  errorMessage?: string\n}\n\n/** Result for a server-side Logout action (Depricated) */\nexport type WebWidgetLogoutResult = {}\n\n/** Result for New Chain Account action */\nexport type WebWidgetNewChainAccountResult = {\n  /** User's new blockchain account name */\n  chainAccount: string\n}\n\n/** Result for a Recover Account action */\nexport type WebWidgetRecoverAccountResult = WebWidgetAuthResult\n\n/** Result for Sign transaction action */\nexport type WebWidgetSignResult = {\n  /** array of signatures created during sign flow - signatures might be stringified objects or pure strings */\n  signatures?: string[]\n  /** completed signed transaction (stringified) */\n  signedTransaction?: string\n  /** transactionId to identify transaction on blockchain (if returned) */\n  transactionId?: string\n}\n\n/** Result for Key Export action */\nexport type WebWidgetKeyExportResult = {\n  //  no result - just success or error\n}\n\nexport type WebWidgetActionResult =\n  | WebWidgetAuthResult\n  | WebWidgetLogoutResult\n  | WebWidgetNewChainAccountResult\n  | WebWidgetRecoverAccountResult\n  | WebWidgetSignResult\n  | WebWidgetKeyExportResult\n","/*\n    helper functions\n */\nimport { AxiosError } from 'axios'\nimport { v4 as uuidv4 } from 'uuid'\nimport canonicalize from 'canonicalize'\nimport jwtDecode from 'jwt-decode'\nimport { Base64 } from 'js-base64'\nimport { JWTToken } from '../auth/models'\nimport { AuthProvider, ExternalWalletType, JSONObject, Lookup } from '../common/models'\n\nconst TRACING = false // enable when debugging to see detailed outputs\n\n// split a string or array at a given index position\nexport const splitAt = (index: number, dropChars: number) => (x: string) =>\n  [x.slice(0, index), x.slice(index + dropChars)]\n\nconst replaceAll = (inString: string, search: string, replacement: string) => {\n  return inString.replace(new RegExp(search, 'g'), replacement)\n}\n\nexport default class Helpers {\n  static isInBrowser = typeof window !== 'undefined'\n\n  static isNullOrEmpty(obj: any) {\n    if (obj === undefined) {\n      return true\n    }\n    if (obj === null) {\n      return true\n    }\n    // Check for an empty array too\n    if (Array.isArray(obj)) {\n      if (obj.length === 0) {\n        return true\n      }\n    }\n    return Object.keys(obj).length === 0 && obj.constructor === Object\n  }\n\n  // log data\n  static log(message: string, data?: any) {\n    if (TRACING) {\n      // eslint-disable-next-line no-console\n      console.log(message, data)\n    }\n  }\n\n  /** Decodes a JWT token string\n   *  If token can't be decoded (e.g. corrupted), returns null */\n  static jwtDecodeSafe(token: string): Partial<JWTToken> {\n    let decoded: JWTToken\n    if (this.isNullOrEmpty(token)) {\n      return null\n    }\n    try {\n      decoded = jwtDecode(token) as JWTToken\n    } catch (error) {\n      // throw Error(`Problem decoding or validating JWT token: ${token} error:${error}`)\n    }\n    return decoded\n  }\n\n  /**  Takes a url string and converts it to an object of {paramNane, paramValue}\n   * e.g input: https://xxx?enabled&name=value&name2=val2\n   *   returns: { 'enabled': true, 'name':'value', 'name2':'val2' }\n   * if the parameter only has a name and no value, then its value is set to 'true'\n   * */\n  static parseUrlParams(fullPath: string) {\n    const urlParamsObject: JSONObject = {}\n    let searchString\n    try {\n      const urlObject = new URL(fullPath)\n      if (urlObject.hash) {\n        searchString = urlObject.hash.slice(1) // remove #\n      } else {\n        searchString = urlObject.search\n      }\n    } catch (error) {\n      searchString = fullPath // treat as partial url string E.g. '?param1=value1...'\n    }\n\n    const urlParams = new URLSearchParams(searchString)\n    urlParams.forEach((value, key) => {\n      urlParamsObject[key] = decodeURIComponent(value) || 'true'\n    })\n\n    return urlParamsObject\n  }\n\n  /** Returns Null if parse fails\n   *  Reinflates a serialized object (e.g. UInt8Array) if found in JSON\n   */\n  static tryParseJSON(jsonString: any, unescape = false, replaceQuotes = false) {\n    let finalJsonString = ''\n    if (!jsonString || !Helpers.isAString(jsonString) || jsonString.trim() === '') return null\n    try {\n      if (unescape) {\n        // eslint-disable-next-line no-param-reassign\n        jsonString = decodeURI(jsonString)\n      }\n      finalJsonString = jsonString\n      if (replaceQuotes) {\n        // eslint-disable-next-line quotes\n        finalJsonString = replaceAll(jsonString, \"'\", '\"')\n        finalJsonString = replaceAll(finalJsonString, '`', '\"')\n      }\n      const o = JSON.parse(finalJsonString, Helpers.jsonParseComplexObjectReviver)\n      // Handle non-exception-throwing cases:\n      // Neither JSON.parse(false) or JSON.parse(1234) throw errors, hence the type-checking,\n      // but... JSON.parse(null) returns null, and typeof null === \"object\",\n      // so we must check for that, too. Thankfully, null is falsey, so this suffices:\n      if (o && typeof o === 'object') {\n        return o\n      }\n    } catch (error) {\n      // TODO: should log trace this detail: ('error parsing JSON', { jsonString, doubleQuotes, error });\n    }\n\n    return null\n  }\n\n  /**\n   * The reviver function passed into JSON.parse to implement custom type conversions.\n   * If the value is a previously stringified buffer we convert it to a Buffer,\n   * If its an object of numbers, we convert to UInt8Array {\"0\":2,\"1\":209,\"2\":8 ...}\n   * otherwise return the value\n   */\n  static jsonParseComplexObjectReviver(key: string, value: any) {\n    // Convert Buffer\n    if (\n      value !== null &&\n      typeof value === 'object' &&\n      'type' in value &&\n      value.type === 'Buffer' &&\n      'data' in value &&\n      Array.isArray(value.data)\n    ) {\n      return Buffer.from(value.data)\n    }\n\n    // Convert number array to UInt8Array e.g. {\"0\":2,\"1\":209,\"2\":8 ...}\n    if (\n      value !== null &&\n      typeof value === 'object' &&\n      !Array.isArray(value) &&\n      '0' in value &&\n      Helpers.isANumber(value['0'])\n    ) {\n      const values = Object.entries(value).map(([, val]) => val)\n      // if array only has 8-bit numbers, convert it to UInt8Array\n      if (values.every(val => Helpers.isANumber(val) || val < 256)) {\n        return new Uint8Array(values as number[])\n      }\n    }\n\n    // Return parsed value without modifying\n    return value\n  }\n\n  static base64DecodeSafe(encodedString: string) {\n    let decoded: any = {}\n    if (this.isNullOrEmpty(encodedString)) {\n      return null\n    }\n    try {\n      decoded = Base64.decode(encodedString)\n      // if decoded value is a stringified JSON object, return the object\n      if (Helpers.tryParseJSON(decoded)) {\n        decoded = JSON.parse(decoded)\n      }\n    } catch (error) {\n      // logError('Problem decoding base64DecodeSafe:',error);\n      return null\n    }\n    return decoded\n  }\n\n  /**  Base64 encodes a string\n   * if value passed in is an Object or JSON, it will be stringified first\n   * if value is null, this function returns null */\n  static base64Encode(valueIn: any) {\n    if (!valueIn) return null\n    let value = valueIn\n    if (Helpers.isAnObject(value)) {\n      value = JSON.stringify(value)\n    }\n    return Base64.encode(value)\n  }\n\n  static sleep(ms: number) {\n    return new Promise(resolve => setTimeout(resolve, ms))\n  }\n\n  static createGuid() {\n    return uuidv4()\n  }\n\n  /** Typescript Typeguard to verify that the value is in the enumType specified  */\n  static isInEnum<T>(enumType: T, value: any): value is T[keyof T] {\n    return Object.values(enumType).includes(value as T[keyof T])\n  }\n\n  /** Typescript Typeguard helper to ensure that a string value can be assigned to an Enum type\n   *  If a value can't be matched to a valid option in the enum, returns null (or throws if throwIfInvalid = true) */\n  static toEnumValue<T>(e: T, value: any, throwIfInvalid = false): T[keyof T] {\n    if (this.isNullOrEmpty(value)) return null\n    if (this.isInEnum<T>(e, value)) {\n      return value\n    }\n    const errMsg = `Value ${JSON.stringify(value)} is not a valid member of enum ${JSON.stringify(e)}.`\n    if (throwIfInvalid) {\n      throw new Error(errMsg)\n    }\n    return null\n  }\n\n  /** Parses comma-seperated error_codes from url response\n   * Returns: array of error code strings\n   * Note: Params is a javascript object parsed from callback URL string */\n  static getErrorCodesFromParams(params: any) {\n    let errorCodes: string[]\n    const errorString = params.error_code || params.errorCode\n    const errorMessage = params.error_message || params.errorMessage\n    if (errorString) {\n      errorCodes = errorString.split(/[/?/$&]/)\n    }\n    if (errorCodes || errorMessage) {\n      errorCodes = errorCodes || []\n      errorCodes.push(errorMessage)\n    }\n    return errorCodes\n  }\n\n  /** Retrieve values from a url query string and returns an array of them\n   *  Also parses error codes returned into an array of errors codes/messages\n   */\n  static extractDataFromCallbackUrl(url: string) {\n    let params: { [key: string]: any } = {}\n    if (url) {\n      params = this.parseUrlParams(url)\n      const errors = this.getErrorCodesFromParams(params)\n      return { ...params, errors }\n    }\n    return params\n  }\n\n  /** Call the callback once for each item in the array and await for each to finish in turn */\n  static async asyncForEach(array: any[], callback: (item: any, index: number, array: any[]) => Promise<any>) {\n    if (Helpers.isNullOrEmpty(array)) return\n    for (let index = 0; index < array.length; index += 1) {\n      // eslint-disable-next-line @typescript-eslint/semi\n      // eslint-disable-next-line no-await-in-loop\n      await callback(array[index], index, array)\n    }\n  }\n\n  /** Return a value in a custom claim in a JWT token by using a partial claim name\n   *  e.g. function(token, 'appId') => value for claim https://oreid.io/appId */\n  static getClaimFromJwtTokenBySearchString(decodedToken: JWTToken, searchString: string) {\n    let value: string\n    if (!this.isAnObject(decodedToken)) return null\n    // loop through items in token to find matching string\n    Object.keys(decodedToken).forEach(item => {\n      if (item.includes(searchString)) {\n        value = (decodedToken as Lookup)[item]\n      }\n    })\n    return value\n  }\n\n  /** get error from inside a network request (Axios Error object) and return it */\n  static getErrorFromAxiosError(error: AxiosError) {\n    // Browser thre an error during CORS preflight post - See https://github.com/axios/axios/issues/1143\n    if (error?.message.toLowerCase() === 'network error') {\n      throw new Error(\n        'Browser threw a Network Error. This is likely because of CORS error. Make sure that you are not sending an api-key in the header of the request.',\n      )\n    }\n    if (error?.code === 'ECONNREFUSED') {\n      throw new Error(`Could not connect to ORE ID service. ${error.message}.`)\n    }\n\n    if (!Helpers.isAxiosError(error)) {\n      return error\n    }\n    // extract error message from Axios Error and return new Error\n    const { data = {} } = error?.response || {}\n    const { message } = data\n    const errorCodes = this.getErrorCodesFromParams(data)\n    // oreid apis pass back errorCode/errorMessages\n    // also handle when a standard error message is thrown\n    const errorCodesList = errorCodes && errorCodes?.length > 1 ? errorCodes.join(', ') : errorCodes\n    const errorString = errorCodesList || message || 'unknown error'\n    return Error(errorString)\n  }\n\n  static isAxiosError(error: any): error is AxiosError {\n    return (error as AxiosError).isAxiosError !== undefined\n  }\n\n  static isAString(value: any): boolean {\n    if (!value) {\n      return false\n    }\n    return typeof value === 'string' || value instanceof String\n  }\n\n  static isADate(value: any): boolean {\n    return value instanceof Date\n  }\n\n  static isABoolean(value: any): boolean {\n    return typeof value === 'boolean' || value instanceof Boolean\n  }\n\n  static isANumber(value: any): boolean {\n    if (Number.isNaN(value)) return false\n    return typeof value === 'number' || value instanceof Number\n  }\n\n  static isAnObject(obj: any): boolean {\n    return obj !== null && typeof obj === 'object'\n  }\n\n  /** throw error if invalid provider */\n  static assertValidProvider(provider: AuthProvider) {\n    if (Helpers.isInEnum(AuthProvider, provider)) {\n      return true\n    }\n    throw new Error(`Auth provider ${provider} is not a valid option`)\n  }\n\n  /** Convert an AuthProvider to the ExternalWalletType subset\n   *  Returns null if can't convert member */\n  static mapAuthProviderToWalletType(provider: AuthProvider | ExternalWalletType) {\n    if (!provider) return null\n    return Helpers.toEnumValue(ExternalWalletType, provider)\n  }\n\n  static isCustodial(provider: AuthProvider) {\n    return provider === AuthProvider.Custodial\n  }\n\n  static isValidEmail(email: any): boolean {\n    if (!email) return false\n    const emailRegex =\n      /^(([^<>()[]\\\\.,;:\\s@]+(\\.[^<>()[]\\\\.,;:\\s@]+)*)|(.+))@(([[0-9]{1,3}\\[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n    return emailRegex.test(email)\n  }\n\n  /** Sort JSON in a deterministic way */\n  static sortJson(value: any): any {\n    if (!value) return value\n    const stringified = canonicalize(value)\n    return JSON.parse(stringified)\n  }\n\n  /** filter complex values in array down to an array of a single, uniques values\n   * e.g. if array = [{value:'A', other}, {value:'B', something}, {value:'A', other}]\n   *       => [{value:'A', other}, {value:'B', something}] */\n  static getUniqueValues<T>(array: T[]) {\n    return Array.from(new Set(array.map(item => JSON.stringify(item)))).map(item => JSON.parse(item))\n  }\n\n  /** Execute a callback function at a given Unix Epoch time */\n  static runAtTime(callback: Function, executionEoochTime: number) {\n    const now = Date.now()\n    const runAtTime = Math.max(executionEoochTime, now) // if executionEoochTime is in the past, use the current time to run the function immediately\n    return setTimeout(callback, runAtTime - now)\n  }\n\n  /** whether objects are 'equal' by deep comparing all members */\n  static objectsAreEqual(a: any, b: any) {\n    if (a === b) return true\n    if (typeof a !== 'object' || typeof b !== 'object' || a == null || b == null) return false\n    const keysA = Object.keys(a)\n    const keysB = Object.keys(b)\n    if (keysA.length !== keysB.length) return false\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key of keysA) {\n      if (!keysB.includes(key)) return false\n      if (typeof a[key] === 'function' || typeof b[key] === 'function') {\n        if (a[key].toString() !== b[key].toString()) return false\n      } else if (!Helpers.objectsAreEqual(a[key], b[key])) return false\n    }\n    return true\n  }\n}\n","/* eslint-disable @typescript-eslint/default-param-last */\nimport Helpers from '../utils/helpers'\nimport { JSONObject, ApiKeyUsedFor } from '../models'\nimport OreIdContext from '../core/IOreidContext'\n\nconst { isNullOrEmpty } = Helpers\n\n// ---- API Helper functions\n\n/** check the header of the request for each required param in paramNames */\nexport function assertHeaderhasRequiredValues(params: JSONObject = {}, paramNames: any[], apiName: string) {\n  const missing: any[] = []\n  paramNames.forEach(p => {\n    if (isNullOrEmpty(params[p])) {\n      missing.push(p)\n    }\n  })\n  if (!isNullOrEmpty(missing)) {\n    throw new Error(`Missing required parameter(s) in request header for API ${apiName}: ${missing.join(', ')}`)\n  }\n}\n\n/** Check that we have an apiKey or accessToken */\nexport function assertHasApiKeyOrAccessToken(oreIdContext: OreIdContext, apiName: string) {\n  if (!oreIdContext.accessToken && !oreIdContext.options?.apiKey) {\n    throw new Error(`Missing required header for API ${apiName}: Must have a valid user accessToken or options.apiKey`)\n  }\n}\n\n/** Check that we have an accessToken */\nexport function assertHasAccessToken(oreIdContext: OreIdContext, apiName: string) {\n  if (!oreIdContext.accessToken) {\n    throw new Error(`Missing required header for API ${apiName}: Must have a valid user accessToken`)\n  }\n}\n\n/** Check that we have an apiKey */\nexport function assertHasApiKey(oreIdContext: OreIdContext, usedFor: ApiKeyUsedFor, apiName: string) {\n  if (!oreIdContext.options?.apiKey) {\n    const usedFprMsg = usedFor ? ` - with ${usedFor} right.` : '.'\n    throw new Error(`Missing required header for API ${apiName}: Must have an options.apiKey${usedFprMsg}`)\n  }\n}\n\n/** Check API params for each required param in paramNames */\nexport function assertParamsHaveRequiredValues(params: JSONObject = {}, paramNames: any[], apiName: string) {\n  const missing: any[] = []\n  paramNames.forEach(p => {\n    if (isNullOrEmpty(params[p])) {\n      missing.push(p)\n    }\n  })\n  if (!isNullOrEmpty(missing)) {\n    throw new Error(`Missing required parameter(s) for API ${apiName}: ${missing.join(', ')}`)\n  }\n}\n\n/** Check API params - must include at least one of the params in the list */\nexport function assertParamsHaveAtLeastOneOfValues(params: JSONObject = {}, paramNames: any[], apiName: string) {\n  const matches = paramNames.filter(p => {\n    return !isNullOrEmpty(params[p])\n  })\n  if (matches.length === 0) {\n    throw new Error(`Missing at least one of these parameter(s) for API ${apiName}: ${paramNames.join(', ')}`)\n  }\n}\n\n/** Check API params - must include one and only one of params in the list */\nexport function assertParamsHaveOnlyOneOfValues(params: JSONObject = {}, paramNames: any[], apiName: string) {\n  const matches = paramNames.filter(p => {\n    return !isNullOrEmpty(params[p])\n  })\n  if (matches.length > 1) {\n    throw new Error(`You can only provide one of these parameter(s) for API ${apiName}: ${paramNames.join(', ')}`)\n  }\n}\n\n/** remove processId from data */\nexport function extractProcessIdFromData(data: any) {\n  let processId\n  if (data?.processId) {\n    // eslint-disable-next-line prefer-destructuring\n    processId = data.processId\n    // eslint-disable-next-line no-param-reassign\n    delete data.processId\n  }\n  return { data, processId }\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport {\n  AccountName,\n  ApiEndpoint,\n  ChainAccount,\n  ChainNetwork,\n  ExternalWalletType,\n  PublicKey,\n  RequestType,\n} from '../../models'\nimport { assertHasApiKeyOrAccessToken, assertParamsHaveRequiredValues } from '../helpers'\nimport { ApiMessageResult } from '../models'\n\nexport type ApiAddPermissionParams = {\n  account: AccountName\n  chainAccount: ChainAccount\n  chainNetwork: ChainNetwork\n  parentPermission?: PermissionName\n  permission: PermissionName\n  provider?: ExternalWalletType\n  publicKey: PublicKey\n}\n\n/**\n *  Call api account/addPermission\n *  Adds a public key to a user account with a specific permission name\n * The permission name must be one defined in the App Registration record (Which defines its parent permission as well as preventing adding rougue permissions)\n * This feature allows your app to hold private keys locally (for certain actions enabled by the permission) while having the associated public key in the user's account\n * chainAccount = name of the account on the chain - 12/13-digit string on EOS and Ethereum Address on ETH - it may be the same as the account\n * chainNetwork = one of the valid options defined by the system - Ex: 'eos_main', 'eos_jungle', 'eos_kylin\", 'ore_main', 'eos_test', etc.\n * */\nexport async function callApiAddPermission(\n  oreIdContext: OreIdContext,\n  params: ApiAddPermissionParams,\n): Promise<ApiMessageResult> {\n  const apiName = ApiEndpoint.AddPermission\n\n  assertHasApiKeyOrAccessToken(oreIdContext, apiName)\n  assertParamsHaveRequiredValues(\n    params,\n    ['account', 'chainAccount', 'chainNetwork', 'permission', 'publicKey'],\n    apiName,\n  )\n\n  const { account, permission, provider, parentPermission } = params\n\n  const optionalParams: { [key: string]: any } = {}\n  if (provider) optionalParams['wallet-type'] = provider\n  if (parentPermission) optionalParams['parent-permission'] = parentPermission\n\n  const queryParams = {\n    account,\n    'chain-account': params.chainAccount,\n    'chain-network': params.chainNetwork,\n    'public-key': params.publicKey,\n    permission,\n    ...optionalParams,\n  }\n\n  const response = await oreIdContext.callOreIdApi(RequestType.Get, ApiEndpoint.AddPermission, queryParams, null)\n  return response as ApiMessageResult\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport { ApiEndpoint, AppAccessTokenMetadata, RequestType, ApiKeyUsedFor } from '../../models'\nimport { assertHasApiKey } from '../helpers'\nimport Helpers from '../../utils/helpers'\n\nexport type ApiGetAppTokenParams = {\n  appAccessTokenMetadata?: AppAccessTokenMetadata\n}\n\n/**\n *  Call api app-token to get a new appAccessToken\n *  An apiKey is always required to call this endpoint\n *  Returns: appAccessToken\n * */\nexport async function callApiGetAppToken(oreIdContext: OreIdContext, params: ApiGetAppTokenParams): Promise<string> {\n  const apiName = ApiEndpoint.AppToken\n  const { appAccessTokenMetadata } = params\n\n  // to use appAccessTokenMetadata, we require a apiKey with 'createUser' right\n  if (!Helpers.isNullOrEmpty(appAccessTokenMetadata)) {\n    assertHasApiKey(oreIdContext, ApiKeyUsedFor.CreateUser, apiName)\n  } else {\n    assertHasApiKey(oreIdContext, null, apiName)\n  }\n  const { appAccessToken } = await oreIdContext.callOreIdApi(\n    RequestType.Post,\n    ApiEndpoint.AppToken,\n    appAccessTokenMetadata,\n    null,\n  )\n  return appAccessToken as string\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport {\n  AccountName,\n  ApiEndpoint,\n  ChainAccount,\n  ChainNetwork,\n  ProcessId,\n  RequestType,\n  ApiKeyUsedFor,\n  TransactionData,\n} from '../../models'\nimport { assertHasApiKey, assertParamsHaveOnlyOneOfValues, assertParamsHaveRequiredValues } from '../helpers'\nimport Helpers from '../../utils/helpers'\n\nexport type ApiCanAutosignTransactionBodyParams = {\n  account: AccountName\n  chain_account: ChainAccount\n  chain_network: ChainNetwork\n  signed_transaction?: string\n  transaction?: string\n  transaction_chain_acccount?: string\n}\n\nexport type ApiCanAutosignTransactionResult = {\n  autoSignCredentialsExist: boolean\n  canCreateAutoSignCredentials: boolean\n  maxAutoSignValidForInSeconds: number\n  processId: ProcessId\n}\n\n/** Call api transaction/can-auto-sign\n * Requires a apiKey with the autoSign right\n * Returns: true if transaction provided can be signed using the signTransaction(autosign:true)\n * */\nexport async function callApiCanAutosignTransaction(\n  oreIdContext: OreIdContext,\n  params: TransactionData,\n): Promise<ApiCanAutosignTransactionResult> {\n  const apiName = ApiEndpoint.CanAutoSign\n  const { account, chainAccount, chainNetwork, signedTransaction, transaction, transactionChainAccount } = params\n\n  assertHasApiKey(oreIdContext, ApiKeyUsedFor.AutoSigning, apiName)\n  assertParamsHaveRequiredValues(params, ['account', 'chainNetwork', 'chainAccount'], apiName)\n  assertParamsHaveOnlyOneOfValues(params, ['transaction', 'signedTransaction'], apiName)\n\n  const body: ApiCanAutosignTransactionBodyParams = {\n    account,\n    chain_account: chainAccount,\n    chain_network: chainNetwork,\n  }\n\n  if (transaction) body.transaction = Helpers.base64Encode(transaction)\n  if (signedTransaction) body.signed_transaction = Helpers.base64Encode(signedTransaction)\n  if (transaction) body.transaction_chain_acccount = transactionChainAccount\n\n  const results = await oreIdContext.callOreIdApi(RequestType.Post, ApiEndpoint.CanAutoSign, body, null)\n  return results\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport { ApiEndpoint, ProcessId, RequestType } from '../../models'\nimport { assertHasApiKeyOrAccessToken, assertParamsHaveRequiredValues } from '../helpers'\n\nexport type ApiConvertOauthTokensParams = {\n  accessToken?: string\n  idToken?: string\n}\n\nexport type ApiConvertOauthTokensBodyParams = {\n  access_token?: string\n  id_token?: string\n}\n\nexport type CallApiConvertOauthTokensResult = {\n  accessToken: string\n  idToken: string\n  processId: ProcessId\n}\n\n/** Call the account/convert-oauth api\n * Converts OAuth tokens from some 3rd-party source to OREID Oauth tokens\n * The third-party (e.g. Auth0 or Google) must be registered in the AppRegistration.oauthSettings\n * Returns: OreId issued accessToken and idToken\n * */\nexport async function callApiConvertOauthTokens(\n  oreIdContext: OreIdContext,\n  params: ApiConvertOauthTokensParams,\n): Promise<CallApiConvertOauthTokensResult> {\n  const apiName = ApiEndpoint.ConvertOauthTokens\n  const { accessToken, idToken } = params\n\n  assertHasApiKeyOrAccessToken(oreIdContext, apiName)\n  // assertParamsHaveOnlyOneOfValues(params, ['accessToken', 'idToken'], apiName)\n  assertParamsHaveRequiredValues(params, ['idToken'], apiName)\n\n  const body: ApiConvertOauthTokensBodyParams = {}\n  if (accessToken) body.access_token = accessToken\n  if (idToken) body.id_token = idToken\n\n  const results = await oreIdContext.callOreIdApi(RequestType.Post, ApiEndpoint.ConvertOauthTokens, body, null)\n  return results // accessToken and idToken\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport {\n  AccountName,\n  AccountType,\n  ApiEndpoint,\n  ChainAccount,\n  ChainNetwork,\n  RequestType,\n  ApiKeyUsedFor,\n} from '../../models'\nimport { assertHasApiKey, assertParamsHaveOnlyOneOfValues, assertParamsHaveRequiredValues } from '../helpers'\nimport { ApiResultWithErrorCode } from '../models'\n\nexport type ApiCustodialMigrateAccountParams = {\n  account: AccountName\n  chainAccount: ChainAccount\n  chainNetwork: ChainNetwork\n  toType: AccountType\n  userPassword: string\n  userPasswordEncrypted: string\n}\n\nexport type ApiCustodialMigrateAccountBodyParams = {\n  account: AccountName\n  chain_account: ChainAccount\n  chain_network: ChainNetwork\n  to_type: AccountType\n  user_password?: string\n  user_password_encrypted?: string\n}\n\nexport type ApiCustodialMigrateAccountResult = {\n  account: AccountName\n} & ApiResultWithErrorCode\n\n/** Call the custodial/migrate-user api\n * Converts a user account to a new account type\n * Usually used to convert a virtal account to a native account (on-chain)\n * .. and expects the account to be a managed (custodial) account\n * Requires a wallet password (userPassword) on behalf of the user\n * Requires an apiKey with the accountMigration right\n * Returns: account name of migrated account\n *       OR errorCode, errorMessage, and message if any problems */\nexport async function callApiCustodialMigrateAccount(\n  oreIdContext: OreIdContext,\n  params: ApiCustodialMigrateAccountParams,\n): Promise<ApiCustodialMigrateAccountResult> {\n  const apiName = ApiEndpoint.CustodialMigrateAccount\n\n  const { account, chainAccount, chainNetwork, toType, userPassword, userPasswordEncrypted } = params\n  const body: ApiCustodialMigrateAccountBodyParams = {\n    account,\n    chain_account: chainAccount,\n    chain_network: chainNetwork,\n    to_type: toType,\n    user_password: userPassword,\n    user_password_encrypted: userPasswordEncrypted,\n  }\n\n  assertHasApiKey(oreIdContext, ApiKeyUsedFor.AccountMigration, apiName)\n  assertParamsHaveRequiredValues(params, ['account', 'chainAccount', 'chainNetwork', 'toType'], apiName)\n  assertParamsHaveOnlyOneOfValues(params, ['user_password', 'user_password_encrypted'], apiName)\n\n  const results = await oreIdContext.callOreIdApi(RequestType.Post, ApiEndpoint.CustodialMigrateAccount, body, null)\n  return results\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport { AccountName, AccountType, ApiEndpoint, RequestType, ApiKeyUsedFor } from '../../models'\nimport { assertHasApiKey, assertParamsHaveOnlyOneOfValues, assertParamsHaveRequiredValues } from '../helpers'\nimport { ApiResultWithErrorCode } from '../models'\n\nexport type ApiCustodialNewAccountParams = {\n  accountType: AccountType\n  /** whether we should skip creation of blockchain accounts for a new user */\n  delayWalletSetup?: boolean\n  email?: string\n  emailVerified?: boolean\n  idToken?: string\n  isTestUser?: boolean\n  name?: string\n  picture?: string\n  phone?: string\n  phoneVerified?: boolean\n  userName?: string\n  userPassword?: string\n}\n\nexport type ApiCustodialNewAccountBodyParams = {\n  account_type: AccountType\n  /** whether we should skip creation of blockchain accounts for a new user */\n  delay_wallet_setup?: boolean\n  email?: string\n  email_verified?: boolean\n  id_token?: string\n  is_test_user?: boolean\n  name?: string\n  picture?: string\n  phone?: string\n  phone_verified?: boolean\n  user_name?: string\n  user_password?: string\n  user_password_encrypted?: string\n  user_password_encrypted_backup?: string\n}\n\nexport type ApiCustodialNewAccountResult = {\n  accountName: AccountName\n} & ApiResultWithErrorCode\n\n/** Call the custodial/new-user api\n * Create a new user account that is managed by your app\n * Requires a wallet password (userPassword) on behalf of the user\n * Requires an apiKey with the createUser right\n * Returns: accountName of newly created account\n *       OR errorCode, errorMessage, and message if any problems */\nexport async function callApiCustodialNewAccount(\n  oreIdContext: OreIdContext,\n  params: ApiCustodialNewAccountParams,\n): Promise<ApiCustodialNewAccountResult> {\n  const apiName = ApiEndpoint.CustodialNewAccount\n\n  const {\n    accountType,\n    delayWalletSetup,\n    email,\n    emailVerified,\n    idToken,\n    isTestUser,\n    name,\n    picture,\n    phone,\n    phoneVerified,\n    userName,\n    userPassword,\n  } = params\n  const body: ApiCustodialNewAccountBodyParams = {\n    account_type: accountType,\n    delay_wallet_setup: delayWalletSetup,\n    email,\n    email_verified: emailVerified,\n    id_token: idToken,\n    is_test_user: isTestUser,\n    name,\n    phone,\n    phone_verified: phoneVerified,\n    picture,\n    user_name: userName,\n    user_password: userPassword,\n  }\n\n  assertHasApiKey(oreIdContext, ApiKeyUsedFor.CreateUser, apiName)\n  assertParamsHaveRequiredValues(params, ['accountType'], apiName)\n  assertParamsHaveOnlyOneOfValues(\n    params,\n    ['user_password', 'user_password_encrypted', 'user_password_encrypted_backup'],\n    apiName,\n  )\n\n  if (!idToken && !(email && name)) {\n    throw new Error(`Missing required parameter(s) for API ${apiName}: Must include email AND name or an idToken`)\n  }\n\n  const results = await oreIdContext.callOreIdApi(RequestType.Post, ApiEndpoint.CustodialNewAccount, body, null)\n  return results // accessToken and idToken\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport { ApiEndpoint, ApiKeyUsedFor, RequestType, SignStringMethod } from '../../models'\nimport { assertHasApiKey, assertParamsHaveOnlyOneOfValues, assertParamsHaveRequiredValues } from '../helpers'\nimport { ApiResultWithErrorCode } from '../models'\n\nexport type ApiCustodialSignStringParams = {\n  chainAccount: string\n  chainNetwork: string\n  permission?: string\n  stringToSign: string\n  /** optional - alternative method of signing (chain-specific) */\n  signMethod?: SignStringMethod\n  userPassword?: string\n  userPasswordEncrypted?: string\n}\n\nexport type ApiCustodialSignStringBodyParams = {\n  chain_account: string\n  chain_network: string\n  permission?: string\n  string_to_sign: string\n  sign_method?: SignStringMethod\n  user_password?: string\n  user_password_encrypted?: string\n}\n\nexport type ApiCustodialSignStringResult = {\n  signature: string\n} & ApiResultWithErrorCode\n\n/** Call the custoidal/sign-string api\n * Signs a string (aka message) using the user's private key\n * Requires a wallet password (userPassword) on behalf of the user\n * Requires an apiKey with the createUser right\n * Optional: options - designates the method of signing to perform (e.g. ethereum.eth_sign, ethereum.eth_signTypedData) and related metadata (e.g. ERC712 types)\n * Returns: signature\n *       OR errorCode, errorMessage, and message if any problems */\nexport async function callApiCustodialSignString(\n  oreIdContext: OreIdContext,\n  params: ApiCustodialSignStringParams,\n): Promise<ApiCustodialSignStringResult> {\n  const apiName = ApiEndpoint.CustodialSignString\n\n  const { chainAccount, chainNetwork, permission, stringToSign, signMethod, userPassword } = params\n  const body: ApiCustodialSignStringBodyParams = {\n    chain_account: chainAccount,\n    chain_network: chainNetwork,\n    permission,\n    string_to_sign: stringToSign,\n    user_password: userPassword,\n  }\n\n  if (signMethod) body.sign_method = signMethod\n\n  assertHasApiKey(oreIdContext, ApiKeyUsedFor.ProxySigning, apiName)\n  assertParamsHaveRequiredValues(params, ['chainAccount', 'chainNetwork', 'stringToSign'], apiName)\n  assertParamsHaveOnlyOneOfValues(params, ['user_password', 'user_password_encrypted'], apiName)\n\n  const results = await oreIdContext.callOreIdApi(RequestType.Post, ApiEndpoint.CustodialSignString, body, null)\n  return results\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport { AccountName, ApiEndpoint, RequestType } from '../../models'\nimport { assertHasApiKeyOrAccessToken, assertParamsHaveRequiredValues, extractProcessIdFromData } from '../helpers'\nimport { ApiResultWithErrorCode } from '../models'\n\nexport type ApiDeleteTestUserParams = {\n  account: AccountName\n}\n\nexport type ApiDeleteTestUserResult = {\n  success: boolean\n} & ApiResultWithErrorCode\n\n/**\n *  Delete a user specifically created as a test user via api account/delete-test-user endpoint\n *  Returns: success or errorCode, errorMessage, if any problems\n */\nexport async function callApiDeleteTestUser(\n  oreIdContext: OreIdContext,\n  params: ApiDeleteTestUserParams,\n): Promise<ApiDeleteTestUserResult> {\n  const apiName = ApiEndpoint.DeleteTestUser\n  const { account } = params\n  assertHasApiKeyOrAccessToken(oreIdContext, apiName)\n  assertParamsHaveRequiredValues(params, ['account'], apiName)\n  const body = { account }\n\n  const response = await oreIdContext.callOreIdApi(RequestType.Post, ApiEndpoint.DeleteTestUser, body)\n  const { data } = extractProcessIdFromData(response)\n  return data as ApiDeleteTestUserResult\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport { ApiEndpoint, ConfigType, RequestType } from '../../models'\nimport { assertHasApiKeyOrAccessToken, assertParamsHaveRequiredValues } from '../helpers'\n\nexport type ApiGetConfigParams = {\n  configType: ConfigType.Chains\n}\n\n/**\n *  Call api services/config to get configuration values of a specific type\n *  Returns: for configType:Config.Chains, returns array of SettingChainNetwork objects for all chains suported by the service\n * */\nexport async function callApiGetConfig(oreIdContext: OreIdContext, params: ApiGetConfigParams): Promise<any> {\n  const apiName = ApiEndpoint.GetConfig\n\n  assertHasApiKeyOrAccessToken(oreIdContext, apiName)\n  assertParamsHaveRequiredValues(params, ['configType'], apiName)\n\n  const { configType } = params\n  const queryParams = { type: configType }\n  const { values } = await oreIdContext.callOreIdApi(RequestType.Get, ApiEndpoint.GetConfig, queryParams, null)\n  return values\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport { AccountName, ApiEndpoint, RequestType, UserSourceData } from '../../models'\nimport { assertHasApiKeyOrAccessToken, assertParamsHaveRequiredValues, extractProcessIdFromData } from '../helpers'\n\nexport type ApiGetUserParams = {\n  account: AccountName\n}\n\n/**\n *  Fetch user from api account/user endpoint\n *  Returns: UserSourceData for specified account\n */\nexport async function callApiGetUser(oreIdContext: OreIdContext, params: ApiGetUserParams): Promise<UserSourceData> {\n  const apiName = ApiEndpoint.GetUser\n  const { account } = params\n  assertHasApiKeyOrAccessToken(oreIdContext, apiName)\n  assertParamsHaveRequiredValues(params, ['account'], apiName)\n  const queryParams = { account }\n\n  const response = await oreIdContext.callOreIdApi(RequestType.Get, ApiEndpoint.GetUser, queryParams)\n  const { data } = extractProcessIdFromData(response)\n  return data as UserSourceData\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport { ApiEndpoint, RequestType } from '../../models'\nimport { assertHasApiKey, assertParamsHaveOnlyOneOfValues, assertParamsHaveRequiredValues } from '../helpers'\nimport Helpers from '../../utils/helpers'\nimport { ApiResultWithErrorCode } from '../models'\n\nexport type ApiLoginUserWithTokenParams = {\n  accessToken?: string\n  idToken?: string\n  provider?: string\n}\n\nexport type ApiLoginUserWithTokenBodyParams = {\n  id_token?: string\n  access_token?: string\n  provider?: string\n}\n\n/** Call api account/login-user-with-token\n * Converts OAuth accesstoken or idToken from some 3rd-party source to OREID Oauth accessTokens\n * The third-party (e.g. Auth0 or Google) must be registered in the AppRegistration.oauthSettings\n * If a user does not curently exist that matches the info in the incoming idToken, a new OreID user and account is created\n * Requires either:\n *  1) a valid idToken (needs no accessToken or apiKey in header)\n *  2) an OreId issued JWT accessToken (needs no accessToken or apiKey in header)\n *  3) a 3rd-party accessToken (usually not a JWT) and provider param (e.g. 'google') - Requires api-key in header\n * Returns: OreId issued accessToken and user's account name (if new account created, this is a new account name)\n * */\nexport async function callApiLoginUserWithToken(\n  oreIdContext: OreIdContext,\n  params: ApiLoginUserWithTokenParams,\n): Promise<{ accessToken: string } & ApiResultWithErrorCode> {\n  const apiName = ApiEndpoint.LoginUserWithToken\n  const { accessToken, idToken, provider } = params\n\n  // This function does not require authentication (api-key or accessToken) in request header - when using a signed JWT accessToken or idToken\n  // It does require an api-key when using a non-JWT (third-party) accessToken\n\n  assertParamsHaveOnlyOneOfValues(params, ['accessToken', 'idToken'], apiName)\n  assertParamsHaveOnlyOneOfValues(params, ['idToken', 'provider'], apiName)\n  if (accessToken && !Helpers.jwtDecodeSafe(accessToken)) {\n    assertParamsHaveRequiredValues(params, ['provider'], apiName)\n    // if we have non-JWT access token, we must include an api-key\n    assertHasApiKey(oreIdContext, null, 'login-user-with-token')\n  }\n\n  const body: ApiLoginUserWithTokenBodyParams = {}\n\n  if (idToken) {\n    body.id_token = idToken\n  } else {\n    body.access_token = accessToken\n    body.provider = provider\n  }\n\n  const results = await oreIdContext.callOreIdApi(\n    RequestType.Post,\n    ApiEndpoint.LoginUserWithToken,\n    body,\n    null, // an api key is NOT required to call this api endpoint\n  )\n  return results // accessToken and idToken\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport { ApiEndpoint, AuthProvider, RequestType } from '../../models'\nimport {\n  assertHasApiKey,\n  assertParamsHaveAtLeastOneOfValues,\n  assertParamsHaveOnlyOneOfValues,\n  assertParamsHaveRequiredValues,\n} from '../helpers'\nimport { ApiResultWithErrorCode } from '../models'\n\nexport type ApiNewUserWithTokenParams = {\n  accessToken?: string\n  /** whether we should skip creation of blockchain accounts for a new user */\n  delayWalletSetup?: boolean\n  isTestUser?: boolean\n  idToken?: string\n  provider?: AuthProvider\n}\n\nexport type ApiNewUserWithTokenBodyParams = {\n  access_token?: string\n  /** whether we should skip creation of blockchain accounts for a new user */\n  delay_wallet_setup?: boolean\n  is_test_user?: boolean\n  id_token?: string\n  provider?: string\n}\n\n/** Call api account/new-user-with-token\n * Converts OAuth accesstoken or idToken from some 3rd-party source to OREID Oauth accessTokens\n * The third-party (e.g. Auth0 or Google) must be registered in the AppRegistration.oauthSettings\n * If a user does not curently exist that matches the info in the incoming idToken, a new OreID user and account is created\n * Requires ether:\n *  1) a valid idToken (needs no accessToken or apiKey in header)\n *  2) a 3rd-party accessToken (usually not a JWT) and provider param (e.g. 'google') - Requires api-key in header\n * Set isTestUser to true to create a test user - a test user can be deleted using user.deleteTestUser() - this is helpful for testing\n * Returns: OreId issued accessToken and user's account name (if new account created, this is a new account name)\n * */\nexport async function callApiNewUserWithToken(\n  oreIdContext: OreIdContext,\n  params: ApiNewUserWithTokenParams,\n): Promise<{ accessToken: string } & ApiResultWithErrorCode> {\n  const apiName = ApiEndpoint.NewUserWithToken\n  const { accessToken, delayWalletSetup, isTestUser, idToken, provider } = params\n\n  // This function does not require authentication of any kind - since it allows auth by using any accessToken or idToken\n  assertParamsHaveAtLeastOneOfValues(params, ['idToken', 'accessToken'], apiName)\n  assertParamsHaveOnlyOneOfValues(params, ['idToken', 'provider'], apiName) // if idToken, then no provider should be given\n  if (accessToken) {\n    assertParamsHaveRequiredValues(params, ['accessToken', 'provider'], apiName)\n    // if we have a 3rd party access token, we must include an api-key\n    assertHasApiKey(oreIdContext, null, 'new-user-with-token')\n  }\n\n  const body: ApiNewUserWithTokenBodyParams = {}\n\n  if (idToken) {\n    body.id_token = idToken\n  } else {\n    body.access_token = accessToken\n    body.provider = provider\n  }\n\n  if (isTestUser === true) body.is_test_user = true\n  if (delayWalletSetup === true) body.delay_wallet_setup = true\n\n  const results = await oreIdContext.callOreIdApi(\n    RequestType.Post,\n    ApiEndpoint.NewUserWithToken,\n    body,\n    null, // an api key is NOT required to call this api endpoint\n  )\n  return results // accessToken and idToken\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport { ApiEndpoint, AuthProvider, RequestType } from '../../models'\nimport {\n  assertHasApiKeyOrAccessToken,\n  assertParamsHaveOnlyOneOfValues,\n  assertParamsHaveRequiredValues,\n} from '../helpers'\nimport { ApiMessageResult } from '../models'\n\nexport type ApiPasswordLessSendCodeParams = {\n  email?: string\n  phone?: string\n  provider: AuthProvider\n}\n\n/**\n *  Call api account/login-passwordless-send-code\n *  Returns { success: true } if verification code is sent to email/phone\n * */\nexport async function callApiPasswordLessSendCode(\n  oreIdContext: OreIdContext,\n  params: ApiPasswordLessSendCodeParams,\n): Promise<ApiMessageResult> {\n  const apiName = ApiEndpoint.PasswordLessSendCode\n\n  assertHasApiKeyOrAccessToken(oreIdContext, apiName)\n  assertParamsHaveRequiredValues(params, ['provider'], apiName)\n  assertParamsHaveOnlyOneOfValues(params, ['email', 'phone'], apiName)\n\n  const { email, phone, provider } = params\n\n  const queryParams: Partial<ApiPasswordLessSendCodeParams> = {\n    provider,\n  }\n\n  if (email) queryParams.email = encodeURIComponent(email)\n  if (phone) queryParams.phone = encodeURIComponent(phone) // if user passes in +12103334444, the plus sign needs to be URL encoded\n\n  const response = await oreIdContext.callOreIdApi(RequestType.Get, ApiEndpoint.PasswordLessSendCode, queryParams, null)\n  return response as ApiMessageResult\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport { ApiEndpoint, AuthProvider, RequestType } from '../../models'\nimport {\n  assertHasApiKeyOrAccessToken,\n  assertParamsHaveOnlyOneOfValues,\n  assertParamsHaveRequiredValues,\n} from '../helpers'\nimport { ApiMessageResult } from '../models'\n\nexport type ApiPasswordLessVerifyCodeParams = {\n  code?: string\n  email?: string\n  phone?: string\n  provider: AuthProvider\n}\n\n/**\n *  Call api account/login-passwordless-verify-code\n *  Returns { success: true } if code is verified, throws if code/verification fails\n * */\nexport async function callApiPasswordLessVerifyCode(\n  oreIdContext: OreIdContext,\n  params: ApiPasswordLessVerifyCodeParams,\n): Promise<ApiMessageResult> {\n  const apiName = ApiEndpoint.PasswordLessVerifyCode\n\n  assertHasApiKeyOrAccessToken(oreIdContext, apiName)\n  assertParamsHaveRequiredValues(params, ['code', 'provider'], apiName)\n  assertParamsHaveOnlyOneOfValues(params, ['email', 'phone'], apiName)\n\n  const { code, email, phone, provider } = params\n\n  const queryParams: Partial<ApiPasswordLessVerifyCodeParams> = {\n    code,\n    provider,\n  }\n\n  if (email) queryParams.email = encodeURIComponent(email)\n  if (phone) queryParams.phone = encodeURIComponent(phone) // if user passes in +12103334444, the plus sign needs to be URL encoded\n\n  const response = await oreIdContext.callOreIdApi(\n    RequestType.Get,\n    ApiEndpoint.PasswordLessVerifyCode,\n    queryParams,\n    null,\n  )\n  return response as ApiMessageResult\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport {\n  AccountName,\n  ApiEndpoint,\n  ChainAccount,\n  ChainNetwork,\n  RequestType,\n  ApiKeyUsedFor,\n  TransactionData,\n} from '../../models'\nimport { ApiResultWithErrorCode } from '../models'\nimport {\n  assertHasApiKey,\n  assertHasApiKeyOrAccessToken,\n  assertParamsHaveOnlyOneOfValues,\n  assertParamsHaveRequiredValues,\n} from '../helpers'\nimport Helpers from '../../utils/helpers'\n\nexport type ApiSignTransactionParams = {\n  autoSign?: boolean\n  transactionData: TransactionData\n}\n\nexport type ApiSignTransactionBodyParams = {\n  account: AccountName\n  allow_chain_account_selection?: boolean\n  auto_sign?: boolean\n  broadcast?: boolean\n  chain_account: ChainAccount\n  chain_network: ChainNetwork\n  expire_seconds?: number\n  generate_auto_sign_credential?: boolean\n  multisig_chain_accounts?: string\n  // provider?: AuthProvider\n  return_signed_transaction?: boolean\n  signed_transaction?: string\n  transaction?: string\n  transaction_chain_acccount?: ChainAccount\n  transaction_record_id?: string\n  user_password?: string\n  user_password_encrypted?: string\n}\n\nexport type ApiSignTransactionResult = {\n  signedTransaction?: string\n  transactionId?: string\n} & ApiResultWithErrorCode\n\n/** Compose the API body params for calling signTransaction */\nfunction composeSignBodyFromTransactionData(params: ApiSignTransactionParams): ApiSignTransactionBodyParams {\n  const {\n    account,\n    chainAccount,\n    chainNetwork,\n    expireSeconds,\n    signedTransaction: signedTransactionParam,\n    transaction: transactionParam,\n    transactionChainAccount,\n    transactionRecordId,\n  } = params.transactionData || {}\n\n  const {\n    allowChainAccountSelection,\n    broadcast,\n    generateAutoSignCredential,\n    multiSigChainAccounts,\n    returnSignedTransaction,\n    userPassword,\n    userPasswordEncrypted,\n  } = params.transactionData?.signOptions || {}\n\n  const { autoSign } = params\n\n  const body: ApiSignTransactionBodyParams = {\n    account,\n    broadcast,\n    chain_account: chainAccount,\n    chain_network: chainNetwork,\n  }\n\n  if (allowChainAccountSelection) body.allow_chain_account_selection = allowChainAccountSelection\n  if (autoSign) body.auto_sign = autoSign\n  if (expireSeconds) body.expire_seconds = expireSeconds\n  if (generateAutoSignCredential) body.generate_auto_sign_credential = generateAutoSignCredential\n  if (multiSigChainAccounts) body.multisig_chain_accounts = multiSigChainAccounts\n  // if (provider) body.provider = provider - no provider param for API call\n  if (returnSignedTransaction) body.return_signed_transaction = returnSignedTransaction\n  if (signedTransactionParam) body.signed_transaction = Helpers.base64Encode(signedTransactionParam)\n  // if (stateParam) body.state = Helpers.base64Encode(stateParam) - no state for an API call\n  if (transactionChainAccount) body.transaction_chain_acccount = transactionChainAccount\n  if (transactionParam) body.transaction = Helpers.base64Encode(transactionParam)\n  if (transactionRecordId) body.transaction_record_id = transactionRecordId\n  if (userPassword) body.user_password = userPassword // used for custodial sign\n  if (userPasswordEncrypted) body.user_password_encrypted = userPasswordEncrypted // used for custodial sign\n\n  return body\n}\n\n/** convert snake_case fields in response to camelCase */\nfunction mapSignResultFromApi(apiResult: any): ApiSignTransactionResult {\n  const { signed_transaction: signedTransaction, transaction_id: transactionId, ...rest } = apiResult\n  return {\n    signedTransaction,\n    transactionId,\n    ...rest,\n  }\n}\n\n/** Call api transaction/sign - to sign a transaction for a user\n * Can only sign a transaction if autoSign specified (and previously enabled by user)\n * OR if OreId is managing a private key it can sign with (e.g. most often an account in multiSigChainAccounts)\n * For autoSign param, requires an apiKey with the autoSign right\n * Returns: stringified signedTransaction (and transactionId if available)\n *          OR errorCode, errorDescription, message - if any issues\n * */\nexport async function callApiSignTransaction(\n  oreIdContext: OreIdContext,\n  params: ApiSignTransactionParams,\n): Promise<ApiSignTransactionResult> {\n  const apiName = ApiEndpoint.TransactionSign\n\n  if (params?.autoSign) {\n    assertHasApiKey(oreIdContext, ApiKeyUsedFor.AutoSigning, apiName)\n  } else {\n    assertHasApiKeyOrAccessToken(oreIdContext, apiName)\n  }\n  assertParamsHaveRequiredValues(params.transactionData, ['account', 'chainNetwork', 'chainAccount'], apiName)\n  assertParamsHaveOnlyOneOfValues(params.transactionData, ['transaction', 'signedTransaction'], apiName)\n\n  const body = composeSignBodyFromTransactionData(params)\n\n  const results = await oreIdContext.callOreIdApi(RequestType.Post, ApiEndpoint.TransactionSign, body, null)\n  return mapSignResultFromApi(results)\n}\n\n/** Call api custodial/sign - for signing a transaction on behalf of a user\n * Requires wallet password: either user_password or user_password_encrypted param (used to decrypt user's key)\n * Requires an apiKey with the proxySign right\n * Returns: stringified signedTransaction (and transactionId if available)\n *          OR errorCode, errorDescription, message - if any issues\n * */\nexport async function callApiCustodialSignTransaction(\n  oreIdContext: OreIdContext,\n  params: ApiSignTransactionParams,\n): Promise<ApiSignTransactionResult> {\n  const apiName = ApiEndpoint.CustodialSign\n  const { signOptions } = params.transactionData || {}\n\n  assertHasApiKey(oreIdContext, ApiKeyUsedFor.ProxySigning, apiName)\n  assertParamsHaveRequiredValues(params.transactionData, ['account', 'chainNetwork', 'chainAccount'], apiName)\n  assertParamsHaveOnlyOneOfValues(params.transactionData, ['transaction', 'signedTransaction'], apiName)\n  assertParamsHaveOnlyOneOfValues(signOptions, ['userPassword', 'userPasswordEncrypted'], apiName)\n\n  const body = composeSignBodyFromTransactionData(params)\n\n  const results = await oreIdContext.callOreIdApi(RequestType.Post, ApiEndpoint.CustodialSign, body, null)\n  return mapSignResultFromApi(results)\n}\n","import {\n  AppAccessTokenMetadata,\n  GetOreIdAuthUrlParams,\n  GetOreIdNewChainAccountUrlParams,\n  GetOreIdRecoverAccountUrlParams,\n  GetRecoverAccountUrlResult,\n  TransactionData,\n} from '../models'\nimport Helpers from '../utils/helpers'\nimport OreIdContext from './IOreidContext'\n\nconst { isNullOrEmpty } = Helpers\n\n/** Returns a fully formed url to create a new chain account within a user's wallet account\n *  This function calls the /new-account web endpoint\n *  It requires an apiKey in order to add an appAccessToken with new account metadata\n *  Returns: Callback returns chainAccount - for the new account */\nexport async function getOreIdNewChainAccountUrl(oreIdContext: OreIdContext, args: GetOreIdNewChainAccountUrlParams) {\n  const { account, accountType, chainNetwork, accountOptions, provider, callbackUrl, backgroundColor, state } = args\n  const { oreIdUrl } = oreIdContext.options\n\n  // collect additional params embedded into appAccessToken\n  const appAccessTokenMetadata: AppAccessTokenMetadata = {\n    paramsNewAccount: {\n      account,\n      accountType,\n      chainNetwork,\n      accountOptions,\n    },\n  }\n\n  if (!account || !accountType || !chainNetwork || !provider || !callbackUrl) {\n    throw new Error('Missing a required parameter')\n  }\n\n  const accessTokenParam = `&oauth_access_token=${oreIdContext.accessToken}`\n\n  // optional params\n  const encodedStateParam = state ? `&state=${state}` : ''\n\n  const url =\n    `${oreIdUrl}/new-account#provider=${provider}&chain_network=${chainNetwork}` +\n    `&callback_url=${encodeURIComponent(callbackUrl)}&background_color=${encodeURIComponent(\n      backgroundColor,\n    )}${encodedStateParam}${accessTokenParam}`\n  return oreIdContext.addAccessTokenAndHmacToUrl(url, appAccessTokenMetadata)\n}\n\n/** Returns a fully formed url to login a user\n *  This function calls the /auth web endpoint\n *  Returns: Callback returns account, and optionally accessToken and/or idToken for user */\nexport async function getOreIdAuthUrl(oreIdContext: OreIdContext, args: GetOreIdAuthUrlParams) {\n  const {\n    code,\n    email,\n    phone,\n    provider,\n    callbackUrl,\n    backgroundColor,\n    state,\n    linkToAccount,\n    returnAccessToken,\n    returnIdToken,\n  } = args\n  const { oreIdUrl } = oreIdContext.options\n\n  if (!provider || !callbackUrl) {\n    throw new Error('Missing a required parameter')\n  }\n\n  // optional params\n  const encodedStateParam = state ? `&state=${state}` : ''\n  const linkToAccountParam = linkToAccount ? `&link_to_account=${linkToAccount}` : ''\n\n  // handle passwordless params\n  const codeParam = code ? `&code=${code}` : ''\n  const emailParam = email ? `&email=${encodeURIComponent(email)}` : ''\n  const phoneParam = phone ? `&phone=${encodeURIComponent(phone)}` : '' // if user passes in +12103334444, the plus sign needs to be URL encoded\n\n  const returnAccessTokenParam = returnAccessToken ? `&return_access_token=${returnAccessToken}` : ''\n  const returnIdTokenParam = returnIdToken ? `&return_id_token=${returnIdToken}` : ''\n\n  const url =\n    `${oreIdUrl}/auth#provider=${provider}` +\n    `${codeParam}${emailParam}${phoneParam}` +\n    `&callback_url=${encodeURIComponent(callbackUrl)}&background_color=${encodeURIComponent(\n      backgroundColor,\n    )}${linkToAccountParam}${encodedStateParam}${returnAccessTokenParam}${returnIdTokenParam}`\n\n  return oreIdContext.addAccessTokenAndHmacToUrl(url, null)\n}\n\n/** Returns a fully formed url to login a user\n *  This function calls the /sign web endpoint\n *  Returns: Callback returns transactionId (if available), and optionally signedTransaction */\nexport async function getOreIdSignUrl(oreIdContext: OreIdContext, transactionData: TransactionData) {\n  const { account, chainNetwork, expireSeconds, signedTransaction, transaction, transactionRecordId } = transactionData\n  const {\n    allowChainAccountSelection,\n    broadcast,\n    callbackUrl,\n    multiSigChainAccounts,\n    provider,\n    returnSignedTransaction,\n    state,\n    // userPassword,\n  } = transactionData?.signOptions || {}\n  let { chainAccount } = transactionData\n  const { oreIdUrl } = oreIdContext.options\n  // Now always appends accessToken to signUrl\n  if (!account || !callbackUrl || (!transaction && !signedTransaction)) {\n    throw new Error('Missing a required parameter')\n  }\n\n  // default chainAccount is the same as the user's account\n  if (!chainAccount) {\n    chainAccount = account\n  }\n\n  const encodedTransaction = Helpers.base64Encode(transaction)\n  const encodedSignedTransaction = Helpers.base64Encode(signedTransaction)\n  let optionalParams = state ? `&state=${state}` : ''\n  optionalParams += !isNullOrEmpty(transaction) ? `&transaction=${encodedTransaction}` : ''\n  optionalParams += !isNullOrEmpty(signedTransaction) ? `&signed_transaction=${encodedSignedTransaction}` : ''\n  optionalParams += !isNullOrEmpty(allowChainAccountSelection)\n    ? `&allow_chain_account_selection=${allowChainAccountSelection}`\n    : ''\n  optionalParams += !isNullOrEmpty(expireSeconds) ? `&expire_seconds=${expireSeconds}` : ''\n  optionalParams += !isNullOrEmpty(multiSigChainAccounts) ? `&multisig_chain_accounts=${multiSigChainAccounts}` : ''\n  optionalParams += !isNullOrEmpty(provider) ? `&provider=${provider}` : ''\n  optionalParams += !isNullOrEmpty(returnSignedTransaction)\n    ? `&return_signed_transaction=${returnSignedTransaction}`\n    : ''\n  optionalParams += !isNullOrEmpty(transactionRecordId) ? `&transaction_record_id=${transactionRecordId}` : ''\n  optionalParams += `&oauth_access_token=${oreIdContext.accessToken}`\n\n  // prettier-ignore\n  const url = `${oreIdUrl}/sign#account=${account}&broadcast=${broadcast}&callback_url=${encodeURIComponent(callbackUrl)}&chain_account=${chainAccount}&chain_network=${encodeURIComponent(chainNetwork)}${optionalParams}`\n  return oreIdContext.addAccessTokenAndHmacToUrl(url, null)\n}\n\n/** Returns a fully formed url to recover a user's account (e.g. change password)\n *  This function calls the /recover-account web endpoint\n *  Returns: Callback returns account updated */\nexport async function getRecoverAccountUrl(\n  oreIdContext: OreIdContext,\n  args: GetOreIdRecoverAccountUrlParams,\n): Promise<GetRecoverAccountUrlResult> {\n  const {\n    account,\n    code,\n    email,\n    phone,\n    provider,\n    callbackUrl,\n    backgroundColor,\n    state,\n    recoverAction,\n    overrideAppAccessToken,\n  } = args\n  const { oreIdUrl } = oreIdContext.options\n\n  if (!provider || !callbackUrl) {\n    throw new Error('Missing a required parameter')\n  }\n\n  const accessTokenParam = `&oauth_access_token=${oreIdContext.accessToken}`\n\n  // optional params\n  const encodedStateParam = state ? `&state=${state}` : ''\n  const actionTypeParam = recoverAction ? `&recover_action=${recoverAction}` : ''\n\n  // handle passwordless params\n  const codeParam = code ? `&code=${code}` : ''\n  const emailParam = email ? `&email=${encodeURIComponent(email)}` : ''\n  const phoneParam = phone ? `&phone=${encodeURIComponent(phone)}` : '' // if user passes in +12103334444, the plus sign needs to be URL encoded\n\n  const url =\n    `${oreIdUrl}/recover-account#provider=${provider}` +\n    `&account=${account}` +\n    `${codeParam}${emailParam}${phoneParam}` +\n    `&callback_url=${encodeURIComponent(callbackUrl)}&background_color=${encodeURIComponent(\n      backgroundColor,\n    )}${actionTypeParam}${encodedStateParam}${accessTokenParam}`\n\n  return oreIdContext.addAccessTokenAndHmacToUrl(url, null, overrideAppAccessToken)\n}\n","/* eslint-disable no-prototype-builtins */\n/* eslint-disable prefer-const */\n\nimport { encode } from '@msgpack/msgpack'\n\n// This funciton copied from algoSdk - https://github.com/algorand/js-algorand-sdk/blob/dcec38cc7926de7f54328ce28e76290ffea9fe41/src/encoding/encoding.js#L24\n/**\n * containsEmpty returns true if any of the object's values are empty, false otherwise.\n * Empty arrays considered empty\n * @param obj\n * @returns {{firstEmptyKey: string, containsEmpty: boolean}} {true, empty key} if contains empty, {false, undefined} otherwise\n */\nfunction containsEmpty(obj: any): { firstEmptyKey: string; containsEmpty: boolean } {\n  // eslint-disable-next-line no-restricted-syntax\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (!obj[key] || obj[key].length === 0) {\n        return { containsEmpty: true, firstEmptyKey: key }\n      }\n    }\n  }\n  return { containsEmpty: false, firstEmptyKey: undefined }\n}\n\n// This funciton copied from algoSdk - https://github.com/algorand/js-algorand-sdk/blob/dcec38cc7926de7f54328ce28e76290ffea9fe41/src/encoding/encoding.js#L41\n/**\n * encode encodes objects using msgpack\n * @param obj a dictionary to be encoded. Must not contain empty or 0 values.\n * @returns {Uint8Array} msgpack representation of the object\n * @throws Error containing ERROR_CONTAINS_EMPTY_STRING if the object contains empty or zero values\n */\nexport function msgPackEncode(obj: any) {\n  const ERROR_CONTAINS_EMPTY_STRING =\n    'The object contains empty or 0 values. First empty or 0 value encountered during encoding: '\n  // Check for empty values\n  const emptyCheck = containsEmpty(obj)\n  if (emptyCheck.containsEmpty) {\n    throw new Error(ERROR_CONTAINS_EMPTY_STRING + emptyCheck.firstEmptyKey)\n  }\n\n  // enable the canonical option\n  const options = { sortKeys: true }\n  return encode(obj, options)\n}\n","import { ExternalWalletType, ChainPlatformType } from '../common/models'\nimport {\n  TransitDiscoveryData,\n  TransitDiscoverKeyLookupCallback,\n  TransitDiscoveryAccount,\n  TransitDiscoverContinueCallback,\n  TransitProviderAttributes,\n} from './models'\n\n/** Function used within transit provider to transform a wallet's public key to a full account strucutre */\nconst AlgorandDiscoveryKeyLookupFunc: TransitDiscoverKeyLookupCallback = (\n  discoveryData: TransitDiscoveryData,\n  callback: TransitDiscoverContinueCallback,\n) => {\n  const accountInfoArray: TransitDiscoveryAccount[] = discoveryData.keys.map(key => {\n    // note holds a stringified JSON object - composed by Algosigner Transit plugin\n    const account = JSON.parse(key.note)\n    return {\n      index: key.index,\n      key: key.key,\n      accounts: [\n        {\n          account: account?.accountName,\n          authorization: account?.permission,\n        },\n      ],\n    }\n  })\n  callback(accountInfoArray)\n}\n\n/** Pass-through function used within eos-transit host - if not provided, wallet will try to use EOS to transform keys */\nconst NonEosDiscoveryKeyLookupFunc: TransitDiscoverKeyLookupCallback = (\n  discoveryData: TransitDiscoveryData,\n  callback: TransitDiscoverContinueCallback,\n) => {\n  callback(discoveryData.keyToAccountMap)\n}\n\nexport const transitProviderAttributesData: TransitProviderAttributes[] = [\n  {\n    providerName: ExternalWalletType.AlgoSigner,\n    chainType: ChainPlatformType.algorand,\n    providerId: 'algosigner',\n    requiresLogin: false,\n    supportsDiscovery: true,\n    supportsSignArbitrary: false,\n    requiresLogoutLoginToDiscover: false,\n    requiresDiscoverToLogin: false,\n    helpText: {\n      login: 'This wallet doesnt require you to login.',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    discoveryKeyLookupFunc: AlgorandDiscoveryKeyLookupFunc,\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-algosigner-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.Keycat,\n    chainType: ChainPlatformType.eos,\n    providerId: 'Keycat',\n    requiresLogin: true,\n    supportsDiscovery: false,\n    supportsSignArbitrary: true,\n    requiresLogoutLoginToDiscover: true,\n    requiresDiscoverToLogin: false,\n    helpText: {\n      login: 'Keycat requires logging in through the Keycat app.',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-keycat-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.Ledger,\n    chainType: ChainPlatformType.eos,\n    providerId: 'ledger',\n    requiresLogin: true,\n    supportsDiscovery: true,\n    supportsSignArbitrary: false,\n    requiresLogoutLoginToDiscover: false,\n    requiresDiscoverToLogin: true,\n    defaultDiscoveryPathIndexList: [0, 1, 2],\n    helpText: {\n      login: 'This wallet doesnt require you to login',\n      sign: 'Connect and unlock your Ledger with your PIN code. Launch the EOS app on the device.',\n      discover: 'Connect and unlock your Ledger with your PIN code. Launch the EOS app on the device.',\n      versionsRequired:\n        'You need to have recent versions of your browser, Ledger firmware, and the Ledger EOS app. Click here for more details.',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-ledger-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.Lynx,\n    chainType: ChainPlatformType.eos,\n    providerId: 'EOS Lynx',\n    requiresLogin: true,\n    supportsDiscovery: false,\n    supportsSignArbitrary: true,\n    requiresLogoutLoginToDiscover: true,\n    requiresDiscoverToLogin: false,\n    helpText: {\n      login: 'EOS Lynx requires logging in through the EOS Lynx app.',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-lynx-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.Meetone,\n    chainType: ChainPlatformType.eos,\n    providerId: 'meetone_provider',\n    requiresLogin: false,\n    supportsDiscovery: false,\n    supportsSignArbitrary: true,\n    requiresLogoutLoginToDiscover: true,\n    requiresDiscoverToLogin: false,\n    helpText: {\n      login: 'This wallet doesnt require you to login',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-meetone-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.Metro,\n    chainType: ChainPlatformType.eos,\n    providerId: 'metro',\n    requiresLogin: false,\n    supportsDiscovery: false,\n    supportsSignArbitrary: false,\n    requiresLogoutLoginToDiscover: false,\n    requiresDiscoverToLogin: false,\n    helpText: {\n      login: 'This wallet doesnt require you to login',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-generic-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.Portis,\n    chainType: ChainPlatformType.eos,\n    providerId: 'PortisProvider',\n    requiresLogin: true,\n    supportsDiscovery: false,\n    supportsSignArbitrary: false,\n    requiresLogoutLoginToDiscover: true,\n    requiresDiscoverToLogin: false,\n    helpText: {\n      login: 'Portis requires logging in through the Portis app.',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-portis-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.Scatter,\n    chainType: ChainPlatformType.eos,\n    providerId: 'scatter',\n    requiresLogin: true,\n    supportsDiscovery: false,\n    supportsSignArbitrary: true,\n    requiresLogoutLoginToDiscover: true,\n    requiresDiscoverToLogin: false,\n    helpText: {\n      login: 'Scatter requires logging in through the Scatter app.',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-scatter-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.SimpleEos,\n    chainType: ChainPlatformType.eos,\n    providerId: 'simpleos',\n    requiresLogin: true,\n    supportsDiscovery: false,\n    supportsSignArbitrary: false,\n    requiresLogoutLoginToDiscover: true,\n    requiresDiscoverToLogin: false,\n    helpText: {\n      login: 'Simpleos requires logging in through the Simpleos app.',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-simpleos-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.TokenPocket,\n    chainType: ChainPlatformType.eos,\n    providerId: 'TokenPocket',\n    requiresLogin: true,\n    supportsDiscovery: false,\n    supportsSignArbitrary: true,\n    requiresLogoutLoginToDiscover: true,\n    requiresDiscoverToLogin: false,\n    helpText: {\n      login: 'This wallet doesnt require you to login',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-generic-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.WalletConnect,\n    chainType: ChainPlatformType.ethereum,\n    providerId: 'walletconnect',\n    requiresLogin: false,\n    supportsDiscovery: true,\n    supportsSignArbitrary: true,\n    requiresLogoutLoginToDiscover: false,\n    requiresDiscoverToLogin: false,\n    helpText: {\n      login: 'This wallet doesnt require you to login.',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    discoveryKeyLookupFunc: NonEosDiscoveryKeyLookupFunc,\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-walletconnect-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.Web3,\n    chainType: ChainPlatformType.ethereum,\n    providerId: 'web3',\n    requiresLogin: false,\n    supportsDiscovery: true,\n    supportsSignArbitrary: true,\n    requiresLogoutLoginToDiscover: false,\n    requiresDiscoverToLogin: false,\n    helpText: {\n      login: 'This wallet doesnt require you to login.',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    discoveryKeyLookupFunc: NonEosDiscoveryKeyLookupFunc,\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-web3-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.WhaleVault,\n    chainType: ChainPlatformType.eos,\n    providerId: 'whalevault',\n    requiresLogin: true,\n    supportsDiscovery: false,\n    supportsSignArbitrary: true,\n    requiresLogoutLoginToDiscover: true,\n    requiresDiscoverToLogin: false,\n    helpText: {\n      login: 'Whalevault requires logging in through the Whalevault app.',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-whalevault-logo.png',\n  },\n]\n\n/** Get provider-specific settings and metadata */\nexport function getTransitProviderAttributes(walletType: ExternalWalletType): TransitProviderAttributes {\n  return transitProviderAttributesData.find(tp => tp.providerName === walletType.toString())\n}\n\n/** Get provider-specific settings and metadata */\nexport function getTransitProviderAttributesByProviderId(providerId: string): TransitProviderAttributes {\n  return transitProviderAttributesData.find(tp => tp.providerId === providerId)\n}\n\n/** Get the list of provider attributes for a given chain */\nexport function getTransitProviderAttributesByChain(chain: ChainPlatformType): TransitProviderAttributes[] {\n  return transitProviderAttributesData.filter(p => p.chainType === chain)\n}\n\nexport const supportedTransitProviders: ExternalWalletType[] = transitProviderAttributesData.map(tp => tp.providerName)\n","import { initAccessContext, MakeWalletProviderFn, Wallet } from '@aikon/eos-transit'\nimport { msgPackEncode } from '../utils/chainUtils'\nimport {\n  getTransitProviderAttributes,\n  getTransitProviderAttributesByProviderId,\n  supportedTransitProviders,\n} from './transitProviders'\nimport OreIdContext from '../core/IOreidContext'\nimport Helpers from '../utils/helpers'\nimport {\n  AccountName,\n  AuthProvider,\n  ChainAccount,\n  ChainNetwork,\n  ChainPlatformType,\n  ConnectToTransitProviderParams,\n  DiscoverOptions,\n  ExternalWalletInterface,\n  ExternalWalletType,\n  LoginWithWalletOptions,\n  PermissionName,\n  PublicKey,\n  SetupTransitWalletParams,\n  SignatureProviderArgs,\n  SignatureProviderSignResult,\n  SignStringParams,\n  TransactionData,\n  TransitAccountInfo,\n  TransitWallet,\n  WalletPermission,\n} from '../models'\nimport { TransitDiscoveryOptions, TransitWalletAccessContext } from '.'\nimport { User } from '../user/user'\n\ntype ConnectToTransitProviderResult = {\n  isLoggedIn?: boolean\n  chainAccount?: ChainAccount\n  permissions?: [{ name: PermissionName; publicKey: PublicKey }]\n  transitWallet?: TransitWallet\n  provider?: ExternalWalletType\n}\n\nexport default class TransitHelper {\n  constructor(args: { oreIdContext: OreIdContext; user: User }) {\n    this._oreIdContext = args.oreIdContext\n    this._user = args.user\n    this.transitAccessContexts = {}\n  }\n\n  _oreIdContext: OreIdContext\n\n  _user: User\n\n  transitAccessContexts: { [key: string]: TransitWalletAccessContext }\n\n  /** Verifies that all plugins provided work (can be constructed)\n   *  Stores a list of the installed providerNames (mapped to ExternalWalletType) for all working plugins in transitProvidersInstalled\n   */\n  async installTransitProviders(eosTransitWalletProviders: MakeWalletProviderFn[]) {\n    // Executes each provider's contructor to verify it's working\n    // stores all the providerName's for all plugins into transitProvidersInstalled array\n    this._oreIdContext.transitProvidersInstalled = (eosTransitWalletProviders || [])\n      .map(makeWalletProvider => {\n        try {\n          // if there is an error while initiating a provider dont break the whole process.\n          return makeWalletProvider(null)\n        } catch (e) {\n          console.log(`Couldn't initiate a wallet provider. ${e}`)\n          return null\n        }\n      }) // instantiate the provider with null network so we can get the id\n      .filter(walletProvider => walletProvider && true)\n      .map(walletProvider => {\n        return getTransitProviderAttributesByProviderId(walletProvider.id).providerName\n      })\n  }\n\n  /** Inialize EOS Transit wallet provider and return TransitWallet instance */\n  async setupTransitWallet({ walletType, chainNetwork }: SetupTransitWalletParams): Promise<TransitWallet> {\n    this.assertHasProviderInstalled(walletType, ExternalWalletInterface.Transit)\n    this.assertProviderValidForChainNetwork(walletType, chainNetwork)\n    const { providerId } = getTransitProviderAttributes(walletType)\n    const chainContext = await this.getOrCreateTransitAccessContext(chainNetwork)\n    const transitProvider = chainContext.getWalletProviders().find(wp => wp.id === providerId)\n    const transitWallet = chainContext.initWallet(transitProvider)\n    await transitWallet.connect()\n    await this.waitWhileWalletIsBusy(transitWallet, walletType)\n    return transitWallet\n  }\n\n  /** Creates an EOS Transit WalletContent for the specified network and plugins\n   *  Caches the context for future calls to this function */\n  private async getOrCreateTransitAccessContext(chainNetwork: ChainNetwork) {\n    const { appName, eosTransitWalletProviders = [] } = this._oreIdContext.options\n    if (this.transitAccessContexts[chainNetwork]) {\n      return this.transitAccessContexts[chainNetwork]\n    }\n    const networkConfig = await this._oreIdContext.settings.getChainNetworkNextworkConfig(chainNetwork)\n    const isNotEosNetwork = await this._oreIdContext.settings.isNotEosNetwork(chainNetwork)\n    const walletContext = initAccessContext({\n      appName: appName || 'missing appName',\n      network: networkConfig,\n      walletProviders: eosTransitWalletProviders,\n      isNotEosNetwork, // Tells eos-transit to not use EOS specific rpc calls\n    })\n    // cache for future use\n    this.transitAccessContexts[chainNetwork] = walletContext\n    return walletContext\n  }\n\n  // For Scatter: chainAccount is needed since login will try to use the default account (in scatter\n  // and it wil fail to sign the transaction\n  /** Handles the call to connect() function on the Transit provider */\n  async connectToTransitProvider({\n    walletType,\n    chainNetwork,\n    chainAccount = null,\n  }: ConnectToTransitProviderParams): Promise<ConnectToTransitProviderResult> {\n    let response: ConnectToTransitProviderResult\n    this.assertHasProviderInstalled(walletType, ExternalWalletInterface.Transit)\n    this.assertProviderValidForChainNetwork(walletType, chainNetwork)\n    try {\n      const transitWallet: TransitWallet = await this.setupTransitWallet({ walletType, chainNetwork })\n      response = { transitWallet }\n      // some providers require login flow to connect (usually this means connect() does nothing but login selects an account)\n      if (getTransitProviderAttributes(walletType).requiresLogin) {\n        // if connected, but not authenticated, then login\n        if (!transitWallet.authenticated) {\n          await this.loginToTransitProvider(transitWallet, walletType, chainNetwork, chainAccount)\n        }\n      }\n\n      // If connecting also performs login\n      // return login results or throw error\n      if (transitWallet.connected) {\n        // if wallet has an account (by logging in), add it to OREID account add account info to response\n        if (transitWallet.authenticated && transitWallet.auth) {\n          await this.updateOreAccountPermissionsfromTransitWalletAuth(transitWallet, walletType)\n          const { accountName, permission, publicKey } = transitWallet.auth\n          response = {\n            isLoggedIn: true,\n            chainAccount: accountName,\n            permissions: [{ name: permission, publicKey }], // todo: add parent permission when available\n            transitWallet,\n            provider: walletType,\n          }\n        }\n      } else {\n        let errorString = `${walletType} not connected!`\n        const { hasError, errorMessage } = transitWallet\n        if (hasError) {\n          errorString += ` Error: ${errorMessage}`\n        }\n        throw new Error(errorString)\n      }\n    } catch (error) {\n      const errMsg = `Failed to connect to ${walletType} on ${chainNetwork}. ${error?.message || ''}`\n      console.log(`connectToTransitProvider:${errMsg}`, error)\n      throw new Error(errMsg)\n    } finally {\n      this._oreIdContext.setIsBusy(false)\n    }\n\n    return response\n  }\n\n  /** Handles the call to login() function on the Transit provider\n   *  If required by provider, calls discover() and/or logout() before calling login()\n   *  IMPORTANT: use loginToTransitProvider() instead of this function */\n  private async doTransitProviderLogin(\n    transitWallet: TransitWallet,\n    chainAccount: ChainAccount,\n    chainNetwork: ChainNetwork,\n    walletType: ExternalWalletType,\n    retryCount = 0,\n  ) {\n    let info: TransitAccountInfo\n    this.assertHasProviderInstalled(walletType, ExternalWalletInterface.Transit)\n    this.assertProviderValidForChainNetwork(walletType, chainNetwork)\n    // we should store the index for ledger in the db and pass it along\n    // but for now we need to discover the ledger index\n    const { requiresDiscoverToLogin } = getTransitProviderAttributes(walletType)\n    if (requiresDiscoverToLogin) {\n      // we have to discover on ledger since we don't know the index of the account\n      //\n      const discoveryData = await transitWallet.discover(this.discoverOptionsForProvider(walletType))\n      const foundData = this.findAccountInDiscoverData(discoveryData, chainAccount)\n      if (foundData) {\n        info = await transitWallet.login(chainAccount, foundData.authorization)\n      } else {\n        throw new Error(`Account ${chainAccount} not found in wallet`)\n      }\n    } else {\n      info = await transitWallet.login(chainAccount)\n    }\n\n    if (retryCount > 2) {\n      // don't get stuck in a loop, let the transaction fail so the user will figure it out\n      return null\n    }\n\n    const { accountName: transitAccountName } = transitWallet?.auth || {}\n\n    if (chainAccount && transitAccountName !== chainAccount) {\n      // keep trying until the user logs in with the correct wallet\n      // in scatter, it will ask you to choose an account if you logout and log back in\n      // we could also call discover and login to the matching account and that would avoid a step\n      await transitWallet.logout()\n      this.doTransitProviderLogin(transitWallet, chainAccount, chainNetwork, walletType, retryCount + 1)\n    }\n    return info\n  }\n\n  /** Login using the wallet provider */\n  async loginWithTransitProvider(loginOptions: LoginWithWalletOptions) {\n    const { walletType: provider, chainAccount, chainNetwork } = loginOptions\n    // Connect to Provider\n    const walletType = Helpers.mapAuthProviderToWalletType(provider)\n    const response = await this.connectToTransitProvider({ walletType, chainAccount, chainNetwork })\n    const wallet = response?.transitWallet\n    // Login if needed - if not logged-in by connectToTransitProvider, then call login explicitly\n    if (!wallet?.auth) {\n      await this.loginToTransitProvider(wallet, provider, chainNetwork, chainAccount)\n      await this.updateOreAccountPermissionsfromTransitWalletAuth(wallet, provider)\n    }\n    return response\n  }\n\n  /** Handles the call to login() function on the Transit provider */\n  private async loginToTransitProvider(\n    transitWallet: TransitWallet,\n    walletType: ExternalWalletType,\n    chainNetwork: ChainNetwork,\n    chainAccount: ChainAccount = null,\n  ) {\n    this.assertHasProviderInstalled(walletType, ExternalWalletInterface.Transit)\n    this.assertProviderValidForChainNetwork(walletType, chainNetwork)\n    try {\n      // if the default login is for a different account\n      await this.doTransitProviderLogin(transitWallet, chainAccount, chainNetwork, walletType)\n    } catch (error) {\n      const { message = '' } = error\n      if (message.includes('unknown key (boost::tuples::tuple')) {\n        throw new Error(`The account selected by the wallet for login isn't on the ${chainNetwork} chain`)\n      } else {\n        throw error\n      }\n    } finally {\n      await this.waitWhileWalletIsBusy(transitWallet, walletType)\n    }\n  }\n\n  /** Throw if the required plug-in is not installed */\n  assertHasProviderInstalled(provider: ExternalWalletType, providerType: ExternalWalletInterface) {\n    if (providerType === ExternalWalletInterface.Transit) {\n      if (!this.hasTransitProvider(provider)) {\n        throw Error(`Transit provider:\"${provider}\" not installed. Please pass it in via eosTransitWalletProviders.`)\n      }\n    }\n  }\n\n  /** Discovers keys in a wallet provider.\n   *  Any new keys discovered in wallet are added to user's ORE ID record.\n   *  If the provider doesnt support a discover() function, and requiresLogoutLoginToDiscover == true, attempts a logout then login instead.\n   */\n  async discoverWithTransit(discoverOptions: DiscoverOptions) {\n    const { walletType, chainNetwork = ChainNetwork.EosMain, oreAccount, discoveryPathIndexList } = discoverOptions\n    this.assertProviderValidForChainNetwork(walletType, chainNetwork)\n    let result = null\n    if (this.canDiscover(walletType)) {\n      result = await this.discoverCredentialsInTransitWallet(\n        chainNetwork,\n        walletType,\n        oreAccount,\n        discoveryPathIndexList,\n      )\n    } else {\n      // if provider doesn't support a discover function, we can use login to retrieve a single account/key instead\n      const transitWallet = await this.setupTransitWallet({ walletType, chainNetwork })\n      if (this.requiresLogoutLoginToDiscover(walletType)) {\n        await transitWallet.logout()\n        await transitWallet.login()\n        this.updateOreAccountPermissionsfromTransitWalletAuth(transitWallet, walletType)\n      } else {\n        console.log('Discover not working for walletType: ', walletType)\n      }\n    }\n\n    return result\n  }\n\n  /** Discover all accounts (and related permissions) in the wallet and add them to ORE ID\n   * Note: Most wallets don't support discovery */\n  private async discoverCredentialsInTransitWallet(\n    chainNetwork: ChainNetwork,\n    walletType: ExternalWalletType,\n    oreAccount: AccountName,\n    discoveryPathIndexList: number[],\n  ) {\n    let accountsAndPermissions: WalletPermission[] = []\n\n    try {\n      const transitWallet = await this.setupTransitWallet({ walletType, chainNetwork })\n      this._oreIdContext.setIsBusy(true)\n      const discoveryData = await transitWallet.discover(\n        this.discoverOptionsForProvider(walletType, discoveryPathIndexList),\n      )\n      // this data looks like this: keyToAccountMap[accounts[{account,permission}]] - e.g. keyToAccountMap[accounts[{'myaccount':'owner','myaccount':'active'}]]\n      const credentials = discoveryData.keyToAccountMap\n      // for each entry in the array, add permission to ore account if not already present\n      await Helpers.asyncForEach(credentials, async credential => {\n        const { accounts = [], key: publicKey } = credential\n        // ethereum may not have a public key - dont save if missing\n        if (accounts.length > 0 && !!publicKey) {\n          const [{ account, authorization }] = accounts // get first item in array\n          const permissions: WalletPermission[] = [\n            {\n              account,\n              publicKey,\n              name: authorization,\n              parent: null,\n            },\n          ]\n          // Get the chainNetwork from the transitWallet - in case the wallet provider switches networks somehow\n          const transitChainNetwork = await this.getChainNetworkFromTransitWallet(transitWallet)\n          await this._user?.addWalletPermissionsToOreIdAccount({\n            chainAccount: account,\n            chainNetwork: transitChainNetwork,\n            permissions,\n            walletType,\n          })\n          accountsAndPermissions = accountsAndPermissions.concat(permissions)\n        }\n      })\n    } finally {\n      this._oreIdContext.setIsBusy(false)\n    }\n    // return a list of account names and related permissions found\n    return accountsAndPermissions\n  }\n\n  /** Discover options composed for specific provider */\n  private discoverOptionsForProvider(\n    provider: ExternalWalletType,\n    pathIndexListParam: number[] = null,\n  ): TransitDiscoveryOptions {\n    let pathIndexList\n    let keyLookupFunc\n    const walletProviderType = Helpers.mapAuthProviderToWalletType(provider)\n    if (this.hasTransitProvider(walletProviderType)) {\n      const walletProvider = Helpers.mapAuthProviderToWalletType(provider)\n      const { defaultDiscoveryPathIndexList, discoveryKeyLookupFunc } = getTransitProviderAttributes(walletProvider)\n      pathIndexList = pathIndexListParam || defaultDiscoveryPathIndexList || []\n      keyLookupFunc = discoveryKeyLookupFunc // optional\n    }\n\n    const response: TransitDiscoveryOptions = { pathIndexList }\n    if (keyLookupFunc) {\n      response.keyLookupFunc = keyLookupFunc\n    }\n\n    return response\n  }\n\n  private findAccountInDiscoverData(discoveryData: any, chainAccount: ChainAccount) {\n    const result = discoveryData.keyToAccountMap.find((data: any) => {\n      return data.accounts.find((acct: any) => {\n        return acct.account === chainAccount\n      })\n    })\n\n    if (result) {\n      let authorization = 'active'\n\n      // could active not exist?  If not, then just get first permission\n      // this may be completely unecessary. remove if so.\n      const active = result.accounts.find((acct: any) => {\n        return acct.authorization === 'active'\n      })\n\n      if (!active) {\n        const [first] = result.accounts\n\n        if (first) {\n          // eslint-disable-next-line prefer-destructuring\n          authorization = first.authorization\n        }\n      }\n\n      return { index: result.index, key: result.key, authorization }\n    }\n\n    return null\n  }\n\n  /** sign with a Transit wallet */\n  async signWithTransitProvider(transactionData: TransactionData, walletType: ExternalWalletType) {\n    let signedTransaction: SignatureProviderSignResult\n    const { chainNetwork, chainAccount } = transactionData\n    this.assertHasProviderInstalled(walletType, ExternalWalletInterface.Transit)\n    this.assertProviderValidForChainNetwork(walletType, chainNetwork)\n    // connect to wallet\n    const { transitWallet } = await this.connectToTransitProvider({\n      walletType,\n      chainNetwork,\n      chainAccount,\n    })\n\n    try {\n      // sign with transit wallet\n      this._oreIdContext.setIsBusy(true)\n      const { chainType } = getTransitProviderAttributes(walletType)\n      // EOS - use eosJS to sign (eosApi.transact)\n      if (chainType === ChainPlatformType.eos) {\n        signedTransaction = await this.signTransactionWithTransitAndEosSDK(transactionData, transitWallet)\n      } else if (chainType === ChainPlatformType.algorand) {\n        // Other chains - use sign function on walletProvider\n        signedTransaction = await this.signTransactionWithTransitAndAlgorandSDK(transactionData, transitWallet)\n      } else if (chainType === ChainPlatformType.ethereum) {\n        // Ethereum - use sign function on ethereum walletProvider\n        signedTransaction = await this.signTransactionWithTransitAndEthereumSDK(transactionData, transitWallet)\n      } else {\n        throw new Error(`signWithTransitProvider doesnt support chain type: ${chainType}`)\n      }\n    } catch (error) {\n      console.error(error)\n      throw error\n    } finally {\n      this._oreIdContext.setIsBusy(false)\n    }\n    // Convert serializedTransaction from UInt8Array to Buffer\n    // i.e. when stringified change from: '{\\\"0\\\":129,\\\"1\\\":163'} to {\"type\":\"Buffer\",\"data\":[129,163]}\n    if (signedTransaction.serializedTransaction) {\n      signedTransaction.serializedTransaction = Buffer.from(signedTransaction.serializedTransaction)\n    }\n    return { signedTransaction }\n  }\n\n  async signStringWithTransitProvider({ walletType, chainNetwork, string, message, metadata }: SignStringParams) {\n    this.assertHasProviderInstalled(walletType, ExternalWalletInterface.Transit)\n    this.assertProviderValidForChainNetwork(walletType, chainNetwork)\n    const { transitWallet } = await this.connectToTransitProvider({ walletType, chainNetwork })\n    try {\n      this._oreIdContext.setIsBusy(true)\n      const response = await transitWallet.signArbitrary(string, message, metadata)\n      return { signedString: response }\n    } catch (error) {\n      console.error(error)\n      throw error\n    } finally {\n      this._oreIdContext.setIsBusy(false)\n    }\n  }\n\n  /** sign transaction using EOS SDK .transact function */\n  private async signTransactionWithTransitAndEosSDK(\n    transactionData: TransactionData,\n    transitWallet: Wallet,\n  ): Promise<SignatureProviderSignResult> {\n    const { expireSeconds, transaction } = transactionData\n    const { broadcast } = transactionData?.signOptions || {}\n    const { signatures, serializedTransaction } = await transitWallet.eosApi.transact(\n      {\n        actions: [transaction],\n      },\n      {\n        broadcast,\n        blocksBehind: 3,\n        expireSeconds: expireSeconds || 60,\n      },\n    )\n    await this.callDiscoverAfterSign(transactionData)\n    return { signatures, serializedTransaction }\n  }\n\n  /** sign transaction using Algorand SDK */\n  private async signTransactionWithTransitAndAlgorandSDK(\n    transactionData: TransactionData,\n    transitWallet: Wallet,\n  ): Promise<SignatureProviderSignResult> {\n    const { chainNetwork, transaction } = transactionData\n    // Other chains - use sign function on walletProvider\n    const networkConfig = await this._oreIdContext.settings.getChainNetworkNextworkConfig(chainNetwork)\n    const signParams: SignatureProviderArgs = {\n      chainId: networkConfig.chainId, // Chain transaction is for\n      requiredKeys: null, // not used by Algorand signatureProvider\n      serializedTransaction: msgPackEncode(transaction), // Transaction to sign\n      abis: null, // not used by Algorand signatureProvider\n    }\n    const { signatures, serializedTransaction } = await transitWallet.provider.signatureProvider.sign(signParams)\n    await this.callDiscoverAfterSign(transactionData)\n    return { signatures, serializedTransaction }\n  }\n\n  /** sign transaction using ethereum web3 SDK */\n  private async signTransactionWithTransitAndEthereumSDK(\n    transactionData: TransactionData,\n    transitWallet: Wallet,\n  ): Promise<SignatureProviderSignResult> {\n    const { chainNetwork, transaction } = transactionData\n    // Other chains - use sign function on walletProvider\n    const networkConfig = await this._oreIdContext.settings.getChainNetworkNextworkConfig(chainNetwork)\n    const signParams: SignatureProviderArgs = {\n      chainId: networkConfig.chainId, // Chain transaction is for\n      requiredKeys: null, // not used by Ethereum signatureProvider\n      serializedTransaction: msgPackEncode(transaction), // Transaction to sign\n      abis: null, // not used by Ethereum signatureProvider\n    }\n    const { signatures, serializedTransaction } = await transitWallet.provider.signatureProvider.sign(signParams)\n    await this.callDiscoverAfterSign(transactionData)\n    return { signatures, serializedTransaction }\n  }\n\n  /** Determine the chainNetwork from the transitWallet context */\n  async getChainNetworkFromTransitWallet(transitWallet: TransitWallet) {\n    const { chainId } = transitWallet?.ctx?.network || {}\n    if (!chainId) {\n      return null\n    }\n    const networks = await this._oreIdContext.settings.getAllChainNetworkSettings()\n    return networks.find(net => net.hosts.find(host => host.chainId === chainId))?.network\n  }\n\n  /** Add the account selected in the transitWallet to the ORE account's list of account/permissions */\n  async updateOreAccountPermissionsfromTransitWalletAuth(transitWallet: TransitWallet, walletType: ExternalWalletType) {\n    if (!transitWallet?.connected || !transitWallet?.auth) {\n      return\n    }\n    const { accountName, permission, publicKey } = transitWallet.auth\n    // abort silently if account is missing some info - some chains/wallets (e.g. ethereum) dont provide the public key, so we can't add the perm here\n    if (!accountName || !permission || !publicKey) {\n      return\n    }\n    const permissions: WalletPermission[] = [{ name: permission, publicKey }] // todo: add parent permission when available\n    // Get the chainNetwork from the transitWallet - in case the wallet provider switches networks somehow\n    const transitChainNetwork = await this.getChainNetworkFromTransitWallet(transitWallet)\n    if (transitChainNetwork) {\n      await this._user?.updatePermissionsIfNecessary({\n        chainAccount: accountName,\n        chainNetwork: transitChainNetwork,\n        permissions,\n        walletType,\n      })\n    }\n  }\n\n  isTransitProvider(provider: AuthProvider | ExternalWalletType) {\n    const walletProviderType = Helpers.mapAuthProviderToWalletType(provider)\n    if (!walletProviderType) return false\n    return supportedTransitProviders.includes(walletProviderType)\n  }\n\n  /** Whether this Eos Transit provider was installed upon instantiation */\n  hasTransitProvider(walletType: ExternalWalletType): boolean {\n    return this._oreIdContext.transitProvidersInstalled.includes(walletType)\n  }\n\n  /** Throw if the provider doesnt support the specified chainNetwork */\n  async assertProviderValidForChainNetwork(walletType: ExternalWalletType, chainNetwork: ChainNetwork) {\n    const { chainType } = getTransitProviderAttributes(walletType)\n    const networks = await this._oreIdContext.settings.getAllChainNetworkSettings()\n    const isValid = !!networks.find(n => n.network === chainNetwork && n.type === chainType)\n    if (!isValid) {\n      throw Error(\n        `External Wallet Type: ${walletType} doesnt support chainNetwork ${chainNetwork}. Hint: It supports networks of type ${chainType}.`,\n      )\n    }\n  }\n\n  private async waitWhileWalletIsBusy(transitWallet: TransitWallet, walletType: ExternalWalletType) {\n    while (transitWallet.inProgress) {\n      this._oreIdContext.setIsBusy(true)\n      // todo: add timeout\n      // eslint-disable-next-line no-await-in-loop\n      await Helpers.sleep(250)\n      // this is here to help a developer debug - dont remove this - if a wallet is not open to connect to, it will hang here\n      console.log(`connecting to ${walletType} via eos-transit wallet in progress:`, transitWallet.inProgress)\n    }\n    this._oreIdContext.setIsBusy(false)\n  }\n\n  /** Discovers keys in a wallet provider.\n   *  Any new keys discovered in wallet are added to user's ORE ID record.\n   *  If the provider doesnt support a discover() function, and requiresLogoutLoginToDiscover == true, attempts a logout then login instead.\n   */\n  async discover(discoverOptions: DiscoverOptions) {\n    return this.discoverWithTransit(discoverOptions)\n  }\n\n  /** Call discover after signing so we capture and save the account\n   *  Note: This is needed for Ethereum since we dont know a public key until we sign with an account\n   */\n  async callDiscoverAfterSign(transactionData: TransactionData) {\n    const { chainNetwork, account } = transactionData\n    const { provider } = transactionData?.signOptions || {}\n    const walletProvider = Helpers.mapAuthProviderToWalletType(provider)\n    const discoverOptions: DiscoverOptions = {\n      walletType: walletProvider,\n      chainNetwork,\n      oreAccount: account,\n    }\n    await this.discover(discoverOptions)\n  }\n\n  // Supported features by provider\n\n  /** whether discovery is supported by the provider */\n  canDiscover(walletType: ExternalWalletType) {\n    if (this.hasTransitProvider(walletType)) {\n      return getTransitProviderAttributes(walletType).supportsDiscovery\n    }\n    return false\n  }\n\n  /** whether signString is supported by the provider */\n  canSignString(walletType: ExternalWalletType) {\n    if (this.hasTransitProvider(walletType)) {\n      return getTransitProviderAttributes(walletType).supportsSignArbitrary\n    }\n    return false\n  }\n\n  /** whether call to discover is required by provider before login */\n  requiresDiscoverToLogin(walletType: ExternalWalletType) {\n    if (this.hasTransitProvider(walletType)) {\n      return getTransitProviderAttributes(walletType).requiresDiscoverToLogin\n    }\n    return false\n  }\n\n  /** whether call to logout then login is required by provider before discover */\n  requiresLogoutLoginToDiscover(walletType: ExternalWalletType) {\n    if (this.hasTransitProvider(walletType)) {\n      return getTransitProviderAttributes(walletType).requiresLogoutLoginToDiscover\n    }\n    return false\n  }\n\n  /** default path index for provider (if any) */\n  defaultDiscoveryPathIndexList(walletType: ExternalWalletType): number[] {\n    if (this.hasTransitProvider(walletType)) {\n      return getTransitProviderAttributes(walletType)?.defaultDiscoveryPathIndexList\n    }\n    return null\n  }\n\n  /** help text displayed to user for provider */\n  helpTextForProvider(walletType: ExternalWalletType) {\n    if (this.hasTransitProvider(walletType)) {\n      return getTransitProviderAttributes(walletType).helpText\n    }\n\n    return null\n  }\n}\n","import { ExternalWalletType, ChainPlatformType } from '../common/models'\nimport { UalProviderAttributes } from '../ual/models'\n\nexport const ualProviderAttributesData: UalProviderAttributes[] = [\n  {\n    providerName: ExternalWalletType.Anchor,\n    providerId: 'Anchor',\n    chainType: ChainPlatformType.eos,\n    requiresLogin: true,\n    supportsSignArbitrary: false,\n    requiresLogoutLoginToDiscover: false,\n    requiresDiscoverToLogin: false,\n    supportsDiscovery: false,\n    helpText: {\n      login: 'This wallet doesnt require you to login',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-generic-logo.png', // TODO: Add actual logo\n  },\n  {\n    providerName: ExternalWalletType.Ledger,\n    providerId: 'Ledger',\n    chainType: ChainPlatformType.eos,\n    requiresLogin: true,\n    supportsSignArbitrary: false,\n    requiresLogoutLoginToDiscover: false,\n    requiresDiscoverToLogin: false,\n    supportsDiscovery: false,\n    helpText: {\n      login: 'This wallet doesnt require you to login',\n      sign: 'Connect and unlock your Ledger with your PIN code. Launch the EOS app on the device.',\n      discover: 'Connect and unlock your Ledger with your PIN code. Launch the EOS app on the device.',\n      versionsRequired:\n        'You need to have recent versions of your browser, Ledger firmware, and the Ledger EOS app. Click here for more details.',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-ledger-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.Lynx,\n    providerId: 'Lynx',\n    chainType: ChainPlatformType.eos,\n    requiresLogin: false,\n    supportsSignArbitrary: true,\n    requiresLogoutLoginToDiscover: false,\n    requiresDiscoverToLogin: false,\n    supportsDiscovery: false,\n    helpText: {\n      login: 'This wallet doesnt require you to login',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-lynx-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.Scatter,\n    providerId: 'Scatter',\n    chainType: ChainPlatformType.eos,\n    requiresLogin: true,\n    supportsSignArbitrary: true,\n    requiresLogoutLoginToDiscover: false,\n    requiresDiscoverToLogin: false,\n    supportsDiscovery: false,\n    helpText: {\n      login: 'Scatter requires logging in through the Scatter app.',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-scatter-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.TokenPocket,\n    providerId: 'Token Pocket',\n    chainType: ChainPlatformType.eos,\n    requiresLogin: false,\n    supportsSignArbitrary: true,\n    requiresLogoutLoginToDiscover: false,\n    requiresDiscoverToLogin: false,\n    supportsDiscovery: false,\n    helpText: {\n      login: 'This wallet doesnt require you to login',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-generic-logo.png',\n  },\n  {\n    providerName: ExternalWalletType.Wombat,\n    providerId: 'Wombat',\n    chainType: ChainPlatformType.eos,\n    requiresLogin: true,\n    supportsSignArbitrary: true,\n    requiresLogoutLoginToDiscover: false,\n    requiresDiscoverToLogin: false,\n    supportsDiscovery: false,\n    helpText: {\n      login: 'This wallet doesnt require you to login',\n      sign: '',\n      discover: '',\n      versionsRequired: '',\n    },\n    logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-wombat-logo.png', // TODO: Add actual logo\n  },\n]\n\n/** Get provider-specific settings and metadata */\nexport function getUalProviderAttributes(walletType: ExternalWalletType): UalProviderAttributes {\n  return ualProviderAttributesData.find(up => up.providerName === walletType.toString().toLowerCase())\n}\n\n/** Get provider-specific settings and metadata by the UAL provider name */\nexport function getUalProviderAttributesByUalName(walletType: string): UalProviderAttributes {\n  return ualProviderAttributesData.find(up => up.providerName === walletType.toLowerCase())\n}\n\nexport const supportedUALProviders: ExternalWalletType[] = ualProviderAttributesData.map(tp => tp.providerName)\n","import { getUalProviderAttributes, getUalProviderAttributesByUalName, supportedUALProviders } from './ualProviders'\nimport OreIdContext from '../core/IOreidContext'\nimport Helpers from '../utils/helpers'\nimport {\n  ChainAccount,\n  ChainNetwork,\n  ExternalWalletInterface,\n  ExternalWalletType,\n  LoginWithWalletOptions,\n  SignatureProviderSignResult,\n  SignStringParams,\n  TransactionData,\n} from '../models'\nimport { User } from '../user/user'\nimport {\n  ConnectToUalProviderParams,\n  ConnectToUalProviderResult,\n  UalAuthenticator,\n  UalAuthenticatorFactory,\n  UalUser,\n  UserAccountPermissions,\n} from './models'\nimport { Authenticator, SignTransactionResponse } from 'universal-authenticator-library'\n\nexport default class UalHelper {\n  constructor(args: { oreIdContext: OreIdContext; user: User }) {\n    this._oreIdContext = args.oreIdContext\n    this._user = args.user\n  }\n\n  _oreIdContext: OreIdContext\n\n  _user: User\n\n  /** Verifies that all plugins have a valid name\n   *  Stores a list of the installed providerNames for all working plugins in ualProvidersInstalled\n   */\n  async installUalProviders(ualWalletProviders: UalAuthenticatorFactory[]) {\n    // Maps installed UALProviders to array of ExternaLWalletType names\n    this._oreIdContext.ualProvidersInstalled = (ualWalletProviders || []).map(\n      ualProviderFactory => getUalProviderAttributesByUalName(ualProviderFactory?.name)?.providerName,\n    )\n  }\n\n  /** Retrieve the user and their account/permission details for the matching chainNetwork\n   *  Returns null if nothing in wallet for chainNetwork\n   */\n  async loginToUalProvider(\n    walletType: ExternalWalletType,\n    authenticator: Authenticator,\n    chainNetwork: ChainNetwork,\n    chainAccount: ChainAccount,\n  ): Promise<{ user: UalUser; userPermissions: UserAccountPermissions }> {\n    this.assertHasProviderInstalled(walletType, ExternalWalletInterface.Ual)\n    this.assertProviderValidForChainNetwork(walletType, chainNetwork)\n    try {\n      // we get an array of users - one for each chain being used in the wallet\n      const users: UalUser[] = await authenticator.login(chainAccount)\n      if (Helpers.isNullOrEmpty(users)) return null\n\n      // for every supported chain, populate a result with the user and user's account/permission info\n      const usersWithAccountsDetails: { user: UalUser; userPermissions: UserAccountPermissions }[] = []\n      await Helpers.asyncForEach(users, async user => {\n        const userPermissions = await this.getAccountAndPermissionsFromUalUser(user)\n        usersWithAccountsDetails.push({ user, userPermissions })\n      })\n\n      // get only the user matching the desired chainNetwork\n      const userForChain = usersWithAccountsDetails.find(uwa => uwa.userPermissions.chainNetwork === chainNetwork)\n      return userForChain\n    } catch (error) {\n      const { message = '' } = error\n      if (message.includes('unknown key (boost::tuples::tuple')) {\n        throw new Error(`The account selected by the wallet for login isn't on the ${chainNetwork} chain`)\n      } else {\n        throw error\n      }\n    }\n  }\n\n  // TODO: We should cache the wallet/user object to avoid calling login everytime we need to sign\n  async connectToUalProvider({\n    walletType,\n    chainNetwork,\n    chainAccount = null,\n  }: ConnectToUalProviderParams): Promise<ConnectToUalProviderResult> {\n    this.assertHasProviderInstalled(walletType, ExternalWalletInterface.Ual)\n    this.assertProviderValidForChainNetwork(walletType, chainNetwork)\n    const { options } = this._oreIdContext\n\n    const SelectedAuthenticator = options.ualAuthenticators.find(\n      ualAuthenticator => ualAuthenticator.name.toLowerCase() === walletType,\n    )\n\n    try {\n      const networkConfig = await this._oreIdContext.settings.getChainNetworkNextworkConfig(chainNetwork)\n      const ualNetworkConfig = {\n        chainId: networkConfig.chainId,\n        rpcEndpoints: [\n          {\n            ...networkConfig,\n          },\n        ],\n      }\n      // construct authenticator\n      const authenticator = new SelectedAuthenticator([ualNetworkConfig], {\n        appName: options.appName,\n      })\n\n      this._oreIdContext.setIsBusy(true) // busy is cleared by waitWhileWalletIsBusy when done\n      await authenticator.init()\n      await this.waitWhileWalletIsBusy(authenticator, walletType)\n\n      // TODO: consider if we should wait while .isLoading()\n\n      if (authenticator.isErrored()) {\n        const ualError = authenticator.getError()\n        console.log(`Error connecting to UAL wallet type: ${ualError.name}`, ualError.cause)\n        throw ualError.cause // re-throw error\n      }\n\n      // // TODO: consider if this code is relevant\n      // if (authenticator.shouldAutoLogin() !== true) return null\n\n      const userForChain = await this.loginToUalProvider(walletType, authenticator, chainNetwork, chainAccount)\n\n      // No user in the wallet for the given chainNetwork\n      if (!userForChain) {\n        console.log(`User doesn't have an account for the chainNetwork: ${chainNetwork} in wallet type: ${walletType}`)\n        return null\n      }\n\n      // Update permissions in oreId - TODO: consider if we should update all the permissions in all the found chains (in usersWithAccountsDetails)\n      try {\n        await this.updateOreAccountPermissionsfromUalUser(userForChain.user, walletType)\n      } catch (error) {\n        console.log(\n          `Failed to add newly discovered chain accounts in connectToUalProvider for chainNetwork: ${chainNetwork} in wallet type: ${walletType}`,\n          error,\n        )\n      }\n\n      // const {\n      //   account,\n      //   chainNetwork: chainNetworkFromAuthenticator, // get the chainNetwork from the UALProvider since we cant tell it what network to use\n      //   permissions,\n      // } = await this.getAccountAndPermissionsFromUalUser(user)\n      // const publicKeys = await user.getKeys()\n      // const account = await user.getAccountName()\n      // const permissions = [{ name: 'active', publicKey: publicKeys[0] }]\n\n      const response = {\n        isLoggedIn: true,\n        chainAccount: userForChain.userPermissions.chainAccount,\n        chainNetwork: userForChain.userPermissions.chainNetwork,\n        permissions: userForChain.userPermissions.permissions,\n        walletType,\n        authenticator,\n        ualUser: userForChain.user,\n      }\n      return response\n    } catch (error) {\n      console.log(`Failed to connect to ${walletType} wallet:`, error)\n      throw error\n    }\n  }\n\n  /** Extract user account/permission for all publicKeys in the User's wallet */\n  async getAccountAndPermissionsFromUalUser(ualUser: UalUser): Promise<UserAccountPermissions> {\n    const chainId = await ualUser.getChainId()\n    const chainNetwork = await this._oreIdContext.settings.getChainNetworkByChainId(chainId)\n    const account = await ualUser.getAccountName()\n    const publicKeys = await this.getKeys(ualUser)\n    // for each publicKey in the user's wallet, return a WalletPermission object\n    const permissions = publicKeys.map(publicKey => ({\n      account,\n      publicKey,\n      name: 'active', // UAL doesn't return the permission so we default to active\n      // todo: add parent permission when available\n    }))\n    return { chainAccount: account, chainNetwork, permissions }\n  }\n\n  /** Login using the wallet provider */\n  async loginWithUalProvider(loginOptions: LoginWithWalletOptions) {\n    const { walletType, chainAccount, chainNetwork } = loginOptions\n    // Connect to Provider\n    const response = await this.connectToUalProvider({ walletType, chainAccount, chainNetwork })\n    const { authenticator, isLoggedIn } = response\n    // Login if needed - if not logged-in by connectToUalProvider, then call login explicitly\n    if (!isLoggedIn) {\n      const userForChain = await this.loginToUalProvider(walletType, authenticator, chainNetwork, chainAccount)\n      if (userForChain) {\n        await this.updateOreAccountPermissionsfromUalUser(userForChain.user, walletType)\n      }\n    }\n    return response\n  }\n\n  /** Throw if the required plug-in is not installed */\n  assertHasProviderInstalled(provider: ExternalWalletType, providerType: ExternalWalletInterface) {\n    if (providerType === ExternalWalletInterface.Ual) {\n      if (!this.hasUalProvider(provider)) {\n        throw Error(`UAL authenticator:\"${provider}\" not installed. Please pass it in via ualAuthenticators.`)\n      }\n    }\n  }\n\n  /** sign with a UAL wallet */\n  async signWithUalProvider(\n    transactionData: TransactionData,\n    walletType: ExternalWalletType,\n  ): Promise<{ signedTransaction: SignatureProviderSignResult }> {\n    const { chainNetwork, transaction, chainAccount, signOptions } = transactionData\n    const { provider, broadcast } = signOptions\n    this.assertHasProviderInstalled(walletType, ExternalWalletInterface.Ual)\n    this.assertProviderValidForChainNetwork(walletType, chainNetwork)\n    const { ualUser } = await this.connectToUalProvider({ walletType, chainNetwork, chainAccount })\n    let signedTransactionResponse: SignTransactionResponse\n    try {\n      this._oreIdContext.setIsBusy(true)\n      signedTransactionResponse = await ualUser.signTransaction(transaction, { broadcast })\n\n      // Convert serializedTransaction from UInt8Array to Buffer\n      // i.e. when stringified change from: '{\\\"0\\\":129,\\\"1\\\":163'} to {\"type\":\"Buffer\",\"data\":[129,163]}\n      const { serializedTransaction } = signedTransactionResponse.transaction\n      if (serializedTransaction) {\n        signedTransactionResponse.transaction.serializedTransaction = Buffer.from(serializedTransaction)\n      }\n      return { signedTransaction: signedTransactionResponse.transaction }\n    } catch (error) {\n      console.error(error)\n      throw error\n    } finally {\n      this._oreIdContext.setIsBusy(false)\n    }\n  }\n\n  /** Signs an arbitrary string using a specific provider */\n  async signStringWithUalProvider({ walletType, chainNetwork, string, chainAccount, message }: SignStringParams) {\n    this.assertHasProviderInstalled(walletType, ExternalWalletInterface.Ual)\n    this.assertProviderValidForChainNetwork(walletType, chainNetwork)\n    const { ualUser } = await this.connectToUalProvider({ walletType, chainNetwork, chainAccount })\n    try {\n      this._oreIdContext.setIsBusy(true)\n      const keys = await this.getKeys(ualUser)\n      const response = await ualUser.signArbitrary(keys[0], string, message)\n      return { signedString: response }\n    } catch (error) {\n      console.error(error)\n      throw error\n    } finally {\n      this._oreIdContext.setIsBusy(false)\n    }\n  }\n\n  /** Add the account selected in the UAL User to the ORE account's list of account/permissions */\n  async updateOreAccountPermissionsfromUalUser(user: UalUser, walletType: ExternalWalletType): Promise<void> {\n    if (!user) return\n\n    const { chainAccount, chainNetwork, permissions } = await this.getAccountAndPermissionsFromUalUser(user)\n    // abort silently if account is missing some info - some chains/wallets (e.g. ethereum) dont provide the public key, so we can't add the perm here\n    if (!chainAccount || !permissions || !chainNetwork) return\n\n    // save permissions to oreid service\n    await this._user?.updatePermissionsIfNecessary({\n      chainAccount,\n      chainNetwork,\n      permissions,\n      walletType,\n    })\n    return\n  }\n\n  /** Whether this UAL provider was installed upon instantiation */\n  isUalProvider(walletType: ExternalWalletType) {\n    const walletProviderType = Helpers.mapAuthProviderToWalletType(walletType)\n    if (!walletProviderType) return false\n    return supportedUALProviders.includes(walletProviderType)\n  }\n\n  /** Whether this UAL provider was installed upon instantiation */\n  hasUalProvider(walletType: ExternalWalletType): boolean {\n    return this._oreIdContext.ualProvidersInstalled.includes(walletType)\n  }\n\n  /**\n   * get user account keys\n   * some wallets don't support getKeys\n   */\n  async getKeys(ualUser: UalUser): Promise<string[]> {\n    let keys: string[]\n\n    try {\n      keys = await ualUser.getKeys()\n    } catch (error) {\n      // TODO: add logic to get permissions from eos chain for this account\n      // const account = await ualUser.getAccountName()\n      // const ualUserAccount = (ualUser as any).client && (await (ualUser as any).client.v1.chain.get_account(account))\n      // const keys = await (ualUser as any).extractAccountKeys(ualUserAccount)\n      keys = []\n    }\n\n    return keys\n  }\n\n  /** Throw if the provider doesnt support the specified chainNetwork */\n  async assertProviderValidForChainNetwork(walletType: ExternalWalletType, chainNetwork: ChainNetwork) {\n    const { chainType } = getUalProviderAttributes(walletType)\n    const networks = await this._oreIdContext.settings.getAllChainNetworkSettings()\n    const isValid = !!networks.find(n => n.network === chainNetwork && n.type === chainType)\n    if (!isValid) {\n      throw Error(\n        `External Wallet Type: ${walletType} doesnt support chainNetwork ${chainNetwork}. Hint: It supports networks of type ${chainType}.`,\n      )\n    }\n  }\n\n  /** set isBusy on oreIdContext while wallet authenticator isLoading */\n  private async waitWhileWalletIsBusy(ualAuthenticator: UalAuthenticator, walletType: ExternalWalletType) {\n    while (ualAuthenticator.isLoading()) {\n      this._oreIdContext.setIsBusy(true)\n      // todo: add timeout\n      // eslint-disable-next-line no-await-in-loop\n      await Helpers.sleep(250)\n      // this is here to help a developer debug - dont remove this - if a wallet is not open to connect to, it will hang here\n      console.log(`connecting to ${walletType} via UAL wallet in progress:`, ualAuthenticator.isLoading())\n    }\n    this._oreIdContext.setIsBusy(false)\n  }\n\n  // Supported features by provider\n\n  /** whether discovery is supported by the provider */\n  canDiscover(walletType: ExternalWalletType) {\n    if (this.hasUalProvider(walletType)) {\n      return getUalProviderAttributes(walletType).supportsDiscovery\n    }\n    return false\n  }\n\n  /** whether signString is supported by the provider */\n  canSignString(walletType: ExternalWalletType) {\n    if (this.hasUalProvider(walletType)) {\n      return getUalProviderAttributes(walletType).supportsSignArbitrary\n    }\n    return false\n  }\n\n  /** whether call to discover is required by provider before login */\n  requiresDiscoverToLogin(walletType: ExternalWalletType) {\n    if (this.hasUalProvider(walletType)) {\n      return getUalProviderAttributes(walletType).requiresDiscoverToLogin\n    }\n    return false\n  }\n\n  /** whether call to logout then login is required by provider before discover */\n  requiresLogoutLoginToDiscover(walletType: ExternalWalletType) {\n    if (this.hasUalProvider(walletType)) {\n      return getUalProviderAttributes(walletType).requiresLogoutLoginToDiscover\n    }\n    return false\n  }\n\n  /** default path index for provider (if any) */\n  defaultDiscoveryPathIndexList(walletType: ExternalWalletType): number[] {\n    if (this.hasUalProvider(walletType)) {\n      return getUalProviderAttributes(walletType)?.defaultDiscoveryPathIndexList\n    }\n    return null\n  }\n\n  /** help text displayed to user for provider */\n  helpTextForProvider(walletType: ExternalWalletType) {\n    if (this.hasUalProvider(walletType)) {\n      return getUalProviderAttributes(walletType).helpText\n    }\n\n    return null\n  }\n}\n","export class Observable<Subscriber extends Function> {\n  private _subscribers: any[]\n\n  constructor() {\n    this._subscribers = []\n  }\n\n  public subscribe(subscriber: Subscriber) {\n    const hasThisSubscriber = this._subscribers.find(s => s === subscriber)\n    if (!subscriber || hasThisSubscriber) {\n      return\n    }\n    subscriber(this)\n    this._subscribers.push(subscriber)\n  }\n\n  public unsubscribe(subscriber: Subscriber) {\n    this._subscribers = this._subscribers.filter(f => f !== subscriber)\n  }\n\n  public callSubscribers() {\n    this._subscribers.forEach(f => f(this))\n  }\n}\n","import OreIdContext from '../../core/IOreidContext'\nimport { ApiEndpoint, ProcessId, RequestType } from '../../models'\nimport { assertHasApiKeyOrAccessToken, assertParamsHaveRequiredValues } from '../helpers'\n\nexport type ApiUpdateDelayWalletSetupParams = {\n  account?: string\n  /** new value for wallet.delayWalletSetup property */\n  delayWalletSetup?: boolean\n}\n\nexport type ApiUpdateDelayWalletSetupBodyParams = {\n  account?: string\n  delay_wallet_setup?: boolean\n}\n\nexport type CallApiUpdateDelayWalletSetupResult = {\n  success: boolean\n  processId: ProcessId\n}\n\n/** Call the account/update-delay-wallet-setup api\n * Sets the value of the wallet's delayWalletSetup flag\n * Can only be updated if the wallet is not yet setup (wallet.requiresWalletSetup = false)\n * Returns: success: true (or throws an error)\n * */\nexport async function callApiUpdateDelayWalletSetup(\n  oreIdContext: OreIdContext,\n  params: ApiUpdateDelayWalletSetupParams,\n): Promise<CallApiUpdateDelayWalletSetupResult> {\n  const apiName = ApiEndpoint.UpdateDelayWalletSetup\n  const { account, delayWalletSetup } = params\n\n  assertHasApiKeyOrAccessToken(oreIdContext, apiName)\n  assertParamsHaveRequiredValues(params, ['account', 'delayWalletSetup'], apiName)\n\n  const body: ApiUpdateDelayWalletSetupBodyParams = {\n    account: account,\n    delay_wallet_setup: delayWalletSetup,\n  }\n\n  const results = await oreIdContext.callOreIdApi(RequestType.Post, ApiEndpoint.UpdateDelayWalletSetup, body, null)\n  return results // success: true\n}\n","import {\n  ApiGetUserParams,\n  callApiDeleteTestUser,\n  callApiGetUser,\n  callApiPasswordLessSendCode,\n  callApiPasswordLessVerifyCode,\n} from '../api'\nimport { callApiAddPermission } from '../api/endpoints/addPermission'\nimport OreIdContext from '../core/IOreidContext'\nimport { getOreIdNewChainAccountUrl } from '../core/urlGenerators'\nimport Helpers from '../utils/helpers'\nimport { Observable } from '../utils/observable'\nimport { AuthProvider, AccountName, ChainAccount, ChainNetwork, ExternalWalletType } from '../common/models'\nimport { NewAccountOptions, NewAccountWithOreIdResult } from '../core/models'\nimport {\n  UserChainAccount,\n  UserData,\n  UserPermissionData,\n  UserPermissionForChainAccount,\n  UserSourceData,\n  WalletPermission,\n} from './models'\nimport { AccessTokenHelper } from '../auth/accessTokenHelper'\nimport { callApiUpdateDelayWalletSetup } from '../api/endpoints/updateDelayWalletSetup'\n\nconst { isNullOrEmpty } = Helpers\n\nexport type SubscriberUser = (values: User) => void\n\nexport class User extends Observable<SubscriberUser> {\n  constructor(args: { oreIdContext: OreIdContext; accessTokenHelper: AccessTokenHelper; accountName: AccountName }) {\n    super()\n    this._oreIdContext = args.oreIdContext\n    this._accessTokenHelper = args.accessTokenHelper // reference to current accessToken (via getter)\n    this._accountName = args.accountName\n    this._accessTokenHelper.subscribe(this.onUpdateAccessTokenHelper)\n  }\n\n  // pulled from the accessToken\n  private _accountName: AccountName\n\n  private _accessTokenHelper: AccessTokenHelper\n\n  private _oreIdContext: OreIdContext\n\n  /** User's basic information and blockchain accounts (aka permissions) */\n  private _userSourceData: UserSourceData\n\n  private get accessToken(): string {\n    return this._accessTokenHelper.accessToken\n  }\n\n  /** User's OreID (accountName) */\n  get accountName(): AccountName {\n    return this._accountName\n  }\n\n  /** User's personal info (e.g. name, email, picture) */\n  get data(): UserData {\n    this.assertUserHasData()\n    const { permissions, ...otherInfo } = this._userSourceData\n    return {\n      ...otherInfo,\n      chainAccounts: this.getChainAccounts(),\n    }\n  }\n\n  /** Whether user's data has been retrieved with getData() */\n  get hasData() {\n    return !isNullOrEmpty(this?._userSourceData)\n  }\n\n  private setUserSourceData(userSourceData: UserSourceData) {\n    this._userSourceData = userSourceData\n    super.callSubscribers()\n  }\n\n  /** Return Blockchain accounts associated with the user's OreId account */\n  private getChainAccounts(): UserChainAccount[] {\n    this.assertUserHasData()\n    const chainAccounts = (this._userSourceData.permissions || []).map(perm => {\n      const [defaultPermission] = this.getDefaultPermissionForChainAccount(perm.chainAccount, perm.chainNetwork)\n      return {\n        chainAccount: perm.chainAccount,\n        chainNetwork: perm.chainNetwork,\n        defaultPermission,\n        permissions: this.getPermissionForChainAccount(perm.chainAccount, perm.chainNetwork),\n      }\n    })\n    // only return unique combinations of chainAccount and chainNetwork\n    return Helpers.getUniqueValues(chainAccounts)\n  }\n\n  /** Whether we have a valid access token for the current user */\n  get isLoggedIn(): boolean {\n    return !!this.accessToken\n  }\n\n  /** runs when accessTokenHelper changes */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  private onUpdateAccessTokenHelper = (newAccessTokenHelper: AccessTokenHelper) => {\n    this._accountName = newAccessTokenHelper.accountName\n    super.callSubscribers()\n  }\n\n  /** throw if user data hasn't been retrieved yet */\n  private assertUserHasData() {\n    if (!this.hasData) {\n      throw new Error('User data hasnt been retrieved. Call user.getData() first.')\n    }\n  }\n\n  /** throw if user hasn't have a valid email (i.e. user.email) */\n  private assertUserHasValidEmail() {\n    this.assertUserHasData()\n    const { email } = this?.data || {}\n    if (!Helpers.isValidEmail(email)) throw new Error('User doesnt have a valid email')\n  }\n\n  /** Get the user info from ORE ID API for a given user account and (usually) save the user into localStorage 'cache'\n   *  Must have a valid accessToken to retrieve user\n   */\n  async getData(forceRefresh?: boolean): Promise<UserData> {\n    if (this.hasData && !forceRefresh) return this.data\n    // eslint-disable-next-line prefer-destructuring\n    const accessToken = this.accessToken\n    if (!accessToken) {\n      throw new Error('AccessToken is missing or has expired')\n    }\n    // get account specified in access token\n    const account = this?._accountName\n    const params: ApiGetUserParams = { account }\n    const userSourceData = await callApiGetUser(this._oreIdContext, params)\n\n    this._accountName = account\n    this.setUserSourceData(userSourceData)\n    return this.data\n  }\n\n  /** Clears user's accessToken and user profile data */\n  logout() {\n    this._oreIdContext.logout()\n  }\n\n  /** Request OREID to create a new blockchain account in an existing user's wallet\n   *  This is an advanced feature - it most cases, blockchain accounts will be created automatically upon first login\n   */\n  // async newChainAccount(newAccountOptions: NewAccountOptions) {\n  //   // TODO - call API to create chain account (requires apiKey with createAccount right)\n  //   // for webwidget, it should just refresh user info upon callback\n  // }\n\n  /** Returns a fully formed url to redirect the user's browser to create a new chain account using ORE ID\n   *  This function calls the /new-account web endpoint\n   *  Returns: Callback returns new chainAccount name */\n  async getNewChainAccountUrl(newAccountOptions: NewAccountOptions): Promise<NewAccountWithOreIdResult> {\n    const { account, accountType, chainNetwork, accountOptions, provider, state } = newAccountOptions || {}\n    const { newAccountCallbackUrl, backgroundColor } = this._oreIdContext.options\n    const args = {\n      account,\n      accountType,\n      backgroundColor,\n      chainNetwork,\n      accountOptions,\n      provider,\n      callbackUrl: newAccountCallbackUrl,\n      state,\n    }\n    const newAccountUrl = await getOreIdNewChainAccountUrl(this._oreIdContext, args)\n    return { newAccountUrl, errors: null }\n  }\n\n  /** Delete a test user\n   * Test users are created by setting isTestUser:true on first authentication)\n   */\n  async deleteTestUser() {\n    if (!this?.accountName) throw new Error('User not authenticated. Must be logged-in (or have set an accessToken).')\n    const result = await callApiDeleteTestUser(this._oreIdContext, {\n      account: this.accountName,\n    })\n    return result\n  }\n\n  /** If the user hasn't already setup their wallet, this will prompt the setup on their next interactive authentication\n   * Used to turn-off the delayWalletSetup for a user's account\n   * delayWalletSetup is enabled by passing delayWalletSetup:true for a user's first authentication (e.g. popup.auth(delayWalletSetup:true))\n   * Delayed Wallet Setup allows a user to login without creating blockchain accounts right away\n   * Call this function (to disable delayWalletSetup) just before the user needs a blockchain account (e.g. before signing a transaction)\n   */\n  async disableDelayedWalletSetup() {\n    if (!this?.accountName) throw new Error('User not authenticated. Must be logged-in (or have set an accessToken).')\n    const result = await callApiUpdateDelayWalletSetup(this._oreIdContext, {\n      account: this.accountName,\n      delayWalletSetup: false,\n    })\n    await this.getData(true)\n    return result\n  }\n\n  /** Send a code to the user's primary email (user.email) - in order to verify the user has access to it\n   *  After sending the code, use checkVerificationCodeForEmail() to verify that the user received the code */\n  async sendVerificationCodeToEmail() {\n    this.assertUserHasValidEmail()\n    const result = await callApiPasswordLessSendCode(this._oreIdContext, {\n      email: this?.data?.email,\n      provider: AuthProvider.Email,\n    })\n    return result\n  }\n\n  /** Confirm that the code matches the last one just sent to the email by sendVerificationCodeToEmail() */\n  async checkVerificationCodeForEmail({ code }: { code: string }) {\n    this.assertUserHasValidEmail()\n    const result = await callApiPasswordLessVerifyCode(this._oreIdContext, {\n      code,\n      email: this?.data?.email,\n      provider: AuthProvider.Email,\n    })\n    return result\n  }\n\n  // TODO: rename sendVerificationCodeToEmail - passwordlessVerificationSendCode(type, email, phone)\n  // TODO: rename checkVerificationCodeForEmail - passwordlessVerificationVerifyCode(type, email, phone)\n\n  /** Map permission from server data to local UserPermission object */\n  mapUserPermission(permission: UserPermissionData): UserPermissionForChainAccount {\n    if (isNullOrEmpty(permission)) return null\n    const { chainNetwork, chainAccount, permission: permissionName, ...other } = permission\n    return {\n      ...other,\n      name: permissionName,\n    }\n  }\n\n  /** returns the UserPermissins a chainNetwork/chainAccount\n   * if defaultOnly = true, returns the single default permission for the chainAccount\n   */\n  getPermissionForChainAccount(\n    chainAccount: ChainAccount,\n    chainNetwork: ChainNetwork,\n  ): UserPermissionForChainAccount[] {\n    const accountPermissions = this._userSourceData.permissions.filter(\n      p => p.chainAccount === chainAccount && p.chainNetwork === chainNetwork,\n    )\n    return accountPermissions.map(this.mapUserPermission)\n  }\n\n  getDefaultPermissionForChainAccount(\n    chainAccount: ChainAccount,\n    chainNetwork: ChainNetwork,\n  ): UserPermissionForChainAccount[] {\n    const accountPermissions = this.getPermissionForChainAccount(chainAccount, chainNetwork)\n    let defaultPermission = accountPermissions.filter(p => p.isDefault === true)\n    // if no default is defined, and there is only one permission, use it as the default - this might be an external key\n    if (isNullOrEmpty(defaultPermission) && accountPermissions?.length === 1) {\n      defaultPermission = accountPermissions\n    }\n    return defaultPermission\n  }\n\n  /** Update permissions for user's ORE Account if any */\n  async updatePermissionsIfNecessary(args: {\n    chainAccount: ChainAccount\n    permissions: WalletPermission[]\n    chainNetwork: ChainNetwork\n    walletType: ExternalWalletType\n  }) {\n    // use logged-in account if missing oreAccount param\n    await this.addWalletPermissionsToOreIdAccount(args)\n  }\n\n  // for each permission in the wallet, add to ORE ID (if not in user's record)\n  /** for all walletPermissions not already in the user's OreID wallet, add it by calling the api (addPermission) */\n  async addWalletPermissionsToOreIdAccount(args: {\n    chainAccount: ChainAccount\n    chainNetwork: ChainNetwork\n    permissions: WalletPermission[]\n    walletType: ExternalWalletType\n  }) {\n    // get latest user info\n    await this.getData()\n\n    const { chainAccount, chainNetwork, permissions, walletType } = args\n    if (!this.accountName || isNullOrEmpty(permissions) || isNullOrEmpty(chainNetwork)) {\n      return // todo: consider if we should exit silently here - since we are called after discovery everytime, then answer is probably yes\n    }\n\n    // for each permission provided, check if it's already in the user's list, if not, add it by calling the api (addPermission)\n    await Helpers.asyncForEach(permissions, async perm => {\n      const permission = perm.name\n      let parentPermission = perm.parent\n      if (!parentPermission) {\n        // HACK: assume parent permission - its missing from the discover() results\n        parentPermission = 'active'\n\n        if (permission === 'owner') {\n          parentPermission = ''\n        } else if (permission === 'active') {\n          parentPermission = 'owner'\n        }\n      }\n      // filter out permission that the user already has in his record\n      const skipThisPermission = this._userSourceData.permissions.some(\n        up =>\n          (up.chainAccount === chainAccount && up.chainNetwork === chainNetwork && up.permission === permission) ||\n          permission === 'owner',\n      )\n\n      // don't add 'owner' permission and skip ones that are already stored in user's account\n      if (skipThisPermission !== true) {\n        // let publicKey = p.required_auth.keys[0].key; //TODO: Handle multiple keys and weights\n        const { publicKey } = perm\n        // if call is successful, nothing is returned in response (except processId)\n        await callApiAddPermission(this._oreIdContext, {\n          account: this.accountName,\n          chainAccount,\n          chainNetwork,\n          publicKey,\n          parentPermission,\n          permission,\n          provider: walletType,\n        })\n      }\n    })\n\n    // reload user to get updated permissions\n    await this.getData()\n  }\n}\n","import Helpers from '../utils/helpers'\nimport { JWTToken } from './models'\nimport { Observable } from '../utils/observable'\n\nexport type SubscriberAccessTokenHelper = (accessTokenHelper: AccessTokenHelper) => void\n\nexport class AccessTokenHelper extends Observable<SubscriberAccessTokenHelper> {\n  constructor(accessToken?: string, ignoreIssuer = false) {\n    super()\n    this._ignoreIssuer = ignoreIssuer\n    this.setAccessToken(accessToken)\n  }\n\n  _accessToken: string\n\n  _decodedAccessToken: JWTToken\n\n  _idToken: string\n\n  _decodedIdToken: JWTToken\n\n  _ignoreIssuer: boolean\n\n  get accessToken() {\n    return this._accessToken\n  }\n\n  get decodedAccessToken() {\n    if (!this.accessToken) return null\n    return this._decodedAccessToken\n  }\n\n  get idToken() {\n    return this._idToken\n  }\n\n  get decodedIdToken() {\n    return this._decodedIdToken\n  }\n\n  get accountName() {\n    if (!this.accessToken) return null\n    AccessTokenHelper.assertIsTokenValid(this.decodedAccessToken)\n    return Helpers.getClaimFromJwtTokenBySearchString(this.decodedAccessToken, 'https://oreid.aikon.com/account')\n  }\n\n  /** clear accessToken */\n  clearAccessToken() {\n    this.setAccessToken(null)\n  }\n\n  /** clear idToken */\n  clearIdToken() {\n    this.setIdToken(null)\n  }\n\n  /** Whether current accessToken is expired (or is missing)\n   *  (optional) provide a Date() to compare expiration against - defaults to current Date()\n   *  Returns: (boolean) true if hasExpired\n   */\n  hasExpired(now?: Date): boolean {\n    if (!this._decodedAccessToken) return true\n    if (!AccessTokenHelper.isTokenDateValidNow(this._decodedAccessToken, now)) {\n      return true\n    }\n    return false\n  }\n\n  setAccessToken(value: string) {\n    if (!value) {\n      this._accessToken = null // allows clearing of value\n    } else {\n      const decodedAccessToken = Helpers.jwtDecodeSafe(value) as JWTToken\n      if (!decodedAccessToken) throw Error(`Can't set accessToken. Value provided: ${value}`)\n      AccessTokenHelper.assertIsTokenValid(decodedAccessToken, this._ignoreIssuer)\n      AccessTokenHelper.assertIdTokenMatchesAccessToken(decodedAccessToken, this.decodedIdToken)\n      this._decodedAccessToken = decodedAccessToken\n      this._accessToken = value\n      // Set a timer to clear the token when it expires (will clear if already expired)\n      Helpers.runAtTime(() => {\n        this.clearAccessToken()\n        console.log('accessToken has expired and has been cleared')\n      }, this._decodedAccessToken.exp * 1000)\n    }\n    super.callSubscribers()\n  }\n\n  setIdToken(value: string) {\n    if (!value) {\n      this._decodedIdToken = null // allows clearing of value\n    } else {\n      const decodedIdToken = Helpers.jwtDecodeSafe(value) as JWTToken\n      if (!decodedIdToken) throw Error(`Can't set IdToken. Value provided: ${value}`)\n      AccessTokenHelper.assertIsTokenValid(decodedIdToken, this._ignoreIssuer)\n      AccessTokenHelper.assertIdTokenMatchesAccessToken(this.decodedAccessToken, decodedIdToken)\n      this._decodedIdToken = decodedIdToken\n      this._idToken = value\n      // Set a timer to clear the token when it expires (will clear if already expired)\n      Helpers.runAtTime(() => {\n        this.clearIdToken()\n        console.log('idToken has expired and has been cleared')\n      }, this._decodedIdToken.exp * 1000)\n    }\n    super.callSubscribers()\n  }\n\n  /** Throws if accessToken is NOT set yet */\n  assertHasAccessToken() {\n    if (!this.accessToken) throw Error('AccessToken not set. Login first.')\n  }\n\n  /** Whether token is a valid OREID issued token and NOT expired */\n  static isTokenValid(decodedToken: Partial<JWTToken>, ignoreIssuer = false): boolean {\n    try {\n      AccessTokenHelper.assertIsTokenValid(decodedToken, ignoreIssuer)\n      return true\n    } catch (error) {\n      return false\n    }\n  }\n\n  /** Throws if decodedToken is NOT a valid OREID issued token */\n  static assertIsTokenValid(decodedToken: Partial<JWTToken>, ignoreIssuer = false) {\n    const now = new Date()\n    if (!decodedToken) throw Error('JWT (access or id) token is invalid, or expired)')\n    // check if ORE ID issued this token\n    if (!ignoreIssuer && !decodedToken.iss.includes('oreid.io')) {\n      throw Error('Access token not issued by ORE ID')\n    }\n    if (!AccessTokenHelper.isTokenDateValidNow(decodedToken, now)) {\n      throw Error('Access token has expired')\n    }\n  }\n\n  /** Throws if accessToken does not match the same user and issuer as the idToken */\n  static assertIdTokenMatchesAccessToken(decodedAccessToken: Partial<JWTToken>, decodedIdToken: Partial<JWTToken>) {\n    if (!decodedAccessToken || !decodedIdToken) return\n    // check if ORE ID issued this token\n    if (decodedAccessToken.iss !== decodedIdToken.iss) {\n      throw Error('AccessToken and IdToken mismatch - not issued by the same issuer')\n    }\n    if (decodedAccessToken.sub !== decodedIdToken.sub) {\n      throw Error('AccessToken and IdToken mismatch - not for the same user')\n    }\n  }\n\n  /** Whether a JWT token is valid for use right now - not expired and not being used before first usable date (nbf) */\n  static isTokenDateValidNow(decodedToken: Partial<JWTToken>, now?: Date): boolean {\n    const nowDate = now || new Date()\n    const nowInMs = nowDate.getTime() / 1000\n    if (typeof decodedToken.exp !== 'undefined' && decodedToken?.exp < nowInMs) {\n      return false\n    }\n    if (typeof decodedToken?.nbf !== 'undefined' && decodedToken?.nbf > nowInMs) {\n      return false\n    }\n    return true\n  }\n}\n","import {\n  ApiConvertOauthTokensParams,\n  ApiLoginUserWithTokenParams,\n  ApiMessageResult,\n  ApiNewUserWithTokenParams,\n  callApiConvertOauthTokens,\n  callApiLoginUserWithToken,\n  callApiNewUserWithToken,\n} from '../api'\nimport OreIdContext from '../core/IOreidContext'\nimport { getOreIdAuthUrl } from '../core/urlGenerators'\nimport TransitHelper from '../transit/TransitHelper'\nimport UalHelper from '../ual/UalHelper'\nimport { User } from '../user/user'\nimport Helpers from '../utils/helpers'\nimport LocalState from '../utils/localState'\nimport { Observable } from '../utils/observable'\nimport { AccessTokenHelper } from './accessTokenHelper'\nimport { AuthResult, LoginWithOreIdResult } from '../core/models'\nimport { LoginOptions, LoginWithTokenOptions, LoginWithWalletOptions, NewUserWithTokenOptions } from './models'\n\nexport type SubscriberAuth = (auth: Auth) => void\n\nexport class Auth extends Observable<SubscriberAuth> {\n  constructor(args: { oreIdContext: OreIdContext }) {\n    super()\n    this._oreIdContext = args.oreIdContext\n    this._localState = this._oreIdContext.localState\n    this._transitHelper = new TransitHelper({ oreIdContext: this._oreIdContext, user: this._user })\n    this._ualHelper = new UalHelper({ oreIdContext: this._oreIdContext, user: this._user })\n    this.initAccessTokenHelper()\n  }\n\n  private _accessTokenHelper: AccessTokenHelper\n\n  private _localState: LocalState\n\n  private _oreIdContext: OreIdContext\n\n  private _transitHelper: TransitHelper\n\n  private _ualHelper: UalHelper\n\n  private _user: User\n\n  /** User's OreID (accountName) */\n  get accessTokenHelper(): AccessTokenHelper {\n    return this._accessTokenHelper\n  }\n\n  private initAccessTokenHelper() {\n    this._accessTokenHelper = new AccessTokenHelper()\n    const savedToken = this._localState?.accessToken\n    this.accessToken = savedToken\n    this.saveAccessTokenAndNotifySubscribers(savedToken) // if savedToken is expired, it will be not set here\n    // listen for future changes to accessTokenHelper\n    this._accessTokenHelper.subscribe(this.onUpdateAccessTokenHelper)\n  }\n\n  /** User's OreID (accountName) */\n  get accountName(): string {\n    return this._accessTokenHelper?.accessToken ? this._accessTokenHelper?.accountName : null\n  }\n\n  get idToken() {\n    return this._accessTokenHelper?.idToken\n  }\n\n  /** retrieve accessToken saved in local storage - is automatically deleted when token expires */\n  get accessToken() {\n    return this._accessTokenHelper?.accessToken\n  }\n\n  /** Sets the access token in local storage (and in accessTokenHelper)\n   * this token will be used to call ORE ID APIs (on behalf of the user)\n   * This token is user-specific - call logout to clear it upon user log-out\n   * When the accessToken token expires, it will be deleted from local storage and user will be cleared\n   */\n  set accessToken(accessToken: string) {\n    try {\n      // decodes and validates accessToken is a valid token\n      // if incoming token has expired, _accessTokenHelper will throw (and token wont be saved)\n      this._accessTokenHelper.setAccessToken(accessToken)\n      // NOTE: We dont save the access token to local storage here as that will happen when onUpdateAccessTokenHelper is called\n    } catch (error) {\n      console.log('Cant set accessToken.', error.message)\n    }\n  }\n\n  /** set private variable and save to localState\n   * NOTE: This is called every time this._accessTokenHelper.accessToken changes (or expires)\n   */\n  private saveAccessTokenAndNotifySubscribers(accessToken: string) {\n    if (this._localState?.accessToken !== accessToken) {\n      this._localState.saveAccessToken(accessToken)\n      this._user = null\n    }\n    super.callSubscribers()\n  }\n\n  /** Returns user object matching current accessToken\n   *  A newly created object object won't have user.info populated, call user.getData() to retrieve\n   */\n  get user() {\n    if (!this._user) {\n      this._user = new User({\n        oreIdContext: this._oreIdContext,\n        accessTokenHelper: this._accessTokenHelper, // accessToken helper\n        accountName: this.accountName, // accountName\n      })\n    }\n    return this._user\n  }\n\n  /** We have a valid access token for the current user */\n  get isLoggedIn(): boolean {\n    return !!this.accessToken\n  }\n\n  /** runs when accessTokenHelper changes */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  private onUpdateAccessTokenHelper = (newAccessTokenHelper: AccessTokenHelper) => {\n    // save new access token\n    this.saveAccessTokenAndNotifySubscribers(this._accessTokenHelper.accessToken)\n  }\n\n  private clearAccessToken() {\n    // clear accessToken and user\n    this._localState.clearAccessToken()\n    this._accessTokenHelper.clearAccessToken()\n    super.callSubscribers()\n  }\n\n  /** Calls the 'connect' function on a external wallet (e.g. Metamask)\n   *  For most, however, this function returns the chainAccount selected by the user in the wallet app\n   *  Different wallets have different behavior. Some do not support this feature. */\n  async connectWithWallet(loginOptions: LoginWithWalletOptions) {\n    const { walletType } = loginOptions\n\n    if (!this._oreIdContext.walletHelper.isAValidExternalWalletType(walletType)) {\n      throw new Error(`loginWithWallet not supported for external wallet type: ${walletType}`)\n    }\n\n    return this.connectToWalletProvider(loginOptions)\n  }\n\n  /** Connect to the wallet provider\n   *  For some wallet types, this will include an unlock and 'login' flow to select a chain account\n   *  If a chainAccount is selected, it and it's associated publicKey (if available) will be saved to the user's OreId wallet as an 'external key' */\n  private async connectToWalletProvider(loginOptions: LoginWithWalletOptions) {\n    return this._oreIdContext.walletHelper.connectToWalletProvider(loginOptions)\n  }\n\n  /** Calls the account/convert-oauth api\n   * Converts OAuth tokens from some 3rd-party source to OREID Oauth tokens\n   * The third-party (e.g. Auth0 or Google) must be registered in the AppRegistration.oauthSettings\n   * Returns: OreId issued accessToken and idToken\n   * */\n  private async convertOauthTokens(parms: ApiConvertOauthTokensParams) {\n    return callApiConvertOauthTokens(this._oreIdContext, parms)\n  }\n\n  /**\n   * Converts OAuth accessToken or idToken from some 3rd-party source (e.g. Google) to OreId OAuth accessToken\n   * The third-party (e.g. Auth0 or Google) must be registered in the App Registration's oauthSettings\n   * If a user does not curently exist that matches the info in the incoming idToken, an error is thrown\n   * Does not requires a user to be logged-in (no current accessToken) or apiKey\n   * Returns: OreId issued accessToken\n   * */\n  async loginWithToken(loginOptions: LoginWithTokenOptions): Promise<LoginWithOreIdResult> {\n    if (!loginOptions?.idToken && !loginOptions?.accessToken) {\n      throw new Error('Cant loginWithToken - missing required parameter: accessToken OR idToken')\n    }\n    const { accessToken, error, processId } = await this.loginWithAccessOrIdTokenToken(loginOptions)\n    if (!error) {\n      this.accessToken = accessToken // saves in cache and in local storage\n      await this.user.getData()\n    }\n    return { accessToken, errors: error, processId }\n  }\n\n  /** Converts OAuth idToken from some 3rd-party source to OREID Oauth accessTokens\n   * The third-party (e.g. Auth0 or Google) must be registered in the AppRegistration.oauthSettings\n   * Creates a new OreId user and account from info in the incoming idToken\n   * If a matching user already exist, and error is returned\n   * Requires a valid idToken but no current accessToken or apiKey\n   * Returns: OreId issued accessToken\n   * */\n  async newUserWithToken(userOptions: NewUserWithTokenOptions): Promise<LoginWithOreIdResult> {\n    const { accessToken, error, processId } = await this.newAccountWithIdToken(userOptions)\n    if (!error) {\n      this.accessToken = accessToken // saves in cache and in local storage\n      await this.user.getData()\n    }\n    return { accessToken, errors: error, processId }\n  }\n\n  /** Calls api account/login-user-with-token for loginWithToken() (after checking for valid token */\n  static checkJwtTokenAndReturnError(jwtTokenString: string): { error?: string; message?: string } {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const accessTokenHelper = new AccessTokenHelper(jwtTokenString, true)\n    } catch (error) {\n      return {\n        error: 'token_invalid',\n        message: 'token invalid or corrupt - must be a JWT Oauth2 token',\n      }\n    }\n\n    return null\n  }\n\n  /** Calls api account/login-user-with-token for loginWithToken() (after checking for valid token */\n  private async loginWithAccessOrIdTokenToken(\n    params: ApiLoginUserWithTokenParams,\n  ): Promise<{ accessToken: string } & ApiMessageResult> {\n    const { accessToken, idToken } = params\n    let tokenCheckError\n\n    // check valid JWT tokens (Note: accessToken can be a JWT or not)\n    if (accessToken && Helpers.jwtDecodeSafe(accessToken)) {\n      tokenCheckError = accessToken ? Auth.checkJwtTokenAndReturnError(accessToken) : null\n    } else {\n      tokenCheckError = idToken ? Auth.checkJwtTokenAndReturnError(idToken) : null\n    }\n\n    if (tokenCheckError) return { accessToken: null, ...tokenCheckError }\n\n    const response = await callApiLoginUserWithToken(this._oreIdContext, params)\n    if (!response?.errorCode) {\n      this.setAuthResult({ accessToken: response?.accessToken })\n    }\n    return {\n      accessToken: response.accessToken,\n      error: response?.errorCode,\n      message: response?.errorMessage,\n      processId: response?.processId,\n    }\n  }\n\n  /** Calls api account/new-user-with-token for newUserWithToken() (after checking for valid token */\n  private async newAccountWithIdToken(\n    params: ApiNewUserWithTokenParams,\n  ): Promise<{ accessToken: string } & ApiMessageResult> {\n    const { idToken } = params\n    // check valid ifToken\n    const idTokenCheckError = idToken ? Auth.checkJwtTokenAndReturnError(idToken) : null\n    if (idTokenCheckError) return { accessToken: null, ...idTokenCheckError }\n\n    const response = await callApiNewUserWithToken(this._oreIdContext, params)\n    if (!response?.errorCode) {\n      this.setAuthResult({ accessToken: response?.accessToken })\n    }\n    return {\n      accessToken: response.accessToken,\n      error: response?.errorCode,\n      message: response?.errorMessage,\n      processId: response?.processId,\n    }\n  }\n\n  /** clear accessToken and user */\n  logout() {\n    this.clearAccessToken()\n    this._user = null\n  }\n\n  /** Returns a fully formed url to redirect the user's browser to login using ORE ID\n   *  This function calls the /auth web endpoint\n   *  Returns: Callback returns account, and optionally accessToken and/or idToken for user */\n  async getLoginUrl(loginOptions: LoginOptions): Promise<LoginWithOreIdResult> {\n    const { code, email, idToken, phone, provider, state, linkToAccount, returnAccessToken, returnIdToken } =\n      loginOptions || {}\n    const { authCallbackUrl, backgroundColor } = this._oreIdContext.options\n    const args = {\n      code,\n      email,\n      idToken,\n      phone,\n      provider,\n      backgroundColor,\n      callbackUrl: authCallbackUrl,\n      state,\n      linkToAccount,\n      returnAccessToken: Helpers.isNullOrEmpty(returnAccessToken) ? true : returnAccessToken, // if returnAccessToken not specified, default to true\n      returnIdToken,\n    }\n    const loginUrl = await getOreIdAuthUrl(this._oreIdContext, args)\n    return { loginUrl, errors: null }\n  }\n\n  /** Extracts and returns the response parameters on the /auth callback URL string\n   *  Applies accessToken and idToken (if included on the url) to local state\n   */\n  handleAuthCallback(callbackUrlString: string): AuthResult {\n    // Parses error codes and returns an errors array\n    // (if there is an error_code param sent back - can have more than one error code - seperated by a & delimeter\n    const {\n      access_token: accessToken,\n      account,\n      id_token: idToken,\n      errors,\n      process_id: processId,\n      state,\n    } = Helpers.extractDataFromCallbackUrl(callbackUrlString)\n    const response: AuthResult = { account }\n\n    if (errors) response.errors = errors\n    if (processId) response.processId = processId\n    if (state) response.state = state\n    if (accessToken) response.accessToken = accessToken\n    if (idToken) response.idToken = idToken\n\n    if (!errors) {\n      this.setAuthResult(response)\n    }\n\n    // clear the busy indicator now that we've finsihed the auth flow\n    this._oreIdContext.setIsBusy(false)\n    return response\n  }\n\n  /** store response from auth flow (accountName, accessToken, idToken) in localState */\n  setAuthResult(authResponse: AuthResult) {\n    const { accessToken, idToken } = authResponse\n    if (!accessToken) throw Error('Cant setAuthResult. accessToken is missing')\n    this._accessTokenHelper.setIdToken(null) // clear the existing idToken first (so set accessToken wont throw a mismatch when set)\n    this.accessToken = accessToken // saves the token to localstorage\n    if (idToken) {\n      this._accessTokenHelper.setIdToken(idToken)\n    }\n  }\n}\n","import { ApiEndpoint } from './models'\nimport versionJson from './version.json'\n\nexport const externalWalletsNotImplemented = ['metro']\nexport const defaultOreIdServiceUrl = 'https://service.oreid.io'\nexport const { version } = versionJson\nexport const publicApiEndpoints = [ApiEndpoint.LoginUserWithToken, ApiEndpoint.NewUserWithToken] // api endpoints that dont require authorization\n","import OreIdContext from '../core/IOreidContext'\nimport {\n  ApiKeyUsedFor,\n  CreateTransactionData,\n  ExternalWalletType,\n  SignatureProviderSignResult,\n  SignWithOreIdResult,\n  TransactionData,\n} from '../models'\nimport TransitHelper from '../transit/TransitHelper'\nimport {\n  assertHasApiKey,\n  callApiCanAutosignTransaction,\n  callApiCustodialSignTransaction,\n  callApiSignTransaction,\n} from '../api'\nimport { getOreIdSignUrl } from '../core/urlGenerators'\nimport Helpers from '../utils/helpers'\nimport UalHelper from '../ual/UalHelper'\nimport { User } from '../user/user'\n\nexport default class Transaction {\n  constructor(args: { oreIdContext: OreIdContext; user: User; data: TransactionData }) {\n    this._oreIdContext = args.oreIdContext\n    this._user = args.user\n    this.assertValidTransactionAndSetData(args.data)\n    this._transitHelper = new TransitHelper({ oreIdContext: this._oreIdContext, user: this._user })\n    this._ualHelper = new UalHelper({ oreIdContext: this._oreIdContext, user: this._user })\n  }\n\n  private _oreIdContext: OreIdContext\n\n  private _data: TransactionData\n\n  private _transitHelper: TransitHelper\n\n  private _ualHelper: UalHelper\n\n  private _user: User\n\n  get data() {\n    return this._data\n  }\n\n  /** ensure all required parameters are provided */\n  assertValidTransactionAndSetData(createTransactionData: CreateTransactionData) {\n    const { chainNetwork, transaction, signedTransaction } = createTransactionData || {}\n    const missingFields: string[] = []\n    const validationIssues: string[] = []\n\n    if (!this._user || !this._user.hasData) {\n      throw new Error('Make sure that a user has been authenticated and that youve called user.getData()')\n    }\n\n    // required fields\n    if (!chainNetwork) missingFields.push('chainNetwork')\n    if (!transaction && !signedTransaction) missingFields.push('transaction OR signedTransaction')\n    // validaton rules\n    if (!this._user.accountName)\n      validationIssues.push('Transaction Data error - Expecting a user.accountName - is the user logged-in in?')\n    if (transaction && signedTransaction) validationIssues.push('Only provide one: transaction OR signedTransaction')\n\n    // TODO: call this.validate()\n\n    // transaction OR signedTransaction - check for valid JSON object\n\n    if (!Helpers.isNullOrEmpty(missingFields)) {\n      throw new Error(`Transaction parameter(s) missing: ${missingFields.join(', ')}`)\n    }\n    if (!Helpers.isNullOrEmpty(validationIssues)) {\n      throw new Error(`Transaction parameter error: ${validationIssues.join(', ')}`)\n    }\n\n    this.setTransactionData(createTransactionData)\n  }\n\n  private setTransactionData(createTransactionData: CreateTransactionData) {\n    // account param is set to logged-in user\n    this._data = {\n      account: this._user.accountName,\n      ...createTransactionData,\n    }\n    // set encoded transaction properties\n    if (createTransactionData?.transaction)\n      this._data.encodedTransaction = Helpers.base64Encode(JSON.stringify(createTransactionData.transaction))\n    if (createTransactionData?.signedTransaction)\n      this._data.encodedSignedTransaction = Helpers.base64Encode(\n        JSON.stringify(createTransactionData.signedTransaction),\n      )\n  }\n\n  // TODO: Consider providing property to explain that account/permission is in external wallet so developer can easily check\n  // TODO: Consider web-widget automatically handling pop-up of wallet when sign is called\n\n  /** ensure that the chainNetwork and chainAccount for the transaction are in the user's wallet\n   *  NOTE: This check is not required for a user signing with a wallet app - Since the account may be in the wallet and not yet added to OreId\n   */\n  assertTransactionAccountValidForUser() {\n    const { chainAccount, chainNetwork } = this._data\n    const { accountName } = this._user\n\n    const chainAccountsInWallet = this._user?.data?.chainAccounts?.find(\n      perm => perm.chainNetwork === chainNetwork && perm.chainAccount === chainAccount,\n    )\n\n    const allPermissionsExternal = chainAccountsInWallet?.permissions?.every(p => p.privateKeyStoredExterally === true)\n    const externalWalletType = chainAccountsInWallet?.permissions?.find(\n      p => p.privateKeyStoredExterally === true,\n    )?.externalWalletType\n\n    if (!chainAccountsInWallet) {\n      throw new Error(\n        `Can't find a chainAccount: ${chainAccount} for chainNetwork: ${chainNetwork} in user's oreId account: ${accountName}`,\n      )\n    }\n\n    if (allPermissionsExternal) {\n      throw new Error(\n        `ChainAccount: ${chainAccount} for chainNetwork: ${chainNetwork} appears to be in a wallet app (type: ${externalWalletType}) - use signWithWallet() to sign`,\n      )\n    }\n  }\n\n  // TODO: check user.chainAccounts that\n\n  /** validates that transaction is well-formed for the blockcahin\n   * Returns array of errors\n   */\n  async validate(): Promise<string[]> {\n    // TODO: call API validateTransaction on OREID Service - transaction/validate api endpoint\n    throw new Error('Not Implemented')\n  }\n\n  // TODO: add depricated\n  /**\n   * Returns a url to redirect the user's browser to - to sign transaction using OREID web interface\n   */\n  async getSignUrl(): Promise<SignWithOreIdResult> {\n    this.assertTransactionAccountValidForUser()\n    const transactionData = this.data\n    const { signCallbackUrl } = this._oreIdContext.options\n    // eslint-disable-next-line no-param-reassign\n    if (!transactionData?.signOptions) transactionData.signOptions = {}\n    // eslint-disable-next-line no-param-reassign\n    transactionData.signOptions.callbackUrl = signCallbackUrl\n    const signUrl = await getOreIdSignUrl(this._oreIdContext, transactionData)\n    return { signUrl, errors: null }\n  }\n\n  /**\n   * Whether the provided transaction (or signedTransaction) can be autoSigned via api (without user interaction)\n   * Requires an apiKey with the autoSign right\n   * Returns: true if transaction can be signed using tansaction.sign()\n   * */\n  async checkCanAutoSign() {\n    let autoSignCredentialsExist: boolean\n    try {\n      assertHasApiKey(this._oreIdContext, ApiKeyUsedFor.AutoSigning, '')\n      // this will throw if we don't have an api key with the right rights\n      ;({ autoSignCredentialsExist } = await callApiCanAutosignTransaction(this._oreIdContext, this._data))\n    } catch (error) {\n      return false // can't auto-sign\n    }\n    return autoSignCredentialsExist\n  }\n\n  /** Attempt to sign a transaction without user interaction\n   *  Expects user to have previously approved autoSign for transaction type and it hasn't expired\n   *  Call callApiCanAutosignTransaction() first to confirm that this transaction can be autoSigned before attempting this call\n   */\n  async autoSign() {\n    this.assertTransactionAccountValidForUser()\n    const transactionData = this.data\n    const { processId, signedTransaction, transactionId, errorCode, errorMessage } = await callApiSignTransaction(\n      this._oreIdContext,\n      { transactionData, autoSign: true },\n    )\n\n    if (errorCode || errorMessage) throw new Error(errorMessage)\n    return { processId, signedTransaction, transactionId }\n  }\n\n  /** Sign a transaction without user interaction\n   *  Requires a user's wallet password or encrypted password (a 'custodial' account managed by you)\n   *  Requires an apiKey with the proxySign right\n   */\n  async signWithPassword(userPassword?: string, userPasswordEncrypted?: string) {\n    this.assertTransactionAccountValidForUser()\n    const transactionData = this.data\n    if (!transactionData?.signOptions) transactionData.signOptions = {}\n    if (userPassword) transactionData.signOptions.userPassword = userPassword\n    if (userPasswordEncrypted) transactionData.signOptions.userPasswordEncrypted = userPasswordEncrypted\n\n    if (transactionData.signOptions.userPassword && transactionData.signOptions.userPasswordEncrypted) {\n      throw new Error('Provide either a userPassword OR userPasswordEncrypted param. Both were provided.')\n    }\n\n    const { processId, signedTransaction, transactionId, errorCode, errorMessage } =\n      await callApiCustodialSignTransaction(this._oreIdContext, { transactionData, autoSign: false })\n    if (errorCode || errorMessage) throw new Error(errorMessage)\n    return { processId, signedTransaction, transactionId }\n  }\n\n  /** Sign with a supported blockchain wallet via Transit provider */\n  async signWithWallet(walletType: ExternalWalletType): Promise<{\n    signedTransaction: SignatureProviderSignResult\n  }> {\n    const transactionData = this.data\n    const signResult = await this._oreIdContext.walletHelper.signWithWallet(walletType, transactionData)\n    return signResult\n  }\n}\n","import HmacSHA256 from 'crypto-js/hmac-sha256'\nimport Axios from 'axios'\nimport Helpers from './helpers'\n\nexport function generateHmac(secret: string, data: string) {\n  const hmac = HmacSHA256(data, secret)\n  return hmac.toString()\n}\n\n/** Generate HMAC for data string\n *  data param can be stringified object\n *  If apiKey is not provided, expects useProxyServer:true and a proxy server to be available to generate the hmac\n *  Expects proxyserver /oreid/hmac to host an endpoint to sign with the apiKey and return the hmac\n */\nexport async function generateHmacWithApiKeyOrProxyServer(useProxyServer: boolean, apiKey: string, data: string) {\n  if (!useProxyServer && Helpers.isNullOrEmpty(apiKey)) {\n    throw new Error('Cant generate hmac. apiKey missing or empty - its required if not using a proxy server')\n  }\n\n  let hmac: string\n  if (useProxyServer) {\n    try {\n      // get an hmac from the proxy server endpoint (since it has the secret apiKey)\n      const response = await Axios.post('/oreid/hmac', JSON.stringify({ data }), {\n        headers: { 'Content-Type': 'application/json' },\n      })\n      hmac = response?.data?.hmac\n    } catch (networkError) {\n      const error = this.getErrorFromAxiosError(networkError)\n      throw error\n    }\n  } else {\n    hmac = generateHmac(apiKey, data)\n  }\n  return hmac\n}\n\n/** Generate HMAC for url string and append it to end or url e.g. http:/nnnnnn&hmac=xxx */\nexport async function appendHmacToUrl(useProxyServer: boolean, apiKey: string, url: string) {\n  if (Helpers.isNullOrEmpty(url)) {\n    throw new Error('Cant generate hmac. url missing or empty')\n  }\n\n  const hmac = await generateHmacWithApiKeyOrProxyServer(useProxyServer, apiKey, url)\n\n  const urlEncodedHmac = encodeURIComponent(hmac)\n  // correct hmac already in place\n  if (url.includes(`&hmac=${urlEncodedHmac}`)) {\n    return url\n  }\n  return `${url}&hmac=${urlEncodedHmac}`\n}\n","import { UserSourceData } from '../user/models'\nimport IStorage from '../core/IStorage'\n\nexport default class LocalState {\n  constructor(appId: string, storage: IStorage) {\n    this.appId = appId\n    this.cachedaccessToken = null\n    this.cachedUser = null\n    this.storage = storage\n  }\n\n  appId: string\n\n  cachedaccessToken: string\n\n  cachedUser: UserSourceData\n\n  storage: IStorage\n\n  accessTokenKey() {\n    return `oreid.${this.appId}.accessToken`\n  }\n\n  get accessToken(): string {\n    if (!this.cachedaccessToken) this.loadAccessToken()\n    return this.cachedaccessToken\n  }\n\n  loadAccessToken() {\n    this.cachedaccessToken = this.storage.getItem(this.accessTokenKey())\n  }\n\n  saveAccessToken(accessToken: string) {\n    if (accessToken) {\n      this.cachedaccessToken = accessToken\n      this.storage.setItem(this.accessTokenKey(), accessToken)\n    } else {\n      this.clearAccessToken()\n    }\n  }\n\n  clearAccessToken() {\n    this.cachedaccessToken = null\n    this.storage.removeItem(this.accessTokenKey())\n  }\n\n  clear() {\n    this.clearAccessToken()\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable max-classes-per-file */\n/*\n\nHandles storage to local storage, or cookies, whatever is available to the client\n\nMostly copied originally copied from Auth0.js but modifed to use a class\nhttps://github.com/auth0/auth0.js/tree/master/src/helper/storage\n\n*/\n\nimport * as Cookie from 'js-cookie'\nimport { JSONObject } from '../models'\nimport IStorage from '../core/IStorage'\nimport Helpers from './helpers'\n\nclass CookieStorage implements IStorage {\n  getItem(key: string): string {\n    return Cookie.get(key)\n  }\n\n  removeItem(key: string) {\n    Cookie.remove(key)\n  }\n\n  setItem(key: string, value: string | object, options?: Cookie.CookieAttributes): string {\n    const params = {\n      expires: 1, // 1 day\n      ...options,\n    }\n    return Cookie.set(key, value, params)\n  }\n}\n\nclass LocalStorage implements IStorage {\n  constructor() {\n    if (window) {\n      // some browsers throw an error when trying to access localStorage\n      // when localStorage is disabled.\n      this.storage = window.localStorage\n    } else {\n      Helpers.log('Not running in Browser. Using CookieStorage instead.')\n    }\n  }\n\n  storage: Storage\n\n  getItem(key: string): string {\n    if (this.storage) {\n      return this.storage.getItem(key)\n    }\n    return null\n  }\n\n  removeItem(key: string) {\n    if (this.storage) {\n      this.storage.removeItem(key)\n    }\n  }\n\n  setItem(key: string, value: string, options?: any) {\n    if (this.storage) {\n      this.storage.setItem(key, value)\n    }\n  }\n}\n\n/** does not store or retrieve any values - allows 'disabling' of storage */\nexport class DummyStorage implements IStorage {\n  getItem(key: any): any {\n    return null\n  }\n\n  removeItem(key: any) {\n    // empty\n  }\n\n  setItem(key: any, value: any, options?: any) {\n    // empty\n  }\n}\n\n/** stores items in memory - does not persist across instances */\nexport class MemoryStorage implements IStorage {\n  memoryCache: JSONObject = {}\n\n  getItem(key: any): any {\n    if (key in this.memoryCache) return this.memoryCache[key]\n    return null\n  }\n\n  removeItem(key: any): void {\n    if (!this.getItem(key)) return\n    delete this.memoryCache[key]\n  }\n\n  setItem(key: any, value: any, options?: any) {\n    this.memoryCache[key] = value\n  }\n}\n\nclass StorageHandler implements IStorage {\n  constructor(options = { tryLocalStorageFirst: true }) {\n    this.triedLocalStorage = false\n    this.triedCookieStorage = false\n\n    if (options.tryLocalStorageFirst === true) {\n      this.triedLocalStorage = true\n\n      try {\n        // designed to work on browser or server, so window might not exist\n        const localStorage = new LocalStorage()\n\n        if (localStorage && localStorage.storage) {\n          this.storage = localStorage\n        }\n      } catch (e) {\n        Helpers.log('Cant use localStorage. Using CookieStorage instead.', options)\n      }\n    }\n\n    if (!this.storage) {\n      this.storage = new CookieStorage()\n      this.triedCookieStorage = true\n    }\n  }\n\n  storage: LocalStorage | CookieStorage | DummyStorage | IStorage\n\n  triedLocalStorage: boolean\n\n  triedCookieStorage: boolean\n\n  failover() {\n    if (this.storage instanceof DummyStorage) {\n      return\n    }\n\n    let didSet = false\n\n    if (this.storage instanceof LocalStorage) {\n      if (!this.triedCookieStorage) {\n        this.storage = new CookieStorage()\n        this.triedCookieStorage = true\n        didSet = true\n      }\n    } else if (this.storage instanceof CookieStorage) {\n      if (!this.triedLocalStorage) {\n        this.storage = new LocalStorage()\n        this.triedLocalStorage = true\n        didSet = true\n      }\n    }\n\n    if (!didSet) {\n      this.storage = new DummyStorage()\n    }\n  }\n\n  getItem(key: string): any {\n    try {\n      return this.storage.getItem(key)\n    } catch (e) {\n      Helpers.log('Cant getItem in storage.', e)\n      this.failover()\n      return this.storage.getItem(key)\n    }\n  }\n\n  removeItem(key: string) {\n    try {\n      this.storage.removeItem(key)\n      return\n    } catch (e) {\n      Helpers.log('Cant removeItem in storage.', e)\n      this.failover()\n      this.storage.removeItem(key)\n    }\n  }\n\n  setItem(key: any, value: string | object, options?: any): string | void {\n    try {\n      return this.storage.setItem(key, value, options)\n    } catch (e) {\n      Helpers.log('Cant setItem in storage.', e)\n      this.failover()\n      return this.storage.setItem(key, value, options)\n    }\n  }\n}\n\nexport default StorageHandler\n","import { callApiGetConfig } from '../api'\nimport { ChainNetwork, ChainPlatformType, ConfigType, SettingChainNetwork, SettingChainNetworkHost } from '../models'\nimport Helpers from '../utils/helpers'\nimport OreIdContext from './IOreidContext'\n\nexport default class Settings {\n  constructor(args: { oreIdContext: OreIdContext }) {\n    this._oreIdContext = args.oreIdContext\n    this._cachedChainNetworks = null\n  }\n\n  private _cachedChainNetworks: SettingChainNetwork[] = []\n\n  private _oreIdContext: OreIdContext\n\n  /** Calls getConfigFromApi() to retrieve settings for all chain networks defined by OreID service\n   * and caches the result */\n  async getAllChainNetworkSettings(): Promise<SettingChainNetwork[]> {\n    if (Helpers.isNullOrEmpty(this._cachedChainNetworks)) {\n      // load the chainNetworks list from the ORE ID API\n      const results = await this.getConfigFromApi(ConfigType.Chains)\n      this._cachedChainNetworks = results.chains // as SettingChainNetwork[]\n    }\n\n    return this._cachedChainNetworks\n  }\n\n  /** Returns Chain Network Settings for a specific chain */\n  async getChainNetworkSettings(chainNetwork: ChainNetwork) {\n    const networks = await this.getAllChainNetworkSettings()\n    return networks.find(n => n.network === chainNetwork)\n  }\n\n  /** Loads settings value from the server\n    e.g. configType='chains' returns valid chain types and addresses */\n  async getConfig(configType: ConfigType) {\n    return this.getConfigFromApi(configType)\n  }\n\n  /**\n   *  Call api services/config to get configuration values of a specific type\n   *  Returns: for configType:Config.Chains, returns array of SettingChainNetwork objects for all chains suported by the service\n   * */\n  async getConfigFromApi(configType: ConfigType.Chains) {\n    const values = await callApiGetConfig(this._oreIdContext, { configType })\n    if (Helpers.isNullOrEmpty(values)) {\n      throw new Error(`Not able to retrieve config values for ${configType}`)\n    }\n    return values\n  }\n\n  /** Returns network config (url, port, etc.) for specified chainNetwork */\n  async getChainNetworkNextworkConfig(chainNetwork: ChainNetwork): Promise<SettingChainNetworkHost> {\n    const networkSettings = await this.getChainNetworkSettings(chainNetwork)\n    if (!networkSettings) {\n      throw new Error(`Invalid chain network: ${chainNetwork}.`)\n    }\n    const { chainId, host, port, protocol } = networkSettings?.hosts[0] || {} // using first host\n    return { host, port, protocol, chainId }\n  }\n\n  /** Return ChainNetwork that matches chainId (as defined in OreId Chain Network Settings) */\n  async getChainNetworkByChainId(chainId: string) {\n    const networks = await this.getAllChainNetworkSettings()\n    const chainSettings = networks.find(n => n.hosts.find(h => h.chainId === chainId))\n\n    if (!Helpers.isNullOrEmpty(chainSettings)) {\n      return chainSettings.network\n    }\n    return null\n  }\n\n  /** Returns true if network is NOT an EOS sisterchain */\n  async isNotEosNetwork(chainNetwork: ChainNetwork) {\n    const networkSetting = await this._oreIdContext.settings.getChainNetworkSettings(chainNetwork)\n    return !(networkSetting.type === ChainPlatformType.eos || networkSetting.type === ChainPlatformType.ore)\n  }\n}\n","import { getUalProviderAttributes, supportedUALProviders, ualProviderAttributesData } from '../ual/ualProviders'\nimport { getTransitProviderAttributes, transitProviderAttributesData } from '../transit'\nimport { externalWalletsNotImplemented } from '../constants'\nimport OreIdContext from '../core/IOreidContext'\nimport Helpers from '../utils/helpers'\nimport {\n  AuthProvider,\n  ChainNetwork,\n  ChainPlatformType,\n  ExternalWalletType,\n  LoginWithWalletOptions,\n  SignatureProviderSignResult,\n  SignStringParams,\n  SignStringResult,\n  TransactionData,\n} from '../models'\nimport TransitHelper from '../transit/TransitHelper'\nimport UalHelper from '../ual/UalHelper'\nimport { ExternalWalletInterface, WalletProviderAttributes } from './models'\n\nexport default class WalletHelper {\n  constructor(args: { oreIdContext: OreIdContext; transitHelper: TransitHelper; ualHelper: UalHelper }) {\n    this._oreIdContext = args.oreIdContext\n    this._transitHelper = args.transitHelper\n    this._ualHelper = args.ualHelper\n  }\n\n  _oreIdContext: OreIdContext\n\n  _transitHelper: TransitHelper\n\n  _ualHelper: UalHelper\n\n  /** Transit wallet plugin helper functions and connections */\n  get transitHelper() {\n    return this._transitHelper\n  }\n\n  /** Ual wallet plugin helper functions and connections */\n  get ualHelper() {\n    return this._ualHelper\n  }\n\n  //** Whether wallet type is a Transit or Ual wallet */\n  isAValidExternalWalletType(walletType: ExternalWalletType) {\n    return (\n      (this._transitHelper.isTransitProvider(walletType) || this._ualHelper.isUalProvider(walletType)) &&\n      !externalWalletsNotImplemented.includes(walletType)\n    )\n  }\n\n  /** Returns metadata about the installed external wallet type (e.g. name, logo) and which features it supports\n   *  If optional externalWalletInterface param provided, then gets Info for the specified type (Transit or UAL) instead of seeing what's installed\n   */\n  getExternalWalletInfo(\n    walletType: ExternalWalletType,\n    externalWalletInterface?: ExternalWalletInterface,\n  ): WalletProviderAttributes {\n    if (!this.isAValidExternalWalletType(walletType)) {\n      throw new Error(`Not a valid external wallet type: ${walletType}`)\n    }\n    if (\n      this._transitHelper.hasTransitProvider(walletType) ||\n      externalWalletInterface === ExternalWalletInterface.Transit\n    ) {\n      return getTransitProviderAttributes(walletType)\n    }\n    if (this._ualHelper.hasUalProvider(walletType) || externalWalletInterface === ExternalWalletInterface.Ual) {\n      return getUalProviderAttributes(walletType)\n    }\n    return null\n  }\n\n  /** Returns wallet metadata (for installed wallet providers) for a given chain */\n  getExternalWalletInfoByChain(chain: ChainPlatformType): WalletProviderAttributes[] {\n    const transitWalletsInstalledInfo = transitProviderAttributesData.filter(info =>\n      this._oreIdContext.transitProvidersInstalled.includes(info.providerName),\n    )\n    const ualWalletsInstalledInfo = ualProviderAttributesData.filter(info =>\n      this._oreIdContext.ualProvidersInstalled.includes(info.providerName),\n    )\n\n    return [...transitWalletsInstalledInfo, ...ualWalletsInstalledInfo].filter(p => p.chainType === chain)\n  }\n\n  /** Connect to the wallet provider\n   *  For some wallet types, this will include an unlock and 'login' flow to select a chain account\n   *  If a chainAccount is selected, it and it's associated publicKey (if available) will be saved to the user's OreId wallet as an 'external key' */\n  async connectToWalletProvider(loginOptions: LoginWithWalletOptions) {\n    const { walletType } = loginOptions\n    if (!this.isAValidExternalWalletType(walletType)) {\n      throw new Error(`Not a valid external wallet type: ${walletType}`)\n    }\n    if (this._transitHelper.hasTransitProvider(walletType)) {\n      return this._transitHelper.loginWithTransitProvider(loginOptions)\n    } else if (this._ualHelper.hasUalProvider(walletType)) {\n      return this._ualHelper.loginWithUalProvider(loginOptions)\n    }\n    throw new Error(`Wallet type ${walletType} invalid or not installed`)\n  }\n\n  /** Sign with a supported blockchain wallet via Transit provider */\n  async signWithWallet(\n    walletType: ExternalWalletType,\n    transactionData: TransactionData,\n  ): Promise<{ signedTransaction: SignatureProviderSignResult }> {\n    let signResult: { signedTransaction: SignatureProviderSignResult }\n    if (!this._oreIdContext.walletHelper.isAValidExternalWalletType(walletType)) {\n      throw new Error(`signWithWallet not supported for external wallet type: ${walletType}`)\n    }\n    const provider = Helpers.toEnumValue(AuthProvider, walletType)\n\n    if (this._transitHelper.hasTransitProvider(walletType)) {\n      // Treat as Transit interface\n      signResult = await this._transitHelper.signWithTransitProvider(transactionData, walletType)\n      // If we've signed a transaction with a key in a wallet, callDiscoverAfterSign() will add it to the user's wallet\n      const { account, chainNetwork } = transactionData\n      await this._transitHelper.callDiscoverAfterSign({ account, chainNetwork, signOptions: { provider } })\n    } else if (this._ualHelper.hasUalProvider(walletType)) {\n      // Treat as UAL interface\n      signResult = await this._ualHelper.signWithUalProvider(transactionData, walletType)\n      // await this.ualHelper.callDiscoverAfterSign({ account, chainNetwork, signOptions: { provider } })\n    }\n\n    return signResult\n  }\n\n  /** Sign an arbitrary string (instead of a transaction)\n   * This only supports Transit and Ual wallets\n   */\n  async signStringWithWallet(params: SignStringParams): Promise<SignStringResult> {\n    const { account, walletType, chainNetwork } = params\n    let signResult: SignStringResult\n    if (!this.isAValidExternalWalletType(walletType)) {\n      throw new Error(`signStringWithWallet not supported for external wallet type: ${walletType}`)\n    }\n    const provider = Helpers.toEnumValue(AuthProvider, walletType)\n\n    if (this._transitHelper.hasTransitProvider(walletType)) {\n      // Treat as Transit interface\n      if (!this._transitHelper.canSignString(walletType)) {\n        throw Error(`The walletType ${walletType} does not support signString`)\n      }\n      signResult = await this._transitHelper.signStringWithTransitProvider(params)\n      await this._transitHelper.callDiscoverAfterSign({ account, chainNetwork, signOptions: { provider } })\n    } else if (this._ualHelper.hasUalProvider(walletType)) {\n      // Treat as UAL interface\n      if (!this._ualHelper.canSignString(walletType)) {\n        throw Error(`The walletType ${walletType} does not support signString`)\n      }\n      signResult = await this._ualHelper.signStringWithUalProvider(params)\n      // await this.ualHelper.callDiscoverAfterSign({ account, chainNetwork, signOptions: { provider } })\n    }\n    return signResult\n  }\n\n  /** Throw if the provider doesnt support the specified chainNetwork */\n  async assertWalletTypeValidForChainNetwork(\n    walletType: ExternalWalletType,\n    chainNetwork: ChainNetwork,\n    externalWalletInterface?: ExternalWalletInterface,\n  ) {\n    const { chainType } = this.getExternalWalletInfo(walletType, externalWalletInterface)\n    const networks = await this._oreIdContext.settings.getAllChainNetworkSettings()\n    const isValid = !!networks.find(n => n.network === chainNetwork && n.type === chainType)\n    if (!isValid) {\n      throw Error(\n        `External Wallet Type: ${walletType} doesnt support chainNetwork ${chainNetwork}. Hint: It supports networks of type ${chainType}.`,\n      )\n    }\n  }\n\n  // Supported features by wallet provider\n\n  /** whether discovery is supported by the provider */\n  canDiscover(walletType: ExternalWalletType, externalWalletInterface?: ExternalWalletInterface) {\n    return this.getExternalWalletInfo(walletType, externalWalletInterface)?.supportsDiscovery || false\n  }\n\n  /** whether signString is supported by the provider */\n  canSignString(walletType: ExternalWalletType, externalWalletInterface?: ExternalWalletInterface) {\n    return this.getExternalWalletInfo(walletType, externalWalletInterface)?.supportsSignArbitrary || false\n  }\n\n  /** whether call to discover is required by provider before login */\n  requiresDiscoverToLogin(walletType: ExternalWalletType, externalWalletInterface?: ExternalWalletInterface) {\n    return this.getExternalWalletInfo(walletType, externalWalletInterface)?.requiresDiscoverToLogin || false\n  }\n\n  /** whether call to logout then login is required by provider before discover */\n  requiresLogoutLoginToDiscover(walletType: ExternalWalletType, externalWalletInterface?: ExternalWalletInterface) {\n    return this.getExternalWalletInfo(walletType, externalWalletInterface)?.requiresLogoutLoginToDiscover || false\n  }\n\n  /** default path index for provider (if any) */\n  defaultDiscoveryPathIndexList(\n    walletType: ExternalWalletType,\n    externalWalletInterface?: ExternalWalletInterface,\n  ): number[] {\n    return this.getExternalWalletInfo(walletType, externalWalletInterface)?.defaultDiscoveryPathIndexList || null\n  }\n\n  /** help text displayed to user for provider */\n  helpTextForProvider(walletType: ExternalWalletType, externalWalletInterface?: ExternalWalletInterface) {\n    return this.getExternalWalletInfo(walletType, externalWalletInterface)?.helpText || null\n  }\n}\n","/* eslint-disable no-param-reassign */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable no-console */\nimport axios from 'axios'\nimport {\n  ApiCustodialMigrateAccountParams,\n  ApiCustodialNewAccountParams,\n  ApiCustodialSignStringParams,\n  ApiCustodialSignStringResult,\n  ApiGetAppTokenParams,\n  callApiCustodialMigrateAccount,\n  callApiCustodialNewAccount,\n  callApiCustodialSignString,\n  callApiGetAppToken,\n} from '../api'\nimport { Auth } from '../auth/auth'\nimport { defaultOreIdServiceUrl, publicApiEndpoints, version } from '../constants'\nimport {\n  ApiEndpoint,\n  AppAccessToken,\n  AppAccessTokenMetadata,\n  ExternalWalletType,\n  NewAccountResult,\n  ProcessId,\n  RequestType,\n  SignResult,\n  SignStringParams,\n  SignStringResult,\n  TransactionData,\n  WebWidgetProps,\n} from '../models'\nimport { PopupPlugin } from '../plugins'\nimport { Plugin } from '../plugins/plugin'\nimport Transaction from '../transaction/transaction'\nimport TransitHelper from '../transit/TransitHelper'\nimport UalHelper from '../ual/UalHelper'\nimport Helpers from '../utils/helpers'\nimport { appendHmacToUrl, generateHmacWithApiKeyOrProxyServer } from '../utils/hmac'\nimport LocalState from '../utils/localState'\nimport StorageHandler from '../utils/storage'\nimport IOreidContext from './IOreidContext'\nimport { OreIdOptions } from './IOreIdOptions'\nimport Settings from './Settings'\nimport WalletHelper from '../wallets/WalletHelper'\n\nconst { isNullOrEmpty } = Helpers\n\nexport default class OreId implements IOreidContext {\n  constructor(options: OreIdOptions) {\n    this._options = null\n    this.validateAndSetOptions(options)\n    const storageHandler = this.options?.storageHandler || new StorageHandler()\n    this._localState = new LocalState(this.options?.appId, storageHandler)\n    this._settings = new Settings({ oreIdContext: this })\n    this._auth = new Auth({ oreIdContext: this })\n    this._transitHelper = new TransitHelper({ oreIdContext: this, user: this._auth.user })\n    this._transitHelper.installTransitProviders(this.options?.eosTransitWalletProviders)\n    this._ualHelper = new UalHelper({ oreIdContext: this, user: this._auth.user })\n    this._ualHelper.installUalProviders(this.options?.ualAuthenticators)\n    this._walletHelper = new WalletHelper({\n      oreIdContext: this,\n      transitHelper: this._transitHelper,\n      ualHelper: this._ualHelper,\n    })\n    this._initializerPlugins = options.plugins || {}\n    this._isInitialized = false\n  }\n\n  private _auth: Auth\n\n  private _initializerPlugins: { popup?: Plugin<PopupPlugin> }\n\n  private _isInitialized: boolean\n\n  private _localState: LocalState\n\n  private _options: OreIdOptions\n\n  private _popup?: PopupPlugin\n\n  private _settings: Settings\n\n  private _transitHelper: TransitHelper\n\n  private _ualHelper: UalHelper\n\n  private _walletHelper: WalletHelper\n\n  isBusy: boolean\n\n  /** Names of all Transit providers installed (provided to this constructor) */\n  transitProvidersInstalled: ExternalWalletType[] = []\n\n  /** Names of all Ual wallet providers installed (provided to this constructor) */\n  ualProvidersInstalled: ExternalWalletType[] = []\n\n  /** accessToken (stored in localState) */\n  get accessToken() {\n    return this.auth.accessToken\n  }\n\n  /** accessToken helper functions and current state */\n  get accessTokenHelper() {\n    return this.auth.accessTokenHelper\n  }\n\n  /** authentication flows and login state */\n  get auth() {\n    return this._auth\n  }\n\n  /** whether the current appId is a demo app */\n  get isDemoApp() {\n    return this.options?.appId?.toLowerCase().startsWith('demo') || false\n  }\n\n  /** whether init() has been called */\n  get isInitialized() {\n    return this._isInitialized\n  }\n\n  /** helper to persist data (e.g. accessToken) */\n  get localState() {\n    return this._localState\n  }\n\n  /** oreid options used in constructor */\n  get options() {\n    return this._options\n  }\n\n  /** installed popup plugin */\n  get popup() {\n    this.assertIsInitialized()\n    return this._popup\n  }\n\n  /** If we're running in the browser, we must use a proxy server to talk to OREID api\n  Unless, we are running the demo app, in which case CORS is disabled by OREID server */\n  get requiresProxyServer() {\n    // if we aren't using an apiKey, we dont ever need a proxy server\n    if (this?.options?.isUsingProxyServer) return true\n    if (!this?.options?.apiKey) return false\n    return Helpers.isInBrowser && !this.isDemoApp\n  }\n\n  /** oreid settings helper */\n  get settings() {\n    return this._settings\n  }\n\n  /** External wallet helper functions and connections */\n  get walletHelper() {\n    return this._walletHelper\n  }\n\n  /** perform asynchronous setup tasks */\n  async init() {\n    if (this.isInitialized) return\n\n    if (this._initializerPlugins?.popup) {\n      this._popup = await this._initializerPlugins?.popup?.init(this)\n    }\n\n    this._isInitialized = true\n  }\n\n  /** throw and error if oreId is not initialized yet */\n  private assertIsInitialized() {\n    if (!this.isInitialized) {\n      throw new Error('OreId is not initialized - call init() first')\n    }\n  }\n\n  /** Clears user's accessToken and user profile data */\n  logout() {\n    this.auth.logout()\n  }\n\n  /** Sign an arbitrary string (instead of a transaction)\n   * This only supports Transit and Ual wallets\n   */\n  async signStringWithWallet(params: SignStringParams): Promise<SignStringResult> {\n    return this.walletHelper.signStringWithWallet(params)\n  }\n\n  /** Sign an arbitrary string (instead of a transaction) using ORE ID\n   */\n  async custodialSignString(params: ApiCustodialSignStringParams): Promise<ApiCustodialSignStringResult> {\n    const response = await callApiCustodialSignString(this, params)\n    if (response?.errorCode || response?.errorMessage) throw new Error(response.errorMessage)\n    return response\n  }\n\n  /** Create a new user account that is managed by your app\n   * Requires a wallet password (userPassword) on behalf of the user\n   * Requires an apiKey with the createUser right\n   * Returns: accountName of newly created account\n   *       OR errorCode, errorMessage, and message if any problems */\n  async custodialNewAccount(accountOptions: ApiCustodialNewAccountParams) {\n    const response = await callApiCustodialNewAccount(this, accountOptions)\n    if (response?.errorCode || response?.errorMessage) throw new Error(response.errorMessage)\n    return response\n  }\n\n  /** Call the custodial/migrate-user api\n   * Converts a user account to a new account type\n   * Usually used to convert a virtal account to a native account (on-chain)\n   * .. and expects the account to be a managed (custodial) account\n   * Requires a wallet password (userPassword) on behalf of the user\n   * Requires an apiKey with the accountMigration right\n   * Returns: account name of migrated account\n   *       OR errorCode, errorMessage, and message if any problems */\n  async custodialMigrateAccount(migrateOptions: ApiCustodialMigrateAccountParams) {\n    const response = await callApiCustodialMigrateAccount(this, migrateOptions)\n    if (response?.errorCode || response?.errorMessage) throw new Error(response.errorMessage)\n    return response\n  }\n\n  /** Returns metadata about the installed external wallet type (e.g. name, logo) and which features it supports\n   *  Returns different data depending on the wallet interface type (Transit or Ual)\n   */\n  getExternalWalletInfo(walletType: ExternalWalletType) {\n    return this.walletHelper.getExternalWalletInfo(walletType)\n  }\n\n  /** Create a new Transaction object - used for composing and signing transactions */\n  async createTransaction(data: TransactionData) {\n    if (!this._auth.user.hasData) {\n      await this._auth.user.getData()\n    }\n    return new Transaction({ oreIdContext: this, user: this.auth.user, data })\n  }\n\n  /** Call the setBusyCallback() callback provided in optiont\n   *  Use true or false to set the current busy state\n   */\n  setIsBusy(value: boolean) {\n    if (this.isBusy !== value) {\n      this.isBusy = value\n      if (this.options.setBusyCallback) {\n        this.options.setBusyCallback(value)\n      }\n    }\n  }\n\n  // TODO add validation of newer options\n  /**  Validates startup options */\n  validateAndSetOptions(options: OreIdOptions) {\n    const { appId, apiKey, oreIdUrl } = options || {}\n    let errorMessage = ''\n    // set options now since this.requiresProxyServer needs it set\n    this._options = options\n\n    // Apply default options\n    if (options) this.options.oreIdUrl = oreIdUrl || defaultOreIdServiceUrl\n\n    if (!appId) {\n      errorMessage +=\n        '\\n --> Missing required parameter - appId. You can get an appId when you register your app with ORE ID.'\n    }\n\n    // api-key and service-key not allowed if this is being instantiated in the browser\n    if (this.requiresProxyServer && apiKey) {\n      errorMessage +=\n        '\\n --> You cant include the apiKey when creating an instance of OreId that runs in the browser. This is to prevent your key from being visible in the browser. If this app runs solely in the browser (like a Create React App), you need to set-up a proxy server to protect your keys. Refer to https://github.com/TeamAikon/ore-id-docs. Note: You wont get this error when using the appId and apiKey for a demo app (appId starts with demo_).'\n    }\n    if (errorMessage !== '') {\n      throw new Error(`Options are missing or invalid. ${errorMessage}`)\n    }\n  }\n\n  /** Gets a single-use token to access the service */\n  async getAppAccessToken(params?: ApiGetAppTokenParams) {\n    return callApiGetAppToken(this, params)\n  }\n\n  /** Extracts the response parameters on the /new-account callback URL string */\n  handleNewAccountResponse(callbackUrlString: string): NewAccountResult {\n    const {\n      chain_account: chainAccount,\n      process_id: processId,\n      state,\n      errors,\n    } = Helpers.extractDataFromCallbackUrl(callbackUrlString)\n    this.setIsBusy(false)\n    return { chainAccount, processId, state, errors }\n  }\n\n  /** Extracts and returns the response parameters from the /sign callback URL string */\n  handleSignCallback(callbackUrlString: string): SignResult {\n    let signedTransaction\n    const {\n      signed_transaction: encodedTransaction,\n      process_id: processId,\n      state,\n      transaction_id: transactionId,\n      errors,\n    } = Helpers.extractDataFromCallbackUrl(callbackUrlString)\n\n    if (!errors) {\n      // Decode base64 parameters\n      signedTransaction = Helpers.base64DecodeSafe(encodedTransaction)\n    }\n    this.setIsBusy(false)\n    return { signedTransaction, processId, state, transactionId, errors }\n  }\n\n  /** Updates and returns a WebWidgetProps object to include two new fields: timestamp, signature\n   *  timestamp: current server time\n   *  signature: HMAC signature of the object including the timestamp - calculated using the apiKey\n   *  IF incoming props already has a value for timestamp - it is kept\n   *  If both incoming and timestamp and signature are already present, this returns incoming data unmodified\n   *  If an apiKey is not provided in options, this function expects a proxy server endpoint at /oreid/hmac to generate the siganture with the secured apiKey\n   *  Returns the updated object that includes the timestamp and the signature fields\n   */\n  async appendTimestampAndSignatureToWidgetProps(data: WebWidgetProps) {\n    // if we already have timestamp and signature, just return data as is\n    if (data?.timestamp && data?.signature) return data\n    const signedProps: Partial<WebWidgetProps> = { ...data }\n    // keep existing timestamp if there is one\n    const nowTimestamp = data?.timestamp || new Date().getTime()\n    signedProps.origin = data?.origin || window?.location.origin\n    signedProps.timestamp = nowTimestamp\n    // if we have an apiKey, add a signature\n    try {\n      signedProps.signature = await generateHmacWithApiKeyOrProxyServer(\n        this.requiresProxyServer,\n        this.options.apiKey,\n        JSON.stringify(Helpers.sortJson(data)), // props including timestamp - sortJson ensures json members are always in the same order\n      )\n    } catch (error) {\n      // do nothing, we just can't add a signature since apiKey and proxyServer are missing\n    }\n    return signedProps as WebWidgetProps\n  }\n\n  /** Helper function to call api endpoint and inject api-key\n    here params can be query params in case of a GET request or body params in case of POST request\n    processId (optional) - can be used to associate multiple calls together into a single process flow\n  */\n  async callOreIdApi(\n    requestMethod: RequestType,\n    endpoint: ApiEndpoint,\n    params: { [key: string]: any } = {},\n    /** Required if apiKey is not provider (optional otherwise) */\n    overrideAccessToken?: string,\n    processId: ProcessId = null,\n  ) {\n    let urlString\n    let response\n    const headers: { [key: string]: any } = {}\n    const { apiKey, oreIdUrl } = this.options\n    // if running in browser, we dont call the api directly, we use a proxy server (unless we're running a demo app)\n    // calls to the proxy server must start with '/' (not an host like http://server) and we'll prepend 'oreid' to it e.g. /oreid/api/xxx to make it easier to do proxy server routing\n    const oreIdUrlBase = this.requiresProxyServer ? '/oreid' : oreIdUrl\n    const url = `${oreIdUrlBase}/api/${endpoint}`\n    const accessToken = overrideAccessToken || this.accessToken\n\n    if (!apiKey && !accessToken && !publicApiEndpoints.includes(endpoint)) {\n      throw new Error('OreId API request requires either apiKey or accessToken')\n    }\n\n    // apiKey is optional (accessToken is required if apiKey not provided)\n    if (apiKey) {\n      headers['api-key'] = apiKey\n    }\n\n    if (accessToken) {\n      headers.Authorization = `Bearer ${accessToken}`\n    }\n\n    if (!isNullOrEmpty(processId)) {\n      headers['process-id'] = processId\n    }\n    // add sdk version to request header\n    headers['sdk-version'] = `oreidjs/${version}`\n\n    try {\n      // GET\n      if (requestMethod === RequestType.Get) {\n        if (!isNullOrEmpty(params)) {\n          urlString = Object.keys(params)\n            .map(key => `${key}=${params[key]}`)\n            .join('&')\n        }\n\n        const urlWithParams = urlString ? `${url}?${urlString}` : url\n        response = await axios.get(urlWithParams, { headers })\n      }\n      // POST\n      if (requestMethod === RequestType.Post) {\n        const body = !isNullOrEmpty(params) ? JSON.stringify(params) : null\n        response = await axios.post(url, body, {\n          headers: { 'Content-Type': 'application/json', ...headers },\n        })\n      }\n    } catch (networkError) {\n      const error = Helpers.getErrorFromAxiosError(networkError)\n      throw error\n    }\n    const data = response?.data\n    return data\n  }\n\n  /** Add an app access token and hmac signature to the url\n   *  If running in browser, calls proxy server at /oreid/prepare-url to do both (since they require teh apiKey secret) */\n  async addAccessTokenAndHmacToUrl(\n    urlString: string,\n    appAccessTokenMetadata: AppAccessTokenMetadata,\n    overrideAppAccessToken?: AppAccessToken,\n  ): Promise<string> {\n    const { appId } = this.options\n    // running in browser\n    if (this.requiresProxyServer) {\n      // retrieve and append an app-access-token and a matching hmac signature to the end of the url\n      // calling the proxy server is required to protect the secrets needed to get the access token and to generate the hmac\n      const response = await axios.post('/oreid/prepare-url', { appAccessTokenMetadata, urlString })\n      return response?.data?.urlString\n    }\n    let completeUrl = `${urlString}&app_id=${appId}`\n\n    // if we need app token metadata, then we generate and add an appAccessToken\n    if (!isNullOrEmpty(appAccessTokenMetadata)) {\n      const appAccessToken = overrideAppAccessToken || (await this.getAppAccessToken({ appAccessTokenMetadata }))\n      completeUrl = `${completeUrl}&app_access_token=${appAccessToken}`\n    }\n\n    // An hmac is no longer always required - however, if we have an apiKey, we can generate one\n    if (this.options?.apiKey) {\n      completeUrl = await appendHmacToUrl(false, this.options?.apiKey, completeUrl)\n    }\n\n    return completeUrl\n  }\n}\n","export * from './popupPlugin/models'\n\nexport enum PluginType {\n  Popup = 'popup',\n}\n"],"names":["RequestType","ApiEndpoint","ChainPlatformType","ChainNetwork","AccountType","LoginProvider","ExternalWalletType","AuthProvider","ApiKeyUsedFor","ExternalWalletInterface","ConfigType","RecoverAccountAction","WebWidgetAction","SignStringMethod","replaceAll","inString","search","replacement","replace","RegExp","Helpers","isNullOrEmpty","obj","undefined","Array","isArray","length","Object","keys","constructor","log","message","data","jwtDecodeSafe","token","decoded","this","jwtDecode","error","parseUrlParams","fullPath","searchString","urlParamsObject","urlObject","URL","hash","slice","URLSearchParams","forEach","value","key","decodeURIComponent","tryParseJSON","jsonString","unescape","replaceQuotes","finalJsonString","isAString","trim","decodeURI","o","JSON","parse","jsonParseComplexObjectReviver","type","Buffer","from","isANumber","values","entries","map","_a","__read","every","val","Uint8Array","base64DecodeSafe","encodedString","Base64","decode","base64Encode","valueIn","isAnObject","stringify","encode","sleep","ms","Promise","resolve","setTimeout","createGuid","uuidv4","v4","isInEnum","enumType","includes","toEnumValue","e","throwIfInvalid","errMsg","concat","Error","getErrorCodesFromParams","params","errorCodes","errorString","error_code","errorCode","errorMessage","error_message","split","push","extractDataFromCallbackUrl","url","errors","__assign","asyncForEach","array","callback","index","sent","getClaimFromJwtTokenBySearchString","decodedToken","item","getErrorFromAxiosError","toLowerCase","code","isAxiosError","response","errorCodesList","join","String","isADate","Date","isABoolean","Boolean","Number","isNaN","assertValidProvider","provider","mapAuthProviderToWalletType","isCustodial","Custodial","isValidEmail","email","test","sortJson","stringified","canonicalize","getUniqueValues","Set","runAtTime","executionEoochTime","now","Math","max","objectsAreEqual","a","b","keysA","keysB","keysA_1","__values","keysA_1_1","done","next","toString","isInBrowser","window","assertHasApiKeyOrAccessToken","oreIdContext","apiName","accessToken","options","apiKey","assertHasApiKey","usedFor","usedFprMsg","assertParamsHaveRequiredValues","paramNames","missing","p","assertParamsHaveOnlyOneOfValues","filter","extractProcessIdFromData","processId","callApiAddPermission","AddPermission","account","permission","parentPermission","optionalParams","queryParams","chainAccount","chainNetwork","publicKey","callOreIdApi","Get","callApiGetAppToken","AppToken","appAccessTokenMetadata","CreateUser","Post","appAccessToken","callApiCanAutosignTransaction","CanAutoSign","signedTransaction","transaction","transactionChainAccount","AutoSigning","body","chain_account","chain_network","signed_transaction","transaction_chain_acccount","callApiConvertOauthTokens","ConvertOauthTokens","idToken","access_token","id_token","callApiCustodialMigrateAccount","CustodialMigrateAccount","toType","userPassword","userPasswordEncrypted","to_type","user_password","user_password_encrypted","AccountMigration","callApiCustodialNewAccount","CustodialNewAccount","accountType","delayWalletSetup","emailVerified","isTestUser","name","picture","phone","phoneVerified","userName","account_type","delay_wallet_setup","email_verified","is_test_user","phone_verified","user_name","callApiCustodialSignString","CustodialSignString","stringToSign","signMethod","string_to_sign","sign_method","ProxySigning","callApiDeleteTestUser","DeleteTestUser","callApiGetConfig","GetConfig","configType","callApiGetUser","GetUser","callApiLoginUserWithToken","LoginUserWithToken","callApiNewUserWithToken","NewUserWithToken","assertParamsHaveAtLeastOneOfValues","callApiPasswordLessSendCode","PasswordLessSendCode","encodeURIComponent","callApiPasswordLessVerifyCode","PasswordLessVerifyCode","composeSignBodyFromTransactionData","_b","transactionData","expireSeconds","signedTransactionParam","transactionParam","transactionRecordId","_c","signOptions","allowChainAccountSelection","broadcast","generateAutoSignCredential","multiSigChainAccounts","returnSignedTransaction","autoSign","allow_chain_account_selection","auto_sign","expire_seconds","generate_auto_sign_credential","multisig_chain_accounts","return_signed_transaction","transaction_record_id","mapSignResultFromApi","apiResult","transactionId","transaction_id","rest","__rest","callApiSignTransaction","TransactionSign","callApiCustodialSignTransaction","CustodialSign","getOreIdNewChainAccountUrl","args","accountOptions","callbackUrl","backgroundColor","state","oreIdUrl","paramsNewAccount","accessTokenParam","encodedStateParam","addAccessTokenAndHmacToUrl","getOreIdAuthUrl","linkToAccount","returnAccessToken","returnIdToken","linkToAccountParam","codeParam","emailParam","phoneParam","returnAccessTokenParam","returnIdTokenParam","getOreIdSignUrl","encodedTransaction","encodedSignedTransaction","msgPackEncode","emptyCheck","hasOwnProperty","containsEmpty","firstEmptyKey","sortKeys","NonEosDiscoveryKeyLookupFunc","discoveryData","keyToAccountMap","transitProviderAttributesData","providerName","AlgoSigner","chainType","algorand","providerId","requiresLogin","supportsDiscovery","supportsSignArbitrary","requiresLogoutLoginToDiscover","requiresDiscoverToLogin","helpText","login","sign","discover","versionsRequired","discoveryKeyLookupFunc","note","accounts","accountName","authorization","logoUrl","Keycat","eos","Ledger","defaultDiscoveryPathIndexList","Lynx","Meetone","Metro","Portis","Scatter","SimpleEos","TokenPocket","WalletConnect","ethereum","Web3","WhaleVault","getTransitProviderAttributes","walletType","find","tp","supportedTransitProviders","TransitHelper","_oreIdContext","_user","user","transitAccessContexts","prototype","installTransitProviders","eosTransitWalletProviders","transitProvidersInstalled","makeWalletProvider","console","walletProvider","id","setupTransitWallet","assertHasProviderInstalled","Transit","assertProviderValidForChainNetwork","getOrCreateTransitAccessContext","chainContext","transitProvider","getWalletProviders","wp","transitWallet","initWallet","connect","waitWhileWalletIsBusy","appName","settings","getChainNetworkNextworkConfig","networkConfig","isNotEosNetwork","walletContext","initAccessContext","network","walletProviders","connectToTransitProvider","_d","authenticated","loginToTransitProvider","connected","auth","updateOreAccountPermissionsfromTransitWalletAuth","isLoggedIn","permissions","hasError","error_1","setIsBusy","doTransitProviderLogin","retryCount","discoverOptionsForProvider","foundData","findAccountInDiscoverData","info","transitAccountName","logout","loginWithTransitProvider","loginOptions","wallet","error_2","providerType","hasTransitProvider","discoverWithTransit","discoverOptions","EosMain","oreAccount","discoveryPathIndexList","result","canDiscover","discoverCredentialsInTransitWallet","accountsAndPermissions","transitWallet_1","credentials","credential","__awaiter","_this","parent","getChainNetworkFromTransitWallet","transitChainNetwork","_e","addWalletPermissionsToOreIdAccount","pathIndexListParam","pathIndexList","keyLookupFunc","walletProviderType","acct","first","signWithTransitProvider","signTransactionWithTransitAndEosSDK","signTransactionWithTransitAndAlgorandSDK","signTransactionWithTransitAndEthereumSDK","error_3","serializedTransaction","signStringWithTransitProvider","string","metadata","signArbitrary","signedString","error_4","eosApi","transact","actions","blocksBehind","signatures","callDiscoverAfterSign","signParams","chainId","requiredKeys","abis","signatureProvider","ctx","getAllChainNetworkSettings","networks","net","hosts","host","updatePermissionsIfNecessary","isTransitProvider","n","inProgress","canSignString","helpTextForProvider","ualProviderAttributesData","Anchor","Wombat","getUalProviderAttributes","up","supportedUALProviders","UalHelper","installUalProviders","ualWalletProviders","ualProvidersInstalled","ualProviderFactory","loginToUalProvider","authenticator","Ual","users","usersWithAccountsDetails_1","getAccountAndPermissionsFromUalUser","userPermissions","uwa","connectToUalProvider","SelectedAuthenticator","ualAuthenticators","ualAuthenticator","ualNetworkConfig","rpcEndpoints","init","isErrored","ualError","getError","cause","userForChain","updateOreAccountPermissionsfromUalUser","ualUser","getChainId","getChainNetworkByChainId","getAccountName","getKeys","publicKeys","loginWithUalProvider","hasUalProvider","signWithUalProvider","signTransaction","signedTransactionResponse","signStringWithUalProvider","error_5","isUalProvider","isLoading","Observable","_subscribers","subscribe","subscriber","hasThisSubscriber","s","unsubscribe","f","callSubscribers","callApiUpdateDelayWalletSetup","UpdateDelayWalletSetup","User","_super","onUpdateAccessTokenHelper","newAccessTokenHelper","_accountName","_accessTokenHelper","accessTokenHelper","__extends","defineProperty","get","assertUserHasData","_userSourceData","otherInfo","chainAccounts","getChainAccounts","setUserSourceData","userSourceData","perm","defaultPermission","getDefaultPermissionForChainAccount","getPermissionForChainAccount","hasData","assertUserHasValidEmail","getData","forceRefresh","getNewChainAccountUrl","newAccountOptions","newAccountCallbackUrl","newAccountUrl","deleteTestUser","disableDelayedWalletSetup","sendVerificationCodeToEmail","Email","checkVerificationCodeForEmail","mapUserPermission","permissionName","other","accountPermissions","isDefault","some","AccessTokenHelper","ignoreIssuer","_ignoreIssuer","setAccessToken","_accessToken","_decodedAccessToken","_idToken","_decodedIdToken","assertIsTokenValid","decodedAccessToken","clearAccessToken","clearIdToken","setIdToken","hasExpired","isTokenDateValidNow","assertIdTokenMatchesAccessToken","decodedIdToken","exp","assertHasAccessToken","isTokenValid","iss","sub","nowInMs","getTime","nbf","Auth","saveAccessTokenAndNotifySubscribers","_localState","localState","_transitHelper","_ualHelper","initAccessTokenHelper","savedToken","set","saveAccessToken","connectWithWallet","walletHelper","isAValidExternalWalletType","connectToWalletProvider","convertOauthTokens","parms","loginWithToken","loginWithAccessOrIdTokenToken","newUserWithToken","userOptions","newAccountWithIdToken","checkJwtTokenAndReturnError","jwtTokenString","tokenCheckError","setAuthResult","idTokenCheckError","getLoginUrl","authCallbackUrl","loginUrl","handleAuthCallback","callbackUrlString","process_id","authResponse","externalWalletsNotImplemented","version","publicApiEndpoints","Transaction","assertValidTransactionAndSetData","_data","createTransactionData","missingFields","validationIssues","setTransactionData","assertTransactionAccountValidForUser","_g","chainAccountsInWallet","allPermissionsExternal","privateKeyStoredExterally","externalWalletType","_f","validate","getSignUrl","signCallbackUrl","signUrl","checkCanAutoSign","autoSignCredentialsExist","signWithPassword","signWithWallet","generateHmac","secret","HmacSHA256","generateHmacWithApiKeyOrProxyServer","useProxyServer","Axios","post","headers","hmac","networkError_1","appendHmacToUrl","urlEncodedHmac","LocalState","appId","storage","cachedaccessToken","cachedUser","accessTokenKey","loadAccessToken","getItem","setItem","removeItem","clear","CookieStorage","Cookie","remove","expires","LocalStorage","localStorage","DummyStorage","MemoryStorage","memoryCache","StorageHandler","tryLocalStorageFirst","triedLocalStorage","triedCookieStorage","localStorage_1","failover","didSet","Settings","_cachedChainNetworks","getConfigFromApi","Chains","results","chains","getChainNetworkSettings","getConfig","networkSettings","port","protocol","chainSettings","h","networkSetting","ore","WalletHelper","transitHelper","ualHelper","getExternalWalletInfo","externalWalletInterface","getExternalWalletInfoByChain","chain","transitWalletsInstalledInfo","ualWalletsInstalledInfo","__spreadArray","signResult","signStringWithWallet","assertWalletTypeValidForChainNetwork","OreId","_options","validateAndSetOptions","storageHandler","_settings","_auth","_walletHelper","_initializerPlugins","plugins","_isInitialized","startsWith","assertIsInitialized","_popup","isUsingProxyServer","isDemoApp","isInitialized","popup","custodialSignString","custodialNewAccount","custodialMigrateAccount","migrateOptions","createTransaction","isBusy","setBusyCallback","requiresProxyServer","getAppAccessToken","handleNewAccountResponse","handleSignCallback","appendTimestampAndSignatureToWidgetProps","timestamp","signature","signedProps","nowTimestamp","origin","location","requestMethod","endpoint","overrideAccessToken","oreIdUrlBase","Authorization","urlString","urlWithParams","axios","overrideAppAccessToken","completeUrl","PluginType","exports","WidgetVersion"],"mappings":"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"}