import { JWTToken } from './models';
import { Observable } from '../utils/observable';
export declare type SubscriberAccessTokenHelper = (accessTokenHelper: AccessTokenHelper) => void;
export declare class AccessTokenHelper extends Observable<SubscriberAccessTokenHelper> {
    constructor(accessToken?: string, ignoreIssuer?: boolean);
    _accessToken: string;
    _decodedAccessToken: JWTToken;
    _idToken: string;
    _decodedIdToken: JWTToken;
    _ignoreIssuer: boolean;
    get accessToken(): string;
    get decodedAccessToken(): JWTToken;
    get idToken(): string;
    get decodedIdToken(): JWTToken;
    get accountName(): string;
    /** clear accessToken */
    clearAccessToken(): void;
    /** clear idToken */
    clearIdToken(): void;
    /** Whether current accessToken is expired (or is missing)
     *  (optional) provide a Date() to compare expiration against - defaults to current Date()
     *  Returns: (boolean) true if hasExpired
     */
    hasExpired(now?: Date): boolean;
    setAccessToken(value: string): void;
    setIdToken(value: string): void;
    /** Throws if accessToken is NOT set yet */
    assertHasAccessToken(): void;
    /** Whether token is a valid OREID issued token and NOT expired */
    static isTokenValid(decodedToken: Partial<JWTToken>, ignoreIssuer?: boolean): boolean;
    /** Throws if decodedToken is NOT a valid OREID issued token */
    static assertIsTokenValid(decodedToken: Partial<JWTToken>, ignoreIssuer?: boolean): void;
    /** Throws if accessToken does not match the same user and issuer as the idToken */
    static assertIdTokenMatchesAccessToken(decodedAccessToken: Partial<JWTToken>, decodedIdToken: Partial<JWTToken>): void;
    /** Whether a JWT token is valid for use right now - not expired and not being used before first usable date (nbf) */
    static isTokenDateValidNow(decodedToken: Partial<JWTToken>, now?: Date): boolean;
}
