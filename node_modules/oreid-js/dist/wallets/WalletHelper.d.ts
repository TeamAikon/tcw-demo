import OreIdContext from '../core/IOreidContext';
import { ChainNetwork, ChainPlatformType, ExternalWalletType, LoginWithWalletOptions, SignatureProviderSignResult, SignStringParams, SignStringResult, TransactionData } from '../models';
import TransitHelper from '../transit/TransitHelper';
import UalHelper from '../ual/UalHelper';
import { ExternalWalletInterface, WalletProviderAttributes } from './models';
export default class WalletHelper {
    constructor(args: {
        oreIdContext: OreIdContext;
        transitHelper: TransitHelper;
        ualHelper: UalHelper;
    });
    _oreIdContext: OreIdContext;
    _transitHelper: TransitHelper;
    _ualHelper: UalHelper;
    /** Transit wallet plugin helper functions and connections */
    get transitHelper(): TransitHelper;
    /** Ual wallet plugin helper functions and connections */
    get ualHelper(): UalHelper;
    isAValidExternalWalletType(walletType: ExternalWalletType): boolean;
    /** Returns metadata about the installed external wallet type (e.g. name, logo) and which features it supports
     *  If optional externalWalletInterface param provided, then gets Info for the specified type (Transit or UAL) instead of seeing what's installed
     */
    getExternalWalletInfo(walletType: ExternalWalletType, externalWalletInterface?: ExternalWalletInterface): WalletProviderAttributes;
    /** Returns wallet metadata (for installed wallet providers) for a given chain */
    getExternalWalletInfoByChain(chain: ChainPlatformType): WalletProviderAttributes[];
    /** Connect to the wallet provider
     *  For some wallet types, this will include an unlock and 'login' flow to select a chain account
     *  If a chainAccount is selected, it and it's associated publicKey (if available) will be saved to the user's OreId wallet as an 'external key' */
    connectToWalletProvider(loginOptions: LoginWithWalletOptions): Promise<{
        isLoggedIn?: boolean;
        chainAccount?: string;
        permissions?: [{
            name: string;
            publicKey: string;
        }];
        transitWallet?: import("@aikon/eos-transit/lib").Wallet;
        provider?: ExternalWalletType;
    } | import("../models").ConnectToUalProviderResult>;
    /** Sign with a supported blockchain wallet via Transit provider */
    signWithWallet(walletType: ExternalWalletType, transactionData: TransactionData): Promise<{
        signedTransaction: SignatureProviderSignResult;
    }>;
    /** Sign an arbitrary string (instead of a transaction)
     * This only supports Transit and Ual wallets
     */
    signStringWithWallet(params: SignStringParams): Promise<SignStringResult>;
    /** Throw if the provider doesnt support the specified chainNetwork */
    assertWalletTypeValidForChainNetwork(walletType: ExternalWalletType, chainNetwork: ChainNetwork, externalWalletInterface?: ExternalWalletInterface): Promise<void>;
    /** whether discovery is supported by the provider */
    canDiscover(walletType: ExternalWalletType, externalWalletInterface?: ExternalWalletInterface): boolean;
    /** whether signString is supported by the provider */
    canSignString(walletType: ExternalWalletType, externalWalletInterface?: ExternalWalletInterface): boolean;
    /** whether call to discover is required by provider before login */
    requiresDiscoverToLogin(walletType: ExternalWalletType, externalWalletInterface?: ExternalWalletInterface): boolean;
    /** whether call to logout then login is required by provider before discover */
    requiresLogoutLoginToDiscover(walletType: ExternalWalletType, externalWalletInterface?: ExternalWalletInterface): boolean;
    /** default path index for provider (if any) */
    defaultDiscoveryPathIndexList(walletType: ExternalWalletType, externalWalletInterface?: ExternalWalletInterface): number[];
    /** help text displayed to user for provider */
    helpTextForProvider(walletType: ExternalWalletType, externalWalletInterface?: ExternalWalletInterface): {
        login: string;
        sign: string;
        discover: string;
        versionsRequired: string;
    };
}
