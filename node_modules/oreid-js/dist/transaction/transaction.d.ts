import OreIdContext from '../core/IOreidContext';
import { CreateTransactionData, ExternalWalletType, SignatureProviderSignResult, SignWithOreIdResult, TransactionData } from '../models';
import { User } from '../user/user';
export default class Transaction {
    constructor(args: {
        oreIdContext: OreIdContext;
        user: User;
        data: TransactionData;
    });
    private _oreIdContext;
    private _data;
    private _transitHelper;
    private _ualHelper;
    private _user;
    get data(): TransactionData;
    /** ensure all required parameters are provided */
    assertValidTransactionAndSetData(createTransactionData: CreateTransactionData): void;
    private setTransactionData;
    /** ensure that the chainNetwork and chainAccount for the transaction are in the user's wallet
     *  NOTE: This check is not required for a user signing with a wallet app - Since the account may be in the wallet and not yet added to OreId
     */
    assertTransactionAccountValidForUser(): void;
    /** validates that transaction is well-formed for the blockcahin
     * Returns array of errors
     */
    validate(): Promise<string[]>;
    /**
     * Returns a url to redirect the user's browser to - to sign transaction using OREID web interface
     */
    getSignUrl(): Promise<SignWithOreIdResult>;
    /**
     * Whether the provided transaction (or signedTransaction) can be autoSigned via api (without user interaction)
     * Requires an apiKey with the autoSign right
     * Returns: true if transaction can be signed using tansaction.sign()
     * */
    checkCanAutoSign(): Promise<boolean>;
    /** Attempt to sign a transaction without user interaction
     *  Expects user to have previously approved autoSign for transaction type and it hasn't expired
     *  Call callApiCanAutosignTransaction() first to confirm that this transaction can be autoSigned before attempting this call
     */
    autoSign(): Promise<{
        processId: string;
        signedTransaction: string;
        transactionId: string;
    }>;
    /** Sign a transaction without user interaction
     *  Requires a user's wallet password or encrypted password (a 'custodial' account managed by you)
     *  Requires an apiKey with the proxySign right
     */
    signWithPassword(userPassword?: string, userPasswordEncrypted?: string): Promise<{
        processId: string;
        signedTransaction: string;
        transactionId: string;
    }>;
    /** Sign with a supported blockchain wallet via Transit provider */
    signWithWallet(walletType: ExternalWalletType): Promise<{
        signedTransaction: SignatureProviderSignResult;
    }>;
}
