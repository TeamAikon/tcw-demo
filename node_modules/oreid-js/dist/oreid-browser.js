(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["oreidJs"] = factory();
	else
		root["oreidJs"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Auth": () => (/* binding */ Auth)
/* harmony export */ });
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _core_urlGenerators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
/* harmony import */ var _transit_TransitHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41);
/* harmony import */ var _ual_UalHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(72);
/* harmony import */ var _user_user__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(74);
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17);
/* harmony import */ var _utils_observable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(75);
/* harmony import */ var _accessTokenHelper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(77);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var Auth = /*#__PURE__*/function (_Observable) {
  _inherits(Auth, _Observable);

  var _super = _createSuper(Auth);

  function Auth(args) {
    var _this;

    _classCallCheck(this, Auth);

    _this = _super.call(this);

    _defineProperty(_assertThisInitialized(_this), "onUpdateAccessTokenHelper", function (newAccessTokenHelper) {
      // save new access token
      _this.saveAccessTokenAndNotifySubscribers(_this._accessTokenHelper.accessToken);
    });

    _this._oreIdContext = args.oreIdContext;
    _this._localState = _this._oreIdContext.localState;
    _this._transitHelper = new _transit_TransitHelper__WEBPACK_IMPORTED_MODULE_2__["default"]({
      oreIdContext: _this._oreIdContext,
      user: _this._user
    });
    _this._ualHelper = new _ual_UalHelper__WEBPACK_IMPORTED_MODULE_3__["default"]({
      oreIdContext: _this._oreIdContext,
      user: _this._user
    });

    _this.initAccessTokenHelper();

    return _this;
  }

  _createClass(Auth, [{
    key: "accessTokenHelper",
    get:
    /** User's OreID (accountName) */
    function get() {
      return this._accessTokenHelper;
    }
  }, {
    key: "initAccessTokenHelper",
    value: function initAccessTokenHelper() {
      var _this$_localState;

      this._accessTokenHelper = new _accessTokenHelper__WEBPACK_IMPORTED_MODULE_7__.AccessTokenHelper();
      var savedToken = (_this$_localState = this._localState) === null || _this$_localState === void 0 ? void 0 : _this$_localState.accessToken;
      this.accessToken = savedToken;
      this.saveAccessTokenAndNotifySubscribers(savedToken); // if savedToken is expired, it will be not set here
      // listen for future changes to accessTokenHelper

      this._accessTokenHelper.subscribe(this.onUpdateAccessTokenHelper);
    }
    /** User's OreID (accountName) */

  }, {
    key: "accountName",
    get: function get() {
      var _this$_accessTokenHel, _this$_accessTokenHel2;

      return (_this$_accessTokenHel = this._accessTokenHelper) !== null && _this$_accessTokenHel !== void 0 && _this$_accessTokenHel.accessToken ? (_this$_accessTokenHel2 = this._accessTokenHelper) === null || _this$_accessTokenHel2 === void 0 ? void 0 : _this$_accessTokenHel2.accountName : null;
    }
  }, {
    key: "idToken",
    get: function get() {
      var _this$_accessTokenHel3;

      return (_this$_accessTokenHel3 = this._accessTokenHelper) === null || _this$_accessTokenHel3 === void 0 ? void 0 : _this$_accessTokenHel3.idToken;
    }
    /** retrieve accessToken saved in local storage - is automatically deleted when token expires */

  }, {
    key: "accessToken",
    get: function get() {
      var _this$_accessTokenHel4;

      return (_this$_accessTokenHel4 = this._accessTokenHelper) === null || _this$_accessTokenHel4 === void 0 ? void 0 : _this$_accessTokenHel4.accessToken;
    }
    /** Sets the access token in local storage (and in accessTokenHelper)
     * this token will be used to call ORE ID APIs (on behalf of the user)
     * This token is user-specific - call logout to clear it upon user log-out
     * When the accessToken token expires, it will be deleted from local storage and user will be cleared
     */
    ,
    set: function set(accessToken) {
      try {
        // decodes and validates accessToken is a valid token
        // if incoming token has expired, _accessTokenHelper will throw (and token wont be saved)
        this._accessTokenHelper.setAccessToken(accessToken); // NOTE: We dont save the access token to local storage here as that will happen when onUpdateAccessTokenHelper is called

      } catch (error) {
        console.log('Cant set accessToken.', error.message);
      }
    }
    /** set private variable and save to localState
     * NOTE: This is called every time this._accessTokenHelper.accessToken changes (or expires)
     */

  }, {
    key: "saveAccessTokenAndNotifySubscribers",
    value: function saveAccessTokenAndNotifySubscribers(accessToken) {
      var _this$_localState2;

      if (((_this$_localState2 = this._localState) === null || _this$_localState2 === void 0 ? void 0 : _this$_localState2.accessToken) !== accessToken) {
        this._localState.saveAccessToken(accessToken);

        this._user = null;
      }

      _get(_getPrototypeOf(Auth.prototype), "callSubscribers", this).call(this);
    }
    /** Returns user object matching current accessToken
     *  A newly created object object won't have user.info populated, call user.getData() to retrieve
     */

  }, {
    key: "user",
    get: function get() {
      if (!this._user) {
        this._user = new _user_user__WEBPACK_IMPORTED_MODULE_4__.User({
          oreIdContext: this._oreIdContext,
          accessTokenHelper: this._accessTokenHelper,
          // accessToken helper
          accountName: this.accountName // accountName

        });
      }

      return this._user;
    }
    /** We have a valid access token for the current user */

  }, {
    key: "isLoggedIn",
    get: function get() {
      return !!this.accessToken;
    }
    /** runs when accessTokenHelper changes */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "clearAccessToken",
    value: function clearAccessToken() {
      // clear accessToken and user
      this._localState.clearAccessToken();

      this._accessTokenHelper.clearAccessToken();

      _get(_getPrototypeOf(Auth.prototype), "callSubscribers", this).call(this);
    }
    /** Calls the 'connect' function on a external wallet (e.g. Metamask)
     *  For most, however, this function returns the chainAccount selected by the user in the wallet app
     *  Different wallets have different behavior. Some do not support this feature. */

  }, {
    key: "connectWithWallet",
    value: function () {
      var _connectWithWallet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(loginOptions) {
        var walletType;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                walletType = loginOptions.walletType;

                if (this._oreIdContext.walletHelper.isAValidExternalWalletType(walletType)) {
                  _context.next = 3;
                  break;
                }

                throw new Error("loginWithWallet not supported for external wallet type: ".concat(walletType));

              case 3:
                return _context.abrupt("return", this.connectToWalletProvider(loginOptions));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function connectWithWallet(_x) {
        return _connectWithWallet.apply(this, arguments);
      }

      return connectWithWallet;
    }()
    /** Connect to the wallet provider
     *  For some wallet types, this will include an unlock and 'login' flow to select a chain account
     *  If a chainAccount is selected, it and it's associated publicKey (if available) will be saved to the user's OreId wallet as an 'external key' */

  }, {
    key: "connectToWalletProvider",
    value: function () {
      var _connectToWalletProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(loginOptions) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this._oreIdContext.walletHelper.connectToWalletProvider(loginOptions));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function connectToWalletProvider(_x2) {
        return _connectToWalletProvider.apply(this, arguments);
      }

      return connectToWalletProvider;
    }()
    /** Calls the account/convert-oauth api
     * Converts OAuth tokens from some 3rd-party source to OREID Oauth tokens
     * The third-party (e.g. Auth0 or Google) must be registered in the AppRegistration.oauthSettings
     * Returns: OreId issued accessToken and idToken
     * */

  }, {
    key: "convertOauthTokens",
    value: function () {
      var _convertOauthTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(parms) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", (0,_api__WEBPACK_IMPORTED_MODULE_0__.callApiConvertOauthTokens)(this._oreIdContext, parms));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function convertOauthTokens(_x3) {
        return _convertOauthTokens.apply(this, arguments);
      }

      return convertOauthTokens;
    }()
    /**
     * Converts OAuth accessToken or idToken from some 3rd-party source (e.g. Google) to OreId OAuth accessToken
     * The third-party (e.g. Auth0 or Google) must be registered in the App Registration's oauthSettings
     * If a user does not curently exist that matches the info in the incoming idToken, an error is thrown
     * Does not requires a user to be logged-in (no current accessToken) or apiKey
     * Returns: OreId issued accessToken
     * */

  }, {
    key: "loginWithToken",
    value: function () {
      var _loginWithToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(loginOptions) {
        var _yield$this$loginWith, accessToken, error, processId;

        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(!(loginOptions !== null && loginOptions !== void 0 && loginOptions.idToken) && !(loginOptions !== null && loginOptions !== void 0 && loginOptions.accessToken))) {
                  _context4.next = 2;
                  break;
                }

                throw new Error('Cant loginWithToken - missing required parameter: accessToken OR idToken');

              case 2:
                _context4.next = 4;
                return this.loginWithAccessOrIdTokenToken(loginOptions);

              case 4:
                _yield$this$loginWith = _context4.sent;
                accessToken = _yield$this$loginWith.accessToken;
                error = _yield$this$loginWith.error;
                processId = _yield$this$loginWith.processId;

                if (error) {
                  _context4.next = 12;
                  break;
                }

                this.accessToken = accessToken; // saves in cache and in local storage

                _context4.next = 12;
                return this.user.getData();

              case 12:
                return _context4.abrupt("return", {
                  accessToken: accessToken,
                  errors: error,
                  processId: processId
                });

              case 13:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function loginWithToken(_x4) {
        return _loginWithToken.apply(this, arguments);
      }

      return loginWithToken;
    }()
    /** Converts OAuth idToken from some 3rd-party source to OREID Oauth accessTokens
     * The third-party (e.g. Auth0 or Google) must be registered in the AppRegistration.oauthSettings
     * Creates a new OreId user and account from info in the incoming idToken
     * If a matching user already exist, and error is returned
     * Requires a valid idToken but no current accessToken or apiKey
     * Returns: OreId issued accessToken
     * */

  }, {
    key: "newUserWithToken",
    value: function () {
      var _newUserWithToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(userOptions) {
        var _yield$this$newAccoun, accessToken, error, processId;

        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.newAccountWithIdToken(userOptions);

              case 2:
                _yield$this$newAccoun = _context5.sent;
                accessToken = _yield$this$newAccoun.accessToken;
                error = _yield$this$newAccoun.error;
                processId = _yield$this$newAccoun.processId;

                if (error) {
                  _context5.next = 10;
                  break;
                }

                this.accessToken = accessToken; // saves in cache and in local storage

                _context5.next = 10;
                return this.user.getData();

              case 10:
                return _context5.abrupt("return", {
                  accessToken: accessToken,
                  errors: error,
                  processId: processId
                });

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function newUserWithToken(_x5) {
        return _newUserWithToken.apply(this, arguments);
      }

      return newUserWithToken;
    }()
    /** Calls api account/login-user-with-token for loginWithToken() (after checking for valid token */

  }, {
    key: "loginWithAccessOrIdTokenToken",
    value:
    /** Calls api account/login-user-with-token for loginWithToken() (after checking for valid token */
    function () {
      var _loginWithAccessOrIdTokenToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(params) {
        var accessToken, idToken, tokenCheckError, response;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                accessToken = params.accessToken, idToken = params.idToken;

                // check valid JWT tokens (Note: accessToken can be a JWT or not)
                if (accessToken && _utils_helpers__WEBPACK_IMPORTED_MODULE_5__["default"].jwtDecodeSafe(accessToken)) {
                  tokenCheckError = accessToken ? Auth.checkJwtTokenAndReturnError(accessToken) : null;
                } else {
                  tokenCheckError = idToken ? Auth.checkJwtTokenAndReturnError(idToken) : null;
                }

                if (!tokenCheckError) {
                  _context6.next = 4;
                  break;
                }

                return _context6.abrupt("return", _objectSpread({
                  accessToken: null
                }, tokenCheckError));

              case 4:
                _context6.next = 6;
                return (0,_api__WEBPACK_IMPORTED_MODULE_0__.callApiLoginUserWithToken)(this._oreIdContext, params);

              case 6:
                response = _context6.sent;

                if (!(response !== null && response !== void 0 && response.errorCode)) {
                  this.setAuthResult({
                    accessToken: response === null || response === void 0 ? void 0 : response.accessToken
                  });
                }

                return _context6.abrupt("return", {
                  accessToken: response.accessToken,
                  error: response === null || response === void 0 ? void 0 : response.errorCode,
                  message: response === null || response === void 0 ? void 0 : response.errorMessage,
                  processId: response === null || response === void 0 ? void 0 : response.processId
                });

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function loginWithAccessOrIdTokenToken(_x6) {
        return _loginWithAccessOrIdTokenToken.apply(this, arguments);
      }

      return loginWithAccessOrIdTokenToken;
    }()
    /** Calls api account/new-user-with-token for newUserWithToken() (after checking for valid token */

  }, {
    key: "newAccountWithIdToken",
    value: function () {
      var _newAccountWithIdToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(params) {
        var idToken, idTokenCheckError, response;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                idToken = params.idToken; // check valid ifToken

                idTokenCheckError = idToken ? Auth.checkJwtTokenAndReturnError(idToken) : null;

                if (!idTokenCheckError) {
                  _context7.next = 4;
                  break;
                }

                return _context7.abrupt("return", _objectSpread({
                  accessToken: null
                }, idTokenCheckError));

              case 4:
                _context7.next = 6;
                return (0,_api__WEBPACK_IMPORTED_MODULE_0__.callApiNewUserWithToken)(this._oreIdContext, params);

              case 6:
                response = _context7.sent;

                if (!(response !== null && response !== void 0 && response.errorCode)) {
                  this.setAuthResult({
                    accessToken: response === null || response === void 0 ? void 0 : response.accessToken
                  });
                }

                return _context7.abrupt("return", {
                  accessToken: response.accessToken,
                  error: response === null || response === void 0 ? void 0 : response.errorCode,
                  message: response === null || response === void 0 ? void 0 : response.errorMessage,
                  processId: response === null || response === void 0 ? void 0 : response.processId
                });

              case 9:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function newAccountWithIdToken(_x7) {
        return _newAccountWithIdToken.apply(this, arguments);
      }

      return newAccountWithIdToken;
    }()
    /** clear accessToken and user */

  }, {
    key: "logout",
    value: function logout() {
      this.clearAccessToken();
      this._user = null;
    }
    /** Returns a fully formed url to redirect the user's browser to login using ORE ID
     *  This function calls the /auth web endpoint
     *  Returns: Callback returns account, and optionally accessToken and/or idToken for user */

  }, {
    key: "getLoginUrl",
    value: function () {
      var _getLoginUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(loginOptions) {
        var _ref, code, email, idToken, phone, provider, state, linkToAccount, returnAccessToken, returnIdToken, _this$_oreIdContext$o, authCallbackUrl, backgroundColor, args, loginUrl;

        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _ref = loginOptions || {}, code = _ref.code, email = _ref.email, idToken = _ref.idToken, phone = _ref.phone, provider = _ref.provider, state = _ref.state, linkToAccount = _ref.linkToAccount, returnAccessToken = _ref.returnAccessToken, returnIdToken = _ref.returnIdToken;
                _this$_oreIdContext$o = this._oreIdContext.options, authCallbackUrl = _this$_oreIdContext$o.authCallbackUrl, backgroundColor = _this$_oreIdContext$o.backgroundColor;
                args = {
                  code: code,
                  email: email,
                  idToken: idToken,
                  phone: phone,
                  provider: provider,
                  backgroundColor: backgroundColor,
                  callbackUrl: authCallbackUrl,
                  state: state,
                  linkToAccount: linkToAccount,
                  returnAccessToken: _utils_helpers__WEBPACK_IMPORTED_MODULE_5__["default"].isNullOrEmpty(returnAccessToken) ? true : returnAccessToken,
                  // if returnAccessToken not specified, default to true
                  returnIdToken: returnIdToken
                };
                _context8.next = 5;
                return (0,_core_urlGenerators__WEBPACK_IMPORTED_MODULE_1__.getOreIdAuthUrl)(this._oreIdContext, args);

              case 5:
                loginUrl = _context8.sent;
                return _context8.abrupt("return", {
                  loginUrl: loginUrl,
                  errors: null
                });

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getLoginUrl(_x8) {
        return _getLoginUrl.apply(this, arguments);
      }

      return getLoginUrl;
    }()
    /** Extracts and returns the response parameters on the /auth callback URL string
     *  Applies accessToken and idToken (if included on the url) to local state
     */

  }, {
    key: "handleAuthCallback",
    value: function handleAuthCallback(callbackUrlString) {
      // Parses error codes and returns an errors array
      // (if there is an error_code param sent back - can have more than one error code - seperated by a ‘&’ delimeter
      var _Helpers$extractDataF = _utils_helpers__WEBPACK_IMPORTED_MODULE_5__["default"].extractDataFromCallbackUrl(callbackUrlString),
          accessToken = _Helpers$extractDataF.access_token,
          account = _Helpers$extractDataF.account,
          idToken = _Helpers$extractDataF.id_token,
          errors = _Helpers$extractDataF.errors,
          processId = _Helpers$extractDataF.process_id,
          state = _Helpers$extractDataF.state;

      var response = {
        account: account
      };
      if (errors) response.errors = errors;
      if (processId) response.processId = processId;
      if (state) response.state = state;
      if (accessToken) response.accessToken = accessToken;
      if (idToken) response.idToken = idToken;

      if (!errors) {
        this.setAuthResult(response);
      } // clear the busy indicator now that we've finsihed the auth flow


      this._oreIdContext.setIsBusy(false);

      return response;
    }
    /** store response from auth flow (accountName, accessToken, idToken) in localState */

  }, {
    key: "setAuthResult",
    value: function setAuthResult(authResponse) {
      var accessToken = authResponse.accessToken,
          idToken = authResponse.idToken;
      if (!accessToken) throw Error('Cant setAuthResult. accessToken is missing');

      this._accessTokenHelper.setIdToken(null); // clear the existing idToken first (so set accessToken wont throw a mismatch when set)


      this.accessToken = accessToken; // saves the token to localstorage

      if (idToken) {
        this._accessTokenHelper.setIdToken(idToken);
      }
    }
  }], [{
    key: "checkJwtTokenAndReturnError",
    value: function checkJwtTokenAndReturnError(jwtTokenString) {
      try {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var accessTokenHelper = new _accessTokenHelper__WEBPACK_IMPORTED_MODULE_7__.AccessTokenHelper(jwtTokenString, true);
      } catch (error) {
        return {
          error: 'token_invalid',
          message: 'token invalid or corrupt - must be a JWT Oauth2 token'
        };
      }

      return null;
    }
  }]);

  return Auth;
}(_utils_observable__WEBPACK_IMPORTED_MODULE_6__.Observable);

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiEndpoint": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_2__.ApiEndpoint),
/* harmony export */   "RequestType": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_2__.RequestType),
/* harmony export */   "assertHasAccessToken": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasAccessToken),
/* harmony export */   "assertHasApiKey": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKey),
/* harmony export */   "assertHasApiKeyOrAccessToken": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKeyOrAccessToken),
/* harmony export */   "assertHeaderhasRequiredValues": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_1__.assertHeaderhasRequiredValues),
/* harmony export */   "assertParamsHaveAtLeastOneOfValues": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveAtLeastOneOfValues),
/* harmony export */   "assertParamsHaveOnlyOneOfValues": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveOnlyOneOfValues),
/* harmony export */   "assertParamsHaveRequiredValues": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues),
/* harmony export */   "callApiAddPermission": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiAddPermission),
/* harmony export */   "callApiCanAutosignTransaction": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiCanAutosignTransaction),
/* harmony export */   "callApiConvertOauthTokens": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiConvertOauthTokens),
/* harmony export */   "callApiCustodialMigrateAccount": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiCustodialMigrateAccount),
/* harmony export */   "callApiCustodialNewAccount": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiCustodialNewAccount),
/* harmony export */   "callApiCustodialSignString": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiCustodialSignString),
/* harmony export */   "callApiCustodialSignTransaction": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiCustodialSignTransaction),
/* harmony export */   "callApiDeleteTestUser": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiDeleteTestUser),
/* harmony export */   "callApiGetAppToken": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiGetAppToken),
/* harmony export */   "callApiGetConfig": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiGetConfig),
/* harmony export */   "callApiGetUser": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiGetUser),
/* harmony export */   "callApiLoginUserWithToken": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiLoginUserWithToken),
/* harmony export */   "callApiNewUserWithToken": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiNewUserWithToken),
/* harmony export */   "callApiPasswordLessSendCode": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiPasswordLessSendCode),
/* harmony export */   "callApiPasswordLessVerifyCode": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiPasswordLessVerifyCode),
/* harmony export */   "callApiSignTransaction": () => (/* reexport safe */ _endpoints__WEBPACK_IMPORTED_MODULE_0__.callApiSignTransaction),
/* harmony export */   "extractProcessIdFromData": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_1__.extractProcessIdFromData)
/* harmony export */ });
/* harmony import */ var _endpoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);




/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiAddPermission": () => (/* reexport safe */ _addPermission__WEBPACK_IMPORTED_MODULE_0__.callApiAddPermission),
/* harmony export */   "callApiCanAutosignTransaction": () => (/* reexport safe */ _canAutoSign__WEBPACK_IMPORTED_MODULE_2__.callApiCanAutosignTransaction),
/* harmony export */   "callApiConvertOauthTokens": () => (/* reexport safe */ _convertOauth__WEBPACK_IMPORTED_MODULE_3__.callApiConvertOauthTokens),
/* harmony export */   "callApiCustodialMigrateAccount": () => (/* reexport safe */ _custodialMigrateAccount__WEBPACK_IMPORTED_MODULE_4__.callApiCustodialMigrateAccount),
/* harmony export */   "callApiCustodialNewAccount": () => (/* reexport safe */ _custodialNewAccount__WEBPACK_IMPORTED_MODULE_5__.callApiCustodialNewAccount),
/* harmony export */   "callApiCustodialSignString": () => (/* reexport safe */ _custodialSignString__WEBPACK_IMPORTED_MODULE_6__.callApiCustodialSignString),
/* harmony export */   "callApiCustodialSignTransaction": () => (/* reexport safe */ _signTransaction__WEBPACK_IMPORTED_MODULE_14__.callApiCustodialSignTransaction),
/* harmony export */   "callApiDeleteTestUser": () => (/* reexport safe */ _deleteTestUser__WEBPACK_IMPORTED_MODULE_7__.callApiDeleteTestUser),
/* harmony export */   "callApiGetAppToken": () => (/* reexport safe */ _appToken__WEBPACK_IMPORTED_MODULE_1__.callApiGetAppToken),
/* harmony export */   "callApiGetConfig": () => (/* reexport safe */ _getConfig__WEBPACK_IMPORTED_MODULE_8__.callApiGetConfig),
/* harmony export */   "callApiGetUser": () => (/* reexport safe */ _getUser__WEBPACK_IMPORTED_MODULE_9__.callApiGetUser),
/* harmony export */   "callApiLoginUserWithToken": () => (/* reexport safe */ _loginUserWithToken__WEBPACK_IMPORTED_MODULE_10__.callApiLoginUserWithToken),
/* harmony export */   "callApiNewUserWithToken": () => (/* reexport safe */ _newUserWithToken__WEBPACK_IMPORTED_MODULE_11__.callApiNewUserWithToken),
/* harmony export */   "callApiPasswordLessSendCode": () => (/* reexport safe */ _passwordLessSendCode__WEBPACK_IMPORTED_MODULE_12__.callApiPasswordLessSendCode),
/* harmony export */   "callApiPasswordLessVerifyCode": () => (/* reexport safe */ _passwordLessVerifyCode__WEBPACK_IMPORTED_MODULE_13__.callApiPasswordLessVerifyCode),
/* harmony export */   "callApiSignTransaction": () => (/* reexport safe */ _signTransaction__WEBPACK_IMPORTED_MODULE_14__.callApiSignTransaction)
/* harmony export */ });
/* harmony import */ var _addPermission__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _appToken__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _canAutoSign__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);
/* harmony import */ var _convertOauth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(28);
/* harmony import */ var _custodialMigrateAccount__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(29);
/* harmony import */ var _custodialNewAccount__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(30);
/* harmony import */ var _custodialSignString__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(31);
/* harmony import */ var _deleteTestUser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(32);
/* harmony import */ var _getConfig__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(33);
/* harmony import */ var _getUser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(34);
/* harmony import */ var _loginUserWithToken__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(35);
/* harmony import */ var _newUserWithToken__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(36);
/* harmony import */ var _passwordLessSendCode__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(37);
/* harmony import */ var _passwordLessVerifyCode__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(38);
/* harmony import */ var _signTransaction__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(39);
















/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiAddPermission": () => (/* binding */ callApiAddPermission)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




/**
 *  Call api account/addPermission
 *  Adds a public key to a user account with a specific permission name
 * The permission name must be one defined in the App Registration record (Which defines its parent permission as well as preventing adding rougue permissions)
 * This feature allows your app to hold private keys locally (for certain actions enabled by the permission) while having the associated public key in the user's account
 * chainAccount = name of the account on the chain - 12/13-digit string on EOS and Ethereum Address on ETH - it may be the same as the account
 * chainNetwork = one of the valid options defined by the system - Ex: 'eos_main', 'eos_jungle', 'eos_kylin", 'ore_main', 'eos_test', etc.
 * */
function callApiAddPermission(_x, _x2) {
  return _callApiAddPermission.apply(this, arguments);
}

function _callApiAddPermission() {
  _callApiAddPermission = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, account, permission, provider, parentPermission, optionalParams, queryParams, response;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.AddPermission;
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKeyOrAccessToken)(oreIdContext, apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params, ['account', 'chainAccount', 'chainNetwork', 'permission', 'publicKey'], apiName);
            account = params.account, permission = params.permission, provider = params.provider, parentPermission = params.parentPermission;
            optionalParams = {};
            if (provider) optionalParams['wallet-type'] = provider;
            if (parentPermission) optionalParams['parent-permission'] = parentPermission;
            queryParams = _objectSpread({
              account: account,
              'chain-account': params.chainAccount,
              'chain-network': params.chainNetwork,
              'public-key': params.publicKey,
              permission: permission
            }, optionalParams);
            _context.next = 10;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Get, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.AddPermission, queryParams, null);

          case 10:
            response = _context.sent;
            return _context.abrupt("return", response);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiAddPermission.apply(this, arguments);
}

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AccountType": () => (/* reexport safe */ _common_models__WEBPACK_IMPORTED_MODULE_2__.AccountType),
/* harmony export */   "ApiEndpoint": () => (/* reexport safe */ _api_models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint),
/* harmony export */   "ApiKeyUsedFor": () => (/* reexport safe */ _common_models__WEBPACK_IMPORTED_MODULE_2__.ApiKeyUsedFor),
/* harmony export */   "AuthProvider": () => (/* reexport safe */ _common_models__WEBPACK_IMPORTED_MODULE_2__.AuthProvider),
/* harmony export */   "ChainNetwork": () => (/* reexport safe */ _common_models__WEBPACK_IMPORTED_MODULE_2__.ChainNetwork),
/* harmony export */   "ChainPlatformType": () => (/* reexport safe */ _common_models__WEBPACK_IMPORTED_MODULE_2__.ChainPlatformType),
/* harmony export */   "ConfigType": () => (/* reexport safe */ _common_models__WEBPACK_IMPORTED_MODULE_2__.ConfigType),
/* harmony export */   "ExternalWalletInterface": () => (/* reexport safe */ _wallets_models__WEBPACK_IMPORTED_MODULE_8__.ExternalWalletInterface),
/* harmony export */   "ExternalWalletType": () => (/* reexport safe */ _common_models__WEBPACK_IMPORTED_MODULE_2__.ExternalWalletType),
/* harmony export */   "LoginProvider": () => (/* reexport safe */ _common_models__WEBPACK_IMPORTED_MODULE_2__.LoginProvider),
/* harmony export */   "RecoverAccountAction": () => (/* reexport safe */ _core_models__WEBPACK_IMPORTED_MODULE_3__.RecoverAccountAction),
/* harmony export */   "RequestType": () => (/* reexport safe */ _api_models__WEBPACK_IMPORTED_MODULE_0__.RequestType),
/* harmony export */   "SignStringMethod": () => (/* reexport safe */ _webWidget_models__WEBPACK_IMPORTED_MODULE_9__.SignStringMethod),
/* harmony export */   "WebWidgetAction": () => (/* reexport safe */ _webWidget_models__WEBPACK_IMPORTED_MODULE_9__.WebWidgetAction),
/* harmony export */   "WidgetVersion": () => (/* reexport safe */ _webWidget_models__WEBPACK_IMPORTED_MODULE_9__.WidgetVersion)
/* harmony export */ });
/* harmony import */ var _api_models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var _auth_models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var _common_models__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
/* harmony import */ var _core_models__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9);
/* harmony import */ var _user_models__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);
/* harmony import */ var _transaction_models__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(11);
/* harmony import */ var _transit_models__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12);
/* harmony import */ var _ual_models__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(13);
/* harmony import */ var _wallets_models__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(14);
/* harmony import */ var _webWidget_models__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(15);











/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiEndpoint": () => (/* binding */ ApiEndpoint),
/* harmony export */   "RequestType": () => (/* binding */ RequestType)
/* harmony export */ });
var RequestType;

(function (RequestType) {
  RequestType["Get"] = "get";
  RequestType["Post"] = "put";
})(RequestType || (RequestType = {}));

var ApiEndpoint;
/** Typical API Response (when no data returned) */

(function (ApiEndpoint) {
  ApiEndpoint["AddPermission"] = "account/add-permission";
  ApiEndpoint["AppToken"] = "app-token";
  ApiEndpoint["CanAutoSign"] = "transaction/can-auto-sign";
  ApiEndpoint["ConvertOauthTokens"] = "account/convert-oauth";
  ApiEndpoint["CustodialMigrateAccount"] = "custodial/migrate-account";
  ApiEndpoint["CustodialNewAccount"] = "custodial/new-user";
  ApiEndpoint["CustodialSignString"] = "custodial/sign-string";
  ApiEndpoint["DeleteTestUser"] = "account/delete-test-user";
  ApiEndpoint["CustodialSign"] = "custodial/sign";
  ApiEndpoint["GetUser"] = "account/user";
  ApiEndpoint["GetConfig"] = "services/config";
  ApiEndpoint["LoginUserWithToken"] = "account/login-user-with-token";
  ApiEndpoint["NewUserWithToken"] = "account/new-user-with-token";
  ApiEndpoint["PasswordLessSendCode"] = "account/login-passwordless-send-code";
  ApiEndpoint["PasswordLessVerifyCode"] = "account/login-passwordless-verify-code";
  ApiEndpoint["TransactionSign"] = "transaction/sign";
  ApiEndpoint["UpdateDelayWalletSetup"] = "account/update-delay-wallet-setup";
})(ApiEndpoint || (ApiEndpoint = {}));

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);


/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AccountType": () => (/* binding */ AccountType),
/* harmony export */   "ApiKeyUsedFor": () => (/* binding */ ApiKeyUsedFor),
/* harmony export */   "AuthProvider": () => (/* binding */ AuthProvider),
/* harmony export */   "ChainNetwork": () => (/* binding */ ChainNetwork),
/* harmony export */   "ChainPlatformType": () => (/* binding */ ChainPlatformType),
/* harmony export */   "ConfigType": () => (/* binding */ ConfigType),
/* harmony export */   "ExternalWalletType": () => (/* binding */ ExternalWalletType),
/* harmony export */   "LoginProvider": () => (/* binding */ LoginProvider)
/* harmony export */ });
var ConfigType;
/** Flavor of chain network */

(function (ConfigType) {
  ConfigType["Chains"] = "chains";
})(ConfigType || (ConfigType = {}));

var ChainPlatformType;
/** Named chain network */

(function (ChainPlatformType) {
  ChainPlatformType["algorand"] = "algorand";
  ChainPlatformType["eos"] = "eos";
  ChainPlatformType["ethereum"] = "ethereum";
  ChainPlatformType["ore"] = "ore";
})(ChainPlatformType || (ChainPlatformType = {}));

var ChainNetwork;
/** Physical structure of account */

(function (ChainNetwork) {
  ChainNetwork["AlgoMain"] = "algo_main";
  ChainNetwork["AlgoBeta"] = "algo_beta";
  ChainNetwork["AlgoTest"] = "algo_test";
  ChainNetwork["AvalancheC_Main"] = "avalanchec_main";
  ChainNetwork["AvalancheC_Fuji"] = "avalanchec_fuji";
  ChainNetwork["DspEosKylin1"] = "kylin-dsp-1.liquidapps.io";
  ChainNetwork["DspEosKylin2"] = "kylin-dsp-2.liquidapps.io";
  ChainNetwork["DspMoonlighting"] = "eos_moon_blockstartdsp_com";
  ChainNetwork["DspMoonlightingTest"] = "eos_moontest_blockstartdsp_com";
  ChainNetwork["DosMain"] = "dos_main";
  ChainNetwork["DosTest"] = "dos_test";
  ChainNetwork["EthMain"] = "eth_main";
  ChainNetwork["EthRopsten"] = "eth_ropsten";
  ChainNetwork["EthRinkeby"] = "eth_rinkeby";
  ChainNetwork["EthGoerli"] = "eth_goerli";
  ChainNetwork["EosMain"] = "eos_main";
  ChainNetwork["EosKylin"] = "eos_kylin";
  ChainNetwork["EosJungle"] = "eos_jungle";
  ChainNetwork["MigrateEosMain"] = "migrate_eos_main";
  ChainNetwork["OreMain"] = "ore_main";
  ChainNetwork["OreTest"] = "ore_test";
  ChainNetwork["PolygonMain"] = "polygon_main";
  ChainNetwork["PolygonMumbai"] = "polygon_mumbai";
  ChainNetwork["TelosMain"] = "telos_main";
  ChainNetwork["TelosTest"] = "telos_test";
  ChainNetwork["TelosEvmMain"] = "telosevm_main";
  ChainNetwork["TelosEvmTest"] = "telosevm_test";
  ChainNetwork["UxMain"] = "ux_main";
  ChainNetwork["WaxMain"] = "wax_main";
  ChainNetwork["WaxTest"] = "wax_test";
})(ChainNetwork || (ChainNetwork = {}));

var AccountType;

(function (AccountType) {
  AccountType["Native"] = "native";
  AccountType["Pending"] = "pending";
  AccountType["VirtualLiquid"] = "liquid";
  AccountType["VirtualNested"] = "nested";
})(AccountType || (AccountType = {}));

var LoginProvider;

(function (LoginProvider) {
  LoginProvider["Custodial"] = "custodial";
  LoginProvider["Apple"] = "apple";
  LoginProvider["Email"] = "email";
  LoginProvider["Facebook"] = "facebook";
  LoginProvider["Github"] = "github";
  LoginProvider["Google"] = "google";
  LoginProvider["Instagram"] = "instagram";
  LoginProvider["Kakao"] = "kakao";
  LoginProvider["Line"] = "line";
  LoginProvider["LinkedIn"] = "linkedin";
  LoginProvider["Phone"] = "phone";
  LoginProvider["Twitch"] = "twitch";
  LoginProvider["Twitter"] = "twitter";
})(LoginProvider || (LoginProvider = {}));

var ExternalWalletType;
/** All auth providers - including OreId login types (eg 'Facebook') and wallets (eg 'Scatter') */

(function (ExternalWalletType) {
  ExternalWalletType["AlgoSigner"] = "algosigner";
  ExternalWalletType["Anchor"] = "anchor";
  ExternalWalletType["Keycat"] = "keycat";
  ExternalWalletType["Ledger"] = "ledger";
  ExternalWalletType["Lynx"] = "lynx";
  ExternalWalletType["Meetone"] = "meetone";
  ExternalWalletType["Metro"] = "metro";
  ExternalWalletType["Portis"] = "portis";
  ExternalWalletType["Scatter"] = "scatter";
  ExternalWalletType["SimpleEos"] = "simpleos";
  ExternalWalletType["TokenPocket"] = "tokenpocket";
  ExternalWalletType["WalletConnect"] = "walletconnect";
  ExternalWalletType["Web3"] = "web3";
  ExternalWalletType["WhaleVault"] = "whalevault";
  ExternalWalletType["Wombat"] = "wombat";
})(ExternalWalletType || (ExternalWalletType = {}));

var AuthProvider;

(function (AuthProvider) {
  AuthProvider["Custodial"] = "custodial";
  AuthProvider["Apple"] = "apple";
  AuthProvider["Email"] = "email";
  AuthProvider["Facebook"] = "facebook";
  AuthProvider["Github"] = "github";
  AuthProvider["Google"] = "google";
  AuthProvider["Instagram"] = "instagram";
  AuthProvider["Kakao"] = "kakao";
  AuthProvider["Line"] = "line";
  AuthProvider["LinkedIn"] = "linkedin";
  AuthProvider["Phone"] = "phone";
  AuthProvider["Twitch"] = "twitch";
  AuthProvider["Twitter"] = "twitter";
  AuthProvider["AlgoSigner"] = "algosigner";
  AuthProvider["Anchor"] = "anchor";
  AuthProvider["Keycat"] = "keycat";
  AuthProvider["Ledger"] = "ledger";
  AuthProvider["Lynx"] = "lynx";
  AuthProvider["Meetone"] = "meetone";
  AuthProvider["Metro"] = "metro";
  AuthProvider["Portis"] = "portis";
  AuthProvider["Scatter"] = "scatter";
  AuthProvider["SimpleEos"] = "simpleos";
  AuthProvider["TokenPocket"] = "tokenpocket";
  AuthProvider["WalletConnect"] = "walletconnect";
  AuthProvider["Web3"] = "web3";
  AuthProvider["WhaleVault"] = "whalevault";
  AuthProvider["Wombat"] = "wombat";
  AuthProvider["OreId"] = "oreid";
})(AuthProvider || (AuthProvider = {}));

var ApiKeyUsedFor;
/** type returned by oreid sevice config endpoint for chains */

(function (ApiKeyUsedFor) {
  ApiKeyUsedFor["AccountMigration"] = "accountMigration";
  ApiKeyUsedFor["Airdrop"] = "airdrop";
  ApiKeyUsedFor["AdminAccess"] = "adminAccess";
  ApiKeyUsedFor["AutoSigning"] = "autoSigning";
  ApiKeyUsedFor["ChangePassword"] = "changePassword";
  ApiKeyUsedFor["CreateUser"] = "createUser";
  ApiKeyUsedFor["ProxySigning"] = "proxySigning";
  ApiKeyUsedFor["TokenFunding"] = "tokenFunding";
})(ApiKeyUsedFor || (ApiKeyUsedFor = {}));

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RecoverAccountAction": () => (/* binding */ RecoverAccountAction)
/* harmony export */ });
// NOTE: We are only using types here - Express library won't be emitted in the build here
var RecoverAccountAction;
/** For creating a new chainAccount in an existing wallet */

(function (RecoverAccountAction) {
  RecoverAccountAction["Republic"] = "republic";
})(RecoverAccountAction || (RecoverAccountAction = {}));

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);


/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);


/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);


/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);


/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExternalWalletInterface": () => (/* binding */ ExternalWalletInterface)
/* harmony export */ });
var ExternalWalletInterface;

(function (ExternalWalletInterface) {
  ExternalWalletInterface["Transit"] = "transit";
  ExternalWalletInterface["Ual"] = "ual";
})(ExternalWalletInterface || (ExternalWalletInterface = {}));

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SignStringMethod": () => (/* binding */ SignStringMethod),
/* harmony export */   "WebWidgetAction": () => (/* binding */ WebWidgetAction),
/* harmony export */   "WidgetVersion": () => (/* binding */ WidgetVersion)
/* harmony export */ });
/* eslint-disable @typescript-eslint/indent */
// IMPORTANT: These types are copied from oreid-service webwidget code

/** version of widget served by server that matches these types */
var WidgetVersion = '1';
/** Subset of OreIdOptions used by widget */

/** Actions supported by widget */
var WebWidgetAction;
/** Alternative method to sign a transaction or string (chain specific) */

(function (WebWidgetAction) {
  WebWidgetAction["Auth"] = "auth";
  WebWidgetAction["Logout"] = "logout";
  WebWidgetAction["NewChainAccount"] = "newChainAccount";
  WebWidgetAction["RecoverAccount"] = "recoverAccount";
  WebWidgetAction["Sign"] = "sign";
  WebWidgetAction["Buy"] = "buy";
  WebWidgetAction["KeyExport"] = "keyExport";
})(WebWidgetAction || (WebWidgetAction = {}));

var SignStringMethod;
/** params for Logout action */

(function (SignStringMethod) {
  SignStringMethod["EthereumPersonalSign"] = "ethereum.personal-sign";
  SignStringMethod["EthereumSignTypedData"] = "ethereum.sign-typed-data";
  SignStringMethod["EthereumSign"] = "ethereum.eth-sign";
})(SignStringMethod || (SignStringMethod = {}));

/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assertHasAccessToken": () => (/* binding */ assertHasAccessToken),
/* harmony export */   "assertHasApiKey": () => (/* binding */ assertHasApiKey),
/* harmony export */   "assertHasApiKeyOrAccessToken": () => (/* binding */ assertHasApiKeyOrAccessToken),
/* harmony export */   "assertHeaderhasRequiredValues": () => (/* binding */ assertHeaderhasRequiredValues),
/* harmony export */   "assertParamsHaveAtLeastOneOfValues": () => (/* binding */ assertParamsHaveAtLeastOneOfValues),
/* harmony export */   "assertParamsHaveOnlyOneOfValues": () => (/* binding */ assertParamsHaveOnlyOneOfValues),
/* harmony export */   "assertParamsHaveRequiredValues": () => (/* binding */ assertParamsHaveRequiredValues),
/* harmony export */   "extractProcessIdFromData": () => (/* binding */ extractProcessIdFromData)
/* harmony export */ });
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* eslint-disable @typescript-eslint/default-param-last */

var isNullOrEmpty = _utils_helpers__WEBPACK_IMPORTED_MODULE_0__["default"].isNullOrEmpty; // ---- API Helper functions

/** check the header of the request for each required param in paramNames */

function assertHeaderhasRequiredValues() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var paramNames = arguments.length > 1 ? arguments[1] : undefined;
  var apiName = arguments.length > 2 ? arguments[2] : undefined;
  var missing = [];
  paramNames.forEach(function (p) {
    if (isNullOrEmpty(params[p])) {
      missing.push(p);
    }
  });

  if (!isNullOrEmpty(missing)) {
    throw new Error("Missing required parameter(s) in request header for API ".concat(apiName, ": ").concat(missing.join(', ')));
  }
}
/** Check that we have an apiKey or accessToken */

function assertHasApiKeyOrAccessToken(oreIdContext, apiName) {
  var _oreIdContext$options;

  if (!oreIdContext.accessToken && !((_oreIdContext$options = oreIdContext.options) !== null && _oreIdContext$options !== void 0 && _oreIdContext$options.apiKey)) {
    throw new Error("Missing required header for API ".concat(apiName, ": Must have a valid user accessToken or options.apiKey"));
  }
}
/** Check that we have an accessToken */

function assertHasAccessToken(oreIdContext, apiName) {
  if (!oreIdContext.accessToken) {
    throw new Error("Missing required header for API ".concat(apiName, ": Must have a valid user accessToken"));
  }
}
/** Check that we have an apiKey */

function assertHasApiKey(oreIdContext, usedFor, apiName) {
  var _oreIdContext$options2;

  if (!((_oreIdContext$options2 = oreIdContext.options) !== null && _oreIdContext$options2 !== void 0 && _oreIdContext$options2.apiKey)) {
    var usedFprMsg = usedFor ? " - with ".concat(usedFor, " right.") : '.';
    throw new Error("Missing required header for API ".concat(apiName, ": Must have an options.apiKey").concat(usedFprMsg));
  }
}
/** Check API params for each required param in paramNames */

function assertParamsHaveRequiredValues() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var paramNames = arguments.length > 1 ? arguments[1] : undefined;
  var apiName = arguments.length > 2 ? arguments[2] : undefined;
  var missing = [];
  paramNames.forEach(function (p) {
    if (isNullOrEmpty(params[p])) {
      missing.push(p);
    }
  });

  if (!isNullOrEmpty(missing)) {
    throw new Error("Missing required parameter(s) for API ".concat(apiName, ": ").concat(missing.join(', ')));
  }
}
/** Check API params - must include at least one of the params in the list */

function assertParamsHaveAtLeastOneOfValues() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var paramNames = arguments.length > 1 ? arguments[1] : undefined;
  var apiName = arguments.length > 2 ? arguments[2] : undefined;
  var matches = paramNames.filter(function (p) {
    return !isNullOrEmpty(params[p]);
  });

  if (matches.length === 0) {
    throw new Error("Missing at least one of these parameter(s) for API ".concat(apiName, ": ").concat(paramNames.join(', ')));
  }
}
/** Check API params - must include one and only one of params in the list */

function assertParamsHaveOnlyOneOfValues() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var paramNames = arguments.length > 1 ? arguments[1] : undefined;
  var apiName = arguments.length > 2 ? arguments[2] : undefined;
  var matches = paramNames.filter(function (p) {
    return !isNullOrEmpty(params[p]);
  });

  if (matches.length > 1) {
    throw new Error("You can only provide one of these parameter(s) for API ".concat(apiName, ": ").concat(paramNames.join(', ')));
  }
}
/** remove processId from data */

function extractProcessIdFromData(data) {
  var processId;

  if (data !== null && data !== void 0 && data.processId) {
    // eslint-disable-next-line prefer-destructuring
    processId = data.processId; // eslint-disable-next-line no-param-reassign

    delete data.processId;
  }

  return {
    data: data,
    processId: processId
  };
}

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Helpers),
/* harmony export */   "splitAt": () => (/* binding */ splitAt)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23);
/* harmony import */ var canonicalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);
/* harmony import */ var canonicalize__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(canonicalize__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jwt_decode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var jwt_decode__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jwt_decode__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);
/* harmony import */ var _common_models__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*
    helper functions
 */





var TRACING = false; // enable when debugging to see detailed outputs
// split a string or array at a given index position

var splitAt = function splitAt(index, dropChars) {
  return function (x) {
    return [x.slice(0, index), x.slice(index + dropChars)];
  };
};

var replaceAll = function replaceAll(inString, search, replacement) {
  return inString.replace(new RegExp(search, 'g'), replacement);
};

var Helpers = /*#__PURE__*/function () {
  function Helpers() {
    _classCallCheck(this, Helpers);
  }

  _createClass(Helpers, null, [{
    key: "isNullOrEmpty",
    value: function isNullOrEmpty(obj) {
      if (obj === undefined) {
        return true;
      }

      if (obj === null) {
        return true;
      } // Check for an empty array too


      if (Array.isArray(obj)) {
        if (obj.length === 0) {
          return true;
        }
      }

      return Object.keys(obj).length === 0 && obj.constructor === Object;
    } // log data

  }, {
    key: "log",
    value: function log(message, data) {
      if (TRACING) {
        // eslint-disable-next-line no-console
        console.log(message, data);
      }
    }
    /** Decodes a JWT token string
     *  If token can't be decoded (e.g. corrupted), returns null */

  }, {
    key: "jwtDecodeSafe",
    value: function jwtDecodeSafe(token) {
      var decoded;

      if (this.isNullOrEmpty(token)) {
        return null;
      }

      try {
        decoded = jwt_decode__WEBPACK_IMPORTED_MODULE_1___default()(token);
      } catch (error) {// throw Error(`Problem decoding or validating JWT token: ${token} error:${error}`)
      }

      return decoded;
    }
    /**  Takes a url string and converts it to an object of {paramNane, paramValue}
     * e.g input: https://xxx?enabled&name=value&name2=val2
     *   returns: { 'enabled': true, 'name':'value', 'name2':'val2' }
     * if the parameter only has a name and no value, then its value is set to 'true'
     * */

  }, {
    key: "parseUrlParams",
    value: function parseUrlParams(fullPath) {
      var urlParamsObject = {};
      var searchString;

      try {
        var urlObject = new URL(fullPath);

        if (urlObject.hash) {
          searchString = urlObject.hash.slice(1); // remove #
        } else {
          searchString = urlObject.search;
        }
      } catch (error) {
        searchString = fullPath; // treat as partial url string E.g. '?param1=value1...'
      }

      var urlParams = new URLSearchParams(searchString);
      urlParams.forEach(function (value, key) {
        urlParamsObject[key] = decodeURIComponent(value) || 'true';
      });
      return urlParamsObject;
    }
    /** Returns Null if parse fails
     *  Reinflates a serialized object (e.g. UInt8Array) if found in JSON
     */

  }, {
    key: "tryParseJSON",
    value: function tryParseJSON(jsonString) {
      var unescape = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var replaceQuotes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var finalJsonString = '';
      if (!jsonString || !Helpers.isAString(jsonString) || jsonString.trim() === '') return null;

      try {
        if (unescape) {
          // eslint-disable-next-line no-param-reassign
          jsonString = decodeURI(jsonString);
        }

        finalJsonString = jsonString;

        if (replaceQuotes) {
          // eslint-disable-next-line quotes
          finalJsonString = replaceAll(jsonString, "'", '"');
          finalJsonString = replaceAll(finalJsonString, '`', '"');
        }

        var o = JSON.parse(finalJsonString, Helpers.jsonParseComplexObjectReviver); // Handle non-exception-throwing cases:
        // Neither JSON.parse(false) or JSON.parse(1234) throw errors, hence the type-checking,
        // but... JSON.parse(null) returns null, and typeof null === "object",
        // so we must check for that, too. Thankfully, null is falsey, so this suffices:

        if (o && _typeof(o) === 'object') {
          return o;
        }
      } catch (error) {// TODO: should log trace this detail: ('error parsing JSON', { jsonString, doubleQuotes, error });
      }

      return null;
    }
    /**
     * The reviver function passed into JSON.parse to implement custom type conversions.
     * If the value is a previously stringified buffer we convert it to a Buffer,
     * If its an object of numbers, we convert to UInt8Array {"0":2,"1":209,"2":8 ...}
     * otherwise return the value
     */

  }, {
    key: "jsonParseComplexObjectReviver",
    value: function jsonParseComplexObjectReviver(key, value) {
      // Convert Buffer
      if (value !== null && _typeof(value) === 'object' && 'type' in value && value.type === 'Buffer' && 'data' in value && Array.isArray(value.data)) {
        return Buffer.from(value.data);
      } // Convert number array to UInt8Array e.g. {"0":2,"1":209,"2":8 ...}


      if (value !== null && _typeof(value) === 'object' && !Array.isArray(value) && '0' in value && Helpers.isANumber(value['0'])) {
        var values = Object.entries(value).map(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              val = _ref2[1];

          return val;
        }); // if array only has 8-bit numbers, convert it to UInt8Array

        if (values.every(function (val) {
          return Helpers.isANumber(val) || val < 256;
        })) {
          return new Uint8Array(values);
        }
      } // Return parsed value without modifying


      return value;
    }
  }, {
    key: "base64DecodeSafe",
    value: function base64DecodeSafe(encodedString) {
      var decoded = {};

      if (this.isNullOrEmpty(encodedString)) {
        return null;
      }

      try {
        decoded = js_base64__WEBPACK_IMPORTED_MODULE_2__.Base64.decode(encodedString); // if decoded value is a stringified JSON object, return the object

        if (Helpers.tryParseJSON(decoded)) {
          decoded = JSON.parse(decoded);
        }
      } catch (error) {
        // logError('Problem decoding base64DecodeSafe:',error);
        return null;
      }

      return decoded;
    }
    /**  Base64 encodes a string
     * if value passed in is an Object or JSON, it will be stringified first
     * if value is null, this function returns null */

  }, {
    key: "base64Encode",
    value: function base64Encode(valueIn) {
      if (!valueIn) return null;
      var value = valueIn;

      if (Helpers.isAnObject(value)) {
        value = JSON.stringify(value);
      }

      return js_base64__WEBPACK_IMPORTED_MODULE_2__.Base64.encode(value);
    }
  }, {
    key: "sleep",
    value: function sleep(ms) {
      return new Promise(function (resolve) {
        return setTimeout(resolve, ms);
      });
    }
  }, {
    key: "createGuid",
    value: function createGuid() {
      return (0,uuid__WEBPACK_IMPORTED_MODULE_4__["default"])();
    }
    /** Typescript Typeguard to verify that the value is in the enumType specified  */

  }, {
    key: "isInEnum",
    value: function isInEnum(enumType, value) {
      return Object.values(enumType).includes(value);
    }
    /** Typescript Typeguard helper to ensure that a string value can be assigned to an Enum type
     *  If a value can't be matched to a valid option in the enum, returns null (or throws if throwIfInvalid = true) */

  }, {
    key: "toEnumValue",
    value: function toEnumValue(e, value) {
      var throwIfInvalid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (this.isNullOrEmpty(value)) return null;

      if (this.isInEnum(e, value)) {
        return value;
      }

      var errMsg = "Value ".concat(JSON.stringify(value), " is not a valid member of enum ").concat(JSON.stringify(e), ".");

      if (throwIfInvalid) {
        throw new Error(errMsg);
      }

      return null;
    }
    /** Parses comma-seperated error_codes from url response
     * Returns: array of error code strings
     * Note: Params is a javascript object parsed from callback URL string */

  }, {
    key: "getErrorCodesFromParams",
    value: function getErrorCodesFromParams(params) {
      var errorCodes;
      var errorString = params.error_code || params.errorCode;
      var errorMessage = params.error_message || params.errorMessage;

      if (errorString) {
        errorCodes = errorString.split(/[/?/$&]/);
      }

      if (errorCodes || errorMessage) {
        errorCodes = errorCodes || [];
        errorCodes.push(errorMessage);
      }

      return errorCodes;
    }
    /** Retrieve values from a url query string and returns an array of them
     *  Also parses error codes returned into an array of errors codes/messages
     */

  }, {
    key: "extractDataFromCallbackUrl",
    value: function extractDataFromCallbackUrl(url) {
      var params = {};

      if (url) {
        params = this.parseUrlParams(url);
        var errors = this.getErrorCodesFromParams(params);
        return _objectSpread(_objectSpread({}, params), {}, {
          errors: errors
        });
      }

      return params;
    }
    /** Call the callback once for each item in the array and await for each to finish in turn */

  }, {
    key: "asyncForEach",
    value: function () {
      var _asyncForEach = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(array, callback) {
        var _index;

        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!Helpers.isNullOrEmpty(array)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return");

              case 2:
                _index = 0;

              case 3:
                if (!(_index < array.length)) {
                  _context.next = 9;
                  break;
                }

                _context.next = 6;
                return callback(array[_index], _index, array);

              case 6:
                _index += 1;
                _context.next = 3;
                break;

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function asyncForEach(_x, _x2) {
        return _asyncForEach.apply(this, arguments);
      }

      return asyncForEach;
    }()
    /** Return a value in a custom claim in a JWT token by using a partial claim name
     *  e.g. function(token, 'appId') => value for claim https://oreid.io/appId */

  }, {
    key: "getClaimFromJwtTokenBySearchString",
    value: function getClaimFromJwtTokenBySearchString(decodedToken, searchString) {
      var value;
      if (!this.isAnObject(decodedToken)) return null; // loop through items in token to find matching string

      Object.keys(decodedToken).forEach(function (item) {
        if (item.includes(searchString)) {
          value = decodedToken[item];
        }
      });
      return value;
    }
    /** get error from inside a network request (Axios Error object) and return it */

  }, {
    key: "getErrorFromAxiosError",
    value: function getErrorFromAxiosError(error) {
      // Browser thre an error during CORS preflight post - See https://github.com/axios/axios/issues/1143
      if ((error === null || error === void 0 ? void 0 : error.message.toLowerCase()) === 'network error') {
        throw new Error('Browser threw a Network Error. This is likely because of CORS error. Make sure that you are not sending an api-key in the header of the request.');
      }

      if ((error === null || error === void 0 ? void 0 : error.code) === 'ECONNREFUSED') {
        throw new Error("Could not connect to ORE ID service. ".concat(error.message, "."));
      }

      if (!Helpers.isAxiosError(error)) {
        return error;
      } // extract error message from Axios Error and return new Error


      var _ref3 = (error === null || error === void 0 ? void 0 : error.response) || {},
          _ref3$data = _ref3.data,
          data = _ref3$data === void 0 ? {} : _ref3$data;

      var message = data.message;
      var errorCodes = this.getErrorCodesFromParams(data); // oreid apis pass back errorCode/errorMessages
      // also handle when a standard error message is thrown

      var errorCodesList = errorCodes && (errorCodes === null || errorCodes === void 0 ? void 0 : errorCodes.length) > 1 ? errorCodes.join(', ') : errorCodes;
      var errorString = errorCodesList || message || 'unknown error';
      return Error(errorString);
    }
  }, {
    key: "isAxiosError",
    value: function isAxiosError(error) {
      return error.isAxiosError !== undefined;
    }
  }, {
    key: "isAString",
    value: function isAString(value) {
      if (!value) {
        return false;
      }

      return typeof value === 'string' || value instanceof String;
    }
  }, {
    key: "isADate",
    value: function isADate(value) {
      return value instanceof Date;
    }
  }, {
    key: "isABoolean",
    value: function isABoolean(value) {
      return typeof value === 'boolean' || value instanceof Boolean;
    }
  }, {
    key: "isANumber",
    value: function isANumber(value) {
      if (Number.isNaN(value)) return false;
      return typeof value === 'number' || value instanceof Number;
    }
  }, {
    key: "isAnObject",
    value: function isAnObject(obj) {
      return obj !== null && _typeof(obj) === 'object';
    }
    /** throw error if invalid provider */

  }, {
    key: "assertValidProvider",
    value: function assertValidProvider(provider) {
      if (Helpers.isInEnum(_common_models__WEBPACK_IMPORTED_MODULE_3__.AuthProvider, provider)) {
        return true;
      }

      throw new Error("Auth provider ".concat(provider, " is not a valid option"));
    }
    /** Convert an AuthProvider to the ExternalWalletType subset
     *  Returns null if can't convert member */

  }, {
    key: "mapAuthProviderToWalletType",
    value: function mapAuthProviderToWalletType(provider) {
      if (!provider) return null;
      return Helpers.toEnumValue(_common_models__WEBPACK_IMPORTED_MODULE_3__.ExternalWalletType, provider);
    }
  }, {
    key: "isCustodial",
    value: function isCustodial(provider) {
      return provider === _common_models__WEBPACK_IMPORTED_MODULE_3__.AuthProvider.Custodial;
    }
  }, {
    key: "isValidEmail",
    value: function isValidEmail(email) {
      if (!email) return false;
      var emailRegex = /^(([^<>()[]\\.,;:\s@]+(\.[^<>()[]\\.,;:\s@]+)*)|(.+))@(([[0-9]{1,3}\[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
      return emailRegex.test(email);
    }
    /** Sort JSON in a deterministic way */

  }, {
    key: "sortJson",
    value: function sortJson(value) {
      if (!value) return value;
      var stringified = canonicalize__WEBPACK_IMPORTED_MODULE_0___default()(value);
      return JSON.parse(stringified);
    }
    /** filter complex values in array down to an array of a single, uniques values
     * e.g. if array = [{value:'A', other}, {value:'B', something}, {value:'A', other}]
     *       => [{value:'A', other}, {value:'B', something}] */

  }, {
    key: "getUniqueValues",
    value: function getUniqueValues(array) {
      return Array.from(new Set(array.map(function (item) {
        return JSON.stringify(item);
      }))).map(function (item) {
        return JSON.parse(item);
      });
    }
    /** Execute a callback function at a given Unix Epoch time */

  }, {
    key: "runAtTime",
    value: function runAtTime(callback, executionEoochTime) {
      var now = Date.now();
      var runAtTime = Math.max(executionEoochTime, now); // if executionEoochTime is in the past, use the current time to run the function immediately

      return setTimeout(callback, runAtTime - now);
    }
    /** whether objects are 'equal' by deep comparing all members */

  }, {
    key: "objectsAreEqual",
    value: function objectsAreEqual(a, b) {
      if (a === b) return true;
      if (_typeof(a) !== 'object' || _typeof(b) !== 'object' || a == null || b == null) return false;
      var keysA = Object.keys(a);
      var keysB = Object.keys(b);
      if (keysA.length !== keysB.length) return false; // eslint-disable-next-line no-restricted-syntax

      for (var _i2 = 0, _keysA = keysA; _i2 < _keysA.length; _i2++) {
        var _key = _keysA[_i2];
        if (!keysB.includes(_key)) return false;

        if (typeof a[_key] === 'function' || typeof b[_key] === 'function') {
          if (a[_key].toString() !== b[_key].toString()) return false;
        } else if (!Helpers.objectsAreEqual(a[_key], b[_key])) return false;
      }

      return true;
    }
  }]);

  return Helpers;
}();

_defineProperty(Helpers, "isInBrowser", typeof window !== 'undefined');



/***/ }),
/* 18 */
/***/ ((module) => {

"use strict";
/* jshint esversion: 6 */
/* jslint node: true */


module.exports = function serialize (object) {
  if (object === null || typeof object !== 'object' || object.toJSON != null) {
    return JSON.stringify(object);
  }

  if (Array.isArray(object)) {
    return '[' + object.reduce((t, cv, ci) => {
      const comma = ci === 0 ? '' : ',';
      const value = cv === undefined || typeof cv === 'symbol' ? null : cv;
      return t + comma + serialize(value);
    }, '') + ']';
  }

  return '{' + Object.keys(object).sort().reduce((t, cv, ci) => {
    if (object[cv] === undefined ||
        typeof object[cv] === 'symbol') {
      return t;
    }
    const comma = t.length === 0 ? '' : ',';
    return t + comma + serialize(cv) + ':' + serialize(object[cv]);
  }, '') + '}';
};


/***/ }),
/* 19 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var base64_url_decode = __webpack_require__(20);

function InvalidTokenError(message) {
  this.message = message;
}

InvalidTokenError.prototype = new Error();
InvalidTokenError.prototype.name = 'InvalidTokenError';

module.exports = function (token,options) {
  if (typeof token !== 'string') {
    throw new InvalidTokenError('Invalid token specified');
  }

  options = options || {};
  var pos = options.header === true ? 0 : 1;
  try {
    return JSON.parse(base64_url_decode(token.split('.')[pos]));
  } catch (e) {
    throw new InvalidTokenError('Invalid token specified: ' + e.message);
  }
};

module.exports.InvalidTokenError = InvalidTokenError;


/***/ }),
/* 20 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var atob = __webpack_require__(21);

function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).replace(/(.)/g, function (m, p) {
    var code = p.charCodeAt(0).toString(16).toUpperCase();
    if (code.length < 2) {
      code = '0' + code;
    }
    return '%' + code;
  }));
}

module.exports = function(str) {
  var output = str.replace(/-/g, "+").replace(/_/g, "/");
  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += "==";
      break;
    case 3:
      output += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }

  try{
    return b64DecodeUnicode(output);
  } catch (err) {
    return atob(output);
  }
};


/***/ }),
/* 21 */
/***/ ((module) => {

/**
 * The code was extracted from:
 * https://github.com/davidchambers/Base64.js
 */

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function InvalidCharacterError(message) {
  this.message = message;
}

InvalidCharacterError.prototype = new Error();
InvalidCharacterError.prototype.name = 'InvalidCharacterError';

function polyfill (input) {
  var str = String(input).replace(/=+$/, '');
  if (str.length % 4 == 1) {
    throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
  }
  for (
    // initialize result and counters
    var bc = 0, bs, buffer, idx = 0, output = '';
    // get next character
    buffer = str.charAt(idx++);
    // character found in table? initialize bit storage and add its ascii value;
    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
      // and if not first of each 4 characters,
      // convert the first 8 bits to one ascii character
      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
  ) {
    // try to find character in table (0-63, not found => -1)
    buffer = chars.indexOf(buffer);
  }
  return output;
}


module.exports = typeof window !== 'undefined' && window.atob && window.atob.bind(window) || polyfill;


/***/ }),
/* 22 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Base64": () => (/* binding */ gBase64),
/* harmony export */   "VERSION": () => (/* binding */ VERSION),
/* harmony export */   "atob": () => (/* binding */ _atob),
/* harmony export */   "atobPolyfill": () => (/* binding */ atobPolyfill),
/* harmony export */   "btoa": () => (/* binding */ _btoa),
/* harmony export */   "btoaPolyfill": () => (/* binding */ btoaPolyfill),
/* harmony export */   "btou": () => (/* binding */ btou),
/* harmony export */   "decode": () => (/* binding */ decode),
/* harmony export */   "encode": () => (/* binding */ encode),
/* harmony export */   "encodeURI": () => (/* binding */ encodeURI),
/* harmony export */   "encodeURL": () => (/* binding */ encodeURI),
/* harmony export */   "extendBuiltins": () => (/* binding */ extendBuiltins),
/* harmony export */   "extendString": () => (/* binding */ extendString),
/* harmony export */   "extendUint8Array": () => (/* binding */ extendUint8Array),
/* harmony export */   "fromBase64": () => (/* binding */ decode),
/* harmony export */   "fromUint8Array": () => (/* binding */ fromUint8Array),
/* harmony export */   "isValid": () => (/* binding */ isValid),
/* harmony export */   "toBase64": () => (/* binding */ encode),
/* harmony export */   "toUint8Array": () => (/* binding */ toUint8Array),
/* harmony export */   "utob": () => (/* binding */ utob),
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
/**
 *  base64.ts
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 *
 * @author Dan Kogai (https://github.com/dankogai)
 */
const version = '3.7.2';
/**
 * @deprecated use lowercase `version`.
 */
const VERSION = version;
const _hasatob = typeof atob === 'function';
const _hasbtoa = typeof btoa === 'function';
const _hasBuffer = typeof Buffer === 'function';
const _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
const _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
const b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
const b64chs = Array.prototype.slice.call(b64ch);
const b64tab = ((a) => {
    let tab = {};
    a.forEach((c, i) => tab[c] = i);
    return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === 'function'
    ? Uint8Array.from.bind(Uint8Array)
    : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
const _mkUriSafe = (src) => src
    .replace(/=/g, '').replace(/[+\/]/g, (m0) => m0 == '+' ? '-' : '_');
const _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, '');
/**
 * polyfill version of `btoa`
 */
const btoaPolyfill = (bin) => {
    // console.log('polyfilled');
    let u32, c0, c1, c2, asc = '';
    const pad = bin.length % 3;
    for (let i = 0; i < bin.length;) {
        if ((c0 = bin.charCodeAt(i++)) > 255 ||
            (c1 = bin.charCodeAt(i++)) > 255 ||
            (c2 = bin.charCodeAt(i++)) > 255)
            throw new TypeError('invalid character found');
        u32 = (c0 << 16) | (c1 << 8) | c2;
        asc += b64chs[u32 >> 18 & 63]
            + b64chs[u32 >> 12 & 63]
            + b64chs[u32 >> 6 & 63]
            + b64chs[u32 & 63];
    }
    return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
/**
 * does what `window.btoa` of web browsers do.
 * @param {String} bin binary string
 * @returns {string} Base64-encoded string
 */
const _btoa = _hasbtoa ? (bin) => btoa(bin)
    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')
        : btoaPolyfill;
const _fromUint8Array = _hasBuffer
    ? (u8a) => Buffer.from(u8a).toString('base64')
    : (u8a) => {
        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
        const maxargs = 0x1000;
        let strs = [];
        for (let i = 0, l = u8a.length; i < l; i += maxargs) {
            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
        }
        return _btoa(strs.join(''));
    };
/**
 * converts a Uint8Array to a Base64 string.
 * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5
 * @returns {string} Base64 string
 */
const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const utob = (src: string) => unescape(encodeURIComponent(src));
// reverting good old fationed regexp
const cb_utob = (c) => {
    if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 0x80 ? c
            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))
                + _fromCC(0x80 | (cc & 0x3f)))
                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))
                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                    + _fromCC(0x80 | (cc & 0x3f)));
    }
    else {
        var cc = 0x10000
            + (c.charCodeAt(0) - 0xD800) * 0x400
            + (c.charCodeAt(1) - 0xDC00);
        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))
            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))
            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
            + _fromCC(0x80 | (cc & 0x3f)));
    }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-8 string
 * @returns {string} UTF-16 string
 */
const utob = (u) => u.replace(re_utob, cb_utob);
//
const _encode = _hasBuffer
    ? (s) => Buffer.from(s, 'utf8').toString('base64')
    : _TE
        ? (s) => _fromUint8Array(_TE.encode(s))
        : (s) => _btoa(utob(s));
/**
 * converts a UTF-8-encoded string to a Base64 string.
 * @param {boolean} [urlsafe] if `true` make the result URL-safe
 * @returns {string} Base64 string
 */
const encode = (src, urlsafe = false) => urlsafe
    ? _mkUriSafe(_encode(src))
    : _encode(src);
/**
 * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.
 * @returns {string} Base64 string
 */
const encodeURI = (src) => encode(src, true);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const btou = (src: string) => decodeURIComponent(escape(src));
// reverting good old fationed regexp
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc) => {
    switch (cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                | ((0x3f & cccc.charCodeAt(1)) << 12)
                | ((0x3f & cccc.charCodeAt(2)) << 6)
                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;
            return (_fromCC((offset >>> 10) + 0xD800)
                + _fromCC((offset & 0x3FF) + 0xDC00));
        case 3:
            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)
                | ((0x3f & cccc.charCodeAt(1)) << 6)
                | (0x3f & cccc.charCodeAt(2)));
        default:
            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)
                | (0x3f & cccc.charCodeAt(1)));
    }
};
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-16 string
 * @returns {string} UTF-8 string
 */
const btou = (b) => b.replace(re_btou, cb_btou);
/**
 * polyfill version of `atob`
 */
const atobPolyfill = (asc) => {
    // console.log('polyfilled');
    asc = asc.replace(/\s+/g, '');
    if (!b64re.test(asc))
        throw new TypeError('malformed base64.');
    asc += '=='.slice(2 - (asc.length & 3));
    let u24, bin = '', r1, r2;
    for (let i = 0; i < asc.length;) {
        u24 = b64tab[asc.charAt(i++)] << 18
            | b64tab[asc.charAt(i++)] << 12
            | (r1 = b64tab[asc.charAt(i++)]) << 6
            | (r2 = b64tab[asc.charAt(i++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)
            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)
                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
    }
    return bin;
};
/**
 * does what `window.atob` of web browsers do.
 * @param {String} asc Base64-encoded string
 * @returns {string} binary string
 */
const _atob = _hasatob ? (asc) => atob(_tidyB64(asc))
    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')
        : atobPolyfill;
//
const _toUint8Array = _hasBuffer
    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))
    : (a) => _U8Afrom(_atob(a), c => c.charCodeAt(0));
/**
 * converts a Base64 string to a Uint8Array.
 */
const toUint8Array = (a) => _toUint8Array(_unURI(a));
//
const _decode = _hasBuffer
    ? (a) => Buffer.from(a, 'base64').toString('utf8')
    : _TD
        ? (a) => _TD.decode(_toUint8Array(a))
        : (a) => btou(_atob(a));
const _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));
/**
 * converts a Base64 string to a UTF-8 string.
 * @param {String} src Base64 string.  Both normal and URL-safe are supported
 * @returns {string} UTF-8 string
 */
const decode = (src) => _decode(_unURI(src));
/**
 * check if a value is a valid Base64 string
 * @param {String} src a value to check
  */
const isValid = (src) => {
    if (typeof src !== 'string')
        return false;
    const s = src.replace(/\s+/g, '').replace(/={0,2}$/, '');
    return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
//
const _noEnum = (v) => {
    return {
        value: v, enumerable: false, writable: true, configurable: true
    };
};
/**
 * extend String.prototype with relevant methods
 */
const extendString = function () {
    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
    _add('fromBase64', function () { return decode(this); });
    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });
    _add('toBase64URI', function () { return encode(this, true); });
    _add('toBase64URL', function () { return encode(this, true); });
    _add('toUint8Array', function () { return toUint8Array(this); });
};
/**
 * extend Uint8Array.prototype with relevant methods
 */
const extendUint8Array = function () {
    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });
    _add('toBase64URI', function () { return fromUint8Array(this, true); });
    _add('toBase64URL', function () { return fromUint8Array(this, true); });
};
/**
 * extend Builtin prototypes with relevant methods
 */
const extendBuiltins = () => {
    extendString();
    extendUint8Array();
};
const gBase64 = {
    version: version,
    VERSION: VERSION,
    atob: _atob,
    atobPolyfill: atobPolyfill,
    btoa: _btoa,
    btoaPolyfill: btoaPolyfill,
    fromBase64: decode,
    toBase64: encode,
    encode: encode,
    encodeURI: encodeURI,
    encodeURL: encodeURI,
    utob: utob,
    btou: btou,
    decode: decode,
    isValid: isValid,
    fromUint8Array: fromUint8Array,
    toUint8Array: toUint8Array,
    extendString: extendString,
    extendUint8Array: extendUint8Array,
    extendBuiltins: extendBuiltins,
};
// makecjs:CUT //




















// and finally,



/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony import */ var _bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);



function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }

  options = options || {};
  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || (0,_bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
// find the complete implementation of crypto (msCrypto) on IE11.
var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);
var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

function rng() {
  if (!getRandomValues) {
    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
  }

  return getRandomValues(rnds8);
}

/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4

  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bytesToUuid);

/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiGetAppToken": () => (/* binding */ callApiGetAppToken)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }





/**
 *  Call api app-token to get a new appAccessToken
 *  An apiKey is always required to call this endpoint
 *  Returns: appAccessToken
 * */
function callApiGetAppToken(_x, _x2) {
  return _callApiGetAppToken.apply(this, arguments);
}

function _callApiGetAppToken() {
  _callApiGetAppToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, appAccessTokenMetadata, _yield$oreIdContext$c, appAccessToken;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.AppToken;
            appAccessTokenMetadata = params.appAccessTokenMetadata; // to use appAccessTokenMetadata, we require a apiKey with 'createUser' right

            if (!_utils_helpers__WEBPACK_IMPORTED_MODULE_2__["default"].isNullOrEmpty(appAccessTokenMetadata)) {
              (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKey)(oreIdContext, _models__WEBPACK_IMPORTED_MODULE_0__.ApiKeyUsedFor.CreateUser, apiName);
            } else {
              (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKey)(oreIdContext, null, apiName);
            }

            _context.next = 5;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Post, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.AppToken, appAccessTokenMetadata, null);

          case 5:
            _yield$oreIdContext$c = _context.sent;
            appAccessToken = _yield$oreIdContext$c.appAccessToken;
            return _context.abrupt("return", appAccessToken);

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiGetAppToken.apply(this, arguments);
}

/***/ }),
/* 27 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiCanAutosignTransaction": () => (/* binding */ callApiCanAutosignTransaction)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }





/** Call api transaction/can-auto-sign
 * Requires a apiKey with the autoSign right
 * Returns: true if transaction provided can be signed using the signTransaction(autosign:true)
 * */
function callApiCanAutosignTransaction(_x, _x2) {
  return _callApiCanAutosignTransaction.apply(this, arguments);
}

function _callApiCanAutosignTransaction() {
  _callApiCanAutosignTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, account, chainAccount, chainNetwork, signedTransaction, transaction, transactionChainAccount, body, results;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.CanAutoSign;
            account = params.account, chainAccount = params.chainAccount, chainNetwork = params.chainNetwork, signedTransaction = params.signedTransaction, transaction = params.transaction, transactionChainAccount = params.transactionChainAccount;
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKey)(oreIdContext, _models__WEBPACK_IMPORTED_MODULE_0__.ApiKeyUsedFor.AutoSigning, apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params, ['account', 'chainNetwork', 'chainAccount'], apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveOnlyOneOfValues)(params, ['transaction', 'signedTransaction'], apiName);
            body = {
              account: account,
              chain_account: chainAccount,
              chain_network: chainNetwork
            };
            if (transaction) body.transaction = _utils_helpers__WEBPACK_IMPORTED_MODULE_2__["default"].base64Encode(transaction);
            if (signedTransaction) body.signed_transaction = _utils_helpers__WEBPACK_IMPORTED_MODULE_2__["default"].base64Encode(signedTransaction);
            if (transaction) body.transaction_chain_acccount = transactionChainAccount;
            _context.next = 11;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Post, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.CanAutoSign, body, null);

          case 11:
            results = _context.sent;
            return _context.abrupt("return", results);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiCanAutosignTransaction.apply(this, arguments);
}

/***/ }),
/* 28 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiConvertOauthTokens": () => (/* binding */ callApiConvertOauthTokens)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




/** Call the account/convert-oauth api
 * Converts OAuth tokens from some 3rd-party source to OREID Oauth tokens
 * The third-party (e.g. Auth0 or Google) must be registered in the AppRegistration.oauthSettings
 * Returns: OreId issued accessToken and idToken
 * */
function callApiConvertOauthTokens(_x, _x2) {
  return _callApiConvertOauthTokens.apply(this, arguments);
}

function _callApiConvertOauthTokens() {
  _callApiConvertOauthTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, accessToken, idToken, body, results;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.ConvertOauthTokens;
            accessToken = params.accessToken, idToken = params.idToken;
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKeyOrAccessToken)(oreIdContext, apiName); // assertParamsHaveOnlyOneOfValues(params, ['accessToken', 'idToken'], apiName)

            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params, ['idToken'], apiName);
            body = {};
            if (accessToken) body.access_token = accessToken;
            if (idToken) body.id_token = idToken;
            _context.next = 9;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Post, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.ConvertOauthTokens, body, null);

          case 9:
            results = _context.sent;
            return _context.abrupt("return", results);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiConvertOauthTokens.apply(this, arguments);
}

/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiCustodialMigrateAccount": () => (/* binding */ callApiCustodialMigrateAccount)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




/** Call the custodial/migrate-user api
 * Converts a user account to a new account type
 * Usually used to convert a virtal account to a native account (on-chain)
 * .. and expects the account to be a managed (custodial) account
 * Requires a wallet password (userPassword) on behalf of the user
 * Requires an apiKey with the accountMigration right
 * Returns: account name of migrated account
 *       OR errorCode, errorMessage, and message if any problems */
function callApiCustodialMigrateAccount(_x, _x2) {
  return _callApiCustodialMigrateAccount.apply(this, arguments);
}

function _callApiCustodialMigrateAccount() {
  _callApiCustodialMigrateAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, account, chainAccount, chainNetwork, toType, userPassword, userPasswordEncrypted, body, results;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.CustodialMigrateAccount;
            account = params.account, chainAccount = params.chainAccount, chainNetwork = params.chainNetwork, toType = params.toType, userPassword = params.userPassword, userPasswordEncrypted = params.userPasswordEncrypted;
            body = {
              account: account,
              chain_account: chainAccount,
              chain_network: chainNetwork,
              to_type: toType,
              user_password: userPassword,
              user_password_encrypted: userPasswordEncrypted
            };
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKey)(oreIdContext, _models__WEBPACK_IMPORTED_MODULE_0__.ApiKeyUsedFor.AccountMigration, apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params, ['account', 'chainAccount', 'chainNetwork', 'toType'], apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveOnlyOneOfValues)(params, ['user_password', 'user_password_encrypted'], apiName);
            _context.next = 8;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Post, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.CustodialMigrateAccount, body, null);

          case 8:
            results = _context.sent;
            return _context.abrupt("return", results);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiCustodialMigrateAccount.apply(this, arguments);
}

/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiCustodialNewAccount": () => (/* binding */ callApiCustodialNewAccount)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




/** Call the custodial/new-user api
 * Create a new user account that is managed by your app
 * Requires a wallet password (userPassword) on behalf of the user
 * Requires an apiKey with the createUser right
 * Returns: accountName of newly created account
 *       OR errorCode, errorMessage, and message if any problems */
function callApiCustodialNewAccount(_x, _x2) {
  return _callApiCustodialNewAccount.apply(this, arguments);
}

function _callApiCustodialNewAccount() {
  _callApiCustodialNewAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, accountType, delayWalletSetup, email, emailVerified, idToken, isTestUser, name, picture, phone, phoneVerified, userName, userPassword, body, results;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.CustodialNewAccount;
            accountType = params.accountType, delayWalletSetup = params.delayWalletSetup, email = params.email, emailVerified = params.emailVerified, idToken = params.idToken, isTestUser = params.isTestUser, name = params.name, picture = params.picture, phone = params.phone, phoneVerified = params.phoneVerified, userName = params.userName, userPassword = params.userPassword;
            body = {
              account_type: accountType,
              delay_wallet_setup: delayWalletSetup,
              email: email,
              email_verified: emailVerified,
              id_token: idToken,
              is_test_user: isTestUser,
              name: name,
              phone: phone,
              phone_verified: phoneVerified,
              picture: picture,
              user_name: userName,
              user_password: userPassword
            };
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKey)(oreIdContext, _models__WEBPACK_IMPORTED_MODULE_0__.ApiKeyUsedFor.CreateUser, apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params, ['accountType'], apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveOnlyOneOfValues)(params, ['user_password', 'user_password_encrypted', 'user_password_encrypted_backup'], apiName);

            if (!(!idToken && !(email && name))) {
              _context.next = 8;
              break;
            }

            throw new Error("Missing required parameter(s) for API ".concat(apiName, ": Must include email AND name or an idToken"));

          case 8:
            _context.next = 10;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Post, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.CustodialNewAccount, body, null);

          case 10:
            results = _context.sent;
            return _context.abrupt("return", results);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiCustodialNewAccount.apply(this, arguments);
}

/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiCustodialSignString": () => (/* binding */ callApiCustodialSignString)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




/** Call the custoidal/sign-string api
 * Signs a string (aka message) using the user's private key
 * Requires a wallet password (userPassword) on behalf of the user
 * Requires an apiKey with the createUser right
 * Optional: options - designates the method of signing to perform (e.g. ethereum.eth_sign, ethereum.eth_signTypedData) and related metadata (e.g. ERC712 types)
 * Returns: signature
 *       OR errorCode, errorMessage, and message if any problems */
function callApiCustodialSignString(_x, _x2) {
  return _callApiCustodialSignString.apply(this, arguments);
}

function _callApiCustodialSignString() {
  _callApiCustodialSignString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, chainAccount, chainNetwork, permission, stringToSign, signMethod, userPassword, body, results;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.CustodialSignString;
            chainAccount = params.chainAccount, chainNetwork = params.chainNetwork, permission = params.permission, stringToSign = params.stringToSign, signMethod = params.signMethod, userPassword = params.userPassword;
            body = {
              chain_account: chainAccount,
              chain_network: chainNetwork,
              permission: permission,
              string_to_sign: stringToSign,
              user_password: userPassword
            };
            if (signMethod) body.sign_method = signMethod;
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKey)(oreIdContext, _models__WEBPACK_IMPORTED_MODULE_0__.ApiKeyUsedFor.ProxySigning, apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params, ['chainAccount', 'chainNetwork', 'stringToSign'], apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveOnlyOneOfValues)(params, ['user_password', 'user_password_encrypted'], apiName);
            _context.next = 9;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Post, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.CustodialSignString, body, null);

          case 9:
            results = _context.sent;
            return _context.abrupt("return", results);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiCustodialSignString.apply(this, arguments);
}

/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiDeleteTestUser": () => (/* binding */ callApiDeleteTestUser)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




/**
 *  Delete a user specifically created as a test user via api account/delete-test-user endpoint
 *  Returns: success or errorCode, errorMessage, if any problems
 */
function callApiDeleteTestUser(_x, _x2) {
  return _callApiDeleteTestUser.apply(this, arguments);
}

function _callApiDeleteTestUser() {
  _callApiDeleteTestUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, account, body, response, _extractProcessIdFrom, data;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.DeleteTestUser;
            account = params.account;
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKeyOrAccessToken)(oreIdContext, apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params, ['account'], apiName);
            body = {
              account: account
            };
            _context.next = 7;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Post, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.DeleteTestUser, body);

          case 7:
            response = _context.sent;
            _extractProcessIdFrom = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.extractProcessIdFromData)(response), data = _extractProcessIdFrom.data;
            return _context.abrupt("return", data);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiDeleteTestUser.apply(this, arguments);
}

/***/ }),
/* 33 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiGetConfig": () => (/* binding */ callApiGetConfig)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




/**
 *  Call api services/config to get configuration values of a specific type
 *  Returns: for configType:Config.Chains, returns array of SettingChainNetwork objects for all chains suported by the service
 * */
function callApiGetConfig(_x, _x2) {
  return _callApiGetConfig.apply(this, arguments);
}

function _callApiGetConfig() {
  _callApiGetConfig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, configType, queryParams, _yield$oreIdContext$c, values;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.GetConfig;
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKeyOrAccessToken)(oreIdContext, apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params, ['configType'], apiName);
            configType = params.configType;
            queryParams = {
              type: configType
            };
            _context.next = 7;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Get, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.GetConfig, queryParams, null);

          case 7:
            _yield$oreIdContext$c = _context.sent;
            values = _yield$oreIdContext$c.values;
            return _context.abrupt("return", values);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiGetConfig.apply(this, arguments);
}

/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiGetUser": () => (/* binding */ callApiGetUser)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




/**
 *  Fetch user from api account/user endpoint
 *  Returns: UserSourceData for specified account
 */
function callApiGetUser(_x, _x2) {
  return _callApiGetUser.apply(this, arguments);
}

function _callApiGetUser() {
  _callApiGetUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, account, queryParams, response, _extractProcessIdFrom, data;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.GetUser;
            account = params.account;
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKeyOrAccessToken)(oreIdContext, apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params, ['account'], apiName);
            queryParams = {
              account: account
            };
            _context.next = 7;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Get, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.GetUser, queryParams);

          case 7:
            response = _context.sent;
            _extractProcessIdFrom = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.extractProcessIdFromData)(response), data = _extractProcessIdFrom.data;
            return _context.abrupt("return", data);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiGetUser.apply(this, arguments);
}

/***/ }),
/* 35 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiLoginUserWithToken": () => (/* binding */ callApiLoginUserWithToken)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }





/** Call api account/login-user-with-token
 * Converts OAuth accesstoken or idToken from some 3rd-party source to OREID Oauth accessTokens
 * The third-party (e.g. Auth0 or Google) must be registered in the AppRegistration.oauthSettings
 * If a user does not curently exist that matches the info in the incoming idToken, a new OreID user and account is created
 * Requires either:
 *  1) a valid idToken (needs no accessToken or apiKey in header)
 *  2) an OreId issued JWT accessToken (needs no accessToken or apiKey in header)
 *  3) a 3rd-party accessToken (usually not a JWT) and provider param (e.g. 'google') - Requires api-key in header
 * Returns: OreId issued accessToken and user's account name (if new account created, this is a new account name)
 * */
function callApiLoginUserWithToken(_x, _x2) {
  return _callApiLoginUserWithToken.apply(this, arguments);
}

function _callApiLoginUserWithToken() {
  _callApiLoginUserWithToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, accessToken, idToken, provider, body, results;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.LoginUserWithToken;
            accessToken = params.accessToken, idToken = params.idToken, provider = params.provider; // This function does not require authentication (api-key or accessToken) in request header - when using a signed JWT accessToken or idToken
            // It does require an api-key when using a non-JWT (third-party) accessToken

            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveOnlyOneOfValues)(params, ['accessToken', 'idToken'], apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveOnlyOneOfValues)(params, ['idToken', 'provider'], apiName);

            if (accessToken && !_utils_helpers__WEBPACK_IMPORTED_MODULE_2__["default"].jwtDecodeSafe(accessToken)) {
              (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params, ['provider'], apiName); // if we have non-JWT access token, we must include an api-key

              (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKey)(oreIdContext, null, 'login-user-with-token');
            }

            body = {};

            if (idToken) {
              body.id_token = idToken;
            } else {
              body.access_token = accessToken;
              body.provider = provider;
            }

            _context.next = 9;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Post, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.LoginUserWithToken, body, null // an api key is NOT required to call this api endpoint
            );

          case 9:
            results = _context.sent;
            return _context.abrupt("return", results);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiLoginUserWithToken.apply(this, arguments);
}

/***/ }),
/* 36 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiNewUserWithToken": () => (/* binding */ callApiNewUserWithToken)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




/** Call api account/new-user-with-token
 * Converts OAuth accesstoken or idToken from some 3rd-party source to OREID Oauth accessTokens
 * The third-party (e.g. Auth0 or Google) must be registered in the AppRegistration.oauthSettings
 * If a user does not curently exist that matches the info in the incoming idToken, a new OreID user and account is created
 * Requires ether:
 *  1) a valid idToken (needs no accessToken or apiKey in header)
 *  2) a 3rd-party accessToken (usually not a JWT) and provider param (e.g. 'google') - Requires api-key in header
 * Set isTestUser to true to create a test user - a test user can be deleted using user.deleteTestUser() - this is helpful for testing
 * Returns: OreId issued accessToken and user's account name (if new account created, this is a new account name)
 * */
function callApiNewUserWithToken(_x, _x2) {
  return _callApiNewUserWithToken.apply(this, arguments);
}

function _callApiNewUserWithToken() {
  _callApiNewUserWithToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, accessToken, delayWalletSetup, isTestUser, idToken, provider, body, results;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.NewUserWithToken;
            accessToken = params.accessToken, delayWalletSetup = params.delayWalletSetup, isTestUser = params.isTestUser, idToken = params.idToken, provider = params.provider; // This function does not require authentication of any kind - since it allows auth by using any accessToken or idToken

            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveAtLeastOneOfValues)(params, ['idToken', 'accessToken'], apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveOnlyOneOfValues)(params, ['idToken', 'provider'], apiName); // if idToken, then no provider should be given

            if (accessToken) {
              (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params, ['accessToken', 'provider'], apiName); // if we have a 3rd party access token, we must include an api-key

              (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKey)(oreIdContext, null, 'new-user-with-token');
            }

            body = {};

            if (idToken) {
              body.id_token = idToken;
            } else {
              body.access_token = accessToken;
              body.provider = provider;
            }

            if (isTestUser === true) body.is_test_user = true;
            if (delayWalletSetup === true) body.delay_wallet_setup = true;
            _context.next = 11;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Post, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.NewUserWithToken, body, null // an api key is NOT required to call this api endpoint
            );

          case 11:
            results = _context.sent;
            return _context.abrupt("return", results);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiNewUserWithToken.apply(this, arguments);
}

/***/ }),
/* 37 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiPasswordLessSendCode": () => (/* binding */ callApiPasswordLessSendCode)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




/**
 *  Call api account/login-passwordless-send-code
 *  Returns { success: true } if verification code is sent to email/phone
 * */
function callApiPasswordLessSendCode(_x, _x2) {
  return _callApiPasswordLessSendCode.apply(this, arguments);
}

function _callApiPasswordLessSendCode() {
  _callApiPasswordLessSendCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, email, phone, provider, queryParams, response;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.PasswordLessSendCode;
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKeyOrAccessToken)(oreIdContext, apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params, ['provider'], apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveOnlyOneOfValues)(params, ['email', 'phone'], apiName);
            email = params.email, phone = params.phone, provider = params.provider;
            queryParams = {
              provider: provider
            };
            if (email) queryParams.email = encodeURIComponent(email);
            if (phone) queryParams.phone = encodeURIComponent(phone); // if user passes in +12103334444, the plus sign needs to be URL encoded

            _context.next = 10;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Get, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.PasswordLessSendCode, queryParams, null);

          case 10:
            response = _context.sent;
            return _context.abrupt("return", response);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiPasswordLessSendCode.apply(this, arguments);
}

/***/ }),
/* 38 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiPasswordLessVerifyCode": () => (/* binding */ callApiPasswordLessVerifyCode)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




/**
 *  Call api account/login-passwordless-verify-code
 *  Returns { success: true } if code is verified, throws if code/verification fails
 * */
function callApiPasswordLessVerifyCode(_x, _x2) {
  return _callApiPasswordLessVerifyCode.apply(this, arguments);
}

function _callApiPasswordLessVerifyCode() {
  _callApiPasswordLessVerifyCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, code, email, phone, provider, queryParams, response;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.PasswordLessVerifyCode;
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKeyOrAccessToken)(oreIdContext, apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params, ['code', 'provider'], apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveOnlyOneOfValues)(params, ['email', 'phone'], apiName);
            code = params.code, email = params.email, phone = params.phone, provider = params.provider;
            queryParams = {
              code: code,
              provider: provider
            };
            if (email) queryParams.email = encodeURIComponent(email);
            if (phone) queryParams.phone = encodeURIComponent(phone); // if user passes in +12103334444, the plus sign needs to be URL encoded

            _context.next = 10;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Get, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.PasswordLessVerifyCode, queryParams, null);

          case 10:
            response = _context.sent;
            return _context.abrupt("return", response);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiPasswordLessVerifyCode.apply(this, arguments);
}

/***/ }),
/* 39 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiCustodialSignTransaction": () => (/* binding */ callApiCustodialSignTransaction),
/* harmony export */   "callApiSignTransaction": () => (/* binding */ callApiSignTransaction)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var _excluded = ["signed_transaction", "transaction_id"];

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





/** Compose the API body params for calling signTransaction */
function composeSignBodyFromTransactionData(params) {
  var _params$transactionDa;

  var _ref = params.transactionData || {},
      account = _ref.account,
      chainAccount = _ref.chainAccount,
      chainNetwork = _ref.chainNetwork,
      expireSeconds = _ref.expireSeconds,
      signedTransactionParam = _ref.signedTransaction,
      transactionParam = _ref.transaction,
      transactionChainAccount = _ref.transactionChainAccount,
      transactionRecordId = _ref.transactionRecordId;

  var _ref2 = ((_params$transactionDa = params.transactionData) === null || _params$transactionDa === void 0 ? void 0 : _params$transactionDa.signOptions) || {},
      allowChainAccountSelection = _ref2.allowChainAccountSelection,
      broadcast = _ref2.broadcast,
      generateAutoSignCredential = _ref2.generateAutoSignCredential,
      multiSigChainAccounts = _ref2.multiSigChainAccounts,
      returnSignedTransaction = _ref2.returnSignedTransaction,
      userPassword = _ref2.userPassword,
      userPasswordEncrypted = _ref2.userPasswordEncrypted;

  var autoSign = params.autoSign;
  var body = {
    account: account,
    broadcast: broadcast,
    chain_account: chainAccount,
    chain_network: chainNetwork
  };
  if (allowChainAccountSelection) body.allow_chain_account_selection = allowChainAccountSelection;
  if (autoSign) body.auto_sign = autoSign;
  if (expireSeconds) body.expire_seconds = expireSeconds;
  if (generateAutoSignCredential) body.generate_auto_sign_credential = generateAutoSignCredential;
  if (multiSigChainAccounts) body.multisig_chain_accounts = multiSigChainAccounts; // if (provider) body.provider = provider - no provider param for API call

  if (returnSignedTransaction) body.return_signed_transaction = returnSignedTransaction;
  if (signedTransactionParam) body.signed_transaction = _utils_helpers__WEBPACK_IMPORTED_MODULE_2__["default"].base64Encode(signedTransactionParam); // if (stateParam) body.state = Helpers.base64Encode(stateParam) - no state for an API call

  if (transactionChainAccount) body.transaction_chain_acccount = transactionChainAccount;
  if (transactionParam) body.transaction = _utils_helpers__WEBPACK_IMPORTED_MODULE_2__["default"].base64Encode(transactionParam);
  if (transactionRecordId) body.transaction_record_id = transactionRecordId;
  if (userPassword) body.user_password = userPassword; // used for custodial sign

  if (userPasswordEncrypted) body.user_password_encrypted = userPasswordEncrypted; // used for custodial sign

  return body;
}
/** convert snake_case fields in response to camelCase */


function mapSignResultFromApi(apiResult) {
  var signedTransaction = apiResult.signed_transaction,
      transactionId = apiResult.transaction_id,
      rest = _objectWithoutProperties(apiResult, _excluded);

  return _objectSpread({
    signedTransaction: signedTransaction,
    transactionId: transactionId
  }, rest);
}
/** Call api transaction/sign - to sign a transaction for a user
 * Can only sign a transaction if autoSign specified (and previously enabled by user)
 * OR if OreId is managing a private key it can sign with (e.g. most often an account in multiSigChainAccounts)
 * For autoSign param, requires an apiKey with the autoSign right
 * Returns: stringified signedTransaction (and transactionId if available)
 *          OR errorCode, errorDescription, message - if any issues
 * */


function callApiSignTransaction(_x, _x2) {
  return _callApiSignTransaction.apply(this, arguments);
}
/** Call api custodial/sign - for signing a transaction on behalf of a user
 * Requires wallet password: either user_password or user_password_encrypted param (used to decrypt user's key)
 * Requires an apiKey with the proxySign right
 * Returns: stringified signedTransaction (and transactionId if available)
 *          OR errorCode, errorDescription, message - if any issues
 * */

function _callApiSignTransaction() {
  _callApiSignTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, body, results;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.TransactionSign;

            if (params !== null && params !== void 0 && params.autoSign) {
              (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKey)(oreIdContext, _models__WEBPACK_IMPORTED_MODULE_0__.ApiKeyUsedFor.AutoSigning, apiName);
            } else {
              (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKeyOrAccessToken)(oreIdContext, apiName);
            }

            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params.transactionData, ['account', 'chainNetwork', 'chainAccount'], apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveOnlyOneOfValues)(params.transactionData, ['transaction', 'signedTransaction'], apiName);
            body = composeSignBodyFromTransactionData(params);
            _context.next = 7;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Post, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.TransactionSign, body, null);

          case 7:
            results = _context.sent;
            return _context.abrupt("return", mapSignResultFromApi(results));

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiSignTransaction.apply(this, arguments);
}

function callApiCustodialSignTransaction(_x3, _x4) {
  return _callApiCustodialSignTransaction.apply(this, arguments);
}

function _callApiCustodialSignTransaction() {
  _callApiCustodialSignTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(oreIdContext, params) {
    var apiName, _ref3, signOptions, body, results;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.CustodialSign;
            _ref3 = params.transactionData || {}, signOptions = _ref3.signOptions;
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKey)(oreIdContext, _models__WEBPACK_IMPORTED_MODULE_0__.ApiKeyUsedFor.ProxySigning, apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params.transactionData, ['account', 'chainNetwork', 'chainAccount'], apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveOnlyOneOfValues)(params.transactionData, ['transaction', 'signedTransaction'], apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveOnlyOneOfValues)(signOptions, ['userPassword', 'userPasswordEncrypted'], apiName);
            body = composeSignBodyFromTransactionData(params);
            _context2.next = 9;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Post, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.CustodialSign, body, null);

          case 9:
            results = _context2.sent;
            return _context2.abrupt("return", mapSignResultFromApi(results));

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _callApiCustodialSignTransaction.apply(this, arguments);
}

/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOreIdAuthUrl": () => (/* binding */ getOreIdAuthUrl),
/* harmony export */   "getOreIdNewChainAccountUrl": () => (/* binding */ getOreIdNewChainAccountUrl),
/* harmony export */   "getOreIdSignUrl": () => (/* binding */ getOreIdSignUrl),
/* harmony export */   "getRecoverAccountUrl": () => (/* binding */ getRecoverAccountUrl)
/* harmony export */ });
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }


var isNullOrEmpty = _utils_helpers__WEBPACK_IMPORTED_MODULE_0__["default"].isNullOrEmpty;
/** Returns a fully formed url to create a new chain account within a user's wallet account
 *  This function calls the /new-account web endpoint
 *  It requires an apiKey in order to add an appAccessToken with new account metadata
 *  Returns: Callback returns chainAccount - for the new account */

function getOreIdNewChainAccountUrl(_x, _x2) {
  return _getOreIdNewChainAccountUrl.apply(this, arguments);
}
/** Returns a fully formed url to login a user
 *  This function calls the /auth web endpoint
 *  Returns: Callback returns account, and optionally accessToken and/or idToken for user */

function _getOreIdNewChainAccountUrl() {
  _getOreIdNewChainAccountUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, args) {
    var account, accountType, chainNetwork, accountOptions, provider, callbackUrl, backgroundColor, state, oreIdUrl, appAccessTokenMetadata, accessTokenParam, encodedStateParam, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            account = args.account, accountType = args.accountType, chainNetwork = args.chainNetwork, accountOptions = args.accountOptions, provider = args.provider, callbackUrl = args.callbackUrl, backgroundColor = args.backgroundColor, state = args.state;
            oreIdUrl = oreIdContext.options.oreIdUrl; // collect additional params embedded into appAccessToken

            appAccessTokenMetadata = {
              paramsNewAccount: {
                account: account,
                accountType: accountType,
                chainNetwork: chainNetwork,
                accountOptions: accountOptions
              }
            };

            if (!(!account || !accountType || !chainNetwork || !provider || !callbackUrl)) {
              _context.next = 5;
              break;
            }

            throw new Error('Missing a required parameter');

          case 5:
            accessTokenParam = "&oauth_access_token=".concat(oreIdContext.accessToken); // optional params

            encodedStateParam = state ? "&state=".concat(state) : '';
            url = "".concat(oreIdUrl, "/new-account#provider=").concat(provider, "&chain_network=").concat(chainNetwork) + "&callback_url=".concat(encodeURIComponent(callbackUrl), "&background_color=").concat(encodeURIComponent(backgroundColor)).concat(encodedStateParam).concat(accessTokenParam);
            return _context.abrupt("return", oreIdContext.addAccessTokenAndHmacToUrl(url, appAccessTokenMetadata));

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getOreIdNewChainAccountUrl.apply(this, arguments);
}

function getOreIdAuthUrl(_x3, _x4) {
  return _getOreIdAuthUrl.apply(this, arguments);
}
/** Returns a fully formed url to login a user
 *  This function calls the /sign web endpoint
 *  Returns: Callback returns transactionId (if available), and optionally signedTransaction */

function _getOreIdAuthUrl() {
  _getOreIdAuthUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(oreIdContext, args) {
    var code, email, phone, provider, callbackUrl, backgroundColor, state, linkToAccount, returnAccessToken, returnIdToken, oreIdUrl, encodedStateParam, linkToAccountParam, codeParam, emailParam, phoneParam, returnAccessTokenParam, returnIdTokenParam, url;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            code = args.code, email = args.email, phone = args.phone, provider = args.provider, callbackUrl = args.callbackUrl, backgroundColor = args.backgroundColor, state = args.state, linkToAccount = args.linkToAccount, returnAccessToken = args.returnAccessToken, returnIdToken = args.returnIdToken;
            oreIdUrl = oreIdContext.options.oreIdUrl;

            if (!(!provider || !callbackUrl)) {
              _context2.next = 4;
              break;
            }

            throw new Error('Missing a required parameter');

          case 4:
            // optional params
            encodedStateParam = state ? "&state=".concat(state) : '';
            linkToAccountParam = linkToAccount ? "&link_to_account=".concat(linkToAccount) : ''; // handle passwordless params

            codeParam = code ? "&code=".concat(code) : '';
            emailParam = email ? "&email=".concat(encodeURIComponent(email)) : '';
            phoneParam = phone ? "&phone=".concat(encodeURIComponent(phone)) : ''; // if user passes in +12103334444, the plus sign needs to be URL encoded

            returnAccessTokenParam = returnAccessToken ? "&return_access_token=".concat(returnAccessToken) : '';
            returnIdTokenParam = returnIdToken ? "&return_id_token=".concat(returnIdToken) : '';
            url = "".concat(oreIdUrl, "/auth#provider=").concat(provider) + "".concat(codeParam).concat(emailParam).concat(phoneParam) + "&callback_url=".concat(encodeURIComponent(callbackUrl), "&background_color=").concat(encodeURIComponent(backgroundColor)).concat(linkToAccountParam).concat(encodedStateParam).concat(returnAccessTokenParam).concat(returnIdTokenParam);
            return _context2.abrupt("return", oreIdContext.addAccessTokenAndHmacToUrl(url, null));

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _getOreIdAuthUrl.apply(this, arguments);
}

function getOreIdSignUrl(_x5, _x6) {
  return _getOreIdSignUrl.apply(this, arguments);
}
/** Returns a fully formed url to recover a user's account (e.g. change password)
 *  This function calls the /recover-account web endpoint
 *  Returns: Callback returns account updated */

function _getOreIdSignUrl() {
  _getOreIdSignUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(oreIdContext, transactionData) {
    var account, chainNetwork, expireSeconds, signedTransaction, transaction, transactionRecordId, _ref, allowChainAccountSelection, broadcast, callbackUrl, multiSigChainAccounts, provider, returnSignedTransaction, state, chainAccount, oreIdUrl, encodedTransaction, encodedSignedTransaction, optionalParams, url;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            account = transactionData.account, chainNetwork = transactionData.chainNetwork, expireSeconds = transactionData.expireSeconds, signedTransaction = transactionData.signedTransaction, transaction = transactionData.transaction, transactionRecordId = transactionData.transactionRecordId;
            _ref = (transactionData === null || transactionData === void 0 ? void 0 : transactionData.signOptions) || {}, allowChainAccountSelection = _ref.allowChainAccountSelection, broadcast = _ref.broadcast, callbackUrl = _ref.callbackUrl, multiSigChainAccounts = _ref.multiSigChainAccounts, provider = _ref.provider, returnSignedTransaction = _ref.returnSignedTransaction, state = _ref.state;
            chainAccount = transactionData.chainAccount;
            oreIdUrl = oreIdContext.options.oreIdUrl; // Now always appends accessToken to signUrl

            if (!(!account || !callbackUrl || !transaction && !signedTransaction)) {
              _context3.next = 6;
              break;
            }

            throw new Error('Missing a required parameter');

          case 6:
            // default chainAccount is the same as the user's account
            if (!chainAccount) {
              chainAccount = account;
            }

            encodedTransaction = _utils_helpers__WEBPACK_IMPORTED_MODULE_0__["default"].base64Encode(transaction);
            encodedSignedTransaction = _utils_helpers__WEBPACK_IMPORTED_MODULE_0__["default"].base64Encode(signedTransaction);
            optionalParams = state ? "&state=".concat(state) : '';
            optionalParams += !isNullOrEmpty(transaction) ? "&transaction=".concat(encodedTransaction) : '';
            optionalParams += !isNullOrEmpty(signedTransaction) ? "&signed_transaction=".concat(encodedSignedTransaction) : '';
            optionalParams += !isNullOrEmpty(allowChainAccountSelection) ? "&allow_chain_account_selection=".concat(allowChainAccountSelection) : '';
            optionalParams += !isNullOrEmpty(expireSeconds) ? "&expire_seconds=".concat(expireSeconds) : '';
            optionalParams += !isNullOrEmpty(multiSigChainAccounts) ? "&multisig_chain_accounts=".concat(multiSigChainAccounts) : '';
            optionalParams += !isNullOrEmpty(provider) ? "&provider=".concat(provider) : '';
            optionalParams += !isNullOrEmpty(returnSignedTransaction) ? "&return_signed_transaction=".concat(returnSignedTransaction) : '';
            optionalParams += !isNullOrEmpty(transactionRecordId) ? "&transaction_record_id=".concat(transactionRecordId) : '';
            optionalParams += "&oauth_access_token=".concat(oreIdContext.accessToken); // prettier-ignore

            url = "".concat(oreIdUrl, "/sign#account=").concat(account, "&broadcast=").concat(broadcast, "&callback_url=").concat(encodeURIComponent(callbackUrl), "&chain_account=").concat(chainAccount, "&chain_network=").concat(encodeURIComponent(chainNetwork)).concat(optionalParams);
            return _context3.abrupt("return", oreIdContext.addAccessTokenAndHmacToUrl(url, null));

          case 21:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _getOreIdSignUrl.apply(this, arguments);
}

function getRecoverAccountUrl(_x7, _x8) {
  return _getRecoverAccountUrl.apply(this, arguments);
}

function _getRecoverAccountUrl() {
  _getRecoverAccountUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(oreIdContext, args) {
    var account, code, email, phone, provider, callbackUrl, backgroundColor, state, recoverAction, overrideAppAccessToken, oreIdUrl, accessTokenParam, encodedStateParam, actionTypeParam, codeParam, emailParam, phoneParam, url;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            account = args.account, code = args.code, email = args.email, phone = args.phone, provider = args.provider, callbackUrl = args.callbackUrl, backgroundColor = args.backgroundColor, state = args.state, recoverAction = args.recoverAction, overrideAppAccessToken = args.overrideAppAccessToken;
            oreIdUrl = oreIdContext.options.oreIdUrl;

            if (!(!provider || !callbackUrl)) {
              _context4.next = 4;
              break;
            }

            throw new Error('Missing a required parameter');

          case 4:
            accessTokenParam = "&oauth_access_token=".concat(oreIdContext.accessToken); // optional params

            encodedStateParam = state ? "&state=".concat(state) : '';
            actionTypeParam = recoverAction ? "&recover_action=".concat(recoverAction) : ''; // handle passwordless params

            codeParam = code ? "&code=".concat(code) : '';
            emailParam = email ? "&email=".concat(encodeURIComponent(email)) : '';
            phoneParam = phone ? "&phone=".concat(encodeURIComponent(phone)) : ''; // if user passes in +12103334444, the plus sign needs to be URL encoded

            url = "".concat(oreIdUrl, "/recover-account#provider=").concat(provider) + "&account=".concat(account) + "".concat(codeParam).concat(emailParam).concat(phoneParam) + "&callback_url=".concat(encodeURIComponent(callbackUrl), "&background_color=").concat(encodeURIComponent(backgroundColor)).concat(actionTypeParam).concat(encodedStateParam).concat(accessTokenParam);
            return _context4.abrupt("return", oreIdContext.addAccessTokenAndHmacToUrl(url, null, overrideAppAccessToken));

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _getRecoverAccountUrl.apply(this, arguments);
}

/***/ }),
/* 41 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TransitHelper)
/* harmony export */ });
/* harmony import */ var _aikon_eos_transit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
/* harmony import */ var _utils_chainUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _transitProviders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71);
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17);
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }







var TransitHelper = /*#__PURE__*/function () {
  function TransitHelper(args) {
    _classCallCheck(this, TransitHelper);

    this._oreIdContext = args.oreIdContext;
    this._user = args.user;
    this.transitAccessContexts = {};
  }

  _createClass(TransitHelper, [{
    key: "installTransitProviders",
    value:
    /** Verifies that all plugins provided work (can be constructed)
     *  Stores a list of the installed providerNames (mapped to ExternalWalletType) for all working plugins in transitProvidersInstalled
     */
    function () {
      var _installTransitProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(eosTransitWalletProviders) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // Executes each provider's contructor to verify it's working
                // stores all the providerName's for all plugins into transitProvidersInstalled array
                this._oreIdContext.transitProvidersInstalled = (eosTransitWalletProviders || []).map(function (makeWalletProvider) {
                  try {
                    // if there is an error while initiating a provider dont break the whole process.
                    return makeWalletProvider(null);
                  } catch (e) {
                    console.log("Couldn't initiate a wallet provider. ".concat(e));
                    return null;
                  }
                }) // instantiate the provider with null network so we can get the id
                .filter(function (walletProvider) {
                  return walletProvider && true;
                }).map(function (walletProvider) {
                  return (0,_transitProviders__WEBPACK_IMPORTED_MODULE_2__.getTransitProviderAttributesByProviderId)(walletProvider.id).providerName;
                });

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function installTransitProviders(_x) {
        return _installTransitProviders.apply(this, arguments);
      }

      return installTransitProviders;
    }()
    /** Inialize EOS Transit wallet provider and return TransitWallet instance */

  }, {
    key: "setupTransitWallet",
    value: function () {
      var _setupTransitWallet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref) {
        var walletType, chainNetwork, _getTransitProviderAt, providerId, chainContext, transitProvider, transitWallet;

        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                walletType = _ref.walletType, chainNetwork = _ref.chainNetwork;
                this.assertHasProviderInstalled(walletType, _models__WEBPACK_IMPORTED_MODULE_4__.ExternalWalletInterface.Transit);
                this.assertProviderValidForChainNetwork(walletType, chainNetwork);
                _getTransitProviderAt = (0,_transitProviders__WEBPACK_IMPORTED_MODULE_2__.getTransitProviderAttributes)(walletType), providerId = _getTransitProviderAt.providerId;
                _context2.next = 6;
                return this.getOrCreateTransitAccessContext(chainNetwork);

              case 6:
                chainContext = _context2.sent;
                transitProvider = chainContext.getWalletProviders().find(function (wp) {
                  return wp.id === providerId;
                });
                transitWallet = chainContext.initWallet(transitProvider);
                _context2.next = 11;
                return transitWallet.connect();

              case 11:
                _context2.next = 13;
                return this.waitWhileWalletIsBusy(transitWallet, walletType);

              case 13:
                return _context2.abrupt("return", transitWallet);

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function setupTransitWallet(_x2) {
        return _setupTransitWallet.apply(this, arguments);
      }

      return setupTransitWallet;
    }()
    /** Creates an EOS Transit WalletContent for the specified network and plugins
     *  Caches the context for future calls to this function */

  }, {
    key: "getOrCreateTransitAccessContext",
    value: function () {
      var _getOrCreateTransitAccessContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(chainNetwork) {
        var _this$_oreIdContext$o, appName, _this$_oreIdContext$o2, eosTransitWalletProviders, networkConfig, isNotEosNetwork, walletContext;

        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _this$_oreIdContext$o = this._oreIdContext.options, appName = _this$_oreIdContext$o.appName, _this$_oreIdContext$o2 = _this$_oreIdContext$o.eosTransitWalletProviders, eosTransitWalletProviders = _this$_oreIdContext$o2 === void 0 ? [] : _this$_oreIdContext$o2;

                if (!this.transitAccessContexts[chainNetwork]) {
                  _context3.next = 3;
                  break;
                }

                return _context3.abrupt("return", this.transitAccessContexts[chainNetwork]);

              case 3:
                _context3.next = 5;
                return this._oreIdContext.settings.getChainNetworkNextworkConfig(chainNetwork);

              case 5:
                networkConfig = _context3.sent;
                _context3.next = 8;
                return this._oreIdContext.settings.isNotEosNetwork(chainNetwork);

              case 8:
                isNotEosNetwork = _context3.sent;
                walletContext = (0,_aikon_eos_transit__WEBPACK_IMPORTED_MODULE_0__.initAccessContext)({
                  appName: appName || 'missing appName',
                  network: networkConfig,
                  walletProviders: eosTransitWalletProviders,
                  isNotEosNetwork: isNotEosNetwork // Tells eos-transit to not use EOS specific rpc calls

                }); // cache for future use

                this.transitAccessContexts[chainNetwork] = walletContext;
                return _context3.abrupt("return", walletContext);

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getOrCreateTransitAccessContext(_x3) {
        return _getOrCreateTransitAccessContext.apply(this, arguments);
      }

      return getOrCreateTransitAccessContext;
    }() // For Scatter: chainAccount is needed since login will try to use the default account (in scatter
    // and it wil fail to sign the transaction

    /** Handles the call to connect() function on the Transit provider */

  }, {
    key: "connectToTransitProvider",
    value: function () {
      var _connectToTransitProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref2) {
        var walletType, chainNetwork, _ref2$chainAccount, chainAccount, response, transitWallet, _transitWallet$auth, accountName, permission, publicKey, errorString, hasError, errorMessage, errMsg;

        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                walletType = _ref2.walletType, chainNetwork = _ref2.chainNetwork, _ref2$chainAccount = _ref2.chainAccount, chainAccount = _ref2$chainAccount === void 0 ? null : _ref2$chainAccount;
                this.assertHasProviderInstalled(walletType, _models__WEBPACK_IMPORTED_MODULE_4__.ExternalWalletInterface.Transit);
                this.assertProviderValidForChainNetwork(walletType, chainNetwork);
                _context4.prev = 3;
                _context4.next = 6;
                return this.setupTransitWallet({
                  walletType: walletType,
                  chainNetwork: chainNetwork
                });

              case 6:
                transitWallet = _context4.sent;
                response = {
                  transitWallet: transitWallet
                }; // some providers require login flow to connect (usually this means connect() does nothing but login selects an account)

                if (!(0,_transitProviders__WEBPACK_IMPORTED_MODULE_2__.getTransitProviderAttributes)(walletType).requiresLogin) {
                  _context4.next = 12;
                  break;
                }

                if (transitWallet.authenticated) {
                  _context4.next = 12;
                  break;
                }

                _context4.next = 12;
                return this.loginToTransitProvider(transitWallet, walletType, chainNetwork, chainAccount);

              case 12:
                if (!transitWallet.connected) {
                  _context4.next = 20;
                  break;
                }

                if (!(transitWallet.authenticated && transitWallet.auth)) {
                  _context4.next = 18;
                  break;
                }

                _context4.next = 16;
                return this.updateOreAccountPermissionsfromTransitWalletAuth(transitWallet, walletType);

              case 16:
                _transitWallet$auth = transitWallet.auth, accountName = _transitWallet$auth.accountName, permission = _transitWallet$auth.permission, publicKey = _transitWallet$auth.publicKey;
                response = {
                  isLoggedIn: true,
                  chainAccount: accountName,
                  permissions: [{
                    name: permission,
                    publicKey: publicKey
                  }],
                  // todo: add parent permission when available
                  transitWallet: transitWallet,
                  provider: walletType
                };

              case 18:
                _context4.next = 24;
                break;

              case 20:
                errorString = "".concat(walletType, " not connected!");
                hasError = transitWallet.hasError, errorMessage = transitWallet.errorMessage;

                if (hasError) {
                  errorString += " Error: ".concat(errorMessage);
                }

                throw new Error(errorString);

              case 24:
                _context4.next = 31;
                break;

              case 26:
                _context4.prev = 26;
                _context4.t0 = _context4["catch"](3);
                errMsg = "Failed to connect to ".concat(walletType, " on ").concat(chainNetwork, ". ").concat((_context4.t0 === null || _context4.t0 === void 0 ? void 0 : _context4.t0.message) || '');
                console.log("connectToTransitProvider:".concat(errMsg), _context4.t0);
                throw new Error(errMsg);

              case 31:
                _context4.prev = 31;

                this._oreIdContext.setIsBusy(false);

                return _context4.finish(31);

              case 34:
                return _context4.abrupt("return", response);

              case 35:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[3, 26, 31, 34]]);
      }));

      function connectToTransitProvider(_x4) {
        return _connectToTransitProvider.apply(this, arguments);
      }

      return connectToTransitProvider;
    }()
    /** Handles the call to login() function on the Transit provider
     *  If required by provider, calls discover() and/or logout() before calling login()
     *  IMPORTANT: use loginToTransitProvider() instead of this function */

  }, {
    key: "doTransitProviderLogin",
    value: function () {
      var _doTransitProviderLogin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(transitWallet, chainAccount, chainNetwork, walletType) {
        var retryCount,
            info,
            _getTransitProviderAt2,
            requiresDiscoverToLogin,
            discoveryData,
            foundData,
            _ref3,
            transitAccountName,
            _args5 = arguments;

        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                retryCount = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : 0;
                this.assertHasProviderInstalled(walletType, _models__WEBPACK_IMPORTED_MODULE_4__.ExternalWalletInterface.Transit);
                this.assertProviderValidForChainNetwork(walletType, chainNetwork); // we should store the index for ledger in the db and pass it along
                // but for now we need to discover the ledger index

                _getTransitProviderAt2 = (0,_transitProviders__WEBPACK_IMPORTED_MODULE_2__.getTransitProviderAttributes)(walletType), requiresDiscoverToLogin = _getTransitProviderAt2.requiresDiscoverToLogin;

                if (!requiresDiscoverToLogin) {
                  _context5.next = 18;
                  break;
                }

                _context5.next = 7;
                return transitWallet.discover(this.discoverOptionsForProvider(walletType));

              case 7:
                discoveryData = _context5.sent;
                foundData = this.findAccountInDiscoverData(discoveryData, chainAccount);

                if (!foundData) {
                  _context5.next = 15;
                  break;
                }

                _context5.next = 12;
                return transitWallet.login(chainAccount, foundData.authorization);

              case 12:
                info = _context5.sent;
                _context5.next = 16;
                break;

              case 15:
                throw new Error("Account ".concat(chainAccount, " not found in wallet"));

              case 16:
                _context5.next = 21;
                break;

              case 18:
                _context5.next = 20;
                return transitWallet.login(chainAccount);

              case 20:
                info = _context5.sent;

              case 21:
                if (!(retryCount > 2)) {
                  _context5.next = 23;
                  break;
                }

                return _context5.abrupt("return", null);

              case 23:
                _ref3 = (transitWallet === null || transitWallet === void 0 ? void 0 : transitWallet.auth) || {}, transitAccountName = _ref3.accountName;

                if (!(chainAccount && transitAccountName !== chainAccount)) {
                  _context5.next = 28;
                  break;
                }

                _context5.next = 27;
                return transitWallet.logout();

              case 27:
                this.doTransitProviderLogin(transitWallet, chainAccount, chainNetwork, walletType, retryCount + 1);

              case 28:
                return _context5.abrupt("return", info);

              case 29:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function doTransitProviderLogin(_x5, _x6, _x7, _x8) {
        return _doTransitProviderLogin.apply(this, arguments);
      }

      return doTransitProviderLogin;
    }()
    /** Login using the wallet provider */

  }, {
    key: "loginWithTransitProvider",
    value: function () {
      var _loginWithTransitProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(loginOptions) {
        var provider, chainAccount, chainNetwork, walletType, response, wallet;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                provider = loginOptions.walletType, chainAccount = loginOptions.chainAccount, chainNetwork = loginOptions.chainNetwork; // Connect to Provider

                walletType = _utils_helpers__WEBPACK_IMPORTED_MODULE_3__["default"].mapAuthProviderToWalletType(provider);
                _context6.next = 4;
                return this.connectToTransitProvider({
                  walletType: walletType,
                  chainAccount: chainAccount,
                  chainNetwork: chainNetwork
                });

              case 4:
                response = _context6.sent;
                wallet = response === null || response === void 0 ? void 0 : response.transitWallet; // Login if needed - if not logged-in by connectToTransitProvider, then call login explicitly

                if (wallet !== null && wallet !== void 0 && wallet.auth) {
                  _context6.next = 11;
                  break;
                }

                _context6.next = 9;
                return this.loginToTransitProvider(wallet, provider, chainNetwork, chainAccount);

              case 9:
                _context6.next = 11;
                return this.updateOreAccountPermissionsfromTransitWalletAuth(wallet, provider);

              case 11:
                return _context6.abrupt("return", response);

              case 12:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function loginWithTransitProvider(_x9) {
        return _loginWithTransitProvider.apply(this, arguments);
      }

      return loginWithTransitProvider;
    }()
    /** Handles the call to login() function on the Transit provider */

  }, {
    key: "loginToTransitProvider",
    value: function () {
      var _loginToTransitProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(transitWallet, walletType, chainNetwork) {
        var chainAccount,
            _error$message,
            message,
            _args7 = arguments;

        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                chainAccount = _args7.length > 3 && _args7[3] !== undefined ? _args7[3] : null;
                this.assertHasProviderInstalled(walletType, _models__WEBPACK_IMPORTED_MODULE_4__.ExternalWalletInterface.Transit);
                this.assertProviderValidForChainNetwork(walletType, chainNetwork);
                _context7.prev = 3;
                _context7.next = 6;
                return this.doTransitProviderLogin(transitWallet, chainAccount, chainNetwork, walletType);

              case 6:
                _context7.next = 16;
                break;

              case 8:
                _context7.prev = 8;
                _context7.t0 = _context7["catch"](3);
                _error$message = _context7.t0.message, message = _error$message === void 0 ? '' : _error$message;

                if (!message.includes('unknown key (boost::tuples::tuple')) {
                  _context7.next = 15;
                  break;
                }

                throw new Error("The account selected by the wallet for login isn't on the ".concat(chainNetwork, " chain"));

              case 15:
                throw _context7.t0;

              case 16:
                _context7.prev = 16;
                _context7.next = 19;
                return this.waitWhileWalletIsBusy(transitWallet, walletType);

              case 19:
                return _context7.finish(16);

              case 20:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[3, 8, 16, 20]]);
      }));

      function loginToTransitProvider(_x10, _x11, _x12) {
        return _loginToTransitProvider.apply(this, arguments);
      }

      return loginToTransitProvider;
    }()
    /** Throw if the required plug-in is not installed */

  }, {
    key: "assertHasProviderInstalled",
    value: function assertHasProviderInstalled(provider, providerType) {
      if (providerType === _models__WEBPACK_IMPORTED_MODULE_4__.ExternalWalletInterface.Transit) {
        if (!this.hasTransitProvider(provider)) {
          throw Error("Transit provider:\"".concat(provider, "\" not installed. Please pass it in via eosTransitWalletProviders."));
        }
      }
    }
    /** Discovers keys in a wallet provider.
     *  Any new keys discovered in wallet are added to user's ORE ID record.
     *  If the provider doesnt support a discover() function, and requiresLogoutLoginToDiscover == true, attempts a logout then login instead.
     */

  }, {
    key: "discoverWithTransit",
    value: function () {
      var _discoverWithTransit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(discoverOptions) {
        var walletType, _discoverOptions$chai, chainNetwork, oreAccount, discoveryPathIndexList, result, transitWallet;

        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                walletType = discoverOptions.walletType, _discoverOptions$chai = discoverOptions.chainNetwork, chainNetwork = _discoverOptions$chai === void 0 ? _models__WEBPACK_IMPORTED_MODULE_4__.ChainNetwork.EosMain : _discoverOptions$chai, oreAccount = discoverOptions.oreAccount, discoveryPathIndexList = discoverOptions.discoveryPathIndexList;
                this.assertProviderValidForChainNetwork(walletType, chainNetwork);
                result = null;

                if (!this.canDiscover(walletType)) {
                  _context8.next = 9;
                  break;
                }

                _context8.next = 6;
                return this.discoverCredentialsInTransitWallet(chainNetwork, walletType, oreAccount, discoveryPathIndexList);

              case 6:
                result = _context8.sent;
                _context8.next = 21;
                break;

              case 9:
                _context8.next = 11;
                return this.setupTransitWallet({
                  walletType: walletType,
                  chainNetwork: chainNetwork
                });

              case 11:
                transitWallet = _context8.sent;

                if (!this.requiresLogoutLoginToDiscover(walletType)) {
                  _context8.next = 20;
                  break;
                }

                _context8.next = 15;
                return transitWallet.logout();

              case 15:
                _context8.next = 17;
                return transitWallet.login();

              case 17:
                this.updateOreAccountPermissionsfromTransitWalletAuth(transitWallet, walletType);
                _context8.next = 21;
                break;

              case 20:
                console.log('Discover not working for walletType: ', walletType);

              case 21:
                return _context8.abrupt("return", result);

              case 22:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function discoverWithTransit(_x13) {
        return _discoverWithTransit.apply(this, arguments);
      }

      return discoverWithTransit;
    }()
    /** Discover all accounts (and related permissions) in the wallet and add them to ORE ID
     * Note: Most wallets don't support discovery */

  }, {
    key: "discoverCredentialsInTransitWallet",
    value: function () {
      var _discoverCredentialsInTransitWallet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(chainNetwork, walletType, oreAccount, discoveryPathIndexList) {
        var _this = this;

        var accountsAndPermissions, transitWallet, discoveryData, credentials;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                accountsAndPermissions = [];
                _context10.prev = 1;
                _context10.next = 4;
                return this.setupTransitWallet({
                  walletType: walletType,
                  chainNetwork: chainNetwork
                });

              case 4:
                transitWallet = _context10.sent;

                this._oreIdContext.setIsBusy(true);

                _context10.next = 8;
                return transitWallet.discover(this.discoverOptionsForProvider(walletType, discoveryPathIndexList));

              case 8:
                discoveryData = _context10.sent;
                // this data looks like this: keyToAccountMap[accounts[{account,permission}]] - e.g. keyToAccountMap[accounts[{'myaccount':'owner','myaccount':'active'}]]
                credentials = discoveryData.keyToAccountMap; // for each entry in the array, add permission to ore account if not already present

                _context10.next = 12;
                return _utils_helpers__WEBPACK_IMPORTED_MODULE_3__["default"].asyncForEach(credentials, /*#__PURE__*/function () {
                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(credential) {
                    var _credential$accounts, accounts, publicKey, _this$_user, _accounts, _accounts$, account, authorization, permissions, transitChainNetwork;

                    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                      while (1) {
                        switch (_context9.prev = _context9.next) {
                          case 0:
                            _credential$accounts = credential.accounts, accounts = _credential$accounts === void 0 ? [] : _credential$accounts, publicKey = credential.key; // ethereum may not have a public key - dont save if missing

                            if (!(accounts.length > 0 && !!publicKey)) {
                              _context9.next = 10;
                              break;
                            }

                            _accounts = _slicedToArray(accounts, 1), _accounts$ = _accounts[0], account = _accounts$.account, authorization = _accounts$.authorization; // get first item in array

                            permissions = [{
                              account: account,
                              publicKey: publicKey,
                              name: authorization,
                              parent: null
                            }]; // Get the chainNetwork from the transitWallet - in case the wallet provider switches networks somehow

                            _context9.next = 6;
                            return _this.getChainNetworkFromTransitWallet(transitWallet);

                          case 6:
                            transitChainNetwork = _context9.sent;
                            _context9.next = 9;
                            return (_this$_user = _this._user) === null || _this$_user === void 0 ? void 0 : _this$_user.addWalletPermissionsToOreIdAccount({
                              chainAccount: account,
                              chainNetwork: transitChainNetwork,
                              permissions: permissions,
                              walletType: walletType
                            });

                          case 9:
                            accountsAndPermissions = accountsAndPermissions.concat(permissions);

                          case 10:
                          case "end":
                            return _context9.stop();
                        }
                      }
                    }, _callee9);
                  }));

                  return function (_x18) {
                    return _ref4.apply(this, arguments);
                  };
                }());

              case 12:
                _context10.prev = 12;

                this._oreIdContext.setIsBusy(false);

                return _context10.finish(12);

              case 15:
                return _context10.abrupt("return", accountsAndPermissions);

              case 16:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[1,, 12, 15]]);
      }));

      function discoverCredentialsInTransitWallet(_x14, _x15, _x16, _x17) {
        return _discoverCredentialsInTransitWallet.apply(this, arguments);
      }

      return discoverCredentialsInTransitWallet;
    }()
    /** Discover options composed for specific provider */

  }, {
    key: "discoverOptionsForProvider",
    value: function discoverOptionsForProvider(provider) {
      var pathIndexListParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var pathIndexList;
      var keyLookupFunc;
      var walletProviderType = _utils_helpers__WEBPACK_IMPORTED_MODULE_3__["default"].mapAuthProviderToWalletType(provider);

      if (this.hasTransitProvider(walletProviderType)) {
        var walletProvider = _utils_helpers__WEBPACK_IMPORTED_MODULE_3__["default"].mapAuthProviderToWalletType(provider);

        var _getTransitProviderAt3 = (0,_transitProviders__WEBPACK_IMPORTED_MODULE_2__.getTransitProviderAttributes)(walletProvider),
            defaultDiscoveryPathIndexList = _getTransitProviderAt3.defaultDiscoveryPathIndexList,
            discoveryKeyLookupFunc = _getTransitProviderAt3.discoveryKeyLookupFunc;

        pathIndexList = pathIndexListParam || defaultDiscoveryPathIndexList || [];
        keyLookupFunc = discoveryKeyLookupFunc; // optional
      }

      var response = {
        pathIndexList: pathIndexList
      };

      if (keyLookupFunc) {
        response.keyLookupFunc = keyLookupFunc;
      }

      return response;
    }
  }, {
    key: "findAccountInDiscoverData",
    value: function findAccountInDiscoverData(discoveryData, chainAccount) {
      var result = discoveryData.keyToAccountMap.find(function (data) {
        return data.accounts.find(function (acct) {
          return acct.account === chainAccount;
        });
      });

      if (result) {
        var authorization = 'active'; // could active not exist?  If not, then just get first permission
        // this may be completely unecessary. remove if so.

        var active = result.accounts.find(function (acct) {
          return acct.authorization === 'active';
        });

        if (!active) {
          var _result$accounts = _slicedToArray(result.accounts, 1),
              first = _result$accounts[0];

          if (first) {
            // eslint-disable-next-line prefer-destructuring
            authorization = first.authorization;
          }
        }

        return {
          index: result.index,
          key: result.key,
          authorization: authorization
        };
      }

      return null;
    }
    /** sign with a Transit wallet */

  }, {
    key: "signWithTransitProvider",
    value: function () {
      var _signWithTransitProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(transactionData, walletType) {
        var signedTransaction, chainNetwork, chainAccount, _yield$this$connectTo, transitWallet, _getTransitProviderAt4, chainType;

        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                chainNetwork = transactionData.chainNetwork, chainAccount = transactionData.chainAccount;
                this.assertHasProviderInstalled(walletType, _models__WEBPACK_IMPORTED_MODULE_4__.ExternalWalletInterface.Transit);
                this.assertProviderValidForChainNetwork(walletType, chainNetwork); // connect to wallet

                _context11.next = 5;
                return this.connectToTransitProvider({
                  walletType: walletType,
                  chainNetwork: chainNetwork,
                  chainAccount: chainAccount
                });

              case 5:
                _yield$this$connectTo = _context11.sent;
                transitWallet = _yield$this$connectTo.transitWallet;
                _context11.prev = 7;

                // sign with transit wallet
                this._oreIdContext.setIsBusy(true);

                _getTransitProviderAt4 = (0,_transitProviders__WEBPACK_IMPORTED_MODULE_2__.getTransitProviderAttributes)(walletType), chainType = _getTransitProviderAt4.chainType; // EOS - use eosJS to sign (eosApi.transact)

                if (!(chainType === _models__WEBPACK_IMPORTED_MODULE_4__.ChainPlatformType.eos)) {
                  _context11.next = 16;
                  break;
                }

                _context11.next = 13;
                return this.signTransactionWithTransitAndEosSDK(transactionData, transitWallet);

              case 13:
                signedTransaction = _context11.sent;
                _context11.next = 29;
                break;

              case 16:
                if (!(chainType === _models__WEBPACK_IMPORTED_MODULE_4__.ChainPlatformType.algorand)) {
                  _context11.next = 22;
                  break;
                }

                _context11.next = 19;
                return this.signTransactionWithTransitAndAlgorandSDK(transactionData, transitWallet);

              case 19:
                signedTransaction = _context11.sent;
                _context11.next = 29;
                break;

              case 22:
                if (!(chainType === _models__WEBPACK_IMPORTED_MODULE_4__.ChainPlatformType.ethereum)) {
                  _context11.next = 28;
                  break;
                }

                _context11.next = 25;
                return this.signTransactionWithTransitAndEthereumSDK(transactionData, transitWallet);

              case 25:
                signedTransaction = _context11.sent;
                _context11.next = 29;
                break;

              case 28:
                throw new Error("signWithTransitProvider doesnt support chain type: ".concat(chainType));

              case 29:
                _context11.next = 35;
                break;

              case 31:
                _context11.prev = 31;
                _context11.t0 = _context11["catch"](7);
                console.error(_context11.t0);
                throw _context11.t0;

              case 35:
                _context11.prev = 35;

                this._oreIdContext.setIsBusy(false);

                return _context11.finish(35);

              case 38:
                // Convert serializedTransaction from UInt8Array to Buffer
                // i.e. when stringified change from: '{\"0\":129,\"1\":163'} to {"type":"Buffer","data":[129,163]}
                if (signedTransaction.serializedTransaction) {
                  signedTransaction.serializedTransaction = Buffer.from(signedTransaction.serializedTransaction);
                }

                return _context11.abrupt("return", {
                  signedTransaction: signedTransaction
                });

              case 40:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[7, 31, 35, 38]]);
      }));

      function signWithTransitProvider(_x19, _x20) {
        return _signWithTransitProvider.apply(this, arguments);
      }

      return signWithTransitProvider;
    }()
  }, {
    key: "signStringWithTransitProvider",
    value: function () {
      var _signStringWithTransitProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_ref5) {
        var walletType, chainNetwork, string, message, metadata, _yield$this$connectTo2, transitWallet, response;

        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                walletType = _ref5.walletType, chainNetwork = _ref5.chainNetwork, string = _ref5.string, message = _ref5.message, metadata = _ref5.metadata;
                this.assertHasProviderInstalled(walletType, _models__WEBPACK_IMPORTED_MODULE_4__.ExternalWalletInterface.Transit);
                this.assertProviderValidForChainNetwork(walletType, chainNetwork);
                _context12.next = 5;
                return this.connectToTransitProvider({
                  walletType: walletType,
                  chainNetwork: chainNetwork
                });

              case 5:
                _yield$this$connectTo2 = _context12.sent;
                transitWallet = _yield$this$connectTo2.transitWallet;
                _context12.prev = 7;

                this._oreIdContext.setIsBusy(true);

                _context12.next = 11;
                return transitWallet.signArbitrary(string, message, metadata);

              case 11:
                response = _context12.sent;
                return _context12.abrupt("return", {
                  signedString: response
                });

              case 15:
                _context12.prev = 15;
                _context12.t0 = _context12["catch"](7);
                console.error(_context12.t0);
                throw _context12.t0;

              case 19:
                _context12.prev = 19;

                this._oreIdContext.setIsBusy(false);

                return _context12.finish(19);

              case 22:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[7, 15, 19, 22]]);
      }));

      function signStringWithTransitProvider(_x21) {
        return _signStringWithTransitProvider.apply(this, arguments);
      }

      return signStringWithTransitProvider;
    }()
    /** sign transaction using EOS SDK .transact function */

  }, {
    key: "signTransactionWithTransitAndEosSDK",
    value: function () {
      var _signTransactionWithTransitAndEosSDK = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(transactionData, transitWallet) {
        var expireSeconds, transaction, _ref6, broadcast, _yield$transitWallet$, signatures, serializedTransaction;

        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                expireSeconds = transactionData.expireSeconds, transaction = transactionData.transaction;
                _ref6 = (transactionData === null || transactionData === void 0 ? void 0 : transactionData.signOptions) || {}, broadcast = _ref6.broadcast;
                _context13.next = 4;
                return transitWallet.eosApi.transact({
                  actions: [transaction]
                }, {
                  broadcast: broadcast,
                  blocksBehind: 3,
                  expireSeconds: expireSeconds || 60
                });

              case 4:
                _yield$transitWallet$ = _context13.sent;
                signatures = _yield$transitWallet$.signatures;
                serializedTransaction = _yield$transitWallet$.serializedTransaction;
                _context13.next = 9;
                return this.callDiscoverAfterSign(transactionData);

              case 9:
                return _context13.abrupt("return", {
                  signatures: signatures,
                  serializedTransaction: serializedTransaction
                });

              case 10:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function signTransactionWithTransitAndEosSDK(_x22, _x23) {
        return _signTransactionWithTransitAndEosSDK.apply(this, arguments);
      }

      return signTransactionWithTransitAndEosSDK;
    }()
    /** sign transaction using Algorand SDK */

  }, {
    key: "signTransactionWithTransitAndAlgorandSDK",
    value: function () {
      var _signTransactionWithTransitAndAlgorandSDK = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(transactionData, transitWallet) {
        var chainNetwork, transaction, networkConfig, signParams, _yield$transitWallet$2, signatures, serializedTransaction;

        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                chainNetwork = transactionData.chainNetwork, transaction = transactionData.transaction; // Other chains - use sign function on walletProvider

                _context14.next = 3;
                return this._oreIdContext.settings.getChainNetworkNextworkConfig(chainNetwork);

              case 3:
                networkConfig = _context14.sent;
                signParams = {
                  chainId: networkConfig.chainId,
                  // Chain transaction is for
                  requiredKeys: null,
                  // not used by Algorand signatureProvider
                  serializedTransaction: (0,_utils_chainUtils__WEBPACK_IMPORTED_MODULE_1__.msgPackEncode)(transaction),
                  // Transaction to sign
                  abis: null // not used by Algorand signatureProvider

                };
                _context14.next = 7;
                return transitWallet.provider.signatureProvider.sign(signParams);

              case 7:
                _yield$transitWallet$2 = _context14.sent;
                signatures = _yield$transitWallet$2.signatures;
                serializedTransaction = _yield$transitWallet$2.serializedTransaction;
                _context14.next = 12;
                return this.callDiscoverAfterSign(transactionData);

              case 12:
                return _context14.abrupt("return", {
                  signatures: signatures,
                  serializedTransaction: serializedTransaction
                });

              case 13:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function signTransactionWithTransitAndAlgorandSDK(_x24, _x25) {
        return _signTransactionWithTransitAndAlgorandSDK.apply(this, arguments);
      }

      return signTransactionWithTransitAndAlgorandSDK;
    }()
    /** sign transaction using ethereum web3 SDK */

  }, {
    key: "signTransactionWithTransitAndEthereumSDK",
    value: function () {
      var _signTransactionWithTransitAndEthereumSDK = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(transactionData, transitWallet) {
        var chainNetwork, transaction, networkConfig, signParams, _yield$transitWallet$3, signatures, serializedTransaction;

        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                chainNetwork = transactionData.chainNetwork, transaction = transactionData.transaction; // Other chains - use sign function on walletProvider

                _context15.next = 3;
                return this._oreIdContext.settings.getChainNetworkNextworkConfig(chainNetwork);

              case 3:
                networkConfig = _context15.sent;
                signParams = {
                  chainId: networkConfig.chainId,
                  // Chain transaction is for
                  requiredKeys: null,
                  // not used by Ethereum signatureProvider
                  serializedTransaction: (0,_utils_chainUtils__WEBPACK_IMPORTED_MODULE_1__.msgPackEncode)(transaction),
                  // Transaction to sign
                  abis: null // not used by Ethereum signatureProvider

                };
                _context15.next = 7;
                return transitWallet.provider.signatureProvider.sign(signParams);

              case 7:
                _yield$transitWallet$3 = _context15.sent;
                signatures = _yield$transitWallet$3.signatures;
                serializedTransaction = _yield$transitWallet$3.serializedTransaction;
                _context15.next = 12;
                return this.callDiscoverAfterSign(transactionData);

              case 12:
                return _context15.abrupt("return", {
                  signatures: signatures,
                  serializedTransaction: serializedTransaction
                });

              case 13:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function signTransactionWithTransitAndEthereumSDK(_x26, _x27) {
        return _signTransactionWithTransitAndEthereumSDK.apply(this, arguments);
      }

      return signTransactionWithTransitAndEthereumSDK;
    }()
    /** Determine the chainNetwork from the transitWallet context */

  }, {
    key: "getChainNetworkFromTransitWallet",
    value: function () {
      var _getChainNetworkFromTransitWallet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(transitWallet) {
        var _transitWallet$ctx, _networks$find;

        var _ref7, chainId, networks;

        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _ref7 = (transitWallet === null || transitWallet === void 0 ? void 0 : (_transitWallet$ctx = transitWallet.ctx) === null || _transitWallet$ctx === void 0 ? void 0 : _transitWallet$ctx.network) || {}, chainId = _ref7.chainId;

                if (chainId) {
                  _context16.next = 3;
                  break;
                }

                return _context16.abrupt("return", null);

              case 3:
                _context16.next = 5;
                return this._oreIdContext.settings.getAllChainNetworkSettings();

              case 5:
                networks = _context16.sent;
                return _context16.abrupt("return", (_networks$find = networks.find(function (net) {
                  return net.hosts.find(function (host) {
                    return host.chainId === chainId;
                  });
                })) === null || _networks$find === void 0 ? void 0 : _networks$find.network);

              case 7:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getChainNetworkFromTransitWallet(_x28) {
        return _getChainNetworkFromTransitWallet.apply(this, arguments);
      }

      return getChainNetworkFromTransitWallet;
    }()
    /** Add the account selected in the transitWallet to the ORE account's list of account/permissions */

  }, {
    key: "updateOreAccountPermissionsfromTransitWalletAuth",
    value: function () {
      var _updateOreAccountPermissionsfromTransitWalletAuth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(transitWallet, walletType) {
        var _transitWallet$auth2, accountName, permission, publicKey, permissions, transitChainNetwork, _this$_user2;

        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                if (!(!(transitWallet !== null && transitWallet !== void 0 && transitWallet.connected) || !(transitWallet !== null && transitWallet !== void 0 && transitWallet.auth))) {
                  _context17.next = 2;
                  break;
                }

                return _context17.abrupt("return");

              case 2:
                _transitWallet$auth2 = transitWallet.auth, accountName = _transitWallet$auth2.accountName, permission = _transitWallet$auth2.permission, publicKey = _transitWallet$auth2.publicKey; // abort silently if account is missing some info - some chains/wallets (e.g. ethereum) dont provide the public key, so we can't add the perm here

                if (!(!accountName || !permission || !publicKey)) {
                  _context17.next = 5;
                  break;
                }

                return _context17.abrupt("return");

              case 5:
                permissions = [{
                  name: permission,
                  publicKey: publicKey
                }]; // todo: add parent permission when available
                // Get the chainNetwork from the transitWallet - in case the wallet provider switches networks somehow

                _context17.next = 8;
                return this.getChainNetworkFromTransitWallet(transitWallet);

              case 8:
                transitChainNetwork = _context17.sent;

                if (!transitChainNetwork) {
                  _context17.next = 12;
                  break;
                }

                _context17.next = 12;
                return (_this$_user2 = this._user) === null || _this$_user2 === void 0 ? void 0 : _this$_user2.updatePermissionsIfNecessary({
                  chainAccount: accountName,
                  chainNetwork: transitChainNetwork,
                  permissions: permissions,
                  walletType: walletType
                });

              case 12:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function updateOreAccountPermissionsfromTransitWalletAuth(_x29, _x30) {
        return _updateOreAccountPermissionsfromTransitWalletAuth.apply(this, arguments);
      }

      return updateOreAccountPermissionsfromTransitWalletAuth;
    }()
  }, {
    key: "isTransitProvider",
    value: function isTransitProvider(provider) {
      var walletProviderType = _utils_helpers__WEBPACK_IMPORTED_MODULE_3__["default"].mapAuthProviderToWalletType(provider);
      if (!walletProviderType) return false;
      return _transitProviders__WEBPACK_IMPORTED_MODULE_2__.supportedTransitProviders.includes(walletProviderType);
    }
    /** Whether this Eos Transit provider was installed upon instantiation */

  }, {
    key: "hasTransitProvider",
    value: function hasTransitProvider(walletType) {
      return this._oreIdContext.transitProvidersInstalled.includes(walletType);
    }
    /** Throw if the provider doesnt support the specified chainNetwork */

  }, {
    key: "assertProviderValidForChainNetwork",
    value: function () {
      var _assertProviderValidForChainNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(walletType, chainNetwork) {
        var _getTransitProviderAt5, chainType, networks, isValid;

        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _getTransitProviderAt5 = (0,_transitProviders__WEBPACK_IMPORTED_MODULE_2__.getTransitProviderAttributes)(walletType), chainType = _getTransitProviderAt5.chainType;
                _context18.next = 3;
                return this._oreIdContext.settings.getAllChainNetworkSettings();

              case 3:
                networks = _context18.sent;
                isValid = !!networks.find(function (n) {
                  return n.network === chainNetwork && n.type === chainType;
                });

                if (isValid) {
                  _context18.next = 7;
                  break;
                }

                throw Error("External Wallet Type: ".concat(walletType, " doesnt support chainNetwork ").concat(chainNetwork, ". Hint: It supports networks of type ").concat(chainType, "."));

              case 7:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function assertProviderValidForChainNetwork(_x31, _x32) {
        return _assertProviderValidForChainNetwork.apply(this, arguments);
      }

      return assertProviderValidForChainNetwork;
    }()
  }, {
    key: "waitWhileWalletIsBusy",
    value: function () {
      var _waitWhileWalletIsBusy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(transitWallet, walletType) {
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (!transitWallet.inProgress) {
                  _context19.next = 7;
                  break;
                }

                this._oreIdContext.setIsBusy(true); // todo: add timeout
                // eslint-disable-next-line no-await-in-loop


                _context19.next = 4;
                return _utils_helpers__WEBPACK_IMPORTED_MODULE_3__["default"].sleep(250);

              case 4:
                // this is here to help a developer debug - dont remove this - if a wallet is not open to connect to, it will hang here
                console.log("connecting to ".concat(walletType, " via eos-transit wallet in progress:"), transitWallet.inProgress);
                _context19.next = 0;
                break;

              case 7:
                this._oreIdContext.setIsBusy(false);

              case 8:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function waitWhileWalletIsBusy(_x33, _x34) {
        return _waitWhileWalletIsBusy.apply(this, arguments);
      }

      return waitWhileWalletIsBusy;
    }()
    /** Discovers keys in a wallet provider.
     *  Any new keys discovered in wallet are added to user's ORE ID record.
     *  If the provider doesnt support a discover() function, and requiresLogoutLoginToDiscover == true, attempts a logout then login instead.
     */

  }, {
    key: "discover",
    value: function () {
      var _discover = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(discoverOptions) {
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                return _context20.abrupt("return", this.discoverWithTransit(discoverOptions));

              case 1:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function discover(_x35) {
        return _discover.apply(this, arguments);
      }

      return discover;
    }()
    /** Call discover after signing so we capture and save the account
     *  Note: This is needed for Ethereum since we dont know a public key until we sign with an account
     */

  }, {
    key: "callDiscoverAfterSign",
    value: function () {
      var _callDiscoverAfterSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(transactionData) {
        var chainNetwork, account, _ref8, provider, walletProvider, discoverOptions;

        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                chainNetwork = transactionData.chainNetwork, account = transactionData.account;
                _ref8 = (transactionData === null || transactionData === void 0 ? void 0 : transactionData.signOptions) || {}, provider = _ref8.provider;
                walletProvider = _utils_helpers__WEBPACK_IMPORTED_MODULE_3__["default"].mapAuthProviderToWalletType(provider);
                discoverOptions = {
                  walletType: walletProvider,
                  chainNetwork: chainNetwork,
                  oreAccount: account
                };
                _context21.next = 6;
                return this.discover(discoverOptions);

              case 6:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function callDiscoverAfterSign(_x36) {
        return _callDiscoverAfterSign.apply(this, arguments);
      }

      return callDiscoverAfterSign;
    }() // Supported features by provider

    /** whether discovery is supported by the provider */

  }, {
    key: "canDiscover",
    value: function canDiscover(walletType) {
      if (this.hasTransitProvider(walletType)) {
        return (0,_transitProviders__WEBPACK_IMPORTED_MODULE_2__.getTransitProviderAttributes)(walletType).supportsDiscovery;
      }

      return false;
    }
    /** whether signString is supported by the provider */

  }, {
    key: "canSignString",
    value: function canSignString(walletType) {
      if (this.hasTransitProvider(walletType)) {
        return (0,_transitProviders__WEBPACK_IMPORTED_MODULE_2__.getTransitProviderAttributes)(walletType).supportsSignArbitrary;
      }

      return false;
    }
    /** whether call to discover is required by provider before login */

  }, {
    key: "requiresDiscoverToLogin",
    value: function requiresDiscoverToLogin(walletType) {
      if (this.hasTransitProvider(walletType)) {
        return (0,_transitProviders__WEBPACK_IMPORTED_MODULE_2__.getTransitProviderAttributes)(walletType).requiresDiscoverToLogin;
      }

      return false;
    }
    /** whether call to logout then login is required by provider before discover */

  }, {
    key: "requiresLogoutLoginToDiscover",
    value: function requiresLogoutLoginToDiscover(walletType) {
      if (this.hasTransitProvider(walletType)) {
        return (0,_transitProviders__WEBPACK_IMPORTED_MODULE_2__.getTransitProviderAttributes)(walletType).requiresLogoutLoginToDiscover;
      }

      return false;
    }
    /** default path index for provider (if any) */

  }, {
    key: "defaultDiscoveryPathIndexList",
    value: function defaultDiscoveryPathIndexList(walletType) {
      if (this.hasTransitProvider(walletType)) {
        var _getTransitProviderAt6;

        return (_getTransitProviderAt6 = (0,_transitProviders__WEBPACK_IMPORTED_MODULE_2__.getTransitProviderAttributes)(walletType)) === null || _getTransitProviderAt6 === void 0 ? void 0 : _getTransitProviderAt6.defaultDiscoveryPathIndexList;
      }

      return null;
    }
    /** help text displayed to user for provider */

  }, {
    key: "helpTextForProvider",
    value: function helpTextForProvider(walletType) {
      if (this.hasTransitProvider(walletType)) {
        return (0,_transitProviders__WEBPACK_IMPORTED_MODULE_2__.getTransitProviderAttributes)(walletType).helpText;
      }

      return null;
    }
  }]);

  return TransitHelper;
}();



/***/ }),
/* 42 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var walletAccessContext_1 = __webpack_require__(43);
exports.initAccessContext = walletAccessContext_1.initAccessContext;
var wallet_1 = __webpack_require__(56);
var wallet_2 = __webpack_require__(56);
exports.initWallet = wallet_2.initWallet;
function initDefaultAccessContext(options) {
    exports.defaultAccessContext = walletAccessContext_1.initAccessContext(options);
    return exports.defaultAccessContext;
}
exports.initDefaultAccessContext = initDefaultAccessContext;
var WAL = {
    initDefaultAccessContext: initDefaultAccessContext,
    get accessContext() {
        if (!exports.defaultAccessContext) {
            throw new Error("\n        No default WalletAccessContext is configured. \n        Make sure to first run 'initDefaultAccessContext' to set it up.\n      ");
        }
        return exports.defaultAccessContext;
    },
    initWallet: wallet_1.initWallet
};
exports["default"] = WAL;
// force rebuild 2
//# sourceMappingURL=index.js.map

/***/ }),
/* 43 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var eosjs_1 = __webpack_require__(44);
var stateContainer_1 = __webpack_require__(55);
var wallet_1 = __webpack_require__(56);
var util_1 = __webpack_require__(60);
var DEFAULT_CONTEXT_STATE = {
    wallets: []
};
function findProviderById(walletProviders, providerId) {
    if (!walletProviders.length)
        return void 0;
    return walletProviders.find(function (wp) { return wp.id === providerId; });
}
function initAccessContext(options) {
    var appName = options.appName, network = options.network, isNotEosNetwork = options.isNotEosNetwork;
    var _makeWalletProviderFns = options.walletProviders;
    var walletProviders = _makeWalletProviderFns.map(function (makeWalletProvider) { return makeWalletProvider(network); });
    var _stateContainer = stateContainer_1.makeStateContainer(DEFAULT_CONTEXT_STATE);
    var _listeners = [];
    function _handleUpdate() {
        for (var _i = 0, _listeners_1 = _listeners; _i < _listeners_1.length; _i++) {
            var listener = _listeners_1[_i];
            listener(ctx);
        }
    }
    var _walletUnsubscribeFns = new Map();
    var stateUnsubscribe = _stateContainer.subscribe(_handleUpdate);
    var eosRpc;
    if (!isNotEosNetwork) {
        var eosRpcUrl = util_1.getNetworkUrl(network);
        eosRpc = new eosjs_1.JsonRpc(eosRpcUrl);
    }
    var ctx = {
        appName: appName,
        eosRpc: eosRpc,
        network: network,
        initWallet: function (walletProvider) {
            var _walletProvider = typeof walletProvider === 'string' ? findProviderById(walletProviders, walletProvider) : walletProvider;
            if (!_walletProvider) {
                throw new Error("\n          Cannot initiate a session, invalid wallet provider\n          or wallet provider ID was passed\n        ");
            }
            var newWallet = wallet_1.initWallet(_walletProvider, ctx);
            _stateContainer.updateState(function (state) { return ({
                wallets: ((state && state.wallets) || []).concat([newWallet])
            }); });
            // Subscribe to a new wallet updates immediately
            _walletUnsubscribeFns.set(newWallet._instanceId, newWallet.subscribe(_handleUpdate));
            return newWallet;
        },
        addWalletProvider: function (walletProvider) {
            walletProviders.push(walletProvider(network));
        },
        getWalletProviders: function () {
            return walletProviders;
        },
        getWallets: function () {
            var state = _stateContainer.getState();
            if (!state)
                return [];
            return state.wallets || [];
        },
        getActiveWallets: function () {
            return ctx.getWallets().filter(function (wallet) { return wallet.connected && wallet.authenticated; });
        },
        detachWallet: function (wallet) {
            _stateContainer.updateState(function (state) { return ({
                wallets: ((state && state.wallets) || []).filter(function (w) { return w !== wallet; })
            }); });
            var _instanceId = wallet._instanceId;
            if (_walletUnsubscribeFns.has(_instanceId)) {
                var unsubscribe = _walletUnsubscribeFns.get(_instanceId);
                if (typeof unsubscribe === 'function')
                    unsubscribe();
            }
        },
        logoutAll: function () {
            return Promise.all(ctx.getWallets().map(function (wallet) { return wallet.logout(); })).then(function () { return true; });
        },
        disconnectAll: function () {
            return Promise.all(ctx.getWallets().map(function (wallet) { return wallet.disconnect(); })).then(function () { return true; });
        },
        terminateAll: function () {
            return Promise.all(ctx.getWallets().map(function (wallet) { return wallet.terminate(); })).then(function () { return true; });
        },
        destroy: function () {
            return ctx.terminateAll().then(function () {
                stateUnsubscribe();
                _walletUnsubscribeFns.forEach(function (unsubscribeFn) {
                    if (typeof unsubscribeFn === 'function')
                        unsubscribeFn();
                });
                _listeners = [];
            });
        },
        subscribe: function (listener) {
            _listeners = _listeners.concat([listener]);
            return function unsubscribe() {
                _listeners = _listeners.filter(function (l) { return l !== listener; });
            };
        }
    };
    return ctx;
}
exports.initAccessContext = initAccessContext;
//# sourceMappingURL=walletAccessContext.js.map

/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var eosjs_api_1 = __webpack_require__(45);
exports.Api = eosjs_api_1.Api;
var ApiInterfaces = __webpack_require__(51);
exports.ApiInterfaces = ApiInterfaces;
var eosjs_jsonrpc_1 = __webpack_require__(52);
exports.JsonRpc = eosjs_jsonrpc_1.JsonRpc;
var Numeric = __webpack_require__(47);
exports.Numeric = Numeric;
var RpcInterfaces = __webpack_require__(54);
exports.RpcInterfaces = RpcInterfaces;
var eosjs_rpcerror_1 = __webpack_require__(53);
exports.RpcError = eosjs_rpcerror_1.RpcError;
var Serialize = __webpack_require__(46);
exports.Serialize = Serialize;
//# sourceMappingURL=index.js.map

/***/ }),
/* 45 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @module API
 */
// copyright defined in eosjs/LICENSE.txt
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ser = __webpack_require__(46);
var abiAbi = __webpack_require__(49);
var transactionAbi = __webpack_require__(50);
var Api = /** @class */ (function () {
    /**
     * @param args
     *    * `rpc`: Issues RPC calls
     *    * `authorityProvider`: Get public keys needed to meet authorities in a transaction
     *    * `abiProvider`: Supplies ABIs in raw form (binary)
     *    * `signatureProvider`: Signs transactions
     *    * `chainId`: Identifies chain
     *    * `textEncoder`: `TextEncoder` instance to use. Pass in `null` if running in a browser
     *    * `textDecoder`: `TextDecoder` instance to use. Pass in `null` if running in a browser
     */
    function Api(args) {
        /** Holds information needed to serialize contract actions */
        this.contracts = new Map();
        /** Fetched abis */
        this.cachedAbis = new Map();
        this.rpc = args.rpc;
        this.authorityProvider = args.authorityProvider || args.rpc;
        this.abiProvider = args.abiProvider || args.rpc;
        this.signatureProvider = args.signatureProvider;
        this.chainId = args.chainId;
        this.textEncoder = args.textEncoder;
        this.textDecoder = args.textDecoder;
        this.abiTypes = ser.getTypesFromAbi(ser.createInitialTypes(), abiAbi);
        this.transactionTypes = ser.getTypesFromAbi(ser.createInitialTypes(), transactionAbi);
    }
    /** Decodes an abi as Uint8Array into json. */
    Api.prototype.rawAbiToJson = function (rawAbi) {
        var buffer = new ser.SerialBuffer({
            textEncoder: this.textEncoder,
            textDecoder: this.textDecoder,
            array: rawAbi,
        });
        if (!ser.supportedAbiVersion(buffer.getString())) {
            throw new Error('Unsupported abi version');
        }
        buffer.restartRead();
        return this.abiTypes.get('abi_def').deserialize(buffer);
    };
    /** Get abi in both binary and structured forms. Fetch when needed. */
    Api.prototype.getCachedAbi = function (accountName, reload) {
        if (reload === void 0) { reload = false; }
        return __awaiter(this, void 0, void 0, function () {
            var cachedAbi, rawAbi, abi, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!reload && this.cachedAbis.get(accountName)) {
                            return [2 /*return*/, this.cachedAbis.get(accountName)];
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.abiProvider.getRawAbi(accountName)];
                    case 2:
                        rawAbi = (_a.sent()).abi;
                        abi = this.rawAbiToJson(rawAbi);
                        cachedAbi = { rawAbi: rawAbi, abi: abi };
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        e_1.message = "fetching abi for " + accountName + ": " + e_1.message;
                        throw e_1;
                    case 4:
                        if (!cachedAbi) {
                            throw new Error("Missing abi for " + accountName);
                        }
                        this.cachedAbis.set(accountName, cachedAbi);
                        return [2 /*return*/, cachedAbi];
                }
            });
        });
    };
    /** Get abi in structured form. Fetch when needed. */
    Api.prototype.getAbi = function (accountName, reload) {
        if (reload === void 0) { reload = false; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getCachedAbi(accountName, reload)];
                    case 1: return [2 /*return*/, (_a.sent()).abi];
                }
            });
        });
    };
    /** Get abis needed by a transaction */
    Api.prototype.getTransactionAbis = function (transaction, reload) {
        if (reload === void 0) { reload = false; }
        return __awaiter(this, void 0, void 0, function () {
            var accounts, uniqueAccounts, actionPromises;
            var _this = this;
            return __generator(this, function (_a) {
                accounts = transaction.actions.map(function (action) { return action.account; });
                uniqueAccounts = new Set(accounts);
                actionPromises = __spread(uniqueAccounts).map(function (account) { return __awaiter(_this, void 0, void 0, function () {
                    var _a;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                _a = {
                                    accountName: account
                                };
                                return [4 /*yield*/, this.getCachedAbi(account, reload)];
                            case 1: return [2 /*return*/, (_a.abi = (_b.sent()).rawAbi,
                                    _a)];
                        }
                    });
                }); });
                return [2 /*return*/, Promise.all(actionPromises)];
            });
        });
    };
    /** Get data needed to serialize actions in a contract */
    Api.prototype.getContract = function (accountName, reload) {
        if (reload === void 0) { reload = false; }
        return __awaiter(this, void 0, void 0, function () {
            var e_2, _a, abi, types, actions, _b, _c, _d, name_1, type, result;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!reload && this.contracts.get(accountName)) {
                            return [2 /*return*/, this.contracts.get(accountName)];
                        }
                        return [4 /*yield*/, this.getAbi(accountName, reload)];
                    case 1:
                        abi = _e.sent();
                        types = ser.getTypesFromAbi(ser.createInitialTypes(), abi);
                        actions = new Map();
                        try {
                            for (_b = __values(abi.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
                                _d = _c.value, name_1 = _d.name, type = _d.type;
                                actions.set(name_1, ser.getType(types, type));
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        result = { types: types, actions: actions };
                        this.contracts.set(accountName, result);
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /** Convert `value` to binary form. `type` must be a built-in abi type or in `transaction.abi.json`. */
    Api.prototype.serialize = function (buffer, type, value) {
        this.transactionTypes.get(type).serialize(buffer, value);
    };
    /** Convert data in `buffer` to structured form. `type` must be a built-in abi type or in `transaction.abi.json`. */
    Api.prototype.deserialize = function (buffer, type) {
        return this.transactionTypes.get(type).deserialize(buffer);
    };
    /** Convert a transaction to binary */
    Api.prototype.serializeTransaction = function (transaction) {
        var buffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
        this.serialize(buffer, 'transaction', __assign({ max_net_usage_words: 0, max_cpu_usage_ms: 0, delay_sec: 0, context_free_actions: [], actions: [], transaction_extensions: [] }, transaction));
        return buffer.asUint8Array();
    };
    /** Convert a transaction from binary. Leaves actions in hex. */
    Api.prototype.deserializeTransaction = function (transaction) {
        var buffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
        buffer.pushArray(transaction);
        return this.deserialize(buffer, 'transaction');
    };
    /** Convert actions to hex */
    Api.prototype.serializeActions = function (actions) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.all(actions.map(function (_a) {
                            var account = _a.account, name = _a.name, authorization = _a.authorization, data = _a.data;
                            return __awaiter(_this, void 0, void 0, function () {
                                var contract;
                                return __generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0: return [4 /*yield*/, this.getContract(account)];
                                        case 1:
                                            contract = _b.sent();
                                            return [2 /*return*/, ser.serializeAction(contract, account, name, authorization, data, this.textEncoder, this.textDecoder)];
                                    }
                                });
                            });
                        }))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** Convert actions from hex */
    Api.prototype.deserializeActions = function (actions) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.all(actions.map(function (_a) {
                            var account = _a.account, name = _a.name, authorization = _a.authorization, data = _a.data;
                            return __awaiter(_this, void 0, void 0, function () {
                                var contract;
                                return __generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0: return [4 /*yield*/, this.getContract(account)];
                                        case 1:
                                            contract = _b.sent();
                                            return [2 /*return*/, ser.deserializeAction(contract, account, name, authorization, data, this.textEncoder, this.textDecoder)];
                                    }
                                });
                            });
                        }))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** Convert a transaction from binary. Also deserializes actions. */
    Api.prototype.deserializeTransactionWithActions = function (transaction) {
        return __awaiter(this, void 0, void 0, function () {
            var deserializedTransaction, deserializedActions;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (typeof transaction === 'string') {
                            transaction = ser.hexToUint8Array(transaction);
                        }
                        deserializedTransaction = this.deserializeTransaction(transaction);
                        return [4 /*yield*/, this.deserializeActions(deserializedTransaction.actions)];
                    case 1:
                        deserializedActions = _a.sent();
                        return [2 /*return*/, __assign({}, deserializedTransaction, { actions: deserializedActions })];
                }
            });
        });
    };
    /**
     * Create and optionally broadcast a transaction.
     *
     * Named Parameters:
     *    * `broadcast`: broadcast this transaction?
     *    * `sign`: sign this transaction?
     *    * If both `blocksBehind` and `expireSeconds` are present,
     *      then fetch the block which is `blocksBehind` behind head block,
     *      use it as a reference for TAPoS, and expire the transaction `expireSeconds` after that block's time.
     * @returns node response if `broadcast`, `{signatures, serializedTransaction}` if `!broadcast`
     */
    Api.prototype.transact = function (transaction, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.broadcast, broadcast = _c === void 0 ? true : _c, _d = _b.sign, sign = _d === void 0 ? true : _d, blocksBehind = _b.blocksBehind, expireSeconds = _b.expireSeconds;
        return __awaiter(this, void 0, void 0, function () {
            var info, refBlock, abis, _e, _f, serializedTransaction, pushTransactionArgs, availableKeys, requiredKeys;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        if (!!this.chainId) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.rpc.get_info()];
                    case 1:
                        info = _g.sent();
                        this.chainId = info.chain_id;
                        _g.label = 2;
                    case 2:
                        if (!(typeof blocksBehind === 'number' && expireSeconds)) return [3 /*break*/, 6];
                        if (!!info) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.rpc.get_info()];
                    case 3:
                        info = _g.sent();
                        _g.label = 4;
                    case 4: return [4 /*yield*/, this.rpc.get_block(info.head_block_num - blocksBehind)];
                    case 5:
                        refBlock = _g.sent();
                        transaction = __assign({}, ser.transactionHeader(refBlock, expireSeconds), transaction);
                        _g.label = 6;
                    case 6:
                        if (!this.hasRequiredTaposFields(transaction)) {
                            throw new Error('Required configuration or TAPOS fields are not present');
                        }
                        return [4 /*yield*/, this.getTransactionAbis(transaction)];
                    case 7:
                        abis = _g.sent();
                        _e = [{}, transaction];
                        _f = {};
                        return [4 /*yield*/, this.serializeActions(transaction.actions)];
                    case 8:
                        transaction = __assign.apply(void 0, _e.concat([(_f.actions = _g.sent(), _f)]));
                        serializedTransaction = this.serializeTransaction(transaction);
                        pushTransactionArgs = { serializedTransaction: serializedTransaction, signatures: [] };
                        if (!sign) return [3 /*break*/, 12];
                        return [4 /*yield*/, this.signatureProvider.getAvailableKeys()];
                    case 9:
                        availableKeys = _g.sent();
                        return [4 /*yield*/, this.authorityProvider.getRequiredKeys({ transaction: transaction, availableKeys: availableKeys })];
                    case 10:
                        requiredKeys = _g.sent();
                        return [4 /*yield*/, this.signatureProvider.sign({
                                chainId: this.chainId,
                                requiredKeys: requiredKeys,
                                serializedTransaction: serializedTransaction,
                                abis: abis,
                            })];
                    case 11:
                        pushTransactionArgs = _g.sent();
                        _g.label = 12;
                    case 12:
                        if (broadcast) {
                            return [2 /*return*/, this.pushSignedTransaction(pushTransactionArgs)];
                        }
                        return [2 /*return*/, pushTransactionArgs];
                }
            });
        });
    };
    /** Broadcast a signed transaction */
    Api.prototype.pushSignedTransaction = function (_a) {
        var signatures = _a.signatures, serializedTransaction = _a.serializedTransaction;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                return [2 /*return*/, this.rpc.push_transaction({
                        signatures: signatures,
                        serializedTransaction: serializedTransaction,
                    })];
            });
        });
    };
    // eventually break out into TransactionValidator class
    Api.prototype.hasRequiredTaposFields = function (_a) {
        var expiration = _a.expiration, ref_block_num = _a.ref_block_num, ref_block_prefix = _a.ref_block_prefix, transaction = __rest(_a, ["expiration", "ref_block_num", "ref_block_prefix"]);
        return !!(expiration && ref_block_num && ref_block_prefix);
    };
    return Api;
}()); // Api
exports.Api = Api;
//# sourceMappingURL=eosjs-api.js.map

/***/ }),
/* 46 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @module Serialize
 */
// copyright defined in eosjs/LICENSE.txt
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var numeric = __webpack_require__(47);
/** State for serialize() and deserialize() */
var SerializerState = /** @class */ (function () {
    function SerializerState(options) {
        if (options === void 0) { options = {}; }
        /** Have any binary extensions been skipped? */
        this.skippedBinaryExtension = false;
        this.options = options;
    }
    return SerializerState;
}());
exports.SerializerState = SerializerState;
/** Serialize and deserialize data */
var SerialBuffer = /** @class */ (function () {
    /**
     * @param __namedParameters
     *    * `array`: `null` if serializing, or binary data to deserialize
     *    * `textEncoder`: `TextEncoder` instance to use. Pass in `null` if running in a browser
     *    * `textDecoder`: `TextDecider` instance to use. Pass in `null` if running in a browser
     */
    function SerialBuffer(_a) {
        var _b = _a === void 0 ? {} : _a, textEncoder = _b.textEncoder, textDecoder = _b.textDecoder, array = _b.array;
        /** Current position while reading (deserializing) */
        this.readPos = 0;
        this.array = array || new Uint8Array(1024);
        this.length = array ? array.length : 0;
        this.textEncoder = textEncoder || new TextEncoder();
        this.textDecoder = textDecoder || new TextDecoder('utf-8', { fatal: true });
    }
    /** Resize `array` if needed to have at least `size` bytes free */
    SerialBuffer.prototype.reserve = function (size) {
        if (this.length + size <= this.array.length) {
            return;
        }
        var l = this.array.length;
        while (this.length + size > l) {
            l = Math.ceil(l * 1.5);
        }
        var newArray = new Uint8Array(l);
        newArray.set(this.array);
        this.array = newArray;
    };
    /** Is there data available to read? */
    SerialBuffer.prototype.haveReadData = function () {
        return this.readPos < this.length;
    };
    /** Restart reading from the beginning */
    SerialBuffer.prototype.restartRead = function () {
        this.readPos = 0;
    };
    /** Return data with excess storage trimmed away */
    SerialBuffer.prototype.asUint8Array = function () {
        return new Uint8Array(this.array.buffer, this.array.byteOffset, this.length);
    };
    /** Append bytes */
    SerialBuffer.prototype.pushArray = function (v) {
        this.reserve(v.length);
        this.array.set(v, this.length);
        this.length += v.length;
    };
    /** Append bytes */
    SerialBuffer.prototype.push = function () {
        var v = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            v[_i] = arguments[_i];
        }
        this.pushArray(v);
    };
    /** Get a single byte */
    SerialBuffer.prototype.get = function () {
        if (this.readPos < this.length) {
            return this.array[this.readPos++];
        }
        throw new Error('Read past end of buffer');
    };
    /** Append bytes in `v`. Throws if `len` doesn't match `v.length` */
    SerialBuffer.prototype.pushUint8ArrayChecked = function (v, len) {
        if (v.length !== len) {
            throw new Error('Binary data has incorrect size');
        }
        this.pushArray(v);
    };
    /** Get `len` bytes */
    SerialBuffer.prototype.getUint8Array = function (len) {
        if (this.readPos + len > this.length) {
            throw new Error('Read past end of buffer');
        }
        var result = new Uint8Array(this.array.buffer, this.array.byteOffset + this.readPos, len);
        this.readPos += len;
        return result;
    };
    /** Append a `uint16` */
    SerialBuffer.prototype.pushUint16 = function (v) {
        this.push((v >> 0) & 0xff, (v >> 8) & 0xff);
    };
    /** Get a `uint16` */
    SerialBuffer.prototype.getUint16 = function () {
        var v = 0;
        v |= this.get() << 0;
        v |= this.get() << 8;
        return v;
    };
    /** Append a `uint32` */
    SerialBuffer.prototype.pushUint32 = function (v) {
        this.push((v >> 0) & 0xff, (v >> 8) & 0xff, (v >> 16) & 0xff, (v >> 24) & 0xff);
    };
    /** Get a `uint32` */
    SerialBuffer.prototype.getUint32 = function () {
        var v = 0;
        v |= this.get() << 0;
        v |= this.get() << 8;
        v |= this.get() << 16;
        v |= this.get() << 24;
        return v >>> 0;
    };
    /** Append a `uint64`. *Caution*: `number` only has 53 bits of precision */
    SerialBuffer.prototype.pushNumberAsUint64 = function (v) {
        this.pushUint32(v >>> 0);
        this.pushUint32(Math.floor(v / 4294967296) >>> 0);
    };
    /**
     * Get a `uint64` as a `number`. *Caution*: `number` only has 53 bits of precision; some values will change.
     * `numeric.binaryToDecimal(serialBuffer.getUint8Array(8))` recommended instead
     */
    SerialBuffer.prototype.getUint64AsNumber = function () {
        var low = this.getUint32();
        var high = this.getUint32();
        return (high >>> 0) * 4294967296 + (low >>> 0);
    };
    /** Append a `varuint32` */
    SerialBuffer.prototype.pushVaruint32 = function (v) {
        while (true) {
            if (v >>> 7) {
                this.push(0x80 | (v & 0x7f));
                v = v >>> 7;
            }
            else {
                this.push(v);
                break;
            }
        }
    };
    /** Get a `varuint32` */
    SerialBuffer.prototype.getVaruint32 = function () {
        var v = 0;
        var bit = 0;
        while (true) {
            var b = this.get();
            v |= (b & 0x7f) << bit;
            bit += 7;
            if (!(b & 0x80)) {
                break;
            }
        }
        return v >>> 0;
    };
    /** Append a `varint32` */
    SerialBuffer.prototype.pushVarint32 = function (v) {
        this.pushVaruint32((v << 1) ^ (v >> 31));
    };
    /** Get a `varint32` */
    SerialBuffer.prototype.getVarint32 = function () {
        var v = this.getVaruint32();
        if (v & 1) {
            return ((~v) >> 1) | 2147483648;
        }
        else {
            return v >>> 1;
        }
    };
    /** Append a `float32` */
    SerialBuffer.prototype.pushFloat32 = function (v) {
        this.pushArray(new Uint8Array((new Float32Array([v])).buffer));
    };
    /** Get a `float32` */
    SerialBuffer.prototype.getFloat32 = function () {
        return new Float32Array(this.getUint8Array(4).slice().buffer)[0];
    };
    /** Append a `float64` */
    SerialBuffer.prototype.pushFloat64 = function (v) {
        this.pushArray(new Uint8Array((new Float64Array([v])).buffer));
    };
    /** Get a `float64` */
    SerialBuffer.prototype.getFloat64 = function () {
        return new Float64Array(this.getUint8Array(8).slice().buffer)[0];
    };
    /** Append a `name` */
    SerialBuffer.prototype.pushName = function (s) {
        if (typeof s !== 'string') {
            throw new Error('Expected string containing name');
        }
        function charToSymbol(c) {
            if (c >= 'a'.charCodeAt(0) && c <= 'z'.charCodeAt(0)) {
                return (c - 'a'.charCodeAt(0)) + 6;
            }
            if (c >= '1'.charCodeAt(0) && c <= '5'.charCodeAt(0)) {
                return (c - '1'.charCodeAt(0)) + 1;
            }
            return 0;
        }
        var a = new Uint8Array(8);
        var bit = 63;
        for (var i = 0; i < s.length; ++i) {
            var c = charToSymbol(s.charCodeAt(i));
            if (bit < 5) {
                c = c << 1;
            }
            for (var j = 4; j >= 0; --j) {
                if (bit >= 0) {
                    a[Math.floor(bit / 8)] |= ((c >> j) & 1) << (bit % 8);
                    --bit;
                }
            }
        }
        this.pushArray(a);
    };
    /** Get a `name` */
    SerialBuffer.prototype.getName = function () {
        var a = this.getUint8Array(8);
        var result = '';
        for (var bit = 63; bit >= 0;) {
            var c = 0;
            for (var i = 0; i < 5; ++i) {
                if (bit >= 0) {
                    c = (c << 1) | ((a[Math.floor(bit / 8)] >> (bit % 8)) & 1);
                    --bit;
                }
            }
            if (c >= 6) {
                result += String.fromCharCode(c + 'a'.charCodeAt(0) - 6);
            }
            else if (c >= 1) {
                result += String.fromCharCode(c + '1'.charCodeAt(0) - 1);
            }
            else {
                result += '.';
            }
        }
        while (result.endsWith('.')) {
            result = result.substr(0, result.length - 1);
        }
        return result;
    };
    /** Append length-prefixed binary data */
    SerialBuffer.prototype.pushBytes = function (v) {
        this.pushVaruint32(v.length);
        this.pushArray(v);
    };
    /** Get length-prefixed binary data */
    SerialBuffer.prototype.getBytes = function () {
        return this.getUint8Array(this.getVaruint32());
    };
    /** Append a string */
    SerialBuffer.prototype.pushString = function (v) {
        this.pushBytes(this.textEncoder.encode(v));
    };
    /** Get a string */
    SerialBuffer.prototype.getString = function () {
        return this.textDecoder.decode(this.getBytes());
    };
    /** Append a `symbol_code`. Unlike `symbol`, `symbol_code` doesn't include a precision. */
    SerialBuffer.prototype.pushSymbolCode = function (name) {
        if (typeof name !== 'string') {
            throw new Error('Expected string containing symbol_code');
        }
        var a = [];
        a.push.apply(a, __spread(this.textEncoder.encode(name)));
        while (a.length < 8) {
            a.push(0);
        }
        this.pushArray(a.slice(0, 8));
    };
    /** Get a `symbol_code`. Unlike `symbol`, `symbol_code` doesn't include a precision. */
    SerialBuffer.prototype.getSymbolCode = function () {
        var a = this.getUint8Array(8);
        var len;
        for (len = 0; len < a.length; ++len) {
            if (!a[len]) {
                break;
            }
        }
        var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
        return name;
    };
    /** Append a `symbol` */
    SerialBuffer.prototype.pushSymbol = function (_a) {
        var name = _a.name, precision = _a.precision;
        var a = [precision & 0xff];
        a.push.apply(a, __spread(this.textEncoder.encode(name)));
        while (a.length < 8) {
            a.push(0);
        }
        this.pushArray(a.slice(0, 8));
    };
    /** Get a `symbol` */
    SerialBuffer.prototype.getSymbol = function () {
        var precision = this.get();
        var a = this.getUint8Array(7);
        var len;
        for (len = 0; len < a.length; ++len) {
            if (!a[len]) {
                break;
            }
        }
        var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
        return { name: name, precision: precision };
    };
    /** Append an asset */
    SerialBuffer.prototype.pushAsset = function (s) {
        if (typeof s !== 'string') {
            throw new Error('Expected string containing asset');
        }
        s = s.trim();
        var pos = 0;
        var amount = '';
        var precision = 0;
        if (s[pos] === '-') {
            amount += '-';
            ++pos;
        }
        var foundDigit = false;
        while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {
            foundDigit = true;
            amount += s[pos];
            ++pos;
        }
        if (!foundDigit) {
            throw new Error('Asset must begin with a number');
        }
        if (s[pos] === '.') {
            ++pos;
            while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {
                amount += s[pos];
                ++precision;
                ++pos;
            }
        }
        var name = s.substr(pos).trim();
        this.pushArray(numeric.signedDecimalToBinary(8, amount));
        this.pushSymbol({ name: name, precision: precision });
    };
    /** Get an asset */
    SerialBuffer.prototype.getAsset = function () {
        var amount = this.getUint8Array(8);
        var _a = this.getSymbol(), name = _a.name, precision = _a.precision;
        var s = numeric.signedBinaryToDecimal(amount, precision + 1);
        if (precision) {
            s = s.substr(0, s.length - precision) + '.' + s.substr(s.length - precision);
        }
        return s + ' ' + name;
    };
    /** Append a public key */
    SerialBuffer.prototype.pushPublicKey = function (s) {
        var key = numeric.stringToPublicKey(s);
        this.push(key.type);
        this.pushArray(key.data);
    };
    /** Get a public key */
    SerialBuffer.prototype.getPublicKey = function () {
        var type = this.get();
        var data = this.getUint8Array(numeric.publicKeyDataSize);
        return numeric.publicKeyToString({ type: type, data: data });
    };
    /** Append a private key */
    SerialBuffer.prototype.pushPrivateKey = function (s) {
        var key = numeric.stringToPrivateKey(s);
        this.push(key.type);
        this.pushArray(key.data);
    };
    /** Get a private key */
    SerialBuffer.prototype.getPrivateKey = function () {
        var type = this.get();
        var data = this.getUint8Array(numeric.privateKeyDataSize);
        return numeric.privateKeyToString({ type: type, data: data });
    };
    /** Append a signature */
    SerialBuffer.prototype.pushSignature = function (s) {
        var key = numeric.stringToSignature(s);
        this.push(key.type);
        this.pushArray(key.data);
    };
    /** Get a signature */
    SerialBuffer.prototype.getSignature = function () {
        var type = this.get();
        var data = this.getUint8Array(numeric.signatureDataSize);
        return numeric.signatureToString({ type: type, data: data });
    };
    return SerialBuffer;
}()); // SerialBuffer
exports.SerialBuffer = SerialBuffer;
/** Is this a supported ABI version? */
function supportedAbiVersion(version) {
    return version.startsWith('eosio::abi/1.');
}
exports.supportedAbiVersion = supportedAbiVersion;
function checkDateParse(date) {
    var result = Date.parse(date);
    if (Number.isNaN(result)) {
        throw new Error('Invalid time format');
    }
    return result;
}
/** Convert date in ISO format to `time_point` (miliseconds since epoch) */
function dateToTimePoint(date) {
    return Math.round(checkDateParse(date + 'Z') * 1000);
}
exports.dateToTimePoint = dateToTimePoint;
/** Convert `time_point` (miliseconds since epoch) to date in ISO format */
function timePointToDate(us) {
    var s = (new Date(us / 1000)).toISOString();
    return s.substr(0, s.length - 1);
}
exports.timePointToDate = timePointToDate;
/** Convert date in ISO format to `time_point_sec` (seconds since epoch) */
function dateToTimePointSec(date) {
    return Math.round(checkDateParse(date + 'Z') / 1000);
}
exports.dateToTimePointSec = dateToTimePointSec;
/** Convert `time_point_sec` (seconds since epoch) to to date in ISO format */
function timePointSecToDate(sec) {
    var s = (new Date(sec * 1000)).toISOString();
    return s.substr(0, s.length - 1);
}
exports.timePointSecToDate = timePointSecToDate;
/** Convert date in ISO format to `block_timestamp_type` (half-seconds since a different epoch) */
function dateToBlockTimestamp(date) {
    return Math.round((checkDateParse(date + 'Z') - 946684800000) / 500);
}
exports.dateToBlockTimestamp = dateToBlockTimestamp;
/** Convert `block_timestamp_type` (half-seconds since a different epoch) to to date in ISO format */
function blockTimestampToDate(slot) {
    var s = (new Date(slot * 500 + 946684800000)).toISOString();
    return s.substr(0, s.length - 1);
}
exports.blockTimestampToDate = blockTimestampToDate;
/** Convert `string` to `Symbol`. format: `precision,NAME`. */
function stringToSymbol(s) {
    if (typeof s !== 'string') {
        throw new Error('Expected string containing symbol');
    }
    var m = s.match(/^([0-9]+),([A-Z]+)$/);
    if (!m) {
        throw new Error('Invalid symbol');
    }
    return { name: m[2], precision: +m[1] };
}
exports.stringToSymbol = stringToSymbol;
/** Convert `Symbol` to `string`. format: `precision,NAME`. */
function symbolToString(_a) {
    var name = _a.name, precision = _a.precision;
    return precision + ',' + name;
}
exports.symbolToString = symbolToString;
/** Convert binary data to hex */
function arrayToHex(data) {
    var e_1, _a;
    var result = '';
    try {
        for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
            var x = data_1_1.value;
            result += ('00' + x.toString(16)).slice(-2);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result.toUpperCase();
}
exports.arrayToHex = arrayToHex;
/** Convert hex to binary data */
function hexToUint8Array(hex) {
    if (typeof hex !== 'string') {
        throw new Error('Expected string containing hex digits');
    }
    if (hex.length % 2) {
        throw new Error('Odd number of hex digits');
    }
    var l = hex.length / 2;
    var result = new Uint8Array(l);
    for (var i = 0; i < l; ++i) {
        var x = parseInt(hex.substr(i * 2, 2), 16);
        if (Number.isNaN(x)) {
            throw new Error('Expected hex string');
        }
        result[i] = x;
    }
    return result;
}
exports.hexToUint8Array = hexToUint8Array;
function serializeUnknown(buffer, data) {
    throw new Error('Don\'t know how to serialize ' + this.name);
}
function deserializeUnknown(buffer) {
    throw new Error('Don\'t know how to deserialize ' + this.name);
}
function serializeStruct(buffer, data, state, allowExtensions) {
    if (state === void 0) { state = new SerializerState(); }
    if (allowExtensions === void 0) { allowExtensions = true; }
    var e_2, _a;
    if (typeof data !== 'object') {
        throw new Error('expected object containing data: ' + JSON.stringify(data));
    }
    if (this.base) {
        this.base.serialize(buffer, data, state, allowExtensions);
    }
    try {
        for (var _b = __values(this.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
            var field = _c.value;
            if (field.name in data) {
                if (state.skippedBinaryExtension) {
                    throw new Error('unexpected ' + this.name + '.' + field.name);
                }
                field.type.serialize(buffer, data[field.name], state, allowExtensions && field === this.fields[this.fields.length - 1]);
            }
            else {
                if (allowExtensions && field.type.extensionOf) {
                    state.skippedBinaryExtension = true;
                }
                else {
                    throw new Error('missing ' + this.name + '.' + field.name + ' (type=' + field.type.name + ')');
                }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
}
function deserializeStruct(buffer, state, allowExtensions) {
    if (state === void 0) { state = new SerializerState(); }
    if (allowExtensions === void 0) { allowExtensions = true; }
    var e_3, _a;
    var result;
    if (this.base) {
        result = this.base.deserialize(buffer, state, allowExtensions);
    }
    else {
        result = {};
    }
    try {
        for (var _b = __values(this.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
            var field = _c.value;
            if (allowExtensions && field.type.extensionOf && !buffer.haveReadData()) {
                state.skippedBinaryExtension = true;
            }
            else {
                result[field.name] = field.type.deserialize(buffer, state, allowExtensions);
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return result;
}
function serializeVariant(buffer, data, state, allowExtensions) {
    if (!Array.isArray(data) || data.length !== 2 || typeof data[0] !== 'string') {
        throw new Error('expected variant: ["type", value]');
    }
    var i = this.fields.findIndex(function (field) { return field.name === data[0]; });
    if (i < 0) {
        throw new Error("type \"" + data[0] + "\" is not valid for variant");
    }
    buffer.pushVaruint32(i);
    this.fields[i].type.serialize(buffer, data[1], state, allowExtensions);
}
function deserializeVariant(buffer, state, allowExtensions) {
    var i = buffer.getVaruint32();
    if (i >= this.fields.length) {
        throw new Error("type index " + i + " is not valid for variant");
    }
    var field = this.fields[i];
    return [field.name, field.type.deserialize(buffer, state, allowExtensions)];
}
function serializeArray(buffer, data, state, allowExtensions) {
    var e_4, _a;
    buffer.pushVaruint32(data.length);
    try {
        for (var data_2 = __values(data), data_2_1 = data_2.next(); !data_2_1.done; data_2_1 = data_2.next()) {
            var item = data_2_1.value;
            this.arrayOf.serialize(buffer, item, state, false);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (data_2_1 && !data_2_1.done && (_a = data_2.return)) _a.call(data_2);
        }
        finally { if (e_4) throw e_4.error; }
    }
}
function deserializeArray(buffer, state, allowExtensions) {
    var len = buffer.getVaruint32();
    var result = [];
    for (var i = 0; i < len; ++i) {
        result.push(this.arrayOf.deserialize(buffer, state, false));
    }
    return result;
}
function serializeOptional(buffer, data, state, allowExtensions) {
    if (data === null || data === undefined) {
        buffer.push(0);
    }
    else {
        buffer.push(1);
        this.optionalOf.serialize(buffer, data, state, allowExtensions);
    }
}
function deserializeOptional(buffer, state, allowExtensions) {
    if (buffer.get()) {
        return this.optionalOf.deserialize(buffer, state, allowExtensions);
    }
    else {
        return null;
    }
}
function serializeExtension(buffer, data, state, allowExtensions) {
    this.extensionOf.serialize(buffer, data, state, allowExtensions);
}
function deserializeExtension(buffer, state, allowExtensions) {
    return this.extensionOf.deserialize(buffer, state, allowExtensions);
}
function createType(attrs) {
    return __assign({ name: '<missing name>', aliasOfName: '', arrayOf: null, optionalOf: null, extensionOf: null, baseName: '', base: null, fields: [], serialize: serializeUnknown, deserialize: deserializeUnknown }, attrs);
}
function checkRange(orig, converted) {
    if (Number.isNaN(+orig) || Number.isNaN(+converted) || (typeof orig !== 'number' && typeof orig !== 'string')) {
        throw new Error('Expected number');
    }
    if (+orig !== +converted) {
        throw new Error('Number is out of range');
    }
    return +orig;
}
/** Create the set of types built-in to the abi format */
function createInitialTypes() {
    var result = new Map(Object.entries({
        bool: createType({
            name: 'bool',
            serialize: function (buffer, data) {
                if (typeof data !== 'boolean') {
                    throw new Error('Expected true or false');
                }
                buffer.push(data ? 1 : 0);
            },
            deserialize: function (buffer) { return !!buffer.get(); },
        }),
        uint8: createType({
            name: 'uint8',
            serialize: function (buffer, data) { buffer.push(checkRange(data, data & 0xff)); },
            deserialize: function (buffer) { return buffer.get(); },
        }),
        int8: createType({
            name: 'int8',
            serialize: function (buffer, data) { buffer.push(checkRange(data, data << 24 >> 24)); },
            deserialize: function (buffer) { return buffer.get() << 24 >> 24; },
        }),
        uint16: createType({
            name: 'uint16',
            serialize: function (buffer, data) { buffer.pushUint16(checkRange(data, data & 0xffff)); },
            deserialize: function (buffer) { return buffer.getUint16(); },
        }),
        int16: createType({
            name: 'int16',
            serialize: function (buffer, data) { buffer.pushUint16(checkRange(data, data << 16 >> 16)); },
            deserialize: function (buffer) { return buffer.getUint16() << 16 >> 16; },
        }),
        uint32: createType({
            name: 'uint32',
            serialize: function (buffer, data) { buffer.pushUint32(checkRange(data, data >>> 0)); },
            deserialize: function (buffer) { return buffer.getUint32(); },
        }),
        uint64: createType({
            name: 'uint64',
            serialize: function (buffer, data) {
                buffer.pushArray(numeric.decimalToBinary(8, '' + data));
            },
            deserialize: function (buffer) { return numeric.binaryToDecimal(buffer.getUint8Array(8)); },
        }),
        int64: createType({
            name: 'int64',
            serialize: function (buffer, data) {
                buffer.pushArray(numeric.signedDecimalToBinary(8, '' + data));
            },
            deserialize: function (buffer) { return numeric.signedBinaryToDecimal(buffer.getUint8Array(8)); },
        }),
        int32: createType({
            name: 'int32',
            serialize: function (buffer, data) { buffer.pushUint32(checkRange(data, data | 0)); },
            deserialize: function (buffer) { return buffer.getUint32() | 0; },
        }),
        varuint32: createType({
            name: 'varuint32',
            serialize: function (buffer, data) { buffer.pushVaruint32(checkRange(data, data >>> 0)); },
            deserialize: function (buffer) { return buffer.getVaruint32(); },
        }),
        varint32: createType({
            name: 'varint32',
            serialize: function (buffer, data) { buffer.pushVarint32(checkRange(data, data | 0)); },
            deserialize: function (buffer) { return buffer.getVarint32(); },
        }),
        uint128: createType({
            name: 'uint128',
            serialize: function (buffer, data) { buffer.pushArray(numeric.decimalToBinary(16, '' + data)); },
            deserialize: function (buffer) { return numeric.binaryToDecimal(buffer.getUint8Array(16)); },
        }),
        int128: createType({
            name: 'int128',
            serialize: function (buffer, data) {
                buffer.pushArray(numeric.signedDecimalToBinary(16, '' + data));
            },
            deserialize: function (buffer) { return numeric.signedBinaryToDecimal(buffer.getUint8Array(16)); },
        }),
        float32: createType({
            name: 'float32',
            serialize: function (buffer, data) { buffer.pushFloat32(data); },
            deserialize: function (buffer) { return buffer.getFloat32(); },
        }),
        float64: createType({
            name: 'float64',
            serialize: function (buffer, data) { buffer.pushFloat64(data); },
            deserialize: function (buffer) { return buffer.getFloat64(); },
        }),
        float128: createType({
            name: 'float128',
            serialize: function (buffer, data) { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 16); },
            deserialize: function (buffer) { return arrayToHex(buffer.getUint8Array(16)); },
        }),
        bytes: createType({
            name: 'bytes',
            serialize: function (buffer, data) {
                if (data instanceof Uint8Array || Array.isArray(data)) {
                    buffer.pushBytes(data);
                }
                else {
                    buffer.pushBytes(hexToUint8Array(data));
                }
            },
            deserialize: function (buffer, state) {
                if (state && state.options.bytesAsUint8Array) {
                    return buffer.getBytes();
                }
                else {
                    return arrayToHex(buffer.getBytes());
                }
            },
        }),
        string: createType({
            name: 'string',
            serialize: function (buffer, data) { buffer.pushString(data); },
            deserialize: function (buffer) { return buffer.getString(); },
        }),
        name: createType({
            name: 'name',
            serialize: function (buffer, data) { buffer.pushName(data); },
            deserialize: function (buffer) { return buffer.getName(); },
        }),
        time_point: createType({
            name: 'time_point',
            serialize: function (buffer, data) { buffer.pushNumberAsUint64(dateToTimePoint(data)); },
            deserialize: function (buffer) { return timePointToDate(buffer.getUint64AsNumber()); },
        }),
        time_point_sec: createType({
            name: 'time_point_sec',
            serialize: function (buffer, data) { buffer.pushUint32(dateToTimePointSec(data)); },
            deserialize: function (buffer) { return timePointSecToDate(buffer.getUint32()); },
        }),
        block_timestamp_type: createType({
            name: 'block_timestamp_type',
            serialize: function (buffer, data) { buffer.pushUint32(dateToBlockTimestamp(data)); },
            deserialize: function (buffer) { return blockTimestampToDate(buffer.getUint32()); },
        }),
        symbol_code: createType({
            name: 'symbol_code',
            serialize: function (buffer, data) { buffer.pushSymbolCode(data); },
            deserialize: function (buffer) { return buffer.getSymbolCode(); },
        }),
        symbol: createType({
            name: 'symbol',
            serialize: function (buffer, data) { buffer.pushSymbol(stringToSymbol(data)); },
            deserialize: function (buffer) { return symbolToString(buffer.getSymbol()); },
        }),
        asset: createType({
            name: 'asset',
            serialize: function (buffer, data) { buffer.pushAsset(data); },
            deserialize: function (buffer) { return buffer.getAsset(); },
        }),
        checksum160: createType({
            name: 'checksum160',
            serialize: function (buffer, data) { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 20); },
            deserialize: function (buffer) { return arrayToHex(buffer.getUint8Array(20)); },
        }),
        checksum256: createType({
            name: 'checksum256',
            serialize: function (buffer, data) { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 32); },
            deserialize: function (buffer) { return arrayToHex(buffer.getUint8Array(32)); },
        }),
        checksum512: createType({
            name: 'checksum512',
            serialize: function (buffer, data) { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 64); },
            deserialize: function (buffer) { return arrayToHex(buffer.getUint8Array(64)); },
        }),
        public_key: createType({
            name: 'public_key',
            serialize: function (buffer, data) { buffer.pushPublicKey(data); },
            deserialize: function (buffer) { return buffer.getPublicKey(); },
        }),
        private_key: createType({
            name: 'private_key',
            serialize: function (buffer, data) { buffer.pushPrivateKey(data); },
            deserialize: function (buffer) { return buffer.getPrivateKey(); },
        }),
        signature: createType({
            name: 'signature',
            serialize: function (buffer, data) { buffer.pushSignature(data); },
            deserialize: function (buffer) { return buffer.getSignature(); },
        }),
    }));
    result.set('extended_asset', createType({
        name: 'extended_asset',
        baseName: '',
        fields: [
            { name: 'quantity', typeName: 'asset', type: result.get('asset') },
            { name: 'contract', typeName: 'name', type: result.get('name') },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    return result;
} // createInitialTypes()
exports.createInitialTypes = createInitialTypes;
/** Get type from `types` */
function getType(types, name) {
    var type = types.get(name);
    if (type && type.aliasOfName) {
        return getType(types, type.aliasOfName);
    }
    if (type) {
        return type;
    }
    if (name.endsWith('[]')) {
        return createType({
            name: name,
            arrayOf: getType(types, name.substr(0, name.length - 2)),
            serialize: serializeArray,
            deserialize: deserializeArray,
        });
    }
    if (name.endsWith('?')) {
        return createType({
            name: name,
            optionalOf: getType(types, name.substr(0, name.length - 1)),
            serialize: serializeOptional,
            deserialize: deserializeOptional,
        });
    }
    if (name.endsWith('$')) {
        return createType({
            name: name,
            extensionOf: getType(types, name.substr(0, name.length - 1)),
            serialize: serializeExtension,
            deserialize: deserializeExtension,
        });
    }
    throw new Error('Unknown type: ' + name);
}
exports.getType = getType;
/**
 * Get types from abi
 * @param initialTypes Set of types to build on.
 *     In most cases, it's best to fill this from a fresh call to `getTypesFromAbi()`.
 */
function getTypesFromAbi(initialTypes, abi) {
    var e_5, _a, e_6, _b, e_7, _c, e_8, _d, e_9, _e;
    var types = new Map(initialTypes);
    if (abi.types) {
        try {
            for (var _f = __values(abi.types), _g = _f.next(); !_g.done; _g = _f.next()) {
                var _h = _g.value, new_type_name = _h.new_type_name, type = _h.type;
                types.set(new_type_name, createType({ name: new_type_name, aliasOfName: type }));
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
            }
            finally { if (e_5) throw e_5.error; }
        }
    }
    if (abi.structs) {
        try {
            for (var _j = __values(abi.structs), _k = _j.next(); !_k.done; _k = _j.next()) {
                var _l = _k.value, name_1 = _l.name, base = _l.base, fields = _l.fields;
                types.set(name_1, createType({
                    name: name_1,
                    baseName: base,
                    fields: fields.map(function (_a) {
                        var n = _a.name, type = _a.type;
                        return ({ name: n, typeName: type, type: null });
                    }),
                    serialize: serializeStruct,
                    deserialize: deserializeStruct,
                }));
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_k && !_k.done && (_b = _j.return)) _b.call(_j);
            }
            finally { if (e_6) throw e_6.error; }
        }
    }
    if (abi.variants) {
        try {
            for (var _m = __values(abi.variants), _o = _m.next(); !_o.done; _o = _m.next()) {
                var _p = _o.value, name_2 = _p.name, t = _p.types;
                types.set(name_2, createType({
                    name: name_2,
                    fields: t.map(function (s) { return ({ name: s, typeName: s, type: null }); }),
                    serialize: serializeVariant,
                    deserialize: deserializeVariant,
                }));
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_o && !_o.done && (_c = _m.return)) _c.call(_m);
            }
            finally { if (e_7) throw e_7.error; }
        }
    }
    try {
        for (var types_1 = __values(types), types_1_1 = types_1.next(); !types_1_1.done; types_1_1 = types_1.next()) {
            var _q = __read(types_1_1.value, 2), name_3 = _q[0], type = _q[1];
            if (type.baseName) {
                type.base = getType(types, type.baseName);
            }
            try {
                for (var _r = __values(type.fields), _s = _r.next(); !_s.done; _s = _r.next()) {
                    var field = _s.value;
                    field.type = getType(types, field.typeName);
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_s && !_s.done && (_e = _r.return)) _e.call(_r);
                }
                finally { if (e_9) throw e_9.error; }
            }
        }
    }
    catch (e_8_1) { e_8 = { error: e_8_1 }; }
    finally {
        try {
            if (types_1_1 && !types_1_1.done && (_d = types_1.return)) _d.call(types_1);
        }
        finally { if (e_8) throw e_8.error; }
    }
    return types;
} // getTypesFromAbi
exports.getTypesFromAbi = getTypesFromAbi;
/** TAPoS: Return transaction fields which reference `refBlock` and expire `expireSeconds` after `refBlock.timestamp` */
function transactionHeader(refBlock, expireSeconds) {
    return {
        expiration: timePointSecToDate(dateToTimePointSec(refBlock.timestamp) + expireSeconds),
        ref_block_num: refBlock.block_num & 0xffff,
        ref_block_prefix: refBlock.ref_block_prefix,
    };
}
exports.transactionHeader = transactionHeader;
/** Convert action data to serialized form (hex) */
function serializeActionData(contract, account, name, data, textEncoder, textDecoder) {
    var action = contract.actions.get(name);
    if (!action) {
        throw new Error("Unknown action " + name + " in contract " + account);
    }
    var buffer = new SerialBuffer({ textEncoder: textEncoder, textDecoder: textDecoder });
    action.serialize(buffer, data);
    return arrayToHex(buffer.asUint8Array());
}
exports.serializeActionData = serializeActionData;
/** Return action in serialized form */
function serializeAction(contract, account, name, authorization, data, textEncoder, textDecoder) {
    return {
        account: account,
        name: name,
        authorization: authorization,
        data: serializeActionData(contract, account, name, data, textEncoder, textDecoder),
    };
}
exports.serializeAction = serializeAction;
/** Deserialize action data. If `data` is a `string`, then it's assumed to be in hex. */
function deserializeActionData(contract, account, name, data, textEncoder, textDecoder) {
    var action = contract.actions.get(name);
    if (typeof data === 'string') {
        data = hexToUint8Array(data);
    }
    if (!action) {
        throw new Error("Unknown action " + name + " in contract " + account);
    }
    var buffer = new SerialBuffer({ textDecoder: textDecoder, textEncoder: textEncoder });
    buffer.pushArray(data);
    return action.deserialize(buffer);
}
exports.deserializeActionData = deserializeActionData;
/** Deserialize action. If `data` is a `string`, then it's assumed to be in hex. */
function deserializeAction(contract, account, name, authorization, data, textEncoder, textDecoder) {
    return {
        account: account,
        name: name,
        authorization: authorization,
        data: deserializeActionData(contract, account, name, data, textEncoder, textDecoder),
    };
}
exports.deserializeAction = deserializeAction;
//# sourceMappingURL=eosjs-serialize.js.map

/***/ }),
/* 47 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @module Numeric
 */
// copyright defined in eosjs/LICENSE.txt
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ripemd160 = (__webpack_require__(48).RIPEMD160.hash);
var base58Chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
var base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
function create_base58_map() {
    var base58M = Array(256).fill(-1);
    for (var i = 0; i < base58Chars.length; ++i) {
        base58M[base58Chars.charCodeAt(i)] = i;
    }
    return base58M;
}
var base58Map = create_base58_map();
function create_base64_map() {
    var base64M = Array(256).fill(-1);
    for (var i = 0; i < base64Chars.length; ++i) {
        base64M[base64Chars.charCodeAt(i)] = i;
    }
    base64M['='.charCodeAt(0)] = 0;
    return base64M;
}
var base64Map = create_base64_map();
/** Is `bignum` a negative number? */
function isNegative(bignum) {
    return (bignum[bignum.length - 1] & 0x80) !== 0;
}
exports.isNegative = isNegative;
/** Negate `bignum` */
function negate(bignum) {
    var carry = 1;
    for (var i = 0; i < bignum.length; ++i) {
        var x = (~bignum[i] & 0xff) + carry;
        bignum[i] = x;
        carry = x >> 8;
    }
}
exports.negate = negate;
/**
 * Convert an unsigned decimal number in `s` to a bignum
 * @param size bignum size (bytes)
 */
function decimalToBinary(size, s) {
    var result = new Uint8Array(size);
    for (var i = 0; i < s.length; ++i) {
        var srcDigit = s.charCodeAt(i);
        if (srcDigit < '0'.charCodeAt(0) || srcDigit > '9'.charCodeAt(0)) {
            throw new Error('invalid number');
        }
        var carry = srcDigit - '0'.charCodeAt(0);
        for (var j = 0; j < size; ++j) {
            var x = result[j] * 10 + carry;
            result[j] = x;
            carry = x >> 8;
        }
        if (carry) {
            throw new Error('number is out of range');
        }
    }
    return result;
}
exports.decimalToBinary = decimalToBinary;
/**
 * Convert a signed decimal number in `s` to a bignum
 * @param size bignum size (bytes)
 */
function signedDecimalToBinary(size, s) {
    var negative = s[0] === '-';
    if (negative) {
        s = s.substr(1);
    }
    var result = decimalToBinary(size, s);
    if (negative) {
        negate(result);
        if (!isNegative(result)) {
            throw new Error('number is out of range');
        }
    }
    else if (isNegative(result)) {
        throw new Error('number is out of range');
    }
    return result;
}
exports.signedDecimalToBinary = signedDecimalToBinary;
/**
 * Convert `bignum` to an unsigned decimal number
 * @param minDigits 0-pad result to this many digits
 */
function binaryToDecimal(bignum, minDigits) {
    if (minDigits === void 0) { minDigits = 1; }
    var result = Array(minDigits).fill('0'.charCodeAt(0));
    for (var i = bignum.length - 1; i >= 0; --i) {
        var carry = bignum[i];
        for (var j = 0; j < result.length; ++j) {
            var x = ((result[j] - '0'.charCodeAt(0)) << 8) + carry;
            result[j] = '0'.charCodeAt(0) + x % 10;
            carry = (x / 10) | 0;
        }
        while (carry) {
            result.push('0'.charCodeAt(0) + carry % 10);
            carry = (carry / 10) | 0;
        }
    }
    result.reverse();
    return String.fromCharCode.apply(String, __spread(result));
}
exports.binaryToDecimal = binaryToDecimal;
/**
 * Convert `bignum` to a signed decimal number
 * @param minDigits 0-pad result to this many digits
 */
function signedBinaryToDecimal(bignum, minDigits) {
    if (minDigits === void 0) { minDigits = 1; }
    if (isNegative(bignum)) {
        var x = bignum.slice();
        negate(x);
        return '-' + binaryToDecimal(x, minDigits);
    }
    return binaryToDecimal(bignum, minDigits);
}
exports.signedBinaryToDecimal = signedBinaryToDecimal;
/**
 * Convert an unsigned base-58 number in `s` to a bignum
 * @param size bignum size (bytes)
 */
function base58ToBinary(size, s) {
    var result = new Uint8Array(size);
    for (var i = 0; i < s.length; ++i) {
        var carry = base58Map[s.charCodeAt(i)];
        if (carry < 0) {
            throw new Error('invalid base-58 value');
        }
        for (var j = 0; j < size; ++j) {
            var x = result[j] * 58 + carry;
            result[j] = x;
            carry = x >> 8;
        }
        if (carry) {
            throw new Error('base-58 value is out of range');
        }
    }
    result.reverse();
    return result;
}
exports.base58ToBinary = base58ToBinary;
/**
 * Convert `bignum` to a base-58 number
 * @param minDigits 0-pad result to this many digits
 */
function binaryToBase58(bignum, minDigits) {
    if (minDigits === void 0) { minDigits = 1; }
    var e_1, _a, e_2, _b;
    var result = [];
    try {
        for (var bignum_1 = __values(bignum), bignum_1_1 = bignum_1.next(); !bignum_1_1.done; bignum_1_1 = bignum_1.next()) {
            var byte = bignum_1_1.value;
            var carry = byte;
            for (var j = 0; j < result.length; ++j) {
                var x = (base58Map[result[j]] << 8) + carry;
                result[j] = base58Chars.charCodeAt(x % 58);
                carry = (x / 58) | 0;
            }
            while (carry) {
                result.push(base58Chars.charCodeAt(carry % 58));
                carry = (carry / 58) | 0;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (bignum_1_1 && !bignum_1_1.done && (_a = bignum_1.return)) _a.call(bignum_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var bignum_2 = __values(bignum), bignum_2_1 = bignum_2.next(); !bignum_2_1.done; bignum_2_1 = bignum_2.next()) {
            var byte = bignum_2_1.value;
            if (byte) {
                break;
            }
            else {
                result.push('1'.charCodeAt(0));
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (bignum_2_1 && !bignum_2_1.done && (_b = bignum_2.return)) _b.call(bignum_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    result.reverse();
    return String.fromCharCode.apply(String, __spread(result));
}
exports.binaryToBase58 = binaryToBase58;
/** Convert an unsigned base-64 number in `s` to a bignum */
function base64ToBinary(s) {
    var len = s.length;
    if ((len & 3) === 1 && s[len - 1] === '=') {
        len -= 1;
    } // fc appends an extra '='
    if ((len & 3) !== 0) {
        throw new Error('base-64 value is not padded correctly');
    }
    var groups = len >> 2;
    var bytes = groups * 3;
    if (len > 0 && s[len - 1] === '=') {
        if (s[len - 2] === '=') {
            bytes -= 2;
        }
        else {
            bytes -= 1;
        }
    }
    var result = new Uint8Array(bytes);
    for (var group = 0; group < groups; ++group) {
        var digit0 = base64Map[s.charCodeAt(group * 4 + 0)];
        var digit1 = base64Map[s.charCodeAt(group * 4 + 1)];
        var digit2 = base64Map[s.charCodeAt(group * 4 + 2)];
        var digit3 = base64Map[s.charCodeAt(group * 4 + 3)];
        result[group * 3 + 0] = (digit0 << 2) | (digit1 >> 4);
        if (group * 3 + 1 < bytes) {
            result[group * 3 + 1] = ((digit1 & 15) << 4) | (digit2 >> 2);
        }
        if (group * 3 + 2 < bytes) {
            result[group * 3 + 2] = ((digit2 & 3) << 6) | digit3;
        }
    }
    return result;
}
exports.base64ToBinary = base64ToBinary;
/** Key types this library supports */
var KeyType;
(function (KeyType) {
    KeyType[KeyType["k1"] = 0] = "k1";
    KeyType[KeyType["r1"] = 1] = "r1";
})(KeyType = exports.KeyType || (exports.KeyType = {}));
/** Public key data size, excluding type field */
exports.publicKeyDataSize = 33;
/** Private key data size, excluding type field */
exports.privateKeyDataSize = 32;
/** Signature data size, excluding type field */
exports.signatureDataSize = 65;
function digestSuffixRipemd160(data, suffix) {
    var d = new Uint8Array(data.length + suffix.length);
    for (var i = 0; i < data.length; ++i) {
        d[i] = data[i];
    }
    for (var i = 0; i < suffix.length; ++i) {
        d[data.length + i] = suffix.charCodeAt(i);
    }
    return ripemd160(d);
}
function stringToKey(s, type, size, suffix) {
    var whole = base58ToBinary(size + 4, s);
    var result = { type: type, data: new Uint8Array(whole.buffer, 0, size) };
    var digest = new Uint8Array(digestSuffixRipemd160(result.data, suffix));
    if (digest[0] !== whole[size + 0] || digest[1] !== whole[size + 1]
        || digest[2] !== whole[size + 2] || digest[3] !== whole[size + 3]) {
        throw new Error('checksum doesn\'t match');
    }
    return result;
}
function keyToString(key, suffix, prefix) {
    var digest = new Uint8Array(digestSuffixRipemd160(key.data, suffix));
    var whole = new Uint8Array(key.data.length + 4);
    for (var i = 0; i < key.data.length; ++i) {
        whole[i] = key.data[i];
    }
    for (var i = 0; i < 4; ++i) {
        whole[i + key.data.length] = digest[i];
    }
    return prefix + binaryToBase58(whole);
}
/** Convert key in `s` to binary form */
function stringToPublicKey(s) {
    if (typeof s !== 'string') {
        throw new Error('expected string containing public key');
    }
    if (s.substr(0, 3) === 'EOS') {
        var whole = base58ToBinary(exports.publicKeyDataSize + 4, s.substr(3));
        var key = { type: KeyType.k1, data: new Uint8Array(exports.publicKeyDataSize) };
        for (var i = 0; i < exports.publicKeyDataSize; ++i) {
            key.data[i] = whole[i];
        }
        var digest = new Uint8Array(ripemd160(key.data));
        if (digest[0] !== whole[exports.publicKeyDataSize] || digest[1] !== whole[34]
            || digest[2] !== whole[35] || digest[3] !== whole[36]) {
            throw new Error('checksum doesn\'t match');
        }
        return key;
    }
    else if (s.substr(0, 7) === 'PUB_K1_') {
        return stringToKey(s.substr(7), KeyType.k1, exports.publicKeyDataSize, 'K1');
    }
    else if (s.substr(0, 7) === 'PUB_R1_') {
        return stringToKey(s.substr(7), KeyType.r1, exports.publicKeyDataSize, 'R1');
    }
    else {
        throw new Error('unrecognized public key format');
    }
}
exports.stringToPublicKey = stringToPublicKey;
/** Convert `key` to string (base-58) form */
function publicKeyToString(key) {
    if (key.type === KeyType.k1 && key.data.length === exports.publicKeyDataSize) {
        return keyToString(key, 'K1', 'PUB_K1_');
    }
    else if (key.type === KeyType.r1 && key.data.length === exports.publicKeyDataSize) {
        return keyToString(key, 'R1', 'PUB_R1_');
    }
    else {
        throw new Error('unrecognized public key format');
    }
}
exports.publicKeyToString = publicKeyToString;
/** If a key is in the legacy format (`EOS` prefix), then convert it to the new format (`PUB_K1_`).
 * Leaves other formats untouched
 */
function convertLegacyPublicKey(s) {
    if (s.substr(0, 3) === 'EOS') {
        return publicKeyToString(stringToPublicKey(s));
    }
    return s;
}
exports.convertLegacyPublicKey = convertLegacyPublicKey;
/** If a key is in the legacy format (`EOS` prefix), then convert it to the new format (`PUB_K1_`).
 * Leaves other formats untouched
 */
function convertLegacyPublicKeys(keys) {
    return keys.map(convertLegacyPublicKey);
}
exports.convertLegacyPublicKeys = convertLegacyPublicKeys;
/** Convert key in `s` to binary form */
function stringToPrivateKey(s) {
    if (typeof s !== 'string') {
        throw new Error('expected string containing private key');
    }
    if (s.substr(0, 7) === 'PVT_R1_') {
        return stringToKey(s.substr(7), KeyType.r1, exports.privateKeyDataSize, 'R1');
    }
    else {
        throw new Error('unrecognized private key format');
    }
}
exports.stringToPrivateKey = stringToPrivateKey;
/** Convert `key` to string (base-58) form */
function privateKeyToString(key) {
    if (key.type === KeyType.r1) {
        return keyToString(key, 'R1', 'PVT_R1_');
    }
    else {
        throw new Error('unrecognized private key format');
    }
}
exports.privateKeyToString = privateKeyToString;
/** Convert key in `s` to binary form */
function stringToSignature(s) {
    if (typeof s !== 'string') {
        throw new Error('expected string containing signature');
    }
    if (s.substr(0, 7) === 'SIG_K1_') {
        return stringToKey(s.substr(7), KeyType.k1, exports.signatureDataSize, 'K1');
    }
    else if (s.substr(0, 7) === 'SIG_R1_') {
        return stringToKey(s.substr(7), KeyType.r1, exports.signatureDataSize, 'R1');
    }
    else {
        throw new Error('unrecognized signature format');
    }
}
exports.stringToSignature = stringToSignature;
/** Convert `signature` to string (base-58) form */
function signatureToString(signature) {
    if (signature.type === KeyType.k1) {
        return keyToString(signature, 'K1', 'SIG_K1_');
    }
    else if (signature.type === KeyType.r1) {
        return keyToString(signature, 'R1', 'SIG_R1_');
    }
    else {
        throw new Error('unrecognized signature format');
    }
}
exports.signatureToString = signatureToString;
//# sourceMappingURL=eosjs-numeric.js.map

/***/ }),
/* 48 */
/***/ ((module) => {

"use strict";
// https://gist.githubusercontent.com/wlzla000/bac83df6d3c51916c4dd0bc947e46947/raw/7ee3462b095ab22580ddaf191f44a590da6fe33b/RIPEMD-160.js

/*
	RIPEMD-160.js

		developed
			by K. (https://github.com/wlzla000)
			on December 27-29, 2017,

		licensed under


		the MIT license

		Copyright (c) 2017 K.

		 Permission is hereby granted, free of charge, to any person
		obtaining a copy of this software and associated documentation
		files (the "Software"), to deal in the Software without
		restriction, including without limitation the rights to use,
		copy, modify, merge, publish, distribute, sublicense, and/or
		sell copies of the Software, and to permit persons to whom the
		Software is furnished to do so, subject to the following
		conditions:

		 The above copyright notice and this permission notice shall be
		included in all copies or substantial portions of the Software.

		 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
		EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
		OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
		NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
		HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
		WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
		FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
		OTHER DEALINGS IN THE SOFTWARE.
*/



var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RIPEMD160 = function () {
	function RIPEMD160() {
		// https://webcache.googleusercontent.com/search?q=cache:CnLOgolTHYEJ:https://www.cosic.esat.kuleuven.be/publications/article-317.pdf
		// http://shodhganga.inflibnet.ac.in/bitstream/10603/22978/13/13_appendix.pdf

		_classCallCheck(this, RIPEMD160);
	}

	_createClass(RIPEMD160, null, [{
		key: "get_n_pad_bytes",
		value: function get_n_pad_bytes(message_size /* in bytes, 1 byte is 8 bits. */) {
			//  Obtain the number of bytes needed to pad the message.
			// It does not contain the size of the message size information.
			/*
   	https://webcache.googleusercontent.com/search?q=cache:CnLOgolTHYEJ:https://www.cosic.esat.kuleuven.be/publications/article-317.pdf
   		The Cryptographic Hash Function RIPEMD-160
   		written by
   		Bart Preneel,
   		Hans Dobbertin,
   		Antoon Bosselaers
   	in
   		1997.
   		--------------------------------------------------
   		§5     Description of RIPEMD-160
   		......
   		 In order to guarantee that the total input size is a
   	multiple of 512 bits, the input is padded in the same
   	way as for all the members of the MD4-family: one
   	appends a single 1 followed by a string of 0s (the
   	number of 0s lies between 0 and 511); the last 64 bits
   	of the extended input contain the binary representation
   	of the input size in bits, least significant byte first.
   */
			/*
   	https://tools.ietf.org/rfc/rfc1186.txt
   		RFC 1186: MD4 Message Digest Algorithm.
   		written by
   		Ronald Linn Rivest
   	in
   		October 1990.
   		--------------------------------------------------
   		§3     MD4 Algorithm Description
   		......
   		Step 1. Append padding bits
   		 The message is "padded" (extended) so that its length
   	(in bits) is congruent to 448, modulo 512. That is, the
   	message is extended so that it is just 64 bits shy of
   	being a multiple of 512 bits long. Padding is always
   	performed, even if the length of the message is already
   	congruent to 448, modulo 512 (in which case 512 bits of
   	padding are added).
   		 Padding is performed as follows: a single "1" bit is
   	appended to the message, and then enough zero bits are
   	appended so that the length in bits of the padded
   	message becomes congruent to 448, modulo 512.
   		Step 2. Append length
   		 A 64-bit representation of b (the length of the message
   	before the padding bits were added) is appended to the
   	result of the previous step. In the unlikely event that
   	b is greater than 2^64, then only the low-order 64 bits
   	of b are used. (These bits are appended as two 32-bit
   	words and appended low-order word first in accordance
   	with the previous conventions.)
   		 At this point the resulting message (after padding with
   	bits and with b) has a length that is an exact multiple
   	of 512 bits. Equivalently, this message has a length
   	that is an exact multiple of 16 (32-bit) words. Let
   	M[0 ... N-1] denote the words of the resulting message,
   	where N is a multiple of 16.
   */
			// https://crypto.stackexchange.com/a/32407/54568
			/*
   	Example case  # 1
   		[0 bit: message.]
   		[1 bit: 1.]
   		[447 bits: 0.]
   		[64 bits: message size information.]
   		Example case  # 2
   		[512-bits: message]
   		[1 bit: 1.]
   		[447 bits: 0.]
   		[64 bits: message size information.]
   		Example case  # 3
   		[(512 - 64 = 448) bits: message.]
   		[1 bit: 1.]
   		[511 bits: 0.]
   		[64 bits: message size information.]
   		Example case  # 4
   		[(512 - 65 = 447) bits: message.]
   		[1 bit: 1.]
   		[0 bit: 0.]
   		[64 bits: message size information.]
   */
			// The number of padding zero bits:
			//      511 - [{(message size in bits) + 64} (mod 512)]
			return 64 - (message_size + 8 & 63 /* 63 */);
		}
	}, {
		key: "pad",
		value: function pad(message /* An ArrayBuffer. */) {
			var message_size = message.byteLength;
			var n_pad = RIPEMD160.get_n_pad_bytes(message_size);

			//  `Number.MAX_SAFE_INTEGER` is ((2 ** 53) - 1) and
			// bitwise operation in Javascript is done on 32-bits operands.
			var divmod = function divmod(dividend, divisor) {
				return [Math.floor(dividend / divisor), dividend % divisor];
			};
			/*
   To shift
     00000000 000????? ???????? ???????? ???????? ???????? ???????? ????????
                                      t o
    00000000 ???????? ???????? ???????? ???????? ???????? ???????? ?????000
   --------------------------------------------------------------------------------
   Method #1
      00000000 000????? ???????? ????????  ???????? ???????? ???????? ????????
    [00000000 000AAAAA AAAAAAAA AAAAAAAA] (<A> captured)
    [00000000 AAAAAAAA AAAAAAAA AAAAA000] (<A> shifted)
                          (<B> captured) [BBBBBBBB BBBBBBBB BBBBBBBB BBBBBBBB]
                      (<B> shifted) [BBB][BBBBBBBB BBBBBBBB BBBBBBBB BBBBB000]
    [00000000 AAAAAAAA AAAAAAAA AAAAABBB] (<A> & <B_2> merged)
    [00000000 AAAAAAAA AAAAAAAA AAAAABBB][BBBBBBBB BBBBBBBB BBBBBBBB BBBBB000]
     00000000 ???????? ???????? ????????  ???????? ???????? ???????? ?????000
   	const uint32_max_plus_1 = 0x100000000; // (2 ** 32)
   const [
   	msg_byte_size_most, // Value range [0, (2 ** 21) - 1].
   	msg_byte_size_least // Value range [0, (2 ** 32) - 1].
   ] = divmod(message_size, uint32_max_plus_1);
   const [
   	carry, // Value range [0, 7].
   	msg_bit_size_least // Value range [0, (2 ** 32) - 8].
   ] = divmod(message_byte_size_least * 8, uint32_max_plus_1);
   const message_bit_size_most = message_byte_size_most * 8
   	+ carry; // Value range [0, (2 ** 24) - 1].
   --------------------------------------------------------------------------------
   Method #2
     00000000 000????? ???????? ????????  ???????? ???????? ???????? ????????
       [00000 000AAAAA AAAAAAAA AAAAAAAA  AAA] (<A> captured)
                          (<B> captured) [000BBBBB BBBBBBBB BBBBBBBB BBBBBBBB]
                           (<B> shifted) [BBBBBBBB BBBBBBBB BBBBBBBB BBBBB000]
    [00000000 AAAAAAAA AAAAAAAA AAAAAAAA][BBBBBBBB BBBBBBBB BBBBBBBB BBBBB000]
     00000000 ???????? ???????? ????????  ???????? ???????? ???????? ?????000
   	*/

			var _divmod$map = divmod(message_size, 536870912 /* (2 ** 29) */).map(function (x, index) {
				return index ? x * 8 : x;
			}),
			    _divmod$map2 = _slicedToArray(_divmod$map, 2),
			    msg_bit_size_most = _divmod$map2[0],
			    msg_bit_size_least = _divmod$map2[1];

			// `ArrayBuffer.transfer()` is not supported.


			var padded = new Uint8Array(message_size + n_pad + 8);
			padded.set(new Uint8Array(message), 0);
			var data_view = new DataView(padded.buffer);
			data_view.setUint8(message_size, 128);
			data_view.setUint32(message_size + n_pad, msg_bit_size_least, true // Little-endian
			);
			data_view.setUint32(message_size + n_pad + 4, msg_bit_size_most, true // Little-endian
			);

			return padded.buffer;
		}
	}, {
		key: "f",
		value: function f(j, x, y, z) {
			if (0 <= j && j <= 15) {
				// Exclusive-OR
				return x ^ y ^ z;
			}
			if (16 <= j && j <= 31) {
				// Multiplexing (muxing)
				return x & y | ~x & z;
			}
			if (32 <= j && j <= 47) {
				return (x | ~y) ^ z;
			}
			if (48 <= j && j <= 63) {
				// Multiplexing (muxing)
				return x & z | y & ~z;
			}
			if (64 <= j && j <= 79) {
				return x ^ (y | ~z);
			}
		}
	}, {
		key: "K",
		value: function K(j) {
			if (0 <= j && j <= 15) {
				return 0x00000000;
			}
			if (16 <= j && j <= 31) {
				// Math.floor((2 ** 30) * Math.SQRT2)
				return 0x5A827999;
			}
			if (32 <= j && j <= 47) {
				// Math.floor((2 ** 30) * Math.sqrt(3))
				return 0x6ED9EBA1;
			}
			if (48 <= j && j <= 63) {
				// Math.floor((2 ** 30) * Math.sqrt(5))
				return 0x8F1BBCDC;
			}
			if (64 <= j && j <= 79) {
				// Math.floor((2 ** 30) * Math.sqrt(7))
				return 0xA953FD4E;
			}
		}
	}, {
		key: "KP",
		value: function KP(j) // K'
		{
			if (0 <= j && j <= 15) {
				// Math.floor((2 ** 30) * Math.cbrt(2))
				return 0x50A28BE6;
			}
			if (16 <= j && j <= 31) {
				// Math.floor((2 ** 30) * Math.cbrt(3))
				return 0x5C4DD124;
			}
			if (32 <= j && j <= 47) {
				// Math.floor((2 ** 30) * Math.cbrt(5))
				return 0x6D703EF3;
			}
			if (48 <= j && j <= 63) {
				// Math.floor((2 ** 30) * Math.cbrt(7))
				return 0x7A6D76E9;
			}
			if (64 <= j && j <= 79) {
				return 0x00000000;
			}
		}
	}, {
		key: "add_modulo32",
		value: function add_modulo32() /* ...... */{
			// 1.  Modulo addition (addition modulo) is associative.
			//    https://proofwiki.org/wiki/Modulo_Addition_is_Associative
			// 2.  Bitwise operation in Javascript
			//    is done on 32-bits operands
			//    and results in a 32-bits value.
			return Array.from(arguments).reduce(function (a, b) {
				return a + b;
			}, 0) | 0;
		}
	}, {
		key: "rol32",
		value: function rol32(value, count) {
			// Cyclic left shift (rotate) on 32-bits value.
			return value << count | value >>> 32 - count;
		}
	}, {
		key: "hash",
		value: function hash(message /* An ArrayBuffer. */) {
			//////////       Padding       //////////

			// The padded message.
			var padded = RIPEMD160.pad(message);

			//////////     Compression     //////////

			// Message word selectors.
			var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
			var rP = [// r'
			5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];

			// Amounts for 'rotate left' operation.
			var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
			var sP = [// s'
			8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];

			// The size, in bytes, of a word.
			var word_size = 4;

			// The size, in bytes, of a 16-words block.
			var block_size = 64;

			// The number of the 16-words blocks.
			var t = padded.byteLength / block_size;

			//  The message after padding consists of t 16-word blocks that
			// are denoted with X_i[j], with 0≤i≤(t − 1) and 0≤j≤15.
			var X = new Array(t).fill(undefined).map(function (_, i) {
				return function (j) {
					return new DataView(padded, i * block_size, block_size).getUint32(j * word_size, true // Little-endian
					);
				};
			});

			//  The result of RIPEMD-160 is contained in five 32-bit words,
			// which form the internal state of the algorithm. The final
			// content of these five 32-bit words is converted to a 160-bit
			// string, again using the little-endian convention.
			var h = [0x67452301, // h_0
			0xEFCDAB89, // h_1
			0x98BADCFE, // h_2
			0x10325476, // h_3
			0xC3D2E1F0 // h_4
			];

			for (var i = 0; i < t; ++i) {
				var A = h[0],
				    B = h[1],
				    C = h[2],
				    D = h[3],
				    E = h[4];
				var AP = A,
				    BP = B,
				    CP = C,
				    DP = D,
				    EP = E;
				for (var j = 0; j < 80; ++j) {
					// Left rounds
					var _T = RIPEMD160.add_modulo32(RIPEMD160.rol32(RIPEMD160.add_modulo32(A, RIPEMD160.f(j, B, C, D), X[i](r[j]), RIPEMD160.K(j)), s[j]), E);
					A = E;
					E = D;
					D = RIPEMD160.rol32(C, 10);
					C = B;
					B = _T;

					// Right rounds
					_T = RIPEMD160.add_modulo32(RIPEMD160.rol32(RIPEMD160.add_modulo32(AP, RIPEMD160.f(79 - j, BP, CP, DP), X[i](rP[j]), RIPEMD160.KP(j)), sP[j]), EP);
					AP = EP;
					EP = DP;
					DP = RIPEMD160.rol32(CP, 10);
					CP = BP;
					BP = _T;
				}
				var T = RIPEMD160.add_modulo32(h[1], C, DP);
				h[1] = RIPEMD160.add_modulo32(h[2], D, EP);
				h[2] = RIPEMD160.add_modulo32(h[3], E, AP);
				h[3] = RIPEMD160.add_modulo32(h[4], A, BP);
				h[4] = RIPEMD160.add_modulo32(h[0], B, CP);
				h[0] = T;
			}

			//  The final output string then consists of the concatenatation
			// of h_0, h_1, h_2, h_3, and h_4 after converting each h_i to a
			// 4-byte string using the little-endian convention.
			var result = new ArrayBuffer(20);
			var data_view = new DataView(result);
			h.forEach(function (h_i, i) {
				return data_view.setUint32(i * 4, h_i, true);
			});
			return result;
		}
	}]);

	return RIPEMD160;
}();

module.exports = {
	RIPEMD160: RIPEMD160
};


/***/ }),
/* 49 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"version":"eosio::abi/1.1","structs":[{"name":"extensions_entry","base":"","fields":[{"name":"tag","type":"uint16"},{"name":"value","type":"bytes"}]},{"name":"type_def","base":"","fields":[{"name":"new_type_name","type":"string"},{"name":"type","type":"string"}]},{"name":"field_def","base":"","fields":[{"name":"name","type":"string"},{"name":"type","type":"string"}]},{"name":"struct_def","base":"","fields":[{"name":"name","type":"string"},{"name":"base","type":"string"},{"name":"fields","type":"field_def[]"}]},{"name":"action_def","base":"","fields":[{"name":"name","type":"name"},{"name":"type","type":"string"},{"name":"ricardian_contract","type":"string"}]},{"name":"table_def","base":"","fields":[{"name":"name","type":"name"},{"name":"index_type","type":"string"},{"name":"key_names","type":"string[]"},{"name":"key_types","type":"string[]"},{"name":"type","type":"string"}]},{"name":"clause_pair","base":"","fields":[{"name":"id","type":"string"},{"name":"body","type":"string"}]},{"name":"error_message","base":"","fields":[{"name":"error_code","type":"uint64"},{"name":"error_msg","type":"string"}]},{"name":"variant_def","base":"","fields":[{"name":"name","type":"string"},{"name":"types","type":"string[]"}]},{"name":"abi_def","base":"","fields":[{"name":"version","type":"string"},{"name":"types","type":"type_def[]"},{"name":"structs","type":"struct_def[]"},{"name":"actions","type":"action_def[]"},{"name":"tables","type":"table_def[]"},{"name":"ricardian_clauses","type":"clause_pair[]"},{"name":"error_messages","type":"error_message[]"},{"name":"abi_extensions","type":"extensions_entry[]"},{"name":"variants","type":"variant_def[]$"}]}]}');

/***/ }),
/* 50 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"version":"eosio::abi/1.0","types":[{"new_type_name":"account_name","type":"name"},{"new_type_name":"action_name","type":"name"},{"new_type_name":"permission_name","type":"name"}],"structs":[{"name":"permission_level","base":"","fields":[{"name":"actor","type":"account_name"},{"name":"permission","type":"permission_name"}]},{"name":"action","base":"","fields":[{"name":"account","type":"account_name"},{"name":"name","type":"action_name"},{"name":"authorization","type":"permission_level[]"},{"name":"data","type":"bytes"}]},{"name":"extension","base":"","fields":[{"name":"type","type":"uint16"},{"name":"data","type":"bytes"}]},{"name":"transaction_header","base":"","fields":[{"name":"expiration","type":"time_point_sec"},{"name":"ref_block_num","type":"uint16"},{"name":"ref_block_prefix","type":"uint32"},{"name":"max_net_usage_words","type":"varuint32"},{"name":"max_cpu_usage_ms","type":"uint8"},{"name":"delay_sec","type":"varuint32"}]},{"name":"transaction","base":"transaction_header","fields":[{"name":"context_free_actions","type":"action[]"},{"name":"actions","type":"action[]"},{"name":"transaction_extensions","type":"extension[]"}]}]}');

/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// copyright defined in eosjs/LICENSE.txt
Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=eosjs-api-interfaces.js.map

/***/ }),
/* 52 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @module JSON-RPC
 */
// copyright defined in eosjs/LICENSE.txt
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var eosjs_numeric_1 = __webpack_require__(47);
var eosjs_rpcerror_1 = __webpack_require__(53);
function arrayToHex(data) {
    var e_1, _a;
    var result = '';
    try {
        for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
            var x = data_1_1.value;
            result += ('00' + x.toString(16)).slice(-2);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result;
}
/** Make RPC calls */
var JsonRpc = /** @class */ (function () {
    /**
     * @param args
     *    * `fetch`:
     *    * browsers: leave `null` or `undefined`
     *    * node: provide an implementation
     */
    function JsonRpc(endpoint, args) {
        if (args === void 0) { args = {}; }
        this.endpoint = endpoint;
        if (args.fetch) {
            this.fetchBuiltin = args.fetch;
        }
        else {
            this.fetchBuiltin = __webpack_require__.g.fetch;
        }
    }
    /** Post `body` to `endpoint + path`. Throws detailed error information in `RpcError` when available. */
    JsonRpc.prototype.fetch = function (path, body) {
        return __awaiter(this, void 0, void 0, function () {
            var response, json, f, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        f = this.fetchBuiltin;
                        return [4 /*yield*/, f(this.endpoint + path, {
                                body: JSON.stringify(body),
                                method: 'POST',
                            })];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.json()];
                    case 2:
                        json = _a.sent();
                        if (json.processed && json.processed.except) {
                            throw new eosjs_rpcerror_1.RpcError(json);
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        e_2 = _a.sent();
                        e_2.isFetchError = true;
                        throw e_2;
                    case 4:
                        if (!response.ok) {
                            throw new eosjs_rpcerror_1.RpcError(json);
                        }
                        return [2 /*return*/, json];
                }
            });
        });
    };
    /** Raw call to `/v1/chain/get_abi` */
    JsonRpc.prototype.get_abi = function (accountName) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/chain/get_abi', { account_name: accountName })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** Raw call to `/v1/chain/get_account` */
    JsonRpc.prototype.get_account = function (accountName) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/chain/get_account', { account_name: accountName })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** Raw call to `/v1/chain/get_block_header_state` */
    JsonRpc.prototype.get_block_header_state = function (blockNumOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/chain/get_block_header_state', { block_num_or_id: blockNumOrId })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** Raw call to `/v1/chain/get_block` */
    JsonRpc.prototype.get_block = function (blockNumOrId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/chain/get_block', { block_num_or_id: blockNumOrId })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** Raw call to `/v1/chain/get_code` */
    JsonRpc.prototype.get_code = function (accountName) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/chain/get_code', { account_name: accountName })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** Raw call to `/v1/chain/get_currency_balance` */
    JsonRpc.prototype.get_currency_balance = function (code, account, symbol) {
        if (symbol === void 0) { symbol = null; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/chain/get_currency_balance', { code: code, account: account, symbol: symbol })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** Raw call to `/v1/chain/get_currency_stats` */
    JsonRpc.prototype.get_currency_stats = function (code, symbol) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/chain/get_currency_stats', { code: code, symbol: symbol })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** Raw call to `/v1/chain/get_info` */
    JsonRpc.prototype.get_info = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/chain/get_info', {})];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** Raw call to `/v1/chain/get_producer_schedule` */
    JsonRpc.prototype.get_producer_schedule = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/chain/get_producer_schedule', {})];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** Raw call to `/v1/chain/get_producers` */
    JsonRpc.prototype.get_producers = function (json, lowerBound, limit) {
        if (json === void 0) { json = true; }
        if (lowerBound === void 0) { lowerBound = ''; }
        if (limit === void 0) { limit = 50; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/chain/get_producers', { json: json, lower_bound: lowerBound, limit: limit })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** Raw call to `/v1/chain/get_raw_code_and_abi` */
    JsonRpc.prototype.get_raw_code_and_abi = function (accountName) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/chain/get_raw_code_and_abi', { account_name: accountName })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** calls `/v1/chain/get_raw_code_and_abi` and pulls out unneeded raw wasm code */
    // TODO: use `/v1/chain/get_raw_abi` directly when it becomes available
    JsonRpc.prototype.getRawAbi = function (accountName) {
        return __awaiter(this, void 0, void 0, function () {
            var rawCodeAndAbi, abi;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.get_raw_code_and_abi(accountName)];
                    case 1:
                        rawCodeAndAbi = _a.sent();
                        abi = eosjs_numeric_1.base64ToBinary(rawCodeAndAbi.abi);
                        return [2 /*return*/, { accountName: rawCodeAndAbi.account_name, abi: abi }];
                }
            });
        });
    };
    /** Raw call to `/v1/chain/get_table_rows` */
    JsonRpc.prototype.get_table_rows = function (_a) {
        var _b = _a.json, json = _b === void 0 ? true : _b, code = _a.code, scope = _a.scope, table = _a.table, _c = _a.table_key, table_key = _c === void 0 ? '' : _c, _d = _a.lower_bound, lower_bound = _d === void 0 ? '' : _d, _e = _a.upper_bound, upper_bound = _e === void 0 ? '' : _e, _f = _a.index_position, index_position = _f === void 0 ? 1 : _f, _g = _a.key_type, key_type = _g === void 0 ? '' : _g, _h = _a.limit, limit = _h === void 0 ? 10 : _h, _j = _a.reverse, reverse = _j === void 0 ? false : _j, _k = _a.show_payer, show_payer = _k === void 0 ? false : _k;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_l) {
                switch (_l.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/chain/get_table_rows', {
                            json: json,
                            code: code,
                            scope: scope,
                            table: table,
                            table_key: table_key,
                            lower_bound: lower_bound,
                            upper_bound: upper_bound,
                            index_position: index_position,
                            key_type: key_type,
                            limit: limit,
                            reverse: reverse,
                            show_payer: show_payer,
                        })];
                    case 1: return [2 /*return*/, _l.sent()];
                }
            });
        });
    };
    /** Raw call to `/v1/chain/get_table_by_scope` */
    JsonRpc.prototype.get_table_by_scope = function (_a) {
        var code = _a.code, table = _a.table, _b = _a.lower_bound, lower_bound = _b === void 0 ? '' : _b, _c = _a.upper_bound, upper_bound = _c === void 0 ? '' : _c, _d = _a.limit, limit = _d === void 0 ? 10 : _d;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/chain/get_table_by_scope', {
                            code: code,
                            table: table,
                            lower_bound: lower_bound,
                            upper_bound: upper_bound,
                            limit: limit,
                        })];
                    case 1: return [2 /*return*/, _e.sent()];
                }
            });
        });
    };
    /** Get subset of `availableKeys` needed to meet authorities in `transaction`. Implements `AuthorityProvider` */
    JsonRpc.prototype.getRequiredKeys = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = eosjs_numeric_1.convertLegacyPublicKeys;
                        return [4 /*yield*/, this.fetch('/v1/chain/get_required_keys', {
                                transaction: args.transaction,
                                available_keys: args.availableKeys,
                            })];
                    case 1: return [2 /*return*/, _a.apply(void 0, [(_b.sent()).required_keys])];
                }
            });
        });
    };
    /** Push a serialized transaction */
    JsonRpc.prototype.push_transaction = function (_a) {
        var signatures = _a.signatures, serializedTransaction = _a.serializedTransaction;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/chain/push_transaction', {
                            signatures: signatures,
                            compression: 0,
                            packed_context_free_data: '',
                            packed_trx: arrayToHex(serializedTransaction),
                        })];
                    case 1: return [2 /*return*/, _b.sent()];
                }
            });
        });
    };
    /** Raw call to `/v1/db_size/get` */
    JsonRpc.prototype.db_size_get = function () {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, this.fetch('/v1/db_size/get', {})];
                case 1: return [2 /*return*/, _a.sent()];
            }
        }); });
    };
    /** Raw call to `/v1/history/get_actions` */
    JsonRpc.prototype.history_get_actions = function (accountName, pos, offset) {
        if (pos === void 0) { pos = null; }
        if (offset === void 0) { offset = null; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/history/get_actions', { account_name: accountName, pos: pos, offset: offset })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** Raw call to `/v1/history/get_transaction` */
    JsonRpc.prototype.history_get_transaction = function (id, blockNumHint) {
        if (blockNumHint === void 0) { blockNumHint = null; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/history/get_transaction', { id: id, block_num_hint: blockNumHint })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** Raw call to `/v1/history/get_key_accounts` */
    JsonRpc.prototype.history_get_key_accounts = function (publicKey) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/history/get_key_accounts', { public_key: publicKey })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** Raw call to `/v1/history/get_controlled_accounts` */
    JsonRpc.prototype.history_get_controlled_accounts = function (controllingAccount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch('/v1/history/get_controlled_accounts', { controlling_account: controllingAccount })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return JsonRpc;
}()); // JsonRpc
exports.JsonRpc = JsonRpc;
//# sourceMappingURL=eosjs-jsonrpc.js.map

/***/ }),
/* 53 */
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/**
 * @module RPC-Error
 */
// copyright defined in eosjs/LICENSE.txt
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
/** Holds detailed error information */
var RpcError = /** @class */ (function (_super) {
    __extends(RpcError, _super);
    function RpcError(json) {
        var _this = this;
        if (json.error && json.error.details && json.error.details.length && json.error.details[0].message) {
            _this = _super.call(this, json.error.details[0].message) || this;
        }
        else if (json.processed && json.processed.except && json.processed.except.message) {
            _this = _super.call(this, json.processed.except.message) || this;
        }
        else {
            _this = _super.call(this, json.message) || this;
        }
        Object.setPrototypeOf(_this, RpcError.prototype);
        _this.json = json;
        return _this;
    }
    return RpcError;
}(Error));
exports.RpcError = RpcError;
//# sourceMappingURL=eosjs-rpcerror.js.map

/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// copyright defined in eosjs/LICENSE.txt
Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=eosjs-rpc-interfaces.js.map

/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function makeStateContainer(initialState) {
    var state = initialState;
    var listeners = [];
    return {
        getState: function () {
            return state;
        },
        updateState: function (updater) {
            state =
                typeof updater === 'function'
                    ? updater(state)
                    : updater;
            for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {
                var listener = listeners_1[_i];
                listener(state);
            }
        },
        subscribe: function (listenerFn) {
            listeners.push(listenerFn);
            return function unsubscribe() {
                listeners = listeners.filter(function (l) { return l !== listenerFn; });
            };
        }
    };
}
exports.makeStateContainer = makeStateContainer;
//# sourceMappingURL=stateContainer.js.map

/***/ }),
/* 56 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var eosjs_1 = __webpack_require__(44);
var v4_1 = __importDefault(__webpack_require__(57));
var stateContainer_1 = __webpack_require__(55);
var util_1 = __webpack_require__(60);
var DEFAULT_STATE = {
    connecting: false,
    connected: false,
    connectionError: false,
    connectionErrorMessage: void 0,
    auth: void 0,
    authenticating: false,
    authenticated: false,
    authenticationConfirmed: false,
    authenticationError: false,
    authenticationErrorMessage: void 0,
    accountInfo: void 0,
    accountFetching: false,
    accountFetchError: false,
    accountFetchErrorMessage: void 0
};
function initWallet(walletProvider, ctx) {
    var _instanceId = v4_1.default();
    var _stateContainer = stateContainer_1.makeStateContainer(__assign({}, DEFAULT_STATE));
    //let discoverData: DiscoveryData = { keyToAccountMap: [], keys: [] };
    var discoverData = { keyToAccountMap: [] };
    var counter = 0;
    var getState = _stateContainer.getState;
    var eosApi = new eosjs_1.Api({
        // Api() constructor requires a JsonRpc - even if we dont want one for non-eos, so create empty JsonRpc here
        rpc: ctx.eosRpc ? ctx.eosRpc : new eosjs_1.JsonRpc(''),
        chainId: ctx.network.chainId,
        signatureProvider: walletProvider.signatureProvider
    });
    // Account helpers
    function fetchAccountInfo(accountName) {
        if (!accountName) {
            return Promise.reject('No `accountName` was passed in order to fetch the account info');
        }
        _stateContainer.updateState(function (state) { return (__assign({}, state, { accountFetching: true, accountFetchError: false, accountFetchErrorMessage: void 0 })); });
        // NonEOS Support: if ctx.eosRpc is undefined,
        // return AccountInfo with just accountName
        if (!ctx.eosRpc) {
            var accountInfo_1 = { name: accountName };
            _stateContainer.updateState(function (state) { return (__assign({}, state, { accountFetching: false, accountInfo: accountInfo_1 })); });
            return Promise.resolve(accountInfo_1);
        }
        return ctx.eosRpc
            .get_account(accountName)
            .then(function (accountData) {
            var accountInfo = __assign({}, accountData);
            _stateContainer.updateState(function (state) { return (__assign({}, state, { accountFetching: false, accountInfo: accountInfo })); });
            return accountInfo;
        })
            .catch(function (error) {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { accountFetching: false, accountInfo: void 0, accountFetchError: true, accountFetchErrorMessage: util_1.getErrorMessage(error) })); });
            return Promise.reject(error);
        });
    }
    // Connection
    function connect() {
        _stateContainer.updateState(function (state) { return (__assign({}, state, { connected: false, connecting: true, connectionError: false, connectionErrorMessage: void 0 })); });
        return walletProvider
            .connect(ctx.appName)
            .then(function () {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { connecting: false, connected: true })); });
            return true;
        })
            .catch(function (error) {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { connecting: false, connectionError: true, connectionErrorMessage: util_1.getErrorMessage(error) })); });
            return Promise.reject(error);
        });
    }
    function discover(discoveryOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var accountsDataObjToMerge, discoverResult;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        accountsDataObjToMerge = { keyToAccountMap: [] };
                        return [4 /*yield*/, walletProvider.discover(discoveryOptions).then(function (walletDiscoveryData) { return __awaiter(_this, void 0, void 0, function () {
                                var modifiedData, promises, _loop_1, _i, _a, keyData;
                                var _this = this;
                                return __generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0:
                                            console.log('walletDiscoveryData');
                                            console.log(walletDiscoveryData);
                                            //Merge any properties that were returned from the wallets specific discovery process. This allows the wallet to add custom properties to the response if needed.
                                            accountsDataObjToMerge = __assign({}, accountsDataObjToMerge, walletDiscoveryData);
                                            delete accountsDataObjToMerge.keys;
                                            // let keys: string[] = []; // If the discover fuction in the wallet doesn't return any keys we know the login function is going to have to prompt the user to select one.
                                            // if (walletDiscoveryData.keys) {
                                            // 	keys = walletDiscoveryData.keys;
                                            // }
                                            // A callback of this kind can be supplied to the discover function, which will allow the caller to modify the list of keys before the account lookup process happens. 
                                            // The feature was added so that key returned from the Ledger device can be modified to have a ENU prefix when in use with the the enumivo chain 
                                            if (discoveryOptions.keyModifierFunc !== undefined) {
                                                modifiedData = discoveryOptions.keyModifierFunc(walletDiscoveryData);
                                                walletDiscoveryData = modifiedData;
                                            }
                                            if (!(discoveryOptions.keyLookupFunc !== undefined)) return [3 /*break*/, 1];
                                            // discoveryOptions.keyLookupFunc(walletDiscoveryData);
                                            discoveryOptions.keyLookupFunc(walletDiscoveryData, function (discoveredAccounts) {
                                                accountsDataObjToMerge.keyToAccountMap = discoveredAccounts;
                                                console.log('accountsDataObjToMerge(keyLookupFunc)');
                                                console.log({ accountsDataObjToMerge: accountsDataObjToMerge });
                                                return Promise.resolve({ accountsDataObjToMerge: accountsDataObjToMerge });
                                            });
                                            return [3 /*break*/, 3];
                                        case 1:
                                            promises = [];
                                            _loop_1 = function (keyData) {
                                                var key = keyData.key;
                                                var keyIndex = keyData.index;
                                                var cached = false;
                                                if (discoverData.keyToAccountMap) {
                                                    var foundInCache = discoverData.keyToAccountMap.findIndex(function (y) { return y.index == keyIndex; });
                                                    if (foundInCache > -1)
                                                        cached = true;
                                                }
                                                if (key && !cached && ctx.eosRpc) {
                                                    var p = ctx.eosRpc.history_get_key_accounts(key).then(function (accountData) { return __awaiter(_this, void 0, void 0, function () {
                                                        var accountEntry, _loop_2, _i, _a, account;
                                                        var _this = this;
                                                        return __generator(this, function (_b) {
                                                            switch (_b.label) {
                                                                case 0:
                                                                    accountEntry = {
                                                                        index: keyIndex,
                                                                        key: key,
                                                                        accounts: []
                                                                    };
                                                                    if (!(accountData.account_names.length > 0)) return [3 /*break*/, 4];
                                                                    _loop_2 = function (account) {
                                                                        return __generator(this, function (_a) {
                                                                            switch (_a.label) {
                                                                                case 0: return [4 /*yield*/, ctx.eosRpc.get_account(account).then(function (accountInfo) { return __awaiter(_this, void 0, void 0, function () {
                                                                                        var _i, _a, permission, _b, _c, permissionKey;
                                                                                        return __generator(this, function (_d) {
                                                                                            for (_i = 0, _a = accountInfo.permissions; _i < _a.length; _i++) {
                                                                                                permission = _a[_i];
                                                                                                for (_b = 0, _c = permission.required_auth.keys; _b < _c.length; _b++) {
                                                                                                    permissionKey = _c[_b];
                                                                                                    if (permissionKey.key == key) {
                                                                                                        accountEntry.accounts.push({
                                                                                                            account: account,
                                                                                                            authorization: permission.perm_name
                                                                                                        });
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            return [2 /*return*/];
                                                                                        });
                                                                                    }); })];
                                                                                case 1:
                                                                                    _a.sent();
                                                                                    return [2 /*return*/];
                                                                            }
                                                                        });
                                                                    };
                                                                    _i = 0, _a = accountData.account_names;
                                                                    _b.label = 1;
                                                                case 1:
                                                                    if (!(_i < _a.length)) return [3 /*break*/, 4];
                                                                    account = _a[_i];
                                                                    return [5 /*yield**/, _loop_2(account)];
                                                                case 2:
                                                                    _b.sent();
                                                                    _b.label = 3;
                                                                case 3:
                                                                    _i++;
                                                                    return [3 /*break*/, 1];
                                                                case 4: return [2 /*return*/, accountEntry];
                                                            }
                                                        });
                                                    }); });
                                                    promises.push(p);
                                                }
                                            };
                                            for (_i = 0, _a = walletDiscoveryData.keys; _i < _a.length; _i++) {
                                                keyData = _a[_i];
                                                _loop_1(keyData);
                                            }
                                            return [4 /*yield*/, Promise.all(promises).then(function (results) {
                                                    accountsDataObjToMerge.keyToAccountMap = results || [];
                                                    console.log('accountsDataObjToMerge');
                                                    console.log({ accountsDataObjToMerge: accountsDataObjToMerge });
                                                    return Promise.resolve({ accountsDataObjToMerge: accountsDataObjToMerge });
                                                })];
                                        case 2:
                                            _b.sent();
                                            _b.label = 3;
                                        case 3: return [2 /*return*/];
                                    }
                                });
                            }); })];
                    case 1:
                        discoverResult = _a.sent();
                        counter++;
                        if (discoverData.keyToAccountMap.length == 0) {
                            discoverData = __assign({}, discoverData, accountsDataObjToMerge);
                        }
                        else {
                            accountsDataObjToMerge.keyToAccountMap.forEach(function (newKey) {
                                discoverData.keyToAccountMap.push(newKey);
                                // discoverData.keys = accountsDataObjToMerge.keys;
                            });
                        }
                        // console.log(discoverData);
                        return [2 /*return*/, Promise.resolve(discoverData)];
                }
            });
        });
    }
    function disconnect() {
        return walletProvider.disconnect().then(function () {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { connecting: false, connected: false, connectionError: false, connectionErrorMessage: void 0 })); });
            return true;
        });
    }
    // Authentication
    function login(accountName, authorization) {
        _stateContainer.updateState(function (state) { return (__assign({}, state, { accountInfo: void 0, authenticated: false, authenticationConfirmed: false, authenticating: true, authenticationError: false, authenticationErrorMessage: void 0 })); });
        var index = -1;
        var key = undefined;
        //If we've done discovery then we should be able to find the account trying to login in the discoverData
        if (discoverData.keyToAccountMap.length > 0) {
            // console.log('see if we can find ' + accountName + ' ' + authorization);
            if (accountName && authorization) {
                discoverData.keyToAccountMap.forEach(function (indexObj) {
                    var found = indexObj.accounts.find(function (account) {
                        return account.account == accountName && account.authorization == authorization;
                    });
                    if (found) {
                        index = indexObj.index;
                        key = indexObj.key;
                    }
                });
            }
            if (!key) {
                throw 'Loging was not able to determine the Key and Index for ' + authorization + '@' + accountName;
            }
        }
        return walletProvider
            .login(accountName, authorization, index, key)
            .then(function (walletAuth) {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { auth: walletAuth, authenticated: true, authenticating: false })); });
            return fetchAccountInfo(walletAuth.accountName);
        })
            .then(function (accountInfo) {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { accountInfo: accountInfo })); });
            return accountInfo;
        })
            .catch(function (error) {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { authenticating: false, authenticationError: true, authenticationErrorMessage: util_1.getErrorMessage(error) })); });
            return Promise.reject(error);
        });
    }
    function logout() {
        return walletProvider.logout().then(function () {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { accountInfo: void 0, authenticating: false, authenticated: false, authenticationError: false, authenticationErrorMessage: void 0 })); });
            return true;
        });
    }
    function signArbitrary(data, userMessage, metadata) {
        return walletProvider.signArbitrary(data, userMessage, metadata);
    }
    var wallet = {
        _instanceId: _instanceId,
        ctx: ctx,
        provider: walletProvider,
        eosApi: eosApi,
        get state() {
            return getState() || __assign({}, DEFAULT_STATE);
        },
        // Shortcut state accessors
        get auth() {
            var state = getState();
            return (state && state.auth) || void 0;
        },
        get accountInfo() {
            var state = getState();
            return (state && state.accountInfo) || void 0;
        },
        get connected() {
            var state = getState();
            return (state && state.connected) || false;
        },
        get authenticated() {
            var state = getState();
            return (state && state.authenticated) || false;
        },
        get inProgress() {
            var state = getState();
            if (!state)
                return false;
            var connecting = state.connecting, authenticating = state.authenticating, accountFetching = state.accountFetching;
            return !!(connecting || authenticating || accountFetching);
        },
        get active() {
            var state = getState();
            if (!state)
                return false;
            var connected = state.connected, authenticated = state.authenticated, accountInfo = state.accountInfo;
            return !!(connected && authenticated && accountInfo);
        },
        get hasError() {
            var state = getState();
            if (!state)
                return false;
            var connectionError = state.connectionError, authenticationError = state.authenticationError, accountFetchError = state.accountFetchError;
            return !!(connectionError || authenticationError || accountFetchError);
        },
        get errorMessage() {
            var state = getState();
            if (!state)
                return void 0;
            if (!wallet.hasError)
                return void 0;
            var connectionErrorMessage = state.connectionErrorMessage, authenticationErrorMessage = state.authenticationErrorMessage, accountFetchErrorMessage = state.accountFetchErrorMessage;
            return (connectionErrorMessage ||
                authenticationErrorMessage ||
                accountFetchErrorMessage ||
                'Wallet connection error');
        },
        connect: connect,
        discover: discover,
        disconnect: disconnect,
        login: login,
        logout: logout,
        fetchAccountInfo: fetchAccountInfo,
        terminate: function () {
            return logout().then(disconnect).then(function () {
                ctx.detachWallet(wallet);
                return true;
            });
        },
        subscribe: function (listener) {
            return _stateContainer.subscribe(listener);
        },
        signArbitrary: signArbitrary
    };
    return wallet;
}
exports.initWallet = initWallet;
//# sourceMappingURL=wallet.js.map

/***/ }),
/* 57 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(58);
var bytesToUuid = __webpack_require__(59);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),
/* 58 */
/***/ ((module) => {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),
/* 59 */
/***/ ((module) => {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),
/* 60 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function getNetworkUrl(_a) {
    var protocol = _a.protocol, host = _a.host, port = _a.port;
    return (protocol ? protocol : 'http') + "://" + host + (port ? ":" + port : '');
}
exports.getNetworkUrl = getNetworkUrl;
function getErrorMessage(error, fallbackMessage) {
    if (fallbackMessage === void 0) { fallbackMessage = 'Error'; }
    if (error) {
        return typeof error === 'string' ? error : error.message || fallbackMessage;
    }
    return fallbackMessage;
}
exports.getErrorMessage = getErrorMessage;
//# sourceMappingURL=util.js.map

/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "msgPackEncode": () => (/* binding */ msgPackEncode)
/* harmony export */ });
/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62);
/* eslint-disable no-prototype-builtins */

/* eslint-disable prefer-const */
 // This funciton copied from algoSdk - https://github.com/algorand/js-algorand-sdk/blob/dcec38cc7926de7f54328ce28e76290ffea9fe41/src/encoding/encoding.js#L24

/**
 * containsEmpty returns true if any of the object's values are empty, false otherwise.
 * Empty arrays considered empty
 * @param obj
 * @returns {{firstEmptyKey: string, containsEmpty: boolean}} {true, empty key} if contains empty, {false, undefined} otherwise
 */

function containsEmpty(obj) {
  // eslint-disable-next-line no-restricted-syntax
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      if (!obj[key] || obj[key].length === 0) {
        return {
          containsEmpty: true,
          firstEmptyKey: key
        };
      }
    }
  }

  return {
    containsEmpty: false,
    firstEmptyKey: undefined
  };
} // This funciton copied from algoSdk - https://github.com/algorand/js-algorand-sdk/blob/dcec38cc7926de7f54328ce28e76290ffea9fe41/src/encoding/encoding.js#L41

/**
 * encode encodes objects using msgpack
 * @param obj a dictionary to be encoded. Must not contain empty or 0 values.
 * @returns {Uint8Array} msgpack representation of the object
 * @throws Error containing ERROR_CONTAINS_EMPTY_STRING if the object contains empty or zero values
 */


function msgPackEncode(obj) {
  var ERROR_CONTAINS_EMPTY_STRING = 'The object contains empty or 0 values. First empty or 0 value encountered during encoding: '; // Check for empty values

  var emptyCheck = containsEmpty(obj);

  if (emptyCheck.containsEmpty) {
    throw new Error(ERROR_CONTAINS_EMPTY_STRING + emptyCheck.firstEmptyKey);
  } // enable the canonical option


  var options = {
    sortKeys: true
  };
  return (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_0__.encode)(obj, options);
}

/***/ }),
/* 62 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "encode": () => (/* binding */ encode)
/* harmony export */ });
/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63);

var defaultEncodeOptions = {};
/**
 * It encodes `value` in the MessagePack format and
 * returns a byte buffer.
 *
 * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.
 */
function encode(value, options) {
    if (options === void 0) { options = defaultEncodeOptions; }
    var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);
    return encoder.encodeSharedRef(value);
}
//# sourceMappingURL=encode.mjs.map

/***/ }),
/* 63 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_INITIAL_BUFFER_SIZE": () => (/* binding */ DEFAULT_INITIAL_BUFFER_SIZE),
/* harmony export */   "DEFAULT_MAX_DEPTH": () => (/* binding */ DEFAULT_MAX_DEPTH),
/* harmony export */   "Encoder": () => (/* binding */ Encoder)
/* harmony export */ });
/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(69);
/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64);
/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(66);
/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70);




var DEFAULT_MAX_DEPTH = 100;
var DEFAULT_INITIAL_BUFFER_SIZE = 2048;
var Encoder = /** @class */ (function () {
    function Encoder(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {
        if (extensionCodec === void 0) { extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionCodec.defaultCodec; }
        if (context === void 0) { context = undefined; }
        if (maxDepth === void 0) { maxDepth = DEFAULT_MAX_DEPTH; }
        if (initialBufferSize === void 0) { initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE; }
        if (sortKeys === void 0) { sortKeys = false; }
        if (forceFloat32 === void 0) { forceFloat32 = false; }
        if (ignoreUndefined === void 0) { ignoreUndefined = false; }
        if (forceIntegerToFloat === void 0) { forceIntegerToFloat = false; }
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxDepth = maxDepth;
        this.initialBufferSize = initialBufferSize;
        this.sortKeys = sortKeys;
        this.forceFloat32 = forceFloat32;
        this.ignoreUndefined = ignoreUndefined;
        this.forceIntegerToFloat = forceIntegerToFloat;
        this.pos = 0;
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
        this.bytes = new Uint8Array(this.view.buffer);
    }
    Encoder.prototype.reinitializeState = function () {
        this.pos = 0;
    };
    /**
     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
     *
     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
     */
    Encoder.prototype.encodeSharedRef = function (object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.subarray(0, this.pos);
    };
    /**
     * @returns Encodes the object and returns a copy of the encoder's internal buffer.
     */
    Encoder.prototype.encode = function (object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.slice(0, this.pos);
    };
    Encoder.prototype.doEncode = function (object, depth) {
        if (depth > this.maxDepth) {
            throw new Error("Too deep objects in depth ".concat(depth));
        }
        if (object == null) {
            this.encodeNil();
        }
        else if (typeof object === "boolean") {
            this.encodeBoolean(object);
        }
        else if (typeof object === "number") {
            this.encodeNumber(object);
        }
        else if (typeof object === "string") {
            this.encodeString(object);
        }
        else {
            this.encodeObject(object, depth);
        }
    };
    Encoder.prototype.ensureBufferSizeToWrite = function (sizeToWrite) {
        var requiredSize = this.pos + sizeToWrite;
        if (this.view.byteLength < requiredSize) {
            this.resizeBuffer(requiredSize * 2);
        }
    };
    Encoder.prototype.resizeBuffer = function (newSize) {
        var newBuffer = new ArrayBuffer(newSize);
        var newBytes = new Uint8Array(newBuffer);
        var newView = new DataView(newBuffer);
        newBytes.set(this.bytes);
        this.view = newView;
        this.bytes = newBytes;
    };
    Encoder.prototype.encodeNil = function () {
        this.writeU8(0xc0);
    };
    Encoder.prototype.encodeBoolean = function (object) {
        if (object === false) {
            this.writeU8(0xc2);
        }
        else {
            this.writeU8(0xc3);
        }
    };
    Encoder.prototype.encodeNumber = function (object) {
        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {
            if (object >= 0) {
                if (object < 0x80) {
                    // positive fixint
                    this.writeU8(object);
                }
                else if (object < 0x100) {
                    // uint 8
                    this.writeU8(0xcc);
                    this.writeU8(object);
                }
                else if (object < 0x10000) {
                    // uint 16
                    this.writeU8(0xcd);
                    this.writeU16(object);
                }
                else if (object < 0x100000000) {
                    // uint 32
                    this.writeU8(0xce);
                    this.writeU32(object);
                }
                else {
                    // uint 64
                    this.writeU8(0xcf);
                    this.writeU64(object);
                }
            }
            else {
                if (object >= -0x20) {
                    // negative fixint
                    this.writeU8(0xe0 | (object + 0x20));
                }
                else if (object >= -0x80) {
                    // int 8
                    this.writeU8(0xd0);
                    this.writeI8(object);
                }
                else if (object >= -0x8000) {
                    // int 16
                    this.writeU8(0xd1);
                    this.writeI16(object);
                }
                else if (object >= -0x80000000) {
                    // int 32
                    this.writeU8(0xd2);
                    this.writeI32(object);
                }
                else {
                    // int 64
                    this.writeU8(0xd3);
                    this.writeI64(object);
                }
            }
        }
        else {
            // non-integer numbers
            if (this.forceFloat32) {
                // float 32
                this.writeU8(0xca);
                this.writeF32(object);
            }
            else {
                // float 64
                this.writeU8(0xcb);
                this.writeF64(object);
            }
        }
    };
    Encoder.prototype.writeStringHeader = function (byteLength) {
        if (byteLength < 32) {
            // fixstr
            this.writeU8(0xa0 + byteLength);
        }
        else if (byteLength < 0x100) {
            // str 8
            this.writeU8(0xd9);
            this.writeU8(byteLength);
        }
        else if (byteLength < 0x10000) {
            // str 16
            this.writeU8(0xda);
            this.writeU16(byteLength);
        }
        else if (byteLength < 0x100000000) {
            // str 32
            this.writeU8(0xdb);
            this.writeU32(byteLength);
        }
        else {
            throw new Error("Too long string: ".concat(byteLength, " bytes in UTF-8"));
        }
    };
    Encoder.prototype.encodeString = function (object) {
        var maxHeaderSize = 1 + 4;
        var strLength = object.length;
        if (strLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.TEXT_ENCODER_THRESHOLD) {
            var byteLength = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);
            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
            this.writeStringHeader(byteLength);
            (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8EncodeTE)(object, this.bytes, this.pos);
            this.pos += byteLength;
        }
        else {
            var byteLength = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);
            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
            this.writeStringHeader(byteLength);
            (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8EncodeJs)(object, this.bytes, this.pos);
            this.pos += byteLength;
        }
    };
    Encoder.prototype.encodeObject = function (object, depth) {
        // try to encode objects with custom codec first of non-primitives
        var ext = this.extensionCodec.tryToEncode(object, this.context);
        if (ext != null) {
            this.encodeExtension(ext);
        }
        else if (Array.isArray(object)) {
            this.encodeArray(object, depth);
        }
        else if (ArrayBuffer.isView(object)) {
            this.encodeBinary(object);
        }
        else if (typeof object === "object") {
            this.encodeMap(object, depth);
        }
        else {
            // symbol, function and other special object come here unless extensionCodec handles them.
            throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(object)));
        }
    };
    Encoder.prototype.encodeBinary = function (object) {
        var size = object.byteLength;
        if (size < 0x100) {
            // bin 8
            this.writeU8(0xc4);
            this.writeU8(size);
        }
        else if (size < 0x10000) {
            // bin 16
            this.writeU8(0xc5);
            this.writeU16(size);
        }
        else if (size < 0x100000000) {
            // bin 32
            this.writeU8(0xc6);
            this.writeU32(size);
        }
        else {
            throw new Error("Too large binary: ".concat(size));
        }
        var bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__.ensureUint8Array)(object);
        this.writeU8a(bytes);
    };
    Encoder.prototype.encodeArray = function (object, depth) {
        var size = object.length;
        if (size < 16) {
            // fixarray
            this.writeU8(0x90 + size);
        }
        else if (size < 0x10000) {
            // array 16
            this.writeU8(0xdc);
            this.writeU16(size);
        }
        else if (size < 0x100000000) {
            // array 32
            this.writeU8(0xdd);
            this.writeU32(size);
        }
        else {
            throw new Error("Too large array: ".concat(size));
        }
        for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {
            var item = object_1[_i];
            this.doEncode(item, depth + 1);
        }
    };
    Encoder.prototype.countWithoutUndefined = function (object, keys) {
        var count = 0;
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            if (object[key] !== undefined) {
                count++;
            }
        }
        return count;
    };
    Encoder.prototype.encodeMap = function (object, depth) {
        var keys = Object.keys(object);
        if (this.sortKeys) {
            keys.sort();
        }
        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
        if (size < 16) {
            // fixmap
            this.writeU8(0x80 + size);
        }
        else if (size < 0x10000) {
            // map 16
            this.writeU8(0xde);
            this.writeU16(size);
        }
        else if (size < 0x100000000) {
            // map 32
            this.writeU8(0xdf);
            this.writeU32(size);
        }
        else {
            throw new Error("Too large map object: ".concat(size));
        }
        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
            var key = keys_2[_i];
            var value = object[key];
            if (!(this.ignoreUndefined && value === undefined)) {
                this.encodeString(key);
                this.doEncode(value, depth + 1);
            }
        }
    };
    Encoder.prototype.encodeExtension = function (ext) {
        var size = ext.data.length;
        if (size === 1) {
            // fixext 1
            this.writeU8(0xd4);
        }
        else if (size === 2) {
            // fixext 2
            this.writeU8(0xd5);
        }
        else if (size === 4) {
            // fixext 4
            this.writeU8(0xd6);
        }
        else if (size === 8) {
            // fixext 8
            this.writeU8(0xd7);
        }
        else if (size === 16) {
            // fixext 16
            this.writeU8(0xd8);
        }
        else if (size < 0x100) {
            // ext 8
            this.writeU8(0xc7);
            this.writeU8(size);
        }
        else if (size < 0x10000) {
            // ext 16
            this.writeU8(0xc8);
            this.writeU16(size);
        }
        else if (size < 0x100000000) {
            // ext 32
            this.writeU8(0xc9);
            this.writeU32(size);
        }
        else {
            throw new Error("Too large extension object: ".concat(size));
        }
        this.writeI8(ext.type);
        this.writeU8a(ext.data);
    };
    Encoder.prototype.writeU8 = function (value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setUint8(this.pos, value);
        this.pos++;
    };
    Encoder.prototype.writeU8a = function (values) {
        var size = values.length;
        this.ensureBufferSizeToWrite(size);
        this.bytes.set(values, this.pos);
        this.pos += size;
    };
    Encoder.prototype.writeI8 = function (value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setInt8(this.pos, value);
        this.pos++;
    };
    Encoder.prototype.writeU16 = function (value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setUint16(this.pos, value);
        this.pos += 2;
    };
    Encoder.prototype.writeI16 = function (value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
    };
    Encoder.prototype.writeU32 = function (value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setUint32(this.pos, value);
        this.pos += 4;
    };
    Encoder.prototype.writeI32 = function (value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
    };
    Encoder.prototype.writeF32 = function (value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
    };
    Encoder.prototype.writeF64 = function (value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
    };
    Encoder.prototype.writeU64 = function (value) {
        this.ensureBufferSizeToWrite(8);
        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setUint64)(this.view, this.pos, value);
        this.pos += 8;
    };
    Encoder.prototype.writeI64 = function (value) {
        this.ensureBufferSizeToWrite(8);
        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setInt64)(this.view, this.pos, value);
        this.pos += 8;
    };
    return Encoder;
}());

//# sourceMappingURL=Encoder.mjs.map

/***/ }),
/* 64 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExtensionCodec": () => (/* binding */ ExtensionCodec)
/* harmony export */ });
/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68);
/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65);
// ExtensionCodec to handle MessagePack extensions


var ExtensionCodec = /** @class */ (function () {
    function ExtensionCodec() {
        // built-in extensions
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        // custom extensions
        this.encoders = [];
        this.decoders = [];
        this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__.timestampExtension);
    }
    ExtensionCodec.prototype.register = function (_a) {
        var type = _a.type, encode = _a.encode, decode = _a.decode;
        if (type >= 0) {
            // custom extensions
            this.encoders[type] = encode;
            this.decoders[type] = decode;
        }
        else {
            // built-in extensions
            var index = 1 + type;
            this.builtInEncoders[index] = encode;
            this.builtInDecoders[index] = decode;
        }
    };
    ExtensionCodec.prototype.tryToEncode = function (object, context) {
        // built-in extensions
        for (var i = 0; i < this.builtInEncoders.length; i++) {
            var encodeExt = this.builtInEncoders[i];
            if (encodeExt != null) {
                var data = encodeExt(object, context);
                if (data != null) {
                    var type = -1 - i;
                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);
                }
            }
        }
        // custom extensions
        for (var i = 0; i < this.encoders.length; i++) {
            var encodeExt = this.encoders[i];
            if (encodeExt != null) {
                var data = encodeExt(object, context);
                if (data != null) {
                    var type = i;
                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);
                }
            }
        }
        if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData) {
            // to keep ExtData as is
            return object;
        }
        return null;
    };
    ExtensionCodec.prototype.decode = function (data, type, context) {
        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decodeExt) {
            return decodeExt(data, type, context);
        }
        else {
            // decode() does not fail, returns ExtData instead.
            return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);
        }
    };
    ExtensionCodec.defaultCodec = new ExtensionCodec();
    return ExtensionCodec;
}());

//# sourceMappingURL=ExtensionCodec.mjs.map

/***/ }),
/* 65 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EXT_TIMESTAMP": () => (/* binding */ EXT_TIMESTAMP),
/* harmony export */   "decodeTimestampExtension": () => (/* binding */ decodeTimestampExtension),
/* harmony export */   "decodeTimestampToTimeSpec": () => (/* binding */ decodeTimestampToTimeSpec),
/* harmony export */   "encodeDateToTimeSpec": () => (/* binding */ encodeDateToTimeSpec),
/* harmony export */   "encodeTimeSpecToTimestamp": () => (/* binding */ encodeTimeSpecToTimestamp),
/* harmony export */   "encodeTimestampExtension": () => (/* binding */ encodeTimestampExtension),
/* harmony export */   "timestampExtension": () => (/* binding */ timestampExtension)
/* harmony export */ });
/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67);
/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66);
// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type


var EXT_TIMESTAMP = -1;
var TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int
var TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int
function encodeTimeSpecToTimestamp(_a) {
    var sec = _a.sec, nsec = _a.nsec;
    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
        // Here sec >= 0 && nsec >= 0
        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
            // timestamp 32 = { sec32 (unsigned) }
            var rv = new Uint8Array(4);
            var view = new DataView(rv.buffer);
            view.setUint32(0, sec);
            return rv;
        }
        else {
            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }
            var secHigh = sec / 0x100000000;
            var secLow = sec & 0xffffffff;
            var rv = new Uint8Array(8);
            var view = new DataView(rv.buffer);
            // nsec30 | secHigh2
            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));
            // secLow32
            view.setUint32(4, secLow);
            return rv;
        }
    }
    else {
        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }
        var rv = new Uint8Array(12);
        var view = new DataView(rv.buffer);
        view.setUint32(0, nsec);
        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.setInt64)(view, 4, sec);
        return rv;
    }
}
function encodeDateToTimeSpec(date) {
    var msec = date.getTime();
    var sec = Math.floor(msec / 1e3);
    var nsec = (msec - sec * 1e3) * 1e6;
    // Normalizes { sec, nsec } to ensure nsec is unsigned.
    var nsecInSec = Math.floor(nsec / 1e9);
    return {
        sec: sec + nsecInSec,
        nsec: nsec - nsecInSec * 1e9,
    };
}
function encodeTimestampExtension(object) {
    if (object instanceof Date) {
        var timeSpec = encodeDateToTimeSpec(object);
        return encodeTimeSpecToTimestamp(timeSpec);
    }
    else {
        return null;
    }
}
function decodeTimestampToTimeSpec(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    // data may be 32, 64, or 96 bits
    switch (data.byteLength) {
        case 4: {
            // timestamp 32 = { sec32 }
            var sec = view.getUint32(0);
            var nsec = 0;
            return { sec: sec, nsec: nsec };
        }
        case 8: {
            // timestamp 64 = { nsec30, sec34 }
            var nsec30AndSecHigh2 = view.getUint32(0);
            var secLow32 = view.getUint32(4);
            var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;
            var nsec = nsec30AndSecHigh2 >>> 2;
            return { sec: sec, nsec: nsec };
        }
        case 12: {
            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }
            var sec = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.getInt64)(view, 4);
            var nsec = view.getUint32(0);
            return { sec: sec, nsec: nsec };
        }
        default:
            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__.DecodeError("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(data.length));
    }
}
function decodeTimestampExtension(data) {
    var timeSpec = decodeTimestampToTimeSpec(data);
    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
var timestampExtension = {
    type: EXT_TIMESTAMP,
    encode: encodeTimestampExtension,
    decode: decodeTimestampExtension,
};
//# sourceMappingURL=timestamp.mjs.map

/***/ }),
/* 66 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UINT32_MAX": () => (/* binding */ UINT32_MAX),
/* harmony export */   "getInt64": () => (/* binding */ getInt64),
/* harmony export */   "getUint64": () => (/* binding */ getUint64),
/* harmony export */   "setInt64": () => (/* binding */ setInt64),
/* harmony export */   "setUint64": () => (/* binding */ setUint64)
/* harmony export */ });
// Integer Utility
var UINT32_MAX = 4294967295;
// DataView extension to handle int64 / uint64,
// where the actual range is 53-bits integer (a.k.a. safe integer)
function setUint64(view, offset, value) {
    var high = value / 4294967296;
    var low = value; // high bits are truncated by DataView
    view.setUint32(offset, high);
    view.setUint32(offset + 4, low);
}
function setInt64(view, offset, value) {
    var high = Math.floor(value / 4294967296);
    var low = value; // high bits are truncated by DataView
    view.setUint32(offset, high);
    view.setUint32(offset + 4, low);
}
function getInt64(view, offset) {
    var high = view.getInt32(offset);
    var low = view.getUint32(offset + 4);
    return high * 4294967296 + low;
}
function getUint64(view, offset) {
    var high = view.getUint32(offset);
    var low = view.getUint32(offset + 4);
    return high * 4294967296 + low;
}
//# sourceMappingURL=int.mjs.map

/***/ }),
/* 67 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DecodeError": () => (/* binding */ DecodeError)
/* harmony export */ });
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var DecodeError = /** @class */ (function (_super) {
    __extends(DecodeError, _super);
    function DecodeError(message) {
        var _this = _super.call(this, message) || this;
        // fix the prototype chain in a cross-platform way
        var proto = Object.create(DecodeError.prototype);
        Object.setPrototypeOf(_this, proto);
        Object.defineProperty(_this, "name", {
            configurable: true,
            enumerable: false,
            value: DecodeError.name,
        });
        return _this;
    }
    return DecodeError;
}(Error));

//# sourceMappingURL=DecodeError.mjs.map

/***/ }),
/* 68 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExtData": () => (/* binding */ ExtData)
/* harmony export */ });
/**
 * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.
 */
var ExtData = /** @class */ (function () {
    function ExtData(type, data) {
        this.type = type;
        this.data = data;
    }
    return ExtData;
}());

//# sourceMappingURL=ExtData.mjs.map

/***/ }),
/* 69 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TEXT_DECODER_THRESHOLD": () => (/* binding */ TEXT_DECODER_THRESHOLD),
/* harmony export */   "TEXT_ENCODER_THRESHOLD": () => (/* binding */ TEXT_ENCODER_THRESHOLD),
/* harmony export */   "utf8Count": () => (/* binding */ utf8Count),
/* harmony export */   "utf8DecodeJs": () => (/* binding */ utf8DecodeJs),
/* harmony export */   "utf8DecodeTD": () => (/* binding */ utf8DecodeTD),
/* harmony export */   "utf8EncodeJs": () => (/* binding */ utf8EncodeJs),
/* harmony export */   "utf8EncodeTE": () => (/* binding */ utf8EncodeTE)
/* harmony export */ });
/* harmony import */ var _int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66);
var _a, _b, _c;
/* eslint-disable @typescript-eslint/no-unnecessary-condition */

var TEXT_ENCODING_AVAILABLE = (typeof process === "undefined" || ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a["TEXT_ENCODING"]) !== "never") &&
    typeof TextEncoder !== "undefined" &&
    typeof TextDecoder !== "undefined";
function utf8Count(str) {
    var strLength = str.length;
    var byteLength = 0;
    var pos = 0;
    while (pos < strLength) {
        var value = str.charCodeAt(pos++);
        if ((value & 0xffffff80) === 0) {
            // 1-byte
            byteLength++;
            continue;
        }
        else if ((value & 0xfffff800) === 0) {
            // 2-bytes
            byteLength += 2;
        }
        else {
            // handle surrogate pair
            if (value >= 0xd800 && value <= 0xdbff) {
                // high surrogate
                if (pos < strLength) {
                    var extra = str.charCodeAt(pos);
                    if ((extra & 0xfc00) === 0xdc00) {
                        ++pos;
                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
                    }
                }
            }
            if ((value & 0xffff0000) === 0) {
                // 3-byte
                byteLength += 3;
            }
            else {
                // 4-byte
                byteLength += 4;
            }
        }
    }
    return byteLength;
}
function utf8EncodeJs(str, output, outputOffset) {
    var strLength = str.length;
    var offset = outputOffset;
    var pos = 0;
    while (pos < strLength) {
        var value = str.charCodeAt(pos++);
        if ((value & 0xffffff80) === 0) {
            // 1-byte
            output[offset++] = value;
            continue;
        }
        else if ((value & 0xfffff800) === 0) {
            // 2-bytes
            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;
        }
        else {
            // handle surrogate pair
            if (value >= 0xd800 && value <= 0xdbff) {
                // high surrogate
                if (pos < strLength) {
                    var extra = str.charCodeAt(pos);
                    if ((extra & 0xfc00) === 0xdc00) {
                        ++pos;
                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
                    }
                }
            }
            if ((value & 0xffff0000) === 0) {
                // 3-byte
                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;
                output[offset++] = ((value >> 6) & 0x3f) | 0x80;
            }
            else {
                // 4-byte
                output[offset++] = ((value >> 18) & 0x07) | 0xf0;
                output[offset++] = ((value >> 12) & 0x3f) | 0x80;
                output[offset++] = ((value >> 6) & 0x3f) | 0x80;
            }
        }
        output[offset++] = (value & 0x3f) | 0x80;
    }
}
var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;
var TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE
    ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX
    : typeof process !== "undefined" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b["TEXT_ENCODING"]) !== "force"
        ? 200
        : 0;
function utf8EncodeTEencode(str, output, outputOffset) {
    output.set(sharedTextEncoder.encode(str), outputOffset);
}
function utf8EncodeTEencodeInto(str, output, outputOffset) {
    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
}
var utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;
var CHUNK_SIZE = 4096;
function utf8DecodeJs(bytes, inputOffset, byteLength) {
    var offset = inputOffset;
    var end = offset + byteLength;
    var units = [];
    var result = "";
    while (offset < end) {
        var byte1 = bytes[offset++];
        if ((byte1 & 0x80) === 0) {
            // 1 byte
            units.push(byte1);
        }
        else if ((byte1 & 0xe0) === 0xc0) {
            // 2 bytes
            var byte2 = bytes[offset++] & 0x3f;
            units.push(((byte1 & 0x1f) << 6) | byte2);
        }
        else if ((byte1 & 0xf0) === 0xe0) {
            // 3 bytes
            var byte2 = bytes[offset++] & 0x3f;
            var byte3 = bytes[offset++] & 0x3f;
            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);
        }
        else if ((byte1 & 0xf8) === 0xf0) {
            // 4 bytes
            var byte2 = bytes[offset++] & 0x3f;
            var byte3 = bytes[offset++] & 0x3f;
            var byte4 = bytes[offset++] & 0x3f;
            var unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;
            if (unit > 0xffff) {
                unit -= 0x10000;
                units.push(((unit >>> 10) & 0x3ff) | 0xd800);
                unit = 0xdc00 | (unit & 0x3ff);
            }
            units.push(unit);
        }
        else {
            units.push(byte1);
        }
        if (units.length >= CHUNK_SIZE) {
            result += String.fromCharCode.apply(String, units);
            units.length = 0;
        }
    }
    if (units.length > 0) {
        result += String.fromCharCode.apply(String, units);
    }
    return result;
}
var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;
var TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE
    ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX
    : typeof process !== "undefined" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c["TEXT_DECODER"]) !== "force"
        ? 200
        : 0;
function utf8DecodeTD(bytes, inputOffset, byteLength) {
    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
    return sharedTextDecoder.decode(stringBytes);
}
//# sourceMappingURL=utf8.mjs.map

/***/ }),
/* 70 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDataView": () => (/* binding */ createDataView),
/* harmony export */   "ensureUint8Array": () => (/* binding */ ensureUint8Array)
/* harmony export */ });
function ensureUint8Array(buffer) {
    if (buffer instanceof Uint8Array) {
        return buffer;
    }
    else if (ArrayBuffer.isView(buffer)) {
        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    }
    else if (buffer instanceof ArrayBuffer) {
        return new Uint8Array(buffer);
    }
    else {
        // ArrayLike<number>
        return Uint8Array.from(buffer);
    }
}
function createDataView(buffer) {
    if (buffer instanceof ArrayBuffer) {
        return new DataView(buffer);
    }
    var bufferView = ensureUint8Array(buffer);
    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
}
//# sourceMappingURL=typedArrays.mjs.map

/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTransitProviderAttributes": () => (/* binding */ getTransitProviderAttributes),
/* harmony export */   "getTransitProviderAttributesByChain": () => (/* binding */ getTransitProviderAttributesByChain),
/* harmony export */   "getTransitProviderAttributesByProviderId": () => (/* binding */ getTransitProviderAttributesByProviderId),
/* harmony export */   "supportedTransitProviders": () => (/* binding */ supportedTransitProviders),
/* harmony export */   "transitProviderAttributesData": () => (/* binding */ transitProviderAttributesData)
/* harmony export */ });
/* harmony import */ var _common_models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);


/** Function used within transit provider to transform a wallet's public key to a full account strucutre */
var AlgorandDiscoveryKeyLookupFunc = function AlgorandDiscoveryKeyLookupFunc(discoveryData, callback) {
  var accountInfoArray = discoveryData.keys.map(function (key) {
    // note holds a stringified JSON object - composed by Algosigner Transit plugin
    var account = JSON.parse(key.note);
    return {
      index: key.index,
      key: key.key,
      accounts: [{
        account: account === null || account === void 0 ? void 0 : account.accountName,
        authorization: account === null || account === void 0 ? void 0 : account.permission
      }]
    };
  });
  callback(accountInfoArray);
};
/** Pass-through function used within eos-transit host - if not provided, wallet will try to use EOS to transform keys */


var NonEosDiscoveryKeyLookupFunc = function NonEosDiscoveryKeyLookupFunc(discoveryData, callback) {
  callback(discoveryData.keyToAccountMap);
};

var transitProviderAttributesData = [{
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.AlgoSigner,
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.algorand,
  providerId: 'algosigner',
  requiresLogin: false,
  supportsDiscovery: true,
  supportsSignArbitrary: false,
  requiresLogoutLoginToDiscover: false,
  requiresDiscoverToLogin: false,
  helpText: {
    login: 'This wallet doesn’t require you to login.',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  discoveryKeyLookupFunc: AlgorandDiscoveryKeyLookupFunc,
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-algosigner-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.Keycat,
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  providerId: 'Keycat',
  requiresLogin: true,
  supportsDiscovery: false,
  supportsSignArbitrary: true,
  requiresLogoutLoginToDiscover: true,
  requiresDiscoverToLogin: false,
  helpText: {
    login: 'Keycat requires logging in through the Keycat app.',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-keycat-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.Ledger,
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  providerId: 'ledger',
  requiresLogin: true,
  supportsDiscovery: true,
  supportsSignArbitrary: false,
  requiresLogoutLoginToDiscover: false,
  requiresDiscoverToLogin: true,
  defaultDiscoveryPathIndexList: [0, 1, 2],
  helpText: {
    login: 'This wallet doesn’t require you to login',
    sign: 'Connect and unlock your Ledger with your PIN code. Launch the EOS app on the device.',
    discover: 'Connect and unlock your Ledger with your PIN code. Launch the EOS app on the device.',
    versionsRequired: 'You need to have recent versions of your browser, Ledger firmware, and the Ledger EOS app. Click here for more details.'
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-ledger-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.Lynx,
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  providerId: 'EOS Lynx',
  requiresLogin: true,
  supportsDiscovery: false,
  supportsSignArbitrary: true,
  requiresLogoutLoginToDiscover: true,
  requiresDiscoverToLogin: false,
  helpText: {
    login: 'EOS Lynx requires logging in through the EOS Lynx app.',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-lynx-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.Meetone,
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  providerId: 'meetone_provider',
  requiresLogin: false,
  supportsDiscovery: false,
  supportsSignArbitrary: true,
  requiresLogoutLoginToDiscover: true,
  requiresDiscoverToLogin: false,
  helpText: {
    login: 'This wallet doesn’t require you to login',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-meetone-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.Metro,
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  providerId: 'metro',
  requiresLogin: false,
  supportsDiscovery: false,
  supportsSignArbitrary: false,
  requiresLogoutLoginToDiscover: false,
  requiresDiscoverToLogin: false,
  helpText: {
    login: 'This wallet doesn’t require you to login',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-generic-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.Portis,
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  providerId: 'PortisProvider',
  requiresLogin: true,
  supportsDiscovery: false,
  supportsSignArbitrary: false,
  requiresLogoutLoginToDiscover: true,
  requiresDiscoverToLogin: false,
  helpText: {
    login: 'Portis requires logging in through the Portis app.',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-portis-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.Scatter,
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  providerId: 'scatter',
  requiresLogin: true,
  supportsDiscovery: false,
  supportsSignArbitrary: true,
  requiresLogoutLoginToDiscover: true,
  requiresDiscoverToLogin: false,
  helpText: {
    login: 'Scatter requires logging in through the Scatter app.',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-scatter-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.SimpleEos,
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  providerId: 'simpleos',
  requiresLogin: true,
  supportsDiscovery: false,
  supportsSignArbitrary: false,
  requiresLogoutLoginToDiscover: true,
  requiresDiscoverToLogin: false,
  helpText: {
    login: 'Simpleos requires logging in through the Simpleos app.',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-simpleos-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.TokenPocket,
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  providerId: 'TokenPocket',
  requiresLogin: true,
  supportsDiscovery: false,
  supportsSignArbitrary: true,
  requiresLogoutLoginToDiscover: true,
  requiresDiscoverToLogin: false,
  helpText: {
    login: 'This wallet doesn’t require you to login',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-generic-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.WalletConnect,
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.ethereum,
  providerId: 'walletconnect',
  requiresLogin: false,
  supportsDiscovery: true,
  supportsSignArbitrary: true,
  requiresLogoutLoginToDiscover: false,
  requiresDiscoverToLogin: false,
  helpText: {
    login: 'This wallet doesn’t require you to login.',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  discoveryKeyLookupFunc: NonEosDiscoveryKeyLookupFunc,
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-walletconnect-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.Web3,
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.ethereum,
  providerId: 'web3',
  requiresLogin: false,
  supportsDiscovery: true,
  supportsSignArbitrary: true,
  requiresLogoutLoginToDiscover: false,
  requiresDiscoverToLogin: false,
  helpText: {
    login: 'This wallet doesn’t require you to login.',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  discoveryKeyLookupFunc: NonEosDiscoveryKeyLookupFunc,
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-web3-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.WhaleVault,
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  providerId: 'whalevault',
  requiresLogin: true,
  supportsDiscovery: false,
  supportsSignArbitrary: true,
  requiresLogoutLoginToDiscover: true,
  requiresDiscoverToLogin: false,
  helpText: {
    login: 'Whalevault requires logging in through the Whalevault app.',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-whalevault-logo.png'
}];
/** Get provider-specific settings and metadata */

function getTransitProviderAttributes(walletType) {
  return transitProviderAttributesData.find(function (tp) {
    return tp.providerName === walletType.toString();
  });
}
/** Get provider-specific settings and metadata */

function getTransitProviderAttributesByProviderId(providerId) {
  return transitProviderAttributesData.find(function (tp) {
    return tp.providerId === providerId;
  });
}
/** Get the list of provider attributes for a given chain */

function getTransitProviderAttributesByChain(chain) {
  return transitProviderAttributesData.filter(function (p) {
    return p.chainType === chain;
  });
}
var supportedTransitProviders = transitProviderAttributesData.map(function (tp) {
  return tp.providerName;
});

/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UalHelper)
/* harmony export */ });
/* harmony import */ var _ualProviders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73);
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }





var UalHelper = /*#__PURE__*/function () {
  function UalHelper(args) {
    _classCallCheck(this, UalHelper);

    this._oreIdContext = args.oreIdContext;
    this._user = args.user;
  }

  _createClass(UalHelper, [{
    key: "installUalProviders",
    value:
    /** Verifies that all plugins have a valid name
     *  Stores a list of the installed providerNames for all working plugins in ualProvidersInstalled
     */
    function () {
      var _installUalProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ualWalletProviders) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // Maps installed UALProviders to array of ExternaLWalletType names
                this._oreIdContext.ualProvidersInstalled = (ualWalletProviders || []).map(function (ualProviderFactory) {
                  var _getUalProviderAttrib;

                  return (_getUalProviderAttrib = (0,_ualProviders__WEBPACK_IMPORTED_MODULE_0__.getUalProviderAttributesByUalName)(ualProviderFactory === null || ualProviderFactory === void 0 ? void 0 : ualProviderFactory.name)) === null || _getUalProviderAttrib === void 0 ? void 0 : _getUalProviderAttrib.providerName;
                });

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function installUalProviders(_x) {
        return _installUalProviders.apply(this, arguments);
      }

      return installUalProviders;
    }()
    /** Retrieve the user and their account/permission details for the matching chainNetwork
     *  Returns null if nothing in wallet for chainNetwork
     */

  }, {
    key: "loginToUalProvider",
    value: function () {
      var _loginToUalProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(walletType, authenticator, chainNetwork, chainAccount) {
        var _this = this;

        var users, usersWithAccountsDetails, userForChain, _error$message, message;

        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.assertHasProviderInstalled(walletType, _models__WEBPACK_IMPORTED_MODULE_2__.ExternalWalletInterface.Ual);
                this.assertProviderValidForChainNetwork(walletType, chainNetwork);
                _context3.prev = 2;
                _context3.next = 5;
                return authenticator.login(chainAccount);

              case 5:
                users = _context3.sent;

                if (!_utils_helpers__WEBPACK_IMPORTED_MODULE_1__["default"].isNullOrEmpty(users)) {
                  _context3.next = 8;
                  break;
                }

                return _context3.abrupt("return", null);

              case 8:
                // for every supported chain, populate a result with the user and user's account/permission info
                usersWithAccountsDetails = [];
                _context3.next = 11;
                return _utils_helpers__WEBPACK_IMPORTED_MODULE_1__["default"].asyncForEach(users, /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(user) {
                    var userPermissions;
                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return _this.getAccountAndPermissionsFromUalUser(user);

                          case 2:
                            userPermissions = _context2.sent;
                            usersWithAccountsDetails.push({
                              user: user,
                              userPermissions: userPermissions
                            });

                          case 4:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function (_x6) {
                    return _ref.apply(this, arguments);
                  };
                }());

              case 11:
                // get only the user matching the desired chainNetwork
                userForChain = usersWithAccountsDetails.find(function (uwa) {
                  return uwa.userPermissions.chainNetwork === chainNetwork;
                });
                return _context3.abrupt("return", userForChain);

              case 15:
                _context3.prev = 15;
                _context3.t0 = _context3["catch"](2);
                _error$message = _context3.t0.message, message = _error$message === void 0 ? '' : _error$message;

                if (!message.includes('unknown key (boost::tuples::tuple')) {
                  _context3.next = 22;
                  break;
                }

                throw new Error("The account selected by the wallet for login isn't on the ".concat(chainNetwork, " chain"));

              case 22:
                throw _context3.t0;

              case 23:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2, 15]]);
      }));

      function loginToUalProvider(_x2, _x3, _x4, _x5) {
        return _loginToUalProvider.apply(this, arguments);
      }

      return loginToUalProvider;
    }() // TODO: We should cache the wallet/user object to avoid calling login everytime we need to sign

  }, {
    key: "connectToUalProvider",
    value: function () {
      var _connectToUalProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref2) {
        var walletType, chainNetwork, _ref2$chainAccount, chainAccount, options, SelectedAuthenticator, networkConfig, ualNetworkConfig, authenticator, ualError, userForChain, response;

        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                walletType = _ref2.walletType, chainNetwork = _ref2.chainNetwork, _ref2$chainAccount = _ref2.chainAccount, chainAccount = _ref2$chainAccount === void 0 ? null : _ref2$chainAccount;
                this.assertHasProviderInstalled(walletType, _models__WEBPACK_IMPORTED_MODULE_2__.ExternalWalletInterface.Ual);
                this.assertProviderValidForChainNetwork(walletType, chainNetwork);
                options = this._oreIdContext.options;
                SelectedAuthenticator = options.ualAuthenticators.find(function (ualAuthenticator) {
                  return ualAuthenticator.name.toLowerCase() === walletType;
                });
                _context4.prev = 5;
                _context4.next = 8;
                return this._oreIdContext.settings.getChainNetworkNextworkConfig(chainNetwork);

              case 8:
                networkConfig = _context4.sent;
                ualNetworkConfig = {
                  chainId: networkConfig.chainId,
                  rpcEndpoints: [_objectSpread({}, networkConfig)]
                }; // construct authenticator

                authenticator = new SelectedAuthenticator([ualNetworkConfig], {
                  appName: options.appName
                });

                this._oreIdContext.setIsBusy(true); // busy is cleared by waitWhileWalletIsBusy when done


                _context4.next = 14;
                return authenticator.init();

              case 14:
                _context4.next = 16;
                return this.waitWhileWalletIsBusy(authenticator, walletType);

              case 16:
                if (!authenticator.isErrored()) {
                  _context4.next = 20;
                  break;
                }

                ualError = authenticator.getError();
                console.log("Error connecting to UAL wallet type: ".concat(ualError.name), ualError.cause);
                throw ualError.cause;

              case 20:
                _context4.next = 22;
                return this.loginToUalProvider(walletType, authenticator, chainNetwork, chainAccount);

              case 22:
                userForChain = _context4.sent;

                if (userForChain) {
                  _context4.next = 26;
                  break;
                }

                console.log("User doesn't have an account for the chainNetwork: ".concat(chainNetwork, " in wallet type: ").concat(walletType));
                return _context4.abrupt("return", null);

              case 26:
                _context4.prev = 26;
                _context4.next = 29;
                return this.updateOreAccountPermissionsfromUalUser(userForChain.user, walletType);

              case 29:
                _context4.next = 34;
                break;

              case 31:
                _context4.prev = 31;
                _context4.t0 = _context4["catch"](26);
                console.log("Failed to add newly discovered chain accounts in connectToUalProvider for chainNetwork: ".concat(chainNetwork, " in wallet type: ").concat(walletType), _context4.t0);

              case 34:
                // const {
                //   account,
                //   chainNetwork: chainNetworkFromAuthenticator, // get the chainNetwork from the UALProvider since we cant tell it what network to use
                //   permissions,
                // } = await this.getAccountAndPermissionsFromUalUser(user)
                // const publicKeys = await user.getKeys()
                // const account = await user.getAccountName()
                // const permissions = [{ name: 'active', publicKey: publicKeys[0] }]
                response = {
                  isLoggedIn: true,
                  chainAccount: userForChain.userPermissions.chainAccount,
                  chainNetwork: userForChain.userPermissions.chainNetwork,
                  permissions: userForChain.userPermissions.permissions,
                  walletType: walletType,
                  authenticator: authenticator,
                  ualUser: userForChain.user
                };
                return _context4.abrupt("return", response);

              case 38:
                _context4.prev = 38;
                _context4.t1 = _context4["catch"](5);
                console.log("Failed to connect to ".concat(walletType, " wallet:"), _context4.t1);
                throw _context4.t1;

              case 42:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[5, 38], [26, 31]]);
      }));

      function connectToUalProvider(_x7) {
        return _connectToUalProvider.apply(this, arguments);
      }

      return connectToUalProvider;
    }()
    /** Extract user account/permission for all publicKeys in the User's wallet */

  }, {
    key: "getAccountAndPermissionsFromUalUser",
    value: function () {
      var _getAccountAndPermissionsFromUalUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(ualUser) {
        var chainId, chainNetwork, account, publicKeys, permissions;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return ualUser.getChainId();

              case 2:
                chainId = _context5.sent;
                _context5.next = 5;
                return this._oreIdContext.settings.getChainNetworkByChainId(chainId);

              case 5:
                chainNetwork = _context5.sent;
                _context5.next = 8;
                return ualUser.getAccountName();

              case 8:
                account = _context5.sent;
                _context5.next = 11;
                return this.getKeys(ualUser);

              case 11:
                publicKeys = _context5.sent;
                // for each publicKey in the user's wallet, return a WalletPermission object
                permissions = publicKeys.map(function (publicKey) {
                  return {
                    account: account,
                    publicKey: publicKey,
                    name: 'active' // UAL doesn't return the permission so we default to active
                    // todo: add parent permission when available

                  };
                });
                return _context5.abrupt("return", {
                  chainAccount: account,
                  chainNetwork: chainNetwork,
                  permissions: permissions
                });

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getAccountAndPermissionsFromUalUser(_x8) {
        return _getAccountAndPermissionsFromUalUser.apply(this, arguments);
      }

      return getAccountAndPermissionsFromUalUser;
    }()
    /** Login using the wallet provider */

  }, {
    key: "loginWithUalProvider",
    value: function () {
      var _loginWithUalProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(loginOptions) {
        var walletType, chainAccount, chainNetwork, response, authenticator, isLoggedIn, userForChain;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                walletType = loginOptions.walletType, chainAccount = loginOptions.chainAccount, chainNetwork = loginOptions.chainNetwork; // Connect to Provider

                _context6.next = 3;
                return this.connectToUalProvider({
                  walletType: walletType,
                  chainAccount: chainAccount,
                  chainNetwork: chainNetwork
                });

              case 3:
                response = _context6.sent;
                authenticator = response.authenticator, isLoggedIn = response.isLoggedIn; // Login if needed - if not logged-in by connectToUalProvider, then call login explicitly

                if (isLoggedIn) {
                  _context6.next = 12;
                  break;
                }

                _context6.next = 8;
                return this.loginToUalProvider(walletType, authenticator, chainNetwork, chainAccount);

              case 8:
                userForChain = _context6.sent;

                if (!userForChain) {
                  _context6.next = 12;
                  break;
                }

                _context6.next = 12;
                return this.updateOreAccountPermissionsfromUalUser(userForChain.user, walletType);

              case 12:
                return _context6.abrupt("return", response);

              case 13:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function loginWithUalProvider(_x9) {
        return _loginWithUalProvider.apply(this, arguments);
      }

      return loginWithUalProvider;
    }()
    /** Throw if the required plug-in is not installed */

  }, {
    key: "assertHasProviderInstalled",
    value: function assertHasProviderInstalled(provider, providerType) {
      if (providerType === _models__WEBPACK_IMPORTED_MODULE_2__.ExternalWalletInterface.Ual) {
        if (!this.hasUalProvider(provider)) {
          throw Error("UAL authenticator:\"".concat(provider, "\" not installed. Please pass it in via ualAuthenticators."));
        }
      }
    }
    /** sign with a UAL wallet */

  }, {
    key: "signWithUalProvider",
    value: function () {
      var _signWithUalProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(transactionData, walletType) {
        var chainNetwork, transaction, chainAccount, signOptions, provider, broadcast, _yield$this$connectTo, ualUser, signedTransactionResponse, serializedTransaction;

        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                chainNetwork = transactionData.chainNetwork, transaction = transactionData.transaction, chainAccount = transactionData.chainAccount, signOptions = transactionData.signOptions;
                provider = signOptions.provider, broadcast = signOptions.broadcast;
                this.assertHasProviderInstalled(walletType, _models__WEBPACK_IMPORTED_MODULE_2__.ExternalWalletInterface.Ual);
                this.assertProviderValidForChainNetwork(walletType, chainNetwork);
                _context7.next = 6;
                return this.connectToUalProvider({
                  walletType: walletType,
                  chainNetwork: chainNetwork,
                  chainAccount: chainAccount
                });

              case 6:
                _yield$this$connectTo = _context7.sent;
                ualUser = _yield$this$connectTo.ualUser;
                _context7.prev = 8;

                this._oreIdContext.setIsBusy(true);

                _context7.next = 12;
                return ualUser.signTransaction(transaction, {
                  broadcast: broadcast
                });

              case 12:
                signedTransactionResponse = _context7.sent;
                // Convert serializedTransaction from UInt8Array to Buffer
                // i.e. when stringified change from: '{\"0\":129,\"1\":163'} to {"type":"Buffer","data":[129,163]}
                serializedTransaction = signedTransactionResponse.transaction.serializedTransaction;

                if (serializedTransaction) {
                  signedTransactionResponse.transaction.serializedTransaction = Buffer.from(serializedTransaction);
                }

                return _context7.abrupt("return", {
                  signedTransaction: signedTransactionResponse.transaction
                });

              case 18:
                _context7.prev = 18;
                _context7.t0 = _context7["catch"](8);
                console.error(_context7.t0);
                throw _context7.t0;

              case 22:
                _context7.prev = 22;

                this._oreIdContext.setIsBusy(false);

                return _context7.finish(22);

              case 25:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[8, 18, 22, 25]]);
      }));

      function signWithUalProvider(_x10, _x11) {
        return _signWithUalProvider.apply(this, arguments);
      }

      return signWithUalProvider;
    }()
    /** Signs an arbitrary string using a specific provider */

  }, {
    key: "signStringWithUalProvider",
    value: function () {
      var _signStringWithUalProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_ref3) {
        var walletType, chainNetwork, string, chainAccount, message, _yield$this$connectTo2, ualUser, keys, response;

        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                walletType = _ref3.walletType, chainNetwork = _ref3.chainNetwork, string = _ref3.string, chainAccount = _ref3.chainAccount, message = _ref3.message;
                this.assertHasProviderInstalled(walletType, _models__WEBPACK_IMPORTED_MODULE_2__.ExternalWalletInterface.Ual);
                this.assertProviderValidForChainNetwork(walletType, chainNetwork);
                _context8.next = 5;
                return this.connectToUalProvider({
                  walletType: walletType,
                  chainNetwork: chainNetwork,
                  chainAccount: chainAccount
                });

              case 5:
                _yield$this$connectTo2 = _context8.sent;
                ualUser = _yield$this$connectTo2.ualUser;
                _context8.prev = 7;

                this._oreIdContext.setIsBusy(true);

                _context8.next = 11;
                return this.getKeys(ualUser);

              case 11:
                keys = _context8.sent;
                _context8.next = 14;
                return ualUser.signArbitrary(keys[0], string, message);

              case 14:
                response = _context8.sent;
                return _context8.abrupt("return", {
                  signedString: response
                });

              case 18:
                _context8.prev = 18;
                _context8.t0 = _context8["catch"](7);
                console.error(_context8.t0);
                throw _context8.t0;

              case 22:
                _context8.prev = 22;

                this._oreIdContext.setIsBusy(false);

                return _context8.finish(22);

              case 25:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[7, 18, 22, 25]]);
      }));

      function signStringWithUalProvider(_x12) {
        return _signStringWithUalProvider.apply(this, arguments);
      }

      return signStringWithUalProvider;
    }()
    /** Add the account selected in the UAL User to the ORE account's list of account/permissions */

  }, {
    key: "updateOreAccountPermissionsfromUalUser",
    value: function () {
      var _updateOreAccountPermissionsfromUalUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(user, walletType) {
        var _this$_user;

        var _yield$this$getAccoun, chainAccount, chainNetwork, permissions;

        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (user) {
                  _context9.next = 2;
                  break;
                }

                return _context9.abrupt("return");

              case 2:
                _context9.next = 4;
                return this.getAccountAndPermissionsFromUalUser(user);

              case 4:
                _yield$this$getAccoun = _context9.sent;
                chainAccount = _yield$this$getAccoun.chainAccount;
                chainNetwork = _yield$this$getAccoun.chainNetwork;
                permissions = _yield$this$getAccoun.permissions;

                if (!(!chainAccount || !permissions || !chainNetwork)) {
                  _context9.next = 10;
                  break;
                }

                return _context9.abrupt("return");

              case 10:
                _context9.next = 12;
                return (_this$_user = this._user) === null || _this$_user === void 0 ? void 0 : _this$_user.updatePermissionsIfNecessary({
                  chainAccount: chainAccount,
                  chainNetwork: chainNetwork,
                  permissions: permissions,
                  walletType: walletType
                });

              case 12:
                return _context9.abrupt("return");

              case 13:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function updateOreAccountPermissionsfromUalUser(_x13, _x14) {
        return _updateOreAccountPermissionsfromUalUser.apply(this, arguments);
      }

      return updateOreAccountPermissionsfromUalUser;
    }()
    /** Whether this UAL provider was installed upon instantiation */

  }, {
    key: "isUalProvider",
    value: function isUalProvider(walletType) {
      var walletProviderType = _utils_helpers__WEBPACK_IMPORTED_MODULE_1__["default"].mapAuthProviderToWalletType(walletType);
      if (!walletProviderType) return false;
      return _ualProviders__WEBPACK_IMPORTED_MODULE_0__.supportedUALProviders.includes(walletProviderType);
    }
    /** Whether this UAL provider was installed upon instantiation */

  }, {
    key: "hasUalProvider",
    value: function hasUalProvider(walletType) {
      return this._oreIdContext.ualProvidersInstalled.includes(walletType);
    }
    /**
     * get user account keys
     * some wallets don't support getKeys
     */

  }, {
    key: "getKeys",
    value: function () {
      var _getKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(ualUser) {
        var keys;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.prev = 0;
                _context10.next = 3;
                return ualUser.getKeys();

              case 3:
                keys = _context10.sent;
                _context10.next = 9;
                break;

              case 6:
                _context10.prev = 6;
                _context10.t0 = _context10["catch"](0);
                // TODO: add logic to get permissions from eos chain for this account
                // const account = await ualUser.getAccountName()
                // const ualUserAccount = (ualUser as any).client && (await (ualUser as any).client.v1.chain.get_account(account))
                // const keys = await (ualUser as any).extractAccountKeys(ualUserAccount)
                keys = [];

              case 9:
                return _context10.abrupt("return", keys);

              case 10:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, null, [[0, 6]]);
      }));

      function getKeys(_x15) {
        return _getKeys.apply(this, arguments);
      }

      return getKeys;
    }()
    /** Throw if the provider doesnt support the specified chainNetwork */

  }, {
    key: "assertProviderValidForChainNetwork",
    value: function () {
      var _assertProviderValidForChainNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(walletType, chainNetwork) {
        var _getUalProviderAttrib2, chainType, networks, isValid;

        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _getUalProviderAttrib2 = (0,_ualProviders__WEBPACK_IMPORTED_MODULE_0__.getUalProviderAttributes)(walletType), chainType = _getUalProviderAttrib2.chainType;
                _context11.next = 3;
                return this._oreIdContext.settings.getAllChainNetworkSettings();

              case 3:
                networks = _context11.sent;
                isValid = !!networks.find(function (n) {
                  return n.network === chainNetwork && n.type === chainType;
                });

                if (isValid) {
                  _context11.next = 7;
                  break;
                }

                throw Error("External Wallet Type: ".concat(walletType, " doesnt support chainNetwork ").concat(chainNetwork, ". Hint: It supports networks of type ").concat(chainType, "."));

              case 7:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function assertProviderValidForChainNetwork(_x16, _x17) {
        return _assertProviderValidForChainNetwork.apply(this, arguments);
      }

      return assertProviderValidForChainNetwork;
    }()
    /** set isBusy on oreIdContext while wallet authenticator isLoading */

  }, {
    key: "waitWhileWalletIsBusy",
    value: function () {
      var _waitWhileWalletIsBusy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(ualAuthenticator, walletType) {
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (!ualAuthenticator.isLoading()) {
                  _context12.next = 7;
                  break;
                }

                this._oreIdContext.setIsBusy(true); // todo: add timeout
                // eslint-disable-next-line no-await-in-loop


                _context12.next = 4;
                return _utils_helpers__WEBPACK_IMPORTED_MODULE_1__["default"].sleep(250);

              case 4:
                // this is here to help a developer debug - dont remove this - if a wallet is not open to connect to, it will hang here
                console.log("connecting to ".concat(walletType, " via UAL wallet in progress:"), ualAuthenticator.isLoading());
                _context12.next = 0;
                break;

              case 7:
                this._oreIdContext.setIsBusy(false);

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function waitWhileWalletIsBusy(_x18, _x19) {
        return _waitWhileWalletIsBusy.apply(this, arguments);
      }

      return waitWhileWalletIsBusy;
    }() // Supported features by provider

    /** whether discovery is supported by the provider */

  }, {
    key: "canDiscover",
    value: function canDiscover(walletType) {
      if (this.hasUalProvider(walletType)) {
        return (0,_ualProviders__WEBPACK_IMPORTED_MODULE_0__.getUalProviderAttributes)(walletType).supportsDiscovery;
      }

      return false;
    }
    /** whether signString is supported by the provider */

  }, {
    key: "canSignString",
    value: function canSignString(walletType) {
      if (this.hasUalProvider(walletType)) {
        return (0,_ualProviders__WEBPACK_IMPORTED_MODULE_0__.getUalProviderAttributes)(walletType).supportsSignArbitrary;
      }

      return false;
    }
    /** whether call to discover is required by provider before login */

  }, {
    key: "requiresDiscoverToLogin",
    value: function requiresDiscoverToLogin(walletType) {
      if (this.hasUalProvider(walletType)) {
        return (0,_ualProviders__WEBPACK_IMPORTED_MODULE_0__.getUalProviderAttributes)(walletType).requiresDiscoverToLogin;
      }

      return false;
    }
    /** whether call to logout then login is required by provider before discover */

  }, {
    key: "requiresLogoutLoginToDiscover",
    value: function requiresLogoutLoginToDiscover(walletType) {
      if (this.hasUalProvider(walletType)) {
        return (0,_ualProviders__WEBPACK_IMPORTED_MODULE_0__.getUalProviderAttributes)(walletType).requiresLogoutLoginToDiscover;
      }

      return false;
    }
    /** default path index for provider (if any) */

  }, {
    key: "defaultDiscoveryPathIndexList",
    value: function defaultDiscoveryPathIndexList(walletType) {
      if (this.hasUalProvider(walletType)) {
        var _getUalProviderAttrib3;

        return (_getUalProviderAttrib3 = (0,_ualProviders__WEBPACK_IMPORTED_MODULE_0__.getUalProviderAttributes)(walletType)) === null || _getUalProviderAttrib3 === void 0 ? void 0 : _getUalProviderAttrib3.defaultDiscoveryPathIndexList;
      }

      return null;
    }
    /** help text displayed to user for provider */

  }, {
    key: "helpTextForProvider",
    value: function helpTextForProvider(walletType) {
      if (this.hasUalProvider(walletType)) {
        return (0,_ualProviders__WEBPACK_IMPORTED_MODULE_0__.getUalProviderAttributes)(walletType).helpText;
      }

      return null;
    }
  }]);

  return UalHelper;
}();



/***/ }),
/* 73 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getUalProviderAttributes": () => (/* binding */ getUalProviderAttributes),
/* harmony export */   "getUalProviderAttributesByUalName": () => (/* binding */ getUalProviderAttributesByUalName),
/* harmony export */   "supportedUALProviders": () => (/* binding */ supportedUALProviders),
/* harmony export */   "ualProviderAttributesData": () => (/* binding */ ualProviderAttributesData)
/* harmony export */ });
/* harmony import */ var _common_models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);

var ualProviderAttributesData = [{
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.Anchor,
  providerId: 'Anchor',
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  requiresLogin: true,
  supportsSignArbitrary: false,
  requiresLogoutLoginToDiscover: false,
  requiresDiscoverToLogin: false,
  supportsDiscovery: false,
  helpText: {
    login: 'This wallet doesn’t require you to login',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-generic-logo.png' // TODO: Add actual logo

}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.Ledger,
  providerId: 'Ledger',
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  requiresLogin: true,
  supportsSignArbitrary: false,
  requiresLogoutLoginToDiscover: false,
  requiresDiscoverToLogin: false,
  supportsDiscovery: false,
  helpText: {
    login: 'This wallet doesn’t require you to login',
    sign: 'Connect and unlock your Ledger with your PIN code. Launch the EOS app on the device.',
    discover: 'Connect and unlock your Ledger with your PIN code. Launch the EOS app on the device.',
    versionsRequired: 'You need to have recent versions of your browser, Ledger firmware, and the Ledger EOS app. Click here for more details.'
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-ledger-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.Lynx,
  providerId: 'Lynx',
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  requiresLogin: false,
  supportsSignArbitrary: true,
  requiresLogoutLoginToDiscover: false,
  requiresDiscoverToLogin: false,
  supportsDiscovery: false,
  helpText: {
    login: 'This wallet doesn’t require you to login',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-lynx-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.Scatter,
  providerId: 'Scatter',
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  requiresLogin: true,
  supportsSignArbitrary: true,
  requiresLogoutLoginToDiscover: false,
  requiresDiscoverToLogin: false,
  supportsDiscovery: false,
  helpText: {
    login: 'Scatter requires logging in through the Scatter app.',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-scatter-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.TokenPocket,
  providerId: 'Token Pocket',
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  requiresLogin: false,
  supportsSignArbitrary: true,
  requiresLogoutLoginToDiscover: false,
  requiresDiscoverToLogin: false,
  supportsDiscovery: false,
  helpText: {
    login: 'This wallet doesn’t require you to login',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-generic-logo.png'
}, {
  providerName: _common_models__WEBPACK_IMPORTED_MODULE_0__.ExternalWalletType.Wombat,
  providerId: 'Wombat',
  chainType: _common_models__WEBPACK_IMPORTED_MODULE_0__.ChainPlatformType.eos,
  requiresLogin: true,
  supportsSignArbitrary: true,
  requiresLogoutLoginToDiscover: false,
  requiresDiscoverToLogin: false,
  supportsDiscovery: false,
  helpText: {
    login: 'This wallet doesn’t require you to login',
    sign: '',
    discover: '',
    versionsRequired: ''
  },
  logoUrl: 'https://storage.googleapis.com/oreid-files/partners/wallet-wombat-logo.png' // TODO: Add actual logo

}];
/** Get provider-specific settings and metadata */

function getUalProviderAttributes(walletType) {
  return ualProviderAttributesData.find(function (up) {
    return up.providerName === walletType.toString().toLowerCase();
  });
}
/** Get provider-specific settings and metadata by the UAL provider name */

function getUalProviderAttributesByUalName(walletType) {
  return ualProviderAttributesData.find(function (up) {
    return up.providerName === walletType.toLowerCase();
  });
}
var supportedUALProviders = ualProviderAttributesData.map(function (tp) {
  return tp.providerName;
});

/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "User": () => (/* binding */ User)
/* harmony export */ });
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _api_endpoints_addPermission__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _core_urlGenerators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17);
/* harmony import */ var _utils_observable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75);
/* harmony import */ var _common_models__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8);
/* harmony import */ var _api_endpoints_updateDelayWalletSetup__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(76);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var _excluded = ["permissions"],
    _excluded2 = ["chainNetwork", "chainAccount", "permission"];

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var isNullOrEmpty = _utils_helpers__WEBPACK_IMPORTED_MODULE_3__["default"].isNullOrEmpty;
var User = /*#__PURE__*/function (_Observable) {
  _inherits(User, _Observable);

  var _super = _createSuper(User);

  function User(args) {
    var _thisSuper, _this;

    _classCallCheck(this, User);

    _this = _super.call(this);

    _defineProperty(_assertThisInitialized(_this), "onUpdateAccessTokenHelper", function (newAccessTokenHelper) {
      _this._accountName = newAccessTokenHelper.accountName;

      _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(User.prototype)), "callSubscribers", _thisSuper).call(_thisSuper);
    });

    _this._oreIdContext = args.oreIdContext;
    _this._accessTokenHelper = args.accessTokenHelper; // reference to current accessToken (via getter)

    _this._accountName = args.accountName;

    _this._accessTokenHelper.subscribe(_this.onUpdateAccessTokenHelper);

    return _this;
  } // pulled from the accessToken


  _createClass(User, [{
    key: "accessToken",
    get: function get() {
      return this._accessTokenHelper.accessToken;
    }
    /** User's OreID (accountName) */

  }, {
    key: "accountName",
    get: function get() {
      return this._accountName;
    }
    /** User's personal info (e.g. name, email, picture) */

  }, {
    key: "data",
    get: function get() {
      this.assertUserHasData();

      var _this$_userSourceData = this._userSourceData,
          permissions = _this$_userSourceData.permissions,
          otherInfo = _objectWithoutProperties(_this$_userSourceData, _excluded);

      return _objectSpread(_objectSpread({}, otherInfo), {}, {
        chainAccounts: this.getChainAccounts()
      });
    }
    /** Whether user's data has been retrieved with getData() */

  }, {
    key: "hasData",
    get: function get() {
      return !isNullOrEmpty(this === null || this === void 0 ? void 0 : this._userSourceData);
    }
  }, {
    key: "setUserSourceData",
    value: function setUserSourceData(userSourceData) {
      this._userSourceData = userSourceData;

      _get(_getPrototypeOf(User.prototype), "callSubscribers", this).call(this);
    }
    /** Return Blockchain accounts associated with the user's OreId account */

  }, {
    key: "getChainAccounts",
    value: function getChainAccounts() {
      var _this2 = this;

      this.assertUserHasData();
      var chainAccounts = (this._userSourceData.permissions || []).map(function (perm) {
        var _this2$getDefaultPerm = _this2.getDefaultPermissionForChainAccount(perm.chainAccount, perm.chainNetwork),
            _this2$getDefaultPerm2 = _slicedToArray(_this2$getDefaultPerm, 1),
            defaultPermission = _this2$getDefaultPerm2[0];

        return {
          chainAccount: perm.chainAccount,
          chainNetwork: perm.chainNetwork,
          defaultPermission: defaultPermission,
          permissions: _this2.getPermissionForChainAccount(perm.chainAccount, perm.chainNetwork)
        };
      }); // only return unique combinations of chainAccount and chainNetwork

      return _utils_helpers__WEBPACK_IMPORTED_MODULE_3__["default"].getUniqueValues(chainAccounts);
    }
    /** Whether we have a valid access token for the current user */

  }, {
    key: "isLoggedIn",
    get: function get() {
      return !!this.accessToken;
    }
    /** runs when accessTokenHelper changes */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "assertUserHasData",
    value:
    /** throw if user data hasn't been retrieved yet */
    function assertUserHasData() {
      if (!this.hasData) {
        throw new Error('User data hasnt been retrieved. Call user.getData() first.');
      }
    }
    /** throw if user hasn't have a valid email (i.e. user.email) */

  }, {
    key: "assertUserHasValidEmail",
    value: function assertUserHasValidEmail() {
      this.assertUserHasData();

      var _ref = (this === null || this === void 0 ? void 0 : this.data) || {},
          email = _ref.email;

      if (!_utils_helpers__WEBPACK_IMPORTED_MODULE_3__["default"].isValidEmail(email)) throw new Error('User doesnt have a valid email');
    }
    /** Get the user info from ORE ID API for a given user account and (usually) save the user into localStorage 'cache'
     *  Must have a valid accessToken to retrieve user
     */

  }, {
    key: "getData",
    value: function () {
      var _getData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(forceRefresh) {
        var accessToken, account, params, userSourceData;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this.hasData && !forceRefresh)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", this.data);

              case 2:
                // eslint-disable-next-line prefer-destructuring
                accessToken = this.accessToken;

                if (accessToken) {
                  _context.next = 5;
                  break;
                }

                throw new Error('AccessToken is missing or has expired');

              case 5:
                // get account specified in access token
                account = this === null || this === void 0 ? void 0 : this._accountName;
                params = {
                  account: account
                };
                _context.next = 9;
                return (0,_api__WEBPACK_IMPORTED_MODULE_0__.callApiGetUser)(this._oreIdContext, params);

              case 9:
                userSourceData = _context.sent;
                this._accountName = account;
                this.setUserSourceData(userSourceData);
                return _context.abrupt("return", this.data);

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getData(_x) {
        return _getData.apply(this, arguments);
      }

      return getData;
    }()
    /** Clears user's accessToken and user profile data */

  }, {
    key: "logout",
    value: function logout() {
      this._oreIdContext.logout();
    }
    /** Request OREID to create a new blockchain account in an existing user's wallet
     *  This is an advanced feature - it most cases, blockchain accounts will be created automatically upon first login
     */
    // async newChainAccount(newAccountOptions: NewAccountOptions) {
    //   // TODO - call API to create chain account (requires apiKey with createAccount right)
    //   // for webwidget, it should just refresh user info upon callback
    // }

    /** Returns a fully formed url to redirect the user's browser to create a new chain account using ORE ID
     *  This function calls the /new-account web endpoint
     *  Returns: Callback returns new chainAccount name */

  }, {
    key: "getNewChainAccountUrl",
    value: function () {
      var _getNewChainAccountUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(newAccountOptions) {
        var _ref2, account, accountType, chainNetwork, accountOptions, provider, state, _this$_oreIdContext$o, newAccountCallbackUrl, backgroundColor, args, newAccountUrl;

        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref2 = newAccountOptions || {}, account = _ref2.account, accountType = _ref2.accountType, chainNetwork = _ref2.chainNetwork, accountOptions = _ref2.accountOptions, provider = _ref2.provider, state = _ref2.state;
                _this$_oreIdContext$o = this._oreIdContext.options, newAccountCallbackUrl = _this$_oreIdContext$o.newAccountCallbackUrl, backgroundColor = _this$_oreIdContext$o.backgroundColor;
                args = {
                  account: account,
                  accountType: accountType,
                  backgroundColor: backgroundColor,
                  chainNetwork: chainNetwork,
                  accountOptions: accountOptions,
                  provider: provider,
                  callbackUrl: newAccountCallbackUrl,
                  state: state
                };
                _context2.next = 5;
                return (0,_core_urlGenerators__WEBPACK_IMPORTED_MODULE_2__.getOreIdNewChainAccountUrl)(this._oreIdContext, args);

              case 5:
                newAccountUrl = _context2.sent;
                return _context2.abrupt("return", {
                  newAccountUrl: newAccountUrl,
                  errors: null
                });

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getNewChainAccountUrl(_x2) {
        return _getNewChainAccountUrl.apply(this, arguments);
      }

      return getNewChainAccountUrl;
    }()
    /** Delete a test user
     * Test users are created by setting isTestUser:true on first authentication)
     */

  }, {
    key: "deleteTestUser",
    value: function () {
      var _deleteTestUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var result;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this !== null && this !== void 0 && this.accountName) {
                  _context3.next = 2;
                  break;
                }

                throw new Error('User not authenticated. Must be logged-in (or have set an accessToken).');

              case 2:
                _context3.next = 4;
                return (0,_api__WEBPACK_IMPORTED_MODULE_0__.callApiDeleteTestUser)(this._oreIdContext, {
                  account: this.accountName
                });

              case 4:
                result = _context3.sent;
                return _context3.abrupt("return", result);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function deleteTestUser() {
        return _deleteTestUser.apply(this, arguments);
      }

      return deleteTestUser;
    }()
    /** If the user hasn't already setup their wallet, this will prompt the setup on their next interactive authentication
     * Used to turn-off the delayWalletSetup for a user's account
     * delayWalletSetup is enabled by passing delayWalletSetup:true for a user's first authentication (e.g. popup.auth(delayWalletSetup:true))
     * Delayed Wallet Setup allows a user to login without creating blockchain accounts right away
     * Call this function (to disable delayWalletSetup) just before the user needs a blockchain account (e.g. before signing a transaction)
     */

  }, {
    key: "disableDelayedWalletSetup",
    value: function () {
      var _disableDelayedWalletSetup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var result;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (this !== null && this !== void 0 && this.accountName) {
                  _context4.next = 2;
                  break;
                }

                throw new Error('User not authenticated. Must be logged-in (or have set an accessToken).');

              case 2:
                _context4.next = 4;
                return (0,_api_endpoints_updateDelayWalletSetup__WEBPACK_IMPORTED_MODULE_6__.callApiUpdateDelayWalletSetup)(this._oreIdContext, {
                  account: this.accountName,
                  delayWalletSetup: false
                });

              case 4:
                result = _context4.sent;
                _context4.next = 7;
                return this.getData(true);

              case 7:
                return _context4.abrupt("return", result);

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function disableDelayedWalletSetup() {
        return _disableDelayedWalletSetup.apply(this, arguments);
      }

      return disableDelayedWalletSetup;
    }()
    /** Send a code to the user's primary email (user.email) - in order to verify the user has access to it
     *  After sending the code, use checkVerificationCodeForEmail() to verify that the user received the code */

  }, {
    key: "sendVerificationCodeToEmail",
    value: function () {
      var _sendVerificationCodeToEmail = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var _this$data;

        var result;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this.assertUserHasValidEmail();
                _context5.next = 3;
                return (0,_api__WEBPACK_IMPORTED_MODULE_0__.callApiPasswordLessSendCode)(this._oreIdContext, {
                  email: this === null || this === void 0 ? void 0 : (_this$data = this.data) === null || _this$data === void 0 ? void 0 : _this$data.email,
                  provider: _common_models__WEBPACK_IMPORTED_MODULE_5__.AuthProvider.Email
                });

              case 3:
                result = _context5.sent;
                return _context5.abrupt("return", result);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function sendVerificationCodeToEmail() {
        return _sendVerificationCodeToEmail.apply(this, arguments);
      }

      return sendVerificationCodeToEmail;
    }()
    /** Confirm that the code matches the last one just sent to the email by sendVerificationCodeToEmail() */

  }, {
    key: "checkVerificationCodeForEmail",
    value: function () {
      var _checkVerificationCodeForEmail = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref3) {
        var _this$data2;

        var code, result;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                code = _ref3.code;
                this.assertUserHasValidEmail();
                _context6.next = 4;
                return (0,_api__WEBPACK_IMPORTED_MODULE_0__.callApiPasswordLessVerifyCode)(this._oreIdContext, {
                  code: code,
                  email: this === null || this === void 0 ? void 0 : (_this$data2 = this.data) === null || _this$data2 === void 0 ? void 0 : _this$data2.email,
                  provider: _common_models__WEBPACK_IMPORTED_MODULE_5__.AuthProvider.Email
                });

              case 4:
                result = _context6.sent;
                return _context6.abrupt("return", result);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function checkVerificationCodeForEmail(_x3) {
        return _checkVerificationCodeForEmail.apply(this, arguments);
      }

      return checkVerificationCodeForEmail;
    }() // TODO: rename sendVerificationCodeToEmail - passwordlessVerificationSendCode(type, email, phone)
    // TODO: rename checkVerificationCodeForEmail - passwordlessVerificationVerifyCode(type, email, phone)

    /** Map permission from server data to local UserPermission object */

  }, {
    key: "mapUserPermission",
    value: function mapUserPermission(permission) {
      if (isNullOrEmpty(permission)) return null;

      var chainNetwork = permission.chainNetwork,
          chainAccount = permission.chainAccount,
          permissionName = permission.permission,
          other = _objectWithoutProperties(permission, _excluded2);

      return _objectSpread(_objectSpread({}, other), {}, {
        name: permissionName
      });
    }
    /** returns the UserPermissins a chainNetwork/chainAccount
     * if defaultOnly = true, returns the single default permission for the chainAccount
     */

  }, {
    key: "getPermissionForChainAccount",
    value: function getPermissionForChainAccount(chainAccount, chainNetwork) {
      var accountPermissions = this._userSourceData.permissions.filter(function (p) {
        return p.chainAccount === chainAccount && p.chainNetwork === chainNetwork;
      });

      return accountPermissions.map(this.mapUserPermission);
    }
  }, {
    key: "getDefaultPermissionForChainAccount",
    value: function getDefaultPermissionForChainAccount(chainAccount, chainNetwork) {
      var accountPermissions = this.getPermissionForChainAccount(chainAccount, chainNetwork);
      var defaultPermission = accountPermissions.filter(function (p) {
        return p.isDefault === true;
      }); // if no default is defined, and there is only one permission, use it as the default - this might be an external key

      if (isNullOrEmpty(defaultPermission) && (accountPermissions === null || accountPermissions === void 0 ? void 0 : accountPermissions.length) === 1) {
        defaultPermission = accountPermissions;
      }

      return defaultPermission;
    }
    /** Update permissions for user's ORE Account if any */

  }, {
    key: "updatePermissionsIfNecessary",
    value: function () {
      var _updatePermissionsIfNecessary = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(args) {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.addWalletPermissionsToOreIdAccount(args);

              case 2:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function updatePermissionsIfNecessary(_x4) {
        return _updatePermissionsIfNecessary.apply(this, arguments);
      }

      return updatePermissionsIfNecessary;
    }() // for each permission in the wallet, add to ORE ID (if not in user's record)

    /** for all walletPermissions not already in the user's OreID wallet, add it by calling the api (addPermission) */

  }, {
    key: "addWalletPermissionsToOreIdAccount",
    value: function () {
      var _addWalletPermissionsToOreIdAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(args) {
        var _this3 = this;

        var chainAccount, chainNetwork, permissions, walletType;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.getData();

              case 2:
                chainAccount = args.chainAccount, chainNetwork = args.chainNetwork, permissions = args.permissions, walletType = args.walletType;

                if (!(!this.accountName || isNullOrEmpty(permissions) || isNullOrEmpty(chainNetwork))) {
                  _context9.next = 5;
                  break;
                }

                return _context9.abrupt("return");

              case 5:
                _context9.next = 7;
                return _utils_helpers__WEBPACK_IMPORTED_MODULE_3__["default"].asyncForEach(permissions, /*#__PURE__*/function () {
                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(perm) {
                    var permission, parentPermission, skipThisPermission, publicKey;
                    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                      while (1) {
                        switch (_context8.prev = _context8.next) {
                          case 0:
                            permission = perm.name;
                            parentPermission = perm.parent;

                            if (!parentPermission) {
                              // HACK: assume parent permission - its missing from the discover() results
                              parentPermission = 'active';

                              if (permission === 'owner') {
                                parentPermission = '';
                              } else if (permission === 'active') {
                                parentPermission = 'owner';
                              }
                            } // filter out permission that the user already has in his record


                            skipThisPermission = _this3._userSourceData.permissions.some(function (up) {
                              return up.chainAccount === chainAccount && up.chainNetwork === chainNetwork && up.permission === permission || permission === 'owner';
                            }); // don't add 'owner' permission and skip ones that are already stored in user's account

                            if (!(skipThisPermission !== true)) {
                              _context8.next = 8;
                              break;
                            }

                            // let publicKey = p.required_auth.keys[0].key; //TODO: Handle multiple keys and weights
                            publicKey = perm.publicKey; // if call is successful, nothing is returned in response (except processId)

                            _context8.next = 8;
                            return (0,_api_endpoints_addPermission__WEBPACK_IMPORTED_MODULE_1__.callApiAddPermission)(_this3._oreIdContext, {
                              account: _this3.accountName,
                              chainAccount: chainAccount,
                              chainNetwork: chainNetwork,
                              publicKey: publicKey,
                              parentPermission: parentPermission,
                              permission: permission,
                              provider: walletType
                            });

                          case 8:
                          case "end":
                            return _context8.stop();
                        }
                      }
                    }, _callee8);
                  }));

                  return function (_x6) {
                    return _ref4.apply(this, arguments);
                  };
                }());

              case 7:
                _context9.next = 9;
                return this.getData();

              case 9:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function addWalletPermissionsToOreIdAccount(_x5) {
        return _addWalletPermissionsToOreIdAccount.apply(this, arguments);
      }

      return addWalletPermissionsToOreIdAccount;
    }()
  }]);

  return User;
}(_utils_observable__WEBPACK_IMPORTED_MODULE_4__.Observable);

/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Observable": () => (/* binding */ Observable)
/* harmony export */ });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var Observable = /*#__PURE__*/function () {
  function Observable() {
    _classCallCheck(this, Observable);

    this._subscribers = [];
  }

  _createClass(Observable, [{
    key: "subscribe",
    value: function subscribe(subscriber) {
      var hasThisSubscriber = this._subscribers.find(function (s) {
        return s === subscriber;
      });

      if (!subscriber || hasThisSubscriber) {
        return;
      }

      subscriber(this);

      this._subscribers.push(subscriber);
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(subscriber) {
      this._subscribers = this._subscribers.filter(function (f) {
        return f !== subscriber;
      });
    }
  }, {
    key: "callSubscribers",
    value: function callSubscribers() {
      var _this = this;

      this._subscribers.forEach(function (f) {
        return f(_this);
      });
    }
  }]);

  return Observable;
}();

/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callApiUpdateDelayWalletSetup": () => (/* binding */ callApiUpdateDelayWalletSetup)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




/** Call the account/update-delay-wallet-setup api
 * Sets the value of the wallet's delayWalletSetup flag
 * Can only be updated if the wallet is not yet setup (wallet.requiresWalletSetup = false)
 * Returns: success: true (or throws an error)
 * */
function callApiUpdateDelayWalletSetup(_x, _x2) {
  return _callApiUpdateDelayWalletSetup.apply(this, arguments);
}

function _callApiUpdateDelayWalletSetup() {
  _callApiUpdateDelayWalletSetup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(oreIdContext, params) {
    var apiName, account, delayWalletSetup, body, results;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiName = _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.UpdateDelayWalletSetup;
            account = params.account, delayWalletSetup = params.delayWalletSetup;
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertHasApiKeyOrAccessToken)(oreIdContext, apiName);
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.assertParamsHaveRequiredValues)(params, ['account', 'delayWalletSetup'], apiName);
            body = {
              account: account,
              delay_wallet_setup: delayWalletSetup
            };
            _context.next = 7;
            return oreIdContext.callOreIdApi(_models__WEBPACK_IMPORTED_MODULE_0__.RequestType.Post, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.UpdateDelayWalletSetup, body, null);

          case 7:
            results = _context.sent;
            return _context.abrupt("return", results);

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _callApiUpdateDelayWalletSetup.apply(this, arguments);
}

/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AccessTokenHelper": () => (/* binding */ AccessTokenHelper)
/* harmony export */ });
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _utils_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var AccessTokenHelper = /*#__PURE__*/function (_Observable) {
  _inherits(AccessTokenHelper, _Observable);

  var _super = _createSuper(AccessTokenHelper);

  function AccessTokenHelper(accessToken) {
    var _this;

    var ignoreIssuer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _classCallCheck(this, AccessTokenHelper);

    _this = _super.call(this);
    _this._ignoreIssuer = ignoreIssuer;

    _this.setAccessToken(accessToken);

    return _this;
  }

  _createClass(AccessTokenHelper, [{
    key: "accessToken",
    get: function get() {
      return this._accessToken;
    }
  }, {
    key: "decodedAccessToken",
    get: function get() {
      if (!this.accessToken) return null;
      return this._decodedAccessToken;
    }
  }, {
    key: "idToken",
    get: function get() {
      return this._idToken;
    }
  }, {
    key: "decodedIdToken",
    get: function get() {
      return this._decodedIdToken;
    }
  }, {
    key: "accountName",
    get: function get() {
      if (!this.accessToken) return null;
      AccessTokenHelper.assertIsTokenValid(this.decodedAccessToken);
      return _utils_helpers__WEBPACK_IMPORTED_MODULE_0__["default"].getClaimFromJwtTokenBySearchString(this.decodedAccessToken, 'https://oreid.aikon.com/account');
    }
    /** clear accessToken */

  }, {
    key: "clearAccessToken",
    value: function clearAccessToken() {
      this.setAccessToken(null);
    }
    /** clear idToken */

  }, {
    key: "clearIdToken",
    value: function clearIdToken() {
      this.setIdToken(null);
    }
    /** Whether current accessToken is expired (or is missing)
     *  (optional) provide a Date() to compare expiration against - defaults to current Date()
     *  Returns: (boolean) true if hasExpired
     */

  }, {
    key: "hasExpired",
    value: function hasExpired(now) {
      if (!this._decodedAccessToken) return true;

      if (!AccessTokenHelper.isTokenDateValidNow(this._decodedAccessToken, now)) {
        return true;
      }

      return false;
    }
  }, {
    key: "setAccessToken",
    value: function setAccessToken(value) {
      var _this2 = this;

      if (!value) {
        this._accessToken = null; // allows clearing of value
      } else {
        var decodedAccessToken = _utils_helpers__WEBPACK_IMPORTED_MODULE_0__["default"].jwtDecodeSafe(value);
        if (!decodedAccessToken) throw Error("Can't set accessToken. Value provided: ".concat(value));
        AccessTokenHelper.assertIsTokenValid(decodedAccessToken, this._ignoreIssuer);
        AccessTokenHelper.assertIdTokenMatchesAccessToken(decodedAccessToken, this.decodedIdToken);
        this._decodedAccessToken = decodedAccessToken;
        this._accessToken = value; // Set a timer to clear the token when it expires (will clear if already expired)

        _utils_helpers__WEBPACK_IMPORTED_MODULE_0__["default"].runAtTime(function () {
          _this2.clearAccessToken();

          console.log('accessToken has expired and has been cleared');
        }, this._decodedAccessToken.exp * 1000);
      }

      _get(_getPrototypeOf(AccessTokenHelper.prototype), "callSubscribers", this).call(this);
    }
  }, {
    key: "setIdToken",
    value: function setIdToken(value) {
      var _this3 = this;

      if (!value) {
        this._decodedIdToken = null; // allows clearing of value
      } else {
        var decodedIdToken = _utils_helpers__WEBPACK_IMPORTED_MODULE_0__["default"].jwtDecodeSafe(value);
        if (!decodedIdToken) throw Error("Can't set IdToken. Value provided: ".concat(value));
        AccessTokenHelper.assertIsTokenValid(decodedIdToken, this._ignoreIssuer);
        AccessTokenHelper.assertIdTokenMatchesAccessToken(this.decodedAccessToken, decodedIdToken);
        this._decodedIdToken = decodedIdToken;
        this._idToken = value; // Set a timer to clear the token when it expires (will clear if already expired)

        _utils_helpers__WEBPACK_IMPORTED_MODULE_0__["default"].runAtTime(function () {
          _this3.clearIdToken();

          console.log('idToken has expired and has been cleared');
        }, this._decodedIdToken.exp * 1000);
      }

      _get(_getPrototypeOf(AccessTokenHelper.prototype), "callSubscribers", this).call(this);
    }
    /** Throws if accessToken is NOT set yet */

  }, {
    key: "assertHasAccessToken",
    value: function assertHasAccessToken() {
      if (!this.accessToken) throw Error('AccessToken not set. Login first.');
    }
    /** Whether token is a valid OREID issued token and NOT expired */

  }], [{
    key: "isTokenValid",
    value: function isTokenValid(decodedToken) {
      var ignoreIssuer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      try {
        AccessTokenHelper.assertIsTokenValid(decodedToken, ignoreIssuer);
        return true;
      } catch (error) {
        return false;
      }
    }
    /** Throws if decodedToken is NOT a valid OREID issued token */

  }, {
    key: "assertIsTokenValid",
    value: function assertIsTokenValid(decodedToken) {
      var ignoreIssuer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var now = new Date();
      if (!decodedToken) throw Error('JWT (access or id) token is invalid, or expired)'); // check if ORE ID issued this token

      if (!ignoreIssuer && !decodedToken.iss.includes('oreid.io')) {
        throw Error('Access token not issued by ORE ID');
      }

      if (!AccessTokenHelper.isTokenDateValidNow(decodedToken, now)) {
        throw Error('Access token has expired');
      }
    }
    /** Throws if accessToken does not match the same user and issuer as the idToken */

  }, {
    key: "assertIdTokenMatchesAccessToken",
    value: function assertIdTokenMatchesAccessToken(decodedAccessToken, decodedIdToken) {
      if (!decodedAccessToken || !decodedIdToken) return; // check if ORE ID issued this token

      if (decodedAccessToken.iss !== decodedIdToken.iss) {
        throw Error('AccessToken and IdToken mismatch - not issued by the same issuer');
      }

      if (decodedAccessToken.sub !== decodedIdToken.sub) {
        throw Error('AccessToken and IdToken mismatch - not for the same user');
      }
    }
    /** Whether a JWT token is valid for use right now - not expired and not being used before first usable date (nbf) */

  }, {
    key: "isTokenDateValidNow",
    value: function isTokenDateValidNow(decodedToken, now) {
      var nowDate = now || new Date();
      var nowInMs = nowDate.getTime() / 1000;

      if (typeof decodedToken.exp !== 'undefined' && (decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.exp) < nowInMs) {
        return false;
      }

      if (typeof (decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.nbf) !== 'undefined' && (decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.nbf) > nowInMs) {
        return false;
      }

      return true;
    }
  }]);

  return AccessTokenHelper;
}(_utils_observable__WEBPACK_IMPORTED_MODULE_1__.Observable);

/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OreId)
/* harmony export */ });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _auth_auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(109);
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
/* harmony import */ var _transaction_transaction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(111);
/* harmony import */ var _transit_TransitHelper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(41);
/* harmony import */ var _ual_UalHelper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(72);
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(17);
/* harmony import */ var _utils_hmac__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(112);
/* harmony import */ var _utils_localState__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(118);
/* harmony import */ var _utils_storage__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(119);
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(121);
/* harmony import */ var _wallets_WalletHelper__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(122);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable no-param-reassign */

/* eslint-disable @typescript-eslint/no-unused-vars */

/* eslint-disable no-console */














var isNullOrEmpty = _utils_helpers__WEBPACK_IMPORTED_MODULE_8__["default"].isNullOrEmpty;

var OreId = /*#__PURE__*/function () {
  function OreId(options) {
    var _this$options, _this$options2, _this$options3, _this$options4;

    _classCallCheck(this, OreId);

    _defineProperty(this, "transitProvidersInstalled", []);

    _defineProperty(this, "ualProvidersInstalled", []);

    this._options = null;
    this.validateAndSetOptions(options);
    var storageHandler = ((_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.storageHandler) || new _utils_storage__WEBPACK_IMPORTED_MODULE_11__["default"]();
    this._localState = new _utils_localState__WEBPACK_IMPORTED_MODULE_10__["default"]((_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2.appId, storageHandler);
    this._settings = new _Settings__WEBPACK_IMPORTED_MODULE_12__["default"]({
      oreIdContext: this
    });
    this._auth = new _auth_auth__WEBPACK_IMPORTED_MODULE_2__.Auth({
      oreIdContext: this
    });
    this._transitHelper = new _transit_TransitHelper__WEBPACK_IMPORTED_MODULE_6__["default"]({
      oreIdContext: this,
      user: this._auth.user
    });

    this._transitHelper.installTransitProviders((_this$options3 = this.options) === null || _this$options3 === void 0 ? void 0 : _this$options3.eosTransitWalletProviders);

    this._ualHelper = new _ual_UalHelper__WEBPACK_IMPORTED_MODULE_7__["default"]({
      oreIdContext: this,
      user: this._auth.user
    });

    this._ualHelper.installUalProviders((_this$options4 = this.options) === null || _this$options4 === void 0 ? void 0 : _this$options4.ualAuthenticators);

    this._walletHelper = new _wallets_WalletHelper__WEBPACK_IMPORTED_MODULE_13__["default"]({
      oreIdContext: this,
      transitHelper: this._transitHelper,
      ualHelper: this._ualHelper
    });
    this._initializerPlugins = options.plugins || {};
    this._isInitialized = false;
  }

  _createClass(OreId, [{
    key: "accessToken",
    get:
    /** accessToken (stored in localState) */
    function get() {
      return this.auth.accessToken;
    }
    /** accessToken helper functions and current state */

  }, {
    key: "accessTokenHelper",
    get: function get() {
      return this.auth.accessTokenHelper;
    }
    /** authentication flows and login state */

  }, {
    key: "auth",
    get: function get() {
      return this._auth;
    }
    /** whether the current appId is a demo app */

  }, {
    key: "isDemoApp",
    get: function get() {
      var _this$options5, _this$options5$appId;

      return ((_this$options5 = this.options) === null || _this$options5 === void 0 ? void 0 : (_this$options5$appId = _this$options5.appId) === null || _this$options5$appId === void 0 ? void 0 : _this$options5$appId.toLowerCase().startsWith('demo')) || false;
    }
    /** whether init() has been called */

  }, {
    key: "isInitialized",
    get: function get() {
      return this._isInitialized;
    }
    /** helper to persist data (e.g. accessToken) */

  }, {
    key: "localState",
    get: function get() {
      return this._localState;
    }
    /** oreid options used in constructor */

  }, {
    key: "options",
    get: function get() {
      return this._options;
    }
    /** installed popup plugin */

  }, {
    key: "popup",
    get: function get() {
      this.assertIsInitialized();
      return this._popup;
    }
    /** If we're running in the browser, we must use a proxy server to talk to OREID api
    Unless, we are running the demo app, in which case CORS is disabled by OREID server */

  }, {
    key: "requiresProxyServer",
    get: function get() {
      var _this$options6, _this$options7;

      // if we aren't using an apiKey, we dont ever need a proxy server
      if (this !== null && this !== void 0 && (_this$options6 = this.options) !== null && _this$options6 !== void 0 && _this$options6.isUsingProxyServer) return true;
      if (!(this !== null && this !== void 0 && (_this$options7 = this.options) !== null && _this$options7 !== void 0 && _this$options7.apiKey)) return false;
      return _utils_helpers__WEBPACK_IMPORTED_MODULE_8__["default"].isInBrowser && !this.isDemoApp;
    }
    /** oreid settings helper */

  }, {
    key: "settings",
    get: function get() {
      return this._settings;
    }
    /** External wallet helper functions and connections */

  }, {
    key: "walletHelper",
    get: function get() {
      return this._walletHelper;
    }
    /** perform asynchronous setup tasks */

  }, {
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _this$_initializerPlu;

        var _this$_initializerPlu2, _this$_initializerPlu3;

        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.isInitialized) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return");

              case 2:
                if (!((_this$_initializerPlu = this._initializerPlugins) !== null && _this$_initializerPlu !== void 0 && _this$_initializerPlu.popup)) {
                  _context.next = 6;
                  break;
                }

                _context.next = 5;
                return (_this$_initializerPlu2 = this._initializerPlugins) === null || _this$_initializerPlu2 === void 0 ? void 0 : (_this$_initializerPlu3 = _this$_initializerPlu2.popup) === null || _this$_initializerPlu3 === void 0 ? void 0 : _this$_initializerPlu3.init(this);

              case 5:
                this._popup = _context.sent;

              case 6:
                this._isInitialized = true;

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
    /** throw and error if oreId is not initialized yet */

  }, {
    key: "assertIsInitialized",
    value: function assertIsInitialized() {
      if (!this.isInitialized) {
        throw new Error('OreId is not initialized - call init() first');
      }
    }
    /** Clears user's accessToken and user profile data */

  }, {
    key: "logout",
    value: function logout() {
      this.auth.logout();
    }
    /** Sign an arbitrary string (instead of a transaction)
     * This only supports Transit and Ual wallets
     */

  }, {
    key: "signStringWithWallet",
    value: function () {
      var _signStringWithWallet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.walletHelper.signStringWithWallet(params));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function signStringWithWallet(_x) {
        return _signStringWithWallet.apply(this, arguments);
      }

      return signStringWithWallet;
    }()
    /** Sign an arbitrary string (instead of a transaction) using ORE ID
     */

  }, {
    key: "custodialSignString",
    value: function () {
      var _custodialSignString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(params) {
        var response;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return (0,_api__WEBPACK_IMPORTED_MODULE_1__.callApiCustodialSignString)(this, params);

              case 2:
                response = _context3.sent;

                if (!(response !== null && response !== void 0 && response.errorCode || response !== null && response !== void 0 && response.errorMessage)) {
                  _context3.next = 5;
                  break;
                }

                throw new Error(response.errorMessage);

              case 5:
                return _context3.abrupt("return", response);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function custodialSignString(_x2) {
        return _custodialSignString.apply(this, arguments);
      }

      return custodialSignString;
    }()
    /** Create a new user account that is managed by your app
     * Requires a wallet password (userPassword) on behalf of the user
     * Requires an apiKey with the createUser right
     * Returns: accountName of newly created account
     *       OR errorCode, errorMessage, and message if any problems */

  }, {
    key: "custodialNewAccount",
    value: function () {
      var _custodialNewAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(accountOptions) {
        var response;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return (0,_api__WEBPACK_IMPORTED_MODULE_1__.callApiCustodialNewAccount)(this, accountOptions);

              case 2:
                response = _context4.sent;

                if (!(response !== null && response !== void 0 && response.errorCode || response !== null && response !== void 0 && response.errorMessage)) {
                  _context4.next = 5;
                  break;
                }

                throw new Error(response.errorMessage);

              case 5:
                return _context4.abrupt("return", response);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function custodialNewAccount(_x3) {
        return _custodialNewAccount.apply(this, arguments);
      }

      return custodialNewAccount;
    }()
    /** Call the custodial/migrate-user api
     * Converts a user account to a new account type
     * Usually used to convert a virtal account to a native account (on-chain)
     * .. and expects the account to be a managed (custodial) account
     * Requires a wallet password (userPassword) on behalf of the user
     * Requires an apiKey with the accountMigration right
     * Returns: account name of migrated account
     *       OR errorCode, errorMessage, and message if any problems */

  }, {
    key: "custodialMigrateAccount",
    value: function () {
      var _custodialMigrateAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(migrateOptions) {
        var response;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return (0,_api__WEBPACK_IMPORTED_MODULE_1__.callApiCustodialMigrateAccount)(this, migrateOptions);

              case 2:
                response = _context5.sent;

                if (!(response !== null && response !== void 0 && response.errorCode || response !== null && response !== void 0 && response.errorMessage)) {
                  _context5.next = 5;
                  break;
                }

                throw new Error(response.errorMessage);

              case 5:
                return _context5.abrupt("return", response);

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function custodialMigrateAccount(_x4) {
        return _custodialMigrateAccount.apply(this, arguments);
      }

      return custodialMigrateAccount;
    }()
    /** Returns metadata about the installed external wallet type (e.g. name, logo) and which features it supports
     *  Returns different data depending on the wallet interface type (Transit or Ual)
     */

  }, {
    key: "getExternalWalletInfo",
    value: function getExternalWalletInfo(walletType) {
      return this.walletHelper.getExternalWalletInfo(walletType);
    }
    /** Create a new Transaction object - used for composing and signing transactions */

  }, {
    key: "createTransaction",
    value: function () {
      var _createTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(data) {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (this._auth.user.hasData) {
                  _context6.next = 3;
                  break;
                }

                _context6.next = 3;
                return this._auth.user.getData();

              case 3:
                return _context6.abrupt("return", new _transaction_transaction__WEBPACK_IMPORTED_MODULE_5__["default"]({
                  oreIdContext: this,
                  user: this.auth.user,
                  data: data
                }));

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function createTransaction(_x5) {
        return _createTransaction.apply(this, arguments);
      }

      return createTransaction;
    }()
    /** Call the setBusyCallback() callback provided in optiont
     *  Use true or false to set the current busy state
     */

  }, {
    key: "setIsBusy",
    value: function setIsBusy(value) {
      if (this.isBusy !== value) {
        this.isBusy = value;

        if (this.options.setBusyCallback) {
          this.options.setBusyCallback(value);
        }
      }
    } // TODO add validation of newer options

    /**  Validates startup options */

  }, {
    key: "validateAndSetOptions",
    value: function validateAndSetOptions(options) {
      var _ref = options || {},
          appId = _ref.appId,
          apiKey = _ref.apiKey,
          oreIdUrl = _ref.oreIdUrl;

      var errorMessage = ''; // set options now since this.requiresProxyServer needs it set

      this._options = options; // Apply default options

      if (options) this.options.oreIdUrl = oreIdUrl || _constants__WEBPACK_IMPORTED_MODULE_3__.defaultOreIdServiceUrl;

      if (!appId) {
        errorMessage += '\n --> Missing required parameter - appId. You can get an appId when you register your app with ORE ID.';
      } // api-key and service-key not allowed if this is being instantiated in the browser


      if (this.requiresProxyServer && apiKey) {
        errorMessage += '\n --> You cant include the apiKey when creating an instance of OreId that runs in the browser. This is to prevent your key from being visible in the browser. If this app runs solely in the browser (like a Create React App), you need to set-up a proxy server to protect your keys. Refer to https://github.com/TeamAikon/ore-id-docs. Note: You wont get this error when using the appId and apiKey for a demo app (appId starts with demo_).';
      }

      if (errorMessage !== '') {
        throw new Error("Options are missing or invalid. ".concat(errorMessage));
      }
    }
    /** Gets a single-use token to access the service */

  }, {
    key: "getAppAccessToken",
    value: function () {
      var _getAppAccessToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(params) {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", (0,_api__WEBPACK_IMPORTED_MODULE_1__.callApiGetAppToken)(this, params));

              case 1:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getAppAccessToken(_x6) {
        return _getAppAccessToken.apply(this, arguments);
      }

      return getAppAccessToken;
    }()
    /** Extracts the response parameters on the /new-account callback URL string */

  }, {
    key: "handleNewAccountResponse",
    value: function handleNewAccountResponse(callbackUrlString) {
      var _Helpers$extractDataF = _utils_helpers__WEBPACK_IMPORTED_MODULE_8__["default"].extractDataFromCallbackUrl(callbackUrlString),
          chainAccount = _Helpers$extractDataF.chain_account,
          processId = _Helpers$extractDataF.process_id,
          state = _Helpers$extractDataF.state,
          errors = _Helpers$extractDataF.errors;

      this.setIsBusy(false);
      return {
        chainAccount: chainAccount,
        processId: processId,
        state: state,
        errors: errors
      };
    }
    /** Extracts and returns the response parameters from the /sign callback URL string */

  }, {
    key: "handleSignCallback",
    value: function handleSignCallback(callbackUrlString) {
      var signedTransaction;

      var _Helpers$extractDataF2 = _utils_helpers__WEBPACK_IMPORTED_MODULE_8__["default"].extractDataFromCallbackUrl(callbackUrlString),
          encodedTransaction = _Helpers$extractDataF2.signed_transaction,
          processId = _Helpers$extractDataF2.process_id,
          state = _Helpers$extractDataF2.state,
          transactionId = _Helpers$extractDataF2.transaction_id,
          errors = _Helpers$extractDataF2.errors;

      if (!errors) {
        // Decode base64 parameters
        signedTransaction = _utils_helpers__WEBPACK_IMPORTED_MODULE_8__["default"].base64DecodeSafe(encodedTransaction);
      }

      this.setIsBusy(false);
      return {
        signedTransaction: signedTransaction,
        processId: processId,
        state: state,
        transactionId: transactionId,
        errors: errors
      };
    }
    /** Updates and returns a WebWidgetProps object to include two new fields: timestamp, signature
     *  timestamp: current server time
     *  signature: HMAC signature of the object including the timestamp - calculated using the apiKey
     *  IF incoming props already has a value for timestamp - it is kept
     *  If both incoming and timestamp and signature are already present, this returns incoming data unmodified
     *  If an apiKey is not provided in options, this function expects a proxy server endpoint at /oreid/hmac to generate the siganture with the secured apiKey
     *  Returns the updated object that includes the timestamp and the signature fields
     */

  }, {
    key: "appendTimestampAndSignatureToWidgetProps",
    value: function () {
      var _appendTimestampAndSignatureToWidgetProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(data) {
        var _window;

        var signedProps, nowTimestamp;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!(data !== null && data !== void 0 && data.timestamp && data !== null && data !== void 0 && data.signature)) {
                  _context8.next = 2;
                  break;
                }

                return _context8.abrupt("return", data);

              case 2:
                signedProps = _objectSpread({}, data); // keep existing timestamp if there is one

                nowTimestamp = (data === null || data === void 0 ? void 0 : data.timestamp) || new Date().getTime();
                signedProps.origin = (data === null || data === void 0 ? void 0 : data.origin) || ((_window = window) === null || _window === void 0 ? void 0 : _window.location.origin);
                signedProps.timestamp = nowTimestamp; // if we have an apiKey, add a signature

                _context8.prev = 6;
                _context8.next = 9;
                return (0,_utils_hmac__WEBPACK_IMPORTED_MODULE_9__.generateHmacWithApiKeyOrProxyServer)(this.requiresProxyServer, this.options.apiKey, JSON.stringify(_utils_helpers__WEBPACK_IMPORTED_MODULE_8__["default"].sortJson(data)) // props including timestamp - sortJson ensures json members are always in the same order
                );

              case 9:
                signedProps.signature = _context8.sent;
                _context8.next = 14;
                break;

              case 12:
                _context8.prev = 12;
                _context8.t0 = _context8["catch"](6);

              case 14:
                return _context8.abrupt("return", signedProps);

              case 15:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[6, 12]]);
      }));

      function appendTimestampAndSignatureToWidgetProps(_x7) {
        return _appendTimestampAndSignatureToWidgetProps.apply(this, arguments);
      }

      return appendTimestampAndSignatureToWidgetProps;
    }()
    /** Helper function to call api endpoint and inject api-key
      here params can be query params in case of a GET request or body params in case of POST request
      processId (optional) - can be used to associate multiple calls together into a single process flow
    */

  }, {
    key: "callOreIdApi",
    value: function () {
      var _callOreIdApi = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(requestMethod, endpoint) {
        var _response;

        var params,
            overrideAccessToken,
            processId,
            urlString,
            response,
            headers,
            _this$options8,
            apiKey,
            oreIdUrl,
            oreIdUrlBase,
            url,
            accessToken,
            urlWithParams,
            body,
            error,
            data,
            _args9 = arguments;

        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                params = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : {};

                /** Required if apiKey is not provider (optional otherwise) */
                overrideAccessToken = _args9.length > 3 ? _args9[3] : undefined;
                processId = _args9.length > 4 && _args9[4] !== undefined ? _args9[4] : null;
                headers = {};
                _this$options8 = this.options, apiKey = _this$options8.apiKey, oreIdUrl = _this$options8.oreIdUrl; // if running in browser, we dont call the api directly, we use a proxy server (unless we're running a demo app)
                // calls to the proxy server must start with '/' (not an host like http://server) and we'll prepend 'oreid' to it e.g. /oreid/api/xxx to make it easier to do proxy server routing

                oreIdUrlBase = this.requiresProxyServer ? '/oreid' : oreIdUrl;
                url = "".concat(oreIdUrlBase, "/api/").concat(endpoint);
                accessToken = overrideAccessToken || this.accessToken;

                if (!(!apiKey && !accessToken && !_constants__WEBPACK_IMPORTED_MODULE_3__.publicApiEndpoints.includes(endpoint))) {
                  _context9.next = 10;
                  break;
                }

                throw new Error('OreId API request requires either apiKey or accessToken');

              case 10:
                // apiKey is optional (accessToken is required if apiKey not provided)
                if (apiKey) {
                  headers['api-key'] = apiKey;
                }

                if (accessToken) {
                  headers.Authorization = "Bearer ".concat(accessToken);
                }

                if (!isNullOrEmpty(processId)) {
                  headers['process-id'] = processId;
                } // add sdk version to request header


                headers['sdk-version'] = "oreidjs/".concat(_constants__WEBPACK_IMPORTED_MODULE_3__.version);
                _context9.prev = 14;

                if (!(requestMethod === _models__WEBPACK_IMPORTED_MODULE_4__.RequestType.Get)) {
                  _context9.next = 21;
                  break;
                }

                if (!isNullOrEmpty(params)) {
                  urlString = Object.keys(params).map(function (key) {
                    return "".concat(key, "=").concat(params[key]);
                  }).join('&');
                }

                urlWithParams = urlString ? "".concat(url, "?").concat(urlString) : url;
                _context9.next = 20;
                return axios__WEBPACK_IMPORTED_MODULE_0___default().get(urlWithParams, {
                  headers: headers
                });

              case 20:
                response = _context9.sent;

              case 21:
                if (!(requestMethod === _models__WEBPACK_IMPORTED_MODULE_4__.RequestType.Post)) {
                  _context9.next = 26;
                  break;
                }

                body = !isNullOrEmpty(params) ? JSON.stringify(params) : null;
                _context9.next = 25;
                return axios__WEBPACK_IMPORTED_MODULE_0___default().post(url, body, {
                  headers: _objectSpread({
                    'Content-Type': 'application/json'
                  }, headers)
                });

              case 25:
                response = _context9.sent;

              case 26:
                _context9.next = 32;
                break;

              case 28:
                _context9.prev = 28;
                _context9.t0 = _context9["catch"](14);
                error = _utils_helpers__WEBPACK_IMPORTED_MODULE_8__["default"].getErrorFromAxiosError(_context9.t0);
                throw error;

              case 32:
                data = (_response = response) === null || _response === void 0 ? void 0 : _response.data;
                return _context9.abrupt("return", data);

              case 34:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[14, 28]]);
      }));

      function callOreIdApi(_x8, _x9) {
        return _callOreIdApi.apply(this, arguments);
      }

      return callOreIdApi;
    }()
    /** Add an app access token and hmac signature to the url
     *  If running in browser, calls proxy server at /oreid/prepare-url to do both (since they require teh apiKey secret) */

  }, {
    key: "addAccessTokenAndHmacToUrl",
    value: function () {
      var _addAccessTokenAndHmacToUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(urlString, appAccessTokenMetadata, overrideAppAccessToken) {
        var _this$options9;

        var appId, _response$data, response, completeUrl, appAccessToken, _this$options10;

        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                appId = this.options.appId; // running in browser

                if (!this.requiresProxyServer) {
                  _context10.next = 6;
                  break;
                }

                _context10.next = 4;
                return axios__WEBPACK_IMPORTED_MODULE_0___default().post('/oreid/prepare-url', {
                  appAccessTokenMetadata: appAccessTokenMetadata,
                  urlString: urlString
                });

              case 4:
                response = _context10.sent;
                return _context10.abrupt("return", response === null || response === void 0 ? void 0 : (_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.urlString);

              case 6:
                completeUrl = "".concat(urlString, "&app_id=").concat(appId); // if we need app token metadata, then we generate and add an appAccessToken

                if (isNullOrEmpty(appAccessTokenMetadata)) {
                  _context10.next = 15;
                  break;
                }

                _context10.t0 = overrideAppAccessToken;

                if (_context10.t0) {
                  _context10.next = 13;
                  break;
                }

                _context10.next = 12;
                return this.getAppAccessToken({
                  appAccessTokenMetadata: appAccessTokenMetadata
                });

              case 12:
                _context10.t0 = _context10.sent;

              case 13:
                appAccessToken = _context10.t0;
                completeUrl = "".concat(completeUrl, "&app_access_token=").concat(appAccessToken);

              case 15:
                if (!((_this$options9 = this.options) !== null && _this$options9 !== void 0 && _this$options9.apiKey)) {
                  _context10.next = 19;
                  break;
                }

                _context10.next = 18;
                return (0,_utils_hmac__WEBPACK_IMPORTED_MODULE_9__.appendHmacToUrl)(false, (_this$options10 = this.options) === null || _this$options10 === void 0 ? void 0 : _this$options10.apiKey, completeUrl);

              case 18:
                completeUrl = _context10.sent;

              case 19:
                return _context10.abrupt("return", completeUrl);

              case 20:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function addAccessTokenAndHmacToUrl(_x10, _x11, _x12) {
        return _addAccessTokenAndHmacToUrl.apply(this, arguments);
      }

      return addAccessTokenAndHmacToUrl;
    }()
  }]);

  return OreId;
}();



/***/ }),
/* 79 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(80);

/***/ }),
/* 80 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(81);
var bind = __webpack_require__(82);
var Axios = __webpack_require__(83);
var mergeConfig = __webpack_require__(103);
var defaults = __webpack_require__(88);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(101);
axios.CancelToken = __webpack_require__(106);
axios.isCancel = __webpack_require__(102);
axios.VERSION = (__webpack_require__(105).version);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(107);

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(108);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),
/* 81 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(82);

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return Array.isArray(val);
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return toString.call(val) === '[object FormData]';
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return toString.call(val) === '[object URLSearchParams]';
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),
/* 82 */
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),
/* 83 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(81);
var buildURL = __webpack_require__(84);
var InterceptorManager = __webpack_require__(85);
var dispatchRequest = __webpack_require__(86);
var mergeConfig = __webpack_require__(103);
var validator = __webpack_require__(104);

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),
/* 84 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(81);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),
/* 85 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(81);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),
/* 86 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(81);
var transformData = __webpack_require__(87);
var isCancel = __webpack_require__(102);
var defaults = __webpack_require__(88);
var Cancel = __webpack_require__(101);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new Cancel('canceled');
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),
/* 87 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(81);
var defaults = __webpack_require__(88);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),
/* 88 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(81);
var normalizeHeaderName = __webpack_require__(89);
var enhanceError = __webpack_require__(90);
var transitionalDefaults = __webpack_require__(91);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(92);
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(92);
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: transitionalDefaults,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),
/* 89 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(81);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),
/* 90 */
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error;
};


/***/ }),
/* 91 */
/***/ ((module) => {

"use strict";


module.exports = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};


/***/ }),
/* 92 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(81);
var settle = __webpack_require__(93);
var cookies = __webpack_require__(95);
var buildURL = __webpack_require__(84);
var buildFullPath = __webpack_require__(96);
var parseHeaders = __webpack_require__(99);
var isURLSameOrigin = __webpack_require__(100);
var createError = __webpack_require__(94);
var transitionalDefaults = __webpack_require__(91);
var Cancel = __webpack_require__(101);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),
/* 93 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(94);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),
/* 94 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(90);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),
/* 95 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(81);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),
/* 96 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(97);
var combineURLs = __webpack_require__(98);

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),
/* 97 */
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};


/***/ }),
/* 98 */
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),
/* 99 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(81);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),
/* 100 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(81);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),
/* 101 */
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),
/* 102 */
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),
/* 103 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(81);

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};


/***/ }),
/* 104 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var VERSION = (__webpack_require__(105).version);

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),
/* 105 */
/***/ ((module) => {

module.exports = {
  "version": "0.26.1"
};

/***/ }),
/* 106 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(101);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function(cancel) {
    if (!token._listeners) return;

    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function(onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function(resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),
/* 107 */
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),
/* 108 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(81);

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
};


/***/ }),
/* 109 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultOreIdServiceUrl": () => (/* binding */ defaultOreIdServiceUrl),
/* harmony export */   "externalWalletsNotImplemented": () => (/* binding */ externalWalletsNotImplemented),
/* harmony export */   "publicApiEndpoints": () => (/* binding */ publicApiEndpoints),
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _version_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(110);


var externalWalletsNotImplemented = ['metro'];
var defaultOreIdServiceUrl = 'https://service.oreid.io';
var version = _version_json__WEBPACK_IMPORTED_MODULE_1__.version;

var publicApiEndpoints = [_models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.LoginUserWithToken, _models__WEBPACK_IMPORTED_MODULE_0__.ApiEndpoint.NewUserWithToken]; // api endpoints that dont require authorization

/***/ }),
/* 110 */
/***/ ((module) => {

"use strict";
module.exports = {"version":"4.7.2"};

/***/ }),
/* 111 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Transaction)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _transit_TransitHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
/* harmony import */ var _core_urlGenerators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40);
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17);
/* harmony import */ var _ual_UalHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(72);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }








var Transaction = /*#__PURE__*/function () {
  function Transaction(args) {
    _classCallCheck(this, Transaction);

    this._oreIdContext = args.oreIdContext;
    this._user = args.user;
    this.assertValidTransactionAndSetData(args.data);
    this._transitHelper = new _transit_TransitHelper__WEBPACK_IMPORTED_MODULE_1__["default"]({
      oreIdContext: this._oreIdContext,
      user: this._user
    });
    this._ualHelper = new _ual_UalHelper__WEBPACK_IMPORTED_MODULE_5__["default"]({
      oreIdContext: this._oreIdContext,
      user: this._user
    });
  }

  _createClass(Transaction, [{
    key: "data",
    get: function get() {
      return this._data;
    }
    /** ensure all required parameters are provided */

  }, {
    key: "assertValidTransactionAndSetData",
    value: function assertValidTransactionAndSetData(createTransactionData) {
      var _ref = createTransactionData || {},
          chainNetwork = _ref.chainNetwork,
          transaction = _ref.transaction,
          signedTransaction = _ref.signedTransaction;

      var missingFields = [];
      var validationIssues = [];

      if (!this._user || !this._user.hasData) {
        throw new Error('Make sure that a user has been authenticated and that youve called user.getData()');
      } // required fields


      if (!chainNetwork) missingFields.push('chainNetwork');
      if (!transaction && !signedTransaction) missingFields.push('transaction OR signedTransaction'); // validaton rules

      if (!this._user.accountName) validationIssues.push('Transaction Data error - Expecting a user.accountName - is the user logged-in in?');
      if (transaction && signedTransaction) validationIssues.push('Only provide one: transaction OR signedTransaction'); // TODO: call this.validate()
      // transaction OR signedTransaction - check for valid JSON object

      if (!_utils_helpers__WEBPACK_IMPORTED_MODULE_4__["default"].isNullOrEmpty(missingFields)) {
        throw new Error("Transaction parameter(s) missing: ".concat(missingFields.join(', ')));
      }

      if (!_utils_helpers__WEBPACK_IMPORTED_MODULE_4__["default"].isNullOrEmpty(validationIssues)) {
        throw new Error("Transaction parameter error: ".concat(validationIssues.join(', ')));
      }

      this.setTransactionData(createTransactionData);
    }
  }, {
    key: "setTransactionData",
    value: function setTransactionData(createTransactionData) {
      // account param is set to logged-in user
      this._data = _objectSpread({
        account: this._user.accountName
      }, createTransactionData); // set encoded transaction properties

      if (createTransactionData !== null && createTransactionData !== void 0 && createTransactionData.transaction) this._data.encodedTransaction = _utils_helpers__WEBPACK_IMPORTED_MODULE_4__["default"].base64Encode(JSON.stringify(createTransactionData.transaction));
      if (createTransactionData !== null && createTransactionData !== void 0 && createTransactionData.signedTransaction) this._data.encodedSignedTransaction = _utils_helpers__WEBPACK_IMPORTED_MODULE_4__["default"].base64Encode(JSON.stringify(createTransactionData.signedTransaction));
    } // TODO: Consider providing property to explain that account/permission is in external wallet so developer can easily check
    // TODO: Consider web-widget automatically handling pop-up of wallet when sign is called

    /** ensure that the chainNetwork and chainAccount for the transaction are in the user's wallet
     *  NOTE: This check is not required for a user signing with a wallet app - Since the account may be in the wallet and not yet added to OreId
     */

  }, {
    key: "assertTransactionAccountValidForUser",
    value: function assertTransactionAccountValidForUser() {
      var _this$_user, _this$_user$data, _this$_user$data$chai, _chainAccountsInWalle, _chainAccountsInWalle2, _chainAccountsInWalle3;

      var _this$_data = this._data,
          chainAccount = _this$_data.chainAccount,
          chainNetwork = _this$_data.chainNetwork;
      var accountName = this._user.accountName;
      var chainAccountsInWallet = (_this$_user = this._user) === null || _this$_user === void 0 ? void 0 : (_this$_user$data = _this$_user.data) === null || _this$_user$data === void 0 ? void 0 : (_this$_user$data$chai = _this$_user$data.chainAccounts) === null || _this$_user$data$chai === void 0 ? void 0 : _this$_user$data$chai.find(function (perm) {
        return perm.chainNetwork === chainNetwork && perm.chainAccount === chainAccount;
      });
      var allPermissionsExternal = chainAccountsInWallet === null || chainAccountsInWallet === void 0 ? void 0 : (_chainAccountsInWalle = chainAccountsInWallet.permissions) === null || _chainAccountsInWalle === void 0 ? void 0 : _chainAccountsInWalle.every(function (p) {
        return p.privateKeyStoredExterally === true;
      });
      var externalWalletType = chainAccountsInWallet === null || chainAccountsInWallet === void 0 ? void 0 : (_chainAccountsInWalle2 = chainAccountsInWallet.permissions) === null || _chainAccountsInWalle2 === void 0 ? void 0 : (_chainAccountsInWalle3 = _chainAccountsInWalle2.find(function (p) {
        return p.privateKeyStoredExterally === true;
      })) === null || _chainAccountsInWalle3 === void 0 ? void 0 : _chainAccountsInWalle3.externalWalletType;

      if (!chainAccountsInWallet) {
        throw new Error("Can't find a chainAccount: ".concat(chainAccount, " for chainNetwork: ").concat(chainNetwork, " in user's oreId account: ").concat(accountName));
      }

      if (allPermissionsExternal) {
        throw new Error("ChainAccount: ".concat(chainAccount, " for chainNetwork: ").concat(chainNetwork, " appears to be in a wallet app (type: ").concat(externalWalletType, ") - use signWithWallet() to sign"));
      }
    } // TODO: check user.chainAccounts that

    /** validates that transaction is well-formed for the blockcahin
     * Returns array of errors
     */

  }, {
    key: "validate",
    value: function () {
      var _validate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                throw new Error('Not Implemented');

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function validate() {
        return _validate.apply(this, arguments);
      }

      return validate;
    }() // TODO: add depricated

    /**
     * Returns a url to redirect the user's browser to - to sign transaction using OREID web interface
     */

  }, {
    key: "getSignUrl",
    value: function () {
      var _getSignUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var transactionData, signCallbackUrl, signUrl;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.assertTransactionAccountValidForUser();
                transactionData = this.data;
                signCallbackUrl = this._oreIdContext.options.signCallbackUrl; // eslint-disable-next-line no-param-reassign

                if (!(transactionData !== null && transactionData !== void 0 && transactionData.signOptions)) transactionData.signOptions = {}; // eslint-disable-next-line no-param-reassign

                transactionData.signOptions.callbackUrl = signCallbackUrl;
                _context2.next = 7;
                return (0,_core_urlGenerators__WEBPACK_IMPORTED_MODULE_3__.getOreIdSignUrl)(this._oreIdContext, transactionData);

              case 7:
                signUrl = _context2.sent;
                return _context2.abrupt("return", {
                  signUrl: signUrl,
                  errors: null
                });

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getSignUrl() {
        return _getSignUrl.apply(this, arguments);
      }

      return getSignUrl;
    }()
    /**
     * Whether the provided transaction (or signedTransaction) can be autoSigned via api (without user interaction)
     * Requires an apiKey with the autoSign right
     * Returns: true if transaction can be signed using tansaction.sign()
     * */

  }, {
    key: "checkCanAutoSign",
    value: function () {
      var _checkCanAutoSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var autoSignCredentialsExist, _yield$callApiCanAuto;

        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                (0,_api__WEBPACK_IMPORTED_MODULE_2__.assertHasApiKey)(this._oreIdContext, _models__WEBPACK_IMPORTED_MODULE_0__.ApiKeyUsedFor.AutoSigning, '') // this will throw if we don't have an api key with the right rights
                ;
                _context3.next = 4;
                return (0,_api__WEBPACK_IMPORTED_MODULE_2__.callApiCanAutosignTransaction)(this._oreIdContext, this._data);

              case 4:
                _yield$callApiCanAuto = _context3.sent;
                autoSignCredentialsExist = _yield$callApiCanAuto.autoSignCredentialsExist;
                _context3.next = 11;
                break;

              case 8:
                _context3.prev = 8;
                _context3.t0 = _context3["catch"](0);
                return _context3.abrupt("return", false);

              case 11:
                return _context3.abrupt("return", autoSignCredentialsExist);

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 8]]);
      }));

      function checkCanAutoSign() {
        return _checkCanAutoSign.apply(this, arguments);
      }

      return checkCanAutoSign;
    }()
    /** Attempt to sign a transaction without user interaction
     *  Expects user to have previously approved autoSign for transaction type and it hasn't expired
     *  Call callApiCanAutosignTransaction() first to confirm that this transaction can be autoSigned before attempting this call
     */

  }, {
    key: "autoSign",
    value: function () {
      var _autoSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var transactionData, _yield$callApiSignTra, processId, signedTransaction, transactionId, errorCode, errorMessage;

        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.assertTransactionAccountValidForUser();
                transactionData = this.data;
                _context4.next = 4;
                return (0,_api__WEBPACK_IMPORTED_MODULE_2__.callApiSignTransaction)(this._oreIdContext, {
                  transactionData: transactionData,
                  autoSign: true
                });

              case 4:
                _yield$callApiSignTra = _context4.sent;
                processId = _yield$callApiSignTra.processId;
                signedTransaction = _yield$callApiSignTra.signedTransaction;
                transactionId = _yield$callApiSignTra.transactionId;
                errorCode = _yield$callApiSignTra.errorCode;
                errorMessage = _yield$callApiSignTra.errorMessage;

                if (!(errorCode || errorMessage)) {
                  _context4.next = 12;
                  break;
                }

                throw new Error(errorMessage);

              case 12:
                return _context4.abrupt("return", {
                  processId: processId,
                  signedTransaction: signedTransaction,
                  transactionId: transactionId
                });

              case 13:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function autoSign() {
        return _autoSign.apply(this, arguments);
      }

      return autoSign;
    }()
    /** Sign a transaction without user interaction
     *  Requires a user's wallet password or encrypted password (a 'custodial' account managed by you)
     *  Requires an apiKey with the proxySign right
     */

  }, {
    key: "signWithPassword",
    value: function () {
      var _signWithPassword = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(userPassword, userPasswordEncrypted) {
        var transactionData, _yield$callApiCustodi, processId, signedTransaction, transactionId, errorCode, errorMessage;

        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this.assertTransactionAccountValidForUser();
                transactionData = this.data;
                if (!(transactionData !== null && transactionData !== void 0 && transactionData.signOptions)) transactionData.signOptions = {};
                if (userPassword) transactionData.signOptions.userPassword = userPassword;
                if (userPasswordEncrypted) transactionData.signOptions.userPasswordEncrypted = userPasswordEncrypted;

                if (!(transactionData.signOptions.userPassword && transactionData.signOptions.userPasswordEncrypted)) {
                  _context5.next = 7;
                  break;
                }

                throw new Error('Provide either a userPassword OR userPasswordEncrypted param. Both were provided.');

              case 7:
                _context5.next = 9;
                return (0,_api__WEBPACK_IMPORTED_MODULE_2__.callApiCustodialSignTransaction)(this._oreIdContext, {
                  transactionData: transactionData,
                  autoSign: false
                });

              case 9:
                _yield$callApiCustodi = _context5.sent;
                processId = _yield$callApiCustodi.processId;
                signedTransaction = _yield$callApiCustodi.signedTransaction;
                transactionId = _yield$callApiCustodi.transactionId;
                errorCode = _yield$callApiCustodi.errorCode;
                errorMessage = _yield$callApiCustodi.errorMessage;

                if (!(errorCode || errorMessage)) {
                  _context5.next = 17;
                  break;
                }

                throw new Error(errorMessage);

              case 17:
                return _context5.abrupt("return", {
                  processId: processId,
                  signedTransaction: signedTransaction,
                  transactionId: transactionId
                });

              case 18:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function signWithPassword(_x, _x2) {
        return _signWithPassword.apply(this, arguments);
      }

      return signWithPassword;
    }()
    /** Sign with a supported blockchain wallet via Transit provider */

  }, {
    key: "signWithWallet",
    value: function () {
      var _signWithWallet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(walletType) {
        var transactionData, signResult;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                transactionData = this.data;
                _context6.next = 3;
                return this._oreIdContext.walletHelper.signWithWallet(walletType, transactionData);

              case 3:
                signResult = _context6.sent;
                return _context6.abrupt("return", signResult);

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function signWithWallet(_x3) {
        return _signWithWallet.apply(this, arguments);
      }

      return signWithWallet;
    }()
  }]);

  return Transaction;
}();



/***/ }),
/* 112 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "appendHmacToUrl": () => (/* binding */ appendHmacToUrl),
/* harmony export */   "generateHmac": () => (/* binding */ generateHmac),
/* harmony export */   "generateHmacWithApiKeyOrProxyServer": () => (/* binding */ generateHmacWithApiKeyOrProxyServer)
/* harmony export */ });
/* harmony import */ var crypto_js_hmac_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(113);
/* harmony import */ var crypto_js_hmac_sha256__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js_hmac_sha256__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




function generateHmac(secret, data) {
  var hmac = crypto_js_hmac_sha256__WEBPACK_IMPORTED_MODULE_0___default()(data, secret);
  return hmac.toString();
}
/** Generate HMAC for data string
 *  data param can be stringified object
 *  If apiKey is not provided, expects useProxyServer:true and a proxy server to be available to generate the hmac
 *  Expects proxyserver /oreid/hmac to host an endpoint to sign with the apiKey and return the hmac
 */

function generateHmacWithApiKeyOrProxyServer(_x, _x2, _x3) {
  return _generateHmacWithApiKeyOrProxyServer.apply(this, arguments);
}
/** Generate HMAC for url string and append it to end or url e.g. http:/nnnnnn&hmac=xxx */

function _generateHmacWithApiKeyOrProxyServer() {
  _generateHmacWithApiKeyOrProxyServer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(useProxyServer, apiKey, data) {
    var hmac, _response$data, response, error;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(!useProxyServer && _helpers__WEBPACK_IMPORTED_MODULE_2__["default"].isNullOrEmpty(apiKey))) {
              _context.next = 2;
              break;
            }

            throw new Error('Cant generate hmac. apiKey missing or empty - its required if not using a proxy server');

          case 2:
            if (!useProxyServer) {
              _context.next = 16;
              break;
            }

            _context.prev = 3;
            _context.next = 6;
            return axios__WEBPACK_IMPORTED_MODULE_1___default().post('/oreid/hmac', JSON.stringify({
              data: data
            }), {
              headers: {
                'Content-Type': 'application/json'
              }
            });

          case 6:
            response = _context.sent;
            hmac = response === null || response === void 0 ? void 0 : (_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.hmac;
            _context.next = 14;
            break;

          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](3);
            error = this.getErrorFromAxiosError(_context.t0);
            throw error;

          case 14:
            _context.next = 17;
            break;

          case 16:
            hmac = generateHmac(apiKey, data);

          case 17:
            return _context.abrupt("return", hmac);

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[3, 10]]);
  }));
  return _generateHmacWithApiKeyOrProxyServer.apply(this, arguments);
}

function appendHmacToUrl(_x4, _x5, _x6) {
  return _appendHmacToUrl.apply(this, arguments);
}

function _appendHmacToUrl() {
  _appendHmacToUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(useProxyServer, apiKey, url) {
    var hmac, urlEncodedHmac;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!_helpers__WEBPACK_IMPORTED_MODULE_2__["default"].isNullOrEmpty(url)) {
              _context2.next = 2;
              break;
            }

            throw new Error('Cant generate hmac. url missing or empty');

          case 2:
            _context2.next = 4;
            return generateHmacWithApiKeyOrProxyServer(useProxyServer, apiKey, url);

          case 4:
            hmac = _context2.sent;
            urlEncodedHmac = encodeURIComponent(hmac); // correct hmac already in place

            if (!url.includes("&hmac=".concat(urlEncodedHmac))) {
              _context2.next = 8;
              break;
            }

            return _context2.abrupt("return", url);

          case 8:
            return _context2.abrupt("return", "".concat(url, "&hmac=").concat(urlEncodedHmac));

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _appendHmacToUrl.apply(this, arguments);
}

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(114), __webpack_require__(116), __webpack_require__(117));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.HmacSHA256;

}));

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native crypto in web worker (Browser)
	    if (typeof self !== 'undefined' && self.crypto) {
	        crypto = self.crypto;
	    }

	    // Native crypto from worker
	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
	        crypto = globalThis.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.crypto) {
	        crypto = __webpack_require__.g.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __webpack_require__(115);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }());

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var j = 0; j < thatSigBytes; j += 4) {
	                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),
/* 115 */
/***/ (() => {

/* (ignored) */

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(114));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(114));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),
/* 118 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LocalState)
/* harmony export */ });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var LocalState = /*#__PURE__*/function () {
  function LocalState(appId, storage) {
    _classCallCheck(this, LocalState);

    this.appId = appId;
    this.cachedaccessToken = null;
    this.cachedUser = null;
    this.storage = storage;
  }

  _createClass(LocalState, [{
    key: "accessTokenKey",
    value: function accessTokenKey() {
      return "oreid.".concat(this.appId, ".accessToken");
    }
  }, {
    key: "accessToken",
    get: function get() {
      if (!this.cachedaccessToken) this.loadAccessToken();
      return this.cachedaccessToken;
    }
  }, {
    key: "loadAccessToken",
    value: function loadAccessToken() {
      this.cachedaccessToken = this.storage.getItem(this.accessTokenKey());
    }
  }, {
    key: "saveAccessToken",
    value: function saveAccessToken(accessToken) {
      if (accessToken) {
        this.cachedaccessToken = accessToken;
        this.storage.setItem(this.accessTokenKey(), accessToken);
      } else {
        this.clearAccessToken();
      }
    }
  }, {
    key: "clearAccessToken",
    value: function clearAccessToken() {
      this.cachedaccessToken = null;
      this.storage.removeItem(this.accessTokenKey());
    }
  }, {
    key: "clear",
    value: function clear() {
      this.clearAccessToken();
    }
  }]);

  return LocalState;
}();



/***/ }),
/* 119 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DummyStorage": () => (/* binding */ DummyStorage),
/* harmony export */   "MemoryStorage": () => (/* binding */ MemoryStorage),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(120);
/* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_cookie__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/* eslint-disable @typescript-eslint/no-unused-vars */

/* eslint-disable max-classes-per-file */

/*

Handles storage to local storage, or cookies, whatever is available to the client

Mostly copied originally copied from Auth0.js but modifed to use a class
https://github.com/auth0/auth0.js/tree/master/src/helper/storage

*/



var CookieStorage = /*#__PURE__*/function () {
  function CookieStorage() {
    _classCallCheck(this, CookieStorage);
  }

  _createClass(CookieStorage, [{
    key: "getItem",
    value: function getItem(key) {
      return js_cookie__WEBPACK_IMPORTED_MODULE_0__.get(key);
    }
  }, {
    key: "removeItem",
    value: function removeItem(key) {
      js_cookie__WEBPACK_IMPORTED_MODULE_0__.remove(key);
    }
  }, {
    key: "setItem",
    value: function setItem(key, value, options) {
      var params = _objectSpread({
        expires: 1
      }, options);

      return js_cookie__WEBPACK_IMPORTED_MODULE_0__.set(key, value, params);
    }
  }]);

  return CookieStorage;
}();

var LocalStorage = /*#__PURE__*/function () {
  function LocalStorage() {
    _classCallCheck(this, LocalStorage);

    if (window) {
      // some browsers throw an error when trying to access localStorage
      // when localStorage is disabled.
      this.storage = window.localStorage;
    } else {
      _helpers__WEBPACK_IMPORTED_MODULE_1__["default"].log('Not running in Browser. Using CookieStorage instead.');
    }
  }

  _createClass(LocalStorage, [{
    key: "getItem",
    value: function getItem(key) {
      if (this.storage) {
        return this.storage.getItem(key);
      }

      return null;
    }
  }, {
    key: "removeItem",
    value: function removeItem(key) {
      if (this.storage) {
        this.storage.removeItem(key);
      }
    }
  }, {
    key: "setItem",
    value: function setItem(key, value, options) {
      if (this.storage) {
        this.storage.setItem(key, value);
      }
    }
  }]);

  return LocalStorage;
}();
/** does not store or retrieve any values - allows 'disabling' of storage */


var DummyStorage = /*#__PURE__*/function () {
  function DummyStorage() {
    _classCallCheck(this, DummyStorage);
  }

  _createClass(DummyStorage, [{
    key: "getItem",
    value: function getItem(key) {
      return null;
    }
  }, {
    key: "removeItem",
    value: function removeItem(key) {// empty
    }
  }, {
    key: "setItem",
    value: function setItem(key, value, options) {// empty
    }
  }]);

  return DummyStorage;
}();
/** stores items in memory - does not persist across instances */

var MemoryStorage = /*#__PURE__*/function () {
  function MemoryStorage() {
    _classCallCheck(this, MemoryStorage);

    _defineProperty(this, "memoryCache", {});
  }

  _createClass(MemoryStorage, [{
    key: "getItem",
    value: function getItem(key) {
      if (key in this.memoryCache) return this.memoryCache[key];
      return null;
    }
  }, {
    key: "removeItem",
    value: function removeItem(key) {
      if (!this.getItem(key)) return;
      delete this.memoryCache[key];
    }
  }, {
    key: "setItem",
    value: function setItem(key, value, options) {
      this.memoryCache[key] = value;
    }
  }]);

  return MemoryStorage;
}();

var StorageHandler = /*#__PURE__*/function () {
  function StorageHandler() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      tryLocalStorageFirst: true
    };

    _classCallCheck(this, StorageHandler);

    this.triedLocalStorage = false;
    this.triedCookieStorage = false;

    if (options.tryLocalStorageFirst === true) {
      this.triedLocalStorage = true;

      try {
        // designed to work on browser or server, so window might not exist
        var localStorage = new LocalStorage();

        if (localStorage && localStorage.storage) {
          this.storage = localStorage;
        }
      } catch (e) {
        _helpers__WEBPACK_IMPORTED_MODULE_1__["default"].log('Cant use localStorage. Using CookieStorage instead.', options);
      }
    }

    if (!this.storage) {
      this.storage = new CookieStorage();
      this.triedCookieStorage = true;
    }
  }

  _createClass(StorageHandler, [{
    key: "failover",
    value: function failover() {
      if (this.storage instanceof DummyStorage) {
        return;
      }

      var didSet = false;

      if (this.storage instanceof LocalStorage) {
        if (!this.triedCookieStorage) {
          this.storage = new CookieStorage();
          this.triedCookieStorage = true;
          didSet = true;
        }
      } else if (this.storage instanceof CookieStorage) {
        if (!this.triedLocalStorage) {
          this.storage = new LocalStorage();
          this.triedLocalStorage = true;
          didSet = true;
        }
      }

      if (!didSet) {
        this.storage = new DummyStorage();
      }
    }
  }, {
    key: "getItem",
    value: function getItem(key) {
      try {
        return this.storage.getItem(key);
      } catch (e) {
        _helpers__WEBPACK_IMPORTED_MODULE_1__["default"].log('Cant getItem in storage.', e);
        this.failover();
        return this.storage.getItem(key);
      }
    }
  }, {
    key: "removeItem",
    value: function removeItem(key) {
      try {
        this.storage.removeItem(key);
        return;
      } catch (e) {
        _helpers__WEBPACK_IMPORTED_MODULE_1__["default"].log('Cant removeItem in storage.', e);
        this.failover();
        this.storage.removeItem(key);
      }
    }
  }, {
    key: "setItem",
    value: function setItem(key, value, options) {
      try {
        return this.storage.setItem(key, value, options);
      } catch (e) {
        _helpers__WEBPACK_IMPORTED_MODULE_1__["default"].log('Cant setItem in storage.', e);
        this.failover();
        return this.storage.setItem(key, value, options);
      }
    }
  }]);

  return StorageHandler;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StorageHandler);

/***/ }),
/* 120 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * JavaScript Cookie v2.2.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
;(function (factory) {
	var registeredInModuleLoader;
	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		registeredInModuleLoader = true;
	}
	if (true) {
		module.exports = factory();
		registeredInModuleLoader = true;
	}
	if (!registeredInModuleLoader) {
		var OldCookies = window.Cookies;
		var api = window.Cookies = factory();
		api.noConflict = function () {
			window.Cookies = OldCookies;
			return api;
		};
	}
}(function () {
	function extend () {
		var i = 0;
		var result = {};
		for (; i < arguments.length; i++) {
			var attributes = arguments[ i ];
			for (var key in attributes) {
				result[key] = attributes[key];
			}
		}
		return result;
	}

	function decode (s) {
		return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
	}

	function init (converter) {
		function api() {}

		function set (key, value, attributes) {
			if (typeof document === 'undefined') {
				return;
			}

			attributes = extend({
				path: '/'
			}, api.defaults, attributes);

			if (typeof attributes.expires === 'number') {
				attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
			}

			// We're using "expires" because "max-age" is not supported by IE
			attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

			try {
				var result = JSON.stringify(value);
				if (/^[\{\[]/.test(result)) {
					value = result;
				}
			} catch (e) {}

			value = converter.write ?
				converter.write(value, key) :
				encodeURIComponent(String(value))
					.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

			key = encodeURIComponent(String(key))
				.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
				.replace(/[\(\)]/g, escape);

			var stringifiedAttributes = '';
			for (var attributeName in attributes) {
				if (!attributes[attributeName]) {
					continue;
				}
				stringifiedAttributes += '; ' + attributeName;
				if (attributes[attributeName] === true) {
					continue;
				}

				// Considers RFC 6265 section 5.2:
				// ...
				// 3.  If the remaining unparsed-attributes contains a %x3B (";")
				//     character:
				// Consume the characters of the unparsed-attributes up to,
				// not including, the first %x3B (";") character.
				// ...
				stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
			}

			return (document.cookie = key + '=' + value + stringifiedAttributes);
		}

		function get (key, json) {
			if (typeof document === 'undefined') {
				return;
			}

			var jar = {};
			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all.
			var cookies = document.cookie ? document.cookie.split('; ') : [];
			var i = 0;

			for (; i < cookies.length; i++) {
				var parts = cookies[i].split('=');
				var cookie = parts.slice(1).join('=');

				if (!json && cookie.charAt(0) === '"') {
					cookie = cookie.slice(1, -1);
				}

				try {
					var name = decode(parts[0]);
					cookie = (converter.read || converter)(cookie, name) ||
						decode(cookie);

					if (json) {
						try {
							cookie = JSON.parse(cookie);
						} catch (e) {}
					}

					jar[name] = cookie;

					if (key === name) {
						break;
					}
				} catch (e) {}
			}

			return key ? jar[key] : jar;
		}

		api.set = set;
		api.get = function (key) {
			return get(key, false /* read as raw */);
		};
		api.getJSON = function (key) {
			return get(key, true /* read as json */);
		};
		api.remove = function (key, attributes) {
			set(key, '', extend(attributes, {
				expires: -1
			}));
		};

		api.defaults = {};

		api.withConverter = init;

		return api;
	}

	return init(function () {});
}));


/***/ }),
/* 121 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Settings)
/* harmony export */ });
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var Settings = /*#__PURE__*/function () {
  function Settings(args) {
    _classCallCheck(this, Settings);

    _defineProperty(this, "_cachedChainNetworks", []);

    this._oreIdContext = args.oreIdContext;
    this._cachedChainNetworks = null;
  }

  _createClass(Settings, [{
    key: "getAllChainNetworkSettings",
    value:
    /** Calls getConfigFromApi() to retrieve settings for all chain networks defined by OreID service
     * and caches the result */
    function () {
      var _getAllChainNetworkSettings = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var results;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!_utils_helpers__WEBPACK_IMPORTED_MODULE_2__["default"].isNullOrEmpty(this._cachedChainNetworks)) {
                  _context.next = 5;
                  break;
                }

                _context.next = 3;
                return this.getConfigFromApi(_models__WEBPACK_IMPORTED_MODULE_1__.ConfigType.Chains);

              case 3:
                results = _context.sent;
                this._cachedChainNetworks = results.chains; // as SettingChainNetwork[]

              case 5:
                return _context.abrupt("return", this._cachedChainNetworks);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getAllChainNetworkSettings() {
        return _getAllChainNetworkSettings.apply(this, arguments);
      }

      return getAllChainNetworkSettings;
    }()
    /** Returns Chain Network Settings for a specific chain */

  }, {
    key: "getChainNetworkSettings",
    value: function () {
      var _getChainNetworkSettings = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(chainNetwork) {
        var networks;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getAllChainNetworkSettings();

              case 2:
                networks = _context2.sent;
                return _context2.abrupt("return", networks.find(function (n) {
                  return n.network === chainNetwork;
                }));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getChainNetworkSettings(_x) {
        return _getChainNetworkSettings.apply(this, arguments);
      }

      return getChainNetworkSettings;
    }()
    /** Loads settings value from the server
      e.g. configType='chains' returns valid chain types and addresses */

  }, {
    key: "getConfig",
    value: function () {
      var _getConfig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(configType) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", this.getConfigFromApi(configType));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getConfig(_x2) {
        return _getConfig.apply(this, arguments);
      }

      return getConfig;
    }()
    /**
     *  Call api services/config to get configuration values of a specific type
     *  Returns: for configType:Config.Chains, returns array of SettingChainNetwork objects for all chains suported by the service
     * */

  }, {
    key: "getConfigFromApi",
    value: function () {
      var _getConfigFromApi = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(configType) {
        var values;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return (0,_api__WEBPACK_IMPORTED_MODULE_0__.callApiGetConfig)(this._oreIdContext, {
                  configType: configType
                });

              case 2:
                values = _context4.sent;

                if (!_utils_helpers__WEBPACK_IMPORTED_MODULE_2__["default"].isNullOrEmpty(values)) {
                  _context4.next = 5;
                  break;
                }

                throw new Error("Not able to retrieve config values for ".concat(configType));

              case 5:
                return _context4.abrupt("return", values);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getConfigFromApi(_x3) {
        return _getConfigFromApi.apply(this, arguments);
      }

      return getConfigFromApi;
    }()
    /** Returns network config (url, port, etc.) for specified chainNetwork */

  }, {
    key: "getChainNetworkNextworkConfig",
    value: function () {
      var _getChainNetworkNextworkConfig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(chainNetwork) {
        var networkSettings, _ref, chainId, host, port, protocol;

        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getChainNetworkSettings(chainNetwork);

              case 2:
                networkSettings = _context5.sent;

                if (networkSettings) {
                  _context5.next = 5;
                  break;
                }

                throw new Error("Invalid chain network: ".concat(chainNetwork, "."));

              case 5:
                _ref = (networkSettings === null || networkSettings === void 0 ? void 0 : networkSettings.hosts[0]) || {}, chainId = _ref.chainId, host = _ref.host, port = _ref.port, protocol = _ref.protocol; // using first host

                return _context5.abrupt("return", {
                  host: host,
                  port: port,
                  protocol: protocol,
                  chainId: chainId
                });

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getChainNetworkNextworkConfig(_x4) {
        return _getChainNetworkNextworkConfig.apply(this, arguments);
      }

      return getChainNetworkNextworkConfig;
    }()
    /** Return ChainNetwork that matches chainId (as defined in OreId Chain Network Settings) */

  }, {
    key: "getChainNetworkByChainId",
    value: function () {
      var _getChainNetworkByChainId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(chainId) {
        var networks, chainSettings;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getAllChainNetworkSettings();

              case 2:
                networks = _context6.sent;
                chainSettings = networks.find(function (n) {
                  return n.hosts.find(function (h) {
                    return h.chainId === chainId;
                  });
                });

                if (_utils_helpers__WEBPACK_IMPORTED_MODULE_2__["default"].isNullOrEmpty(chainSettings)) {
                  _context6.next = 6;
                  break;
                }

                return _context6.abrupt("return", chainSettings.network);

              case 6:
                return _context6.abrupt("return", null);

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getChainNetworkByChainId(_x5) {
        return _getChainNetworkByChainId.apply(this, arguments);
      }

      return getChainNetworkByChainId;
    }()
    /** Returns true if network is NOT an EOS sisterchain */

  }, {
    key: "isNotEosNetwork",
    value: function () {
      var _isNotEosNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(chainNetwork) {
        var networkSetting;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._oreIdContext.settings.getChainNetworkSettings(chainNetwork);

              case 2:
                networkSetting = _context7.sent;
                return _context7.abrupt("return", !(networkSetting.type === _models__WEBPACK_IMPORTED_MODULE_1__.ChainPlatformType.eos || networkSetting.type === _models__WEBPACK_IMPORTED_MODULE_1__.ChainPlatformType.ore));

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function isNotEosNetwork(_x6) {
        return _isNotEosNetwork.apply(this, arguments);
      }

      return isNotEosNetwork;
    }()
  }]);

  return Settings;
}();



/***/ }),
/* 122 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WalletHelper)
/* harmony export */ });
/* harmony import */ var _ual_ualProviders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73);
/* harmony import */ var _transit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(123);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(109);
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17);
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(14);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }








var WalletHelper = /*#__PURE__*/function () {
  function WalletHelper(args) {
    _classCallCheck(this, WalletHelper);

    this._oreIdContext = args.oreIdContext;
    this._transitHelper = args.transitHelper;
    this._ualHelper = args.ualHelper;
  }

  _createClass(WalletHelper, [{
    key: "transitHelper",
    get:
    /** Transit wallet plugin helper functions and connections */
    function get() {
      return this._transitHelper;
    }
    /** Ual wallet plugin helper functions and connections */

  }, {
    key: "ualHelper",
    get: function get() {
      return this._ualHelper;
    } //** Whether wallet type is a Transit or Ual wallet */

  }, {
    key: "isAValidExternalWalletType",
    value: function isAValidExternalWalletType(walletType) {
      return (this._transitHelper.isTransitProvider(walletType) || this._ualHelper.isUalProvider(walletType)) && !_constants__WEBPACK_IMPORTED_MODULE_2__.externalWalletsNotImplemented.includes(walletType);
    }
    /** Returns metadata about the installed external wallet type (e.g. name, logo) and which features it supports
     *  If optional externalWalletInterface param provided, then gets Info for the specified type (Transit or UAL) instead of seeing what's installed
     */

  }, {
    key: "getExternalWalletInfo",
    value: function getExternalWalletInfo(walletType, externalWalletInterface) {
      if (!this.isAValidExternalWalletType(walletType)) {
        throw new Error("Not a valid external wallet type: ".concat(walletType));
      }

      if (this._transitHelper.hasTransitProvider(walletType) || externalWalletInterface === _models__WEBPACK_IMPORTED_MODULE_5__.ExternalWalletInterface.Transit) {
        return (0,_transit__WEBPACK_IMPORTED_MODULE_1__.getTransitProviderAttributes)(walletType);
      }

      if (this._ualHelper.hasUalProvider(walletType) || externalWalletInterface === _models__WEBPACK_IMPORTED_MODULE_5__.ExternalWalletInterface.Ual) {
        return (0,_ual_ualProviders__WEBPACK_IMPORTED_MODULE_0__.getUalProviderAttributes)(walletType);
      }

      return null;
    }
    /** Returns wallet metadata (for installed wallet providers) for a given chain */

  }, {
    key: "getExternalWalletInfoByChain",
    value: function getExternalWalletInfoByChain(chain) {
      var _this = this;

      var transitWalletsInstalledInfo = _transit__WEBPACK_IMPORTED_MODULE_1__.transitProviderAttributesData.filter(function (info) {
        return _this._oreIdContext.transitProvidersInstalled.includes(info.providerName);
      });
      var ualWalletsInstalledInfo = _ual_ualProviders__WEBPACK_IMPORTED_MODULE_0__.ualProviderAttributesData.filter(function (info) {
        return _this._oreIdContext.ualProvidersInstalled.includes(info.providerName);
      });
      return [].concat(_toConsumableArray(transitWalletsInstalledInfo), _toConsumableArray(ualWalletsInstalledInfo)).filter(function (p) {
        return p.chainType === chain;
      });
    }
    /** Connect to the wallet provider
     *  For some wallet types, this will include an unlock and 'login' flow to select a chain account
     *  If a chainAccount is selected, it and it's associated publicKey (if available) will be saved to the user's OreId wallet as an 'external key' */

  }, {
    key: "connectToWalletProvider",
    value: function () {
      var _connectToWalletProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(loginOptions) {
        var walletType;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                walletType = loginOptions.walletType;

                if (this.isAValidExternalWalletType(walletType)) {
                  _context.next = 3;
                  break;
                }

                throw new Error("Not a valid external wallet type: ".concat(walletType));

              case 3:
                if (!this._transitHelper.hasTransitProvider(walletType)) {
                  _context.next = 7;
                  break;
                }

                return _context.abrupt("return", this._transitHelper.loginWithTransitProvider(loginOptions));

              case 7:
                if (!this._ualHelper.hasUalProvider(walletType)) {
                  _context.next = 9;
                  break;
                }

                return _context.abrupt("return", this._ualHelper.loginWithUalProvider(loginOptions));

              case 9:
                throw new Error("Wallet type ".concat(walletType, " invalid or not installed"));

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function connectToWalletProvider(_x) {
        return _connectToWalletProvider.apply(this, arguments);
      }

      return connectToWalletProvider;
    }()
    /** Sign with a supported blockchain wallet via Transit provider */

  }, {
    key: "signWithWallet",
    value: function () {
      var _signWithWallet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(walletType, transactionData) {
        var signResult, provider, account, chainNetwork;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this._oreIdContext.walletHelper.isAValidExternalWalletType(walletType)) {
                  _context2.next = 2;
                  break;
                }

                throw new Error("signWithWallet not supported for external wallet type: ".concat(walletType));

              case 2:
                provider = _utils_helpers__WEBPACK_IMPORTED_MODULE_3__["default"].toEnumValue(_models__WEBPACK_IMPORTED_MODULE_4__.AuthProvider, walletType);

                if (!this._transitHelper.hasTransitProvider(walletType)) {
                  _context2.next = 12;
                  break;
                }

                _context2.next = 6;
                return this._transitHelper.signWithTransitProvider(transactionData, walletType);

              case 6:
                signResult = _context2.sent;
                // If we've signed a transaction with a key in a wallet, callDiscoverAfterSign() will add it to the user's wallet
                account = transactionData.account, chainNetwork = transactionData.chainNetwork;
                _context2.next = 10;
                return this._transitHelper.callDiscoverAfterSign({
                  account: account,
                  chainNetwork: chainNetwork,
                  signOptions: {
                    provider: provider
                  }
                });

              case 10:
                _context2.next = 16;
                break;

              case 12:
                if (!this._ualHelper.hasUalProvider(walletType)) {
                  _context2.next = 16;
                  break;
                }

                _context2.next = 15;
                return this._ualHelper.signWithUalProvider(transactionData, walletType);

              case 15:
                signResult = _context2.sent;

              case 16:
                return _context2.abrupt("return", signResult);

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function signWithWallet(_x2, _x3) {
        return _signWithWallet.apply(this, arguments);
      }

      return signWithWallet;
    }()
    /** Sign an arbitrary string (instead of a transaction)
     * This only supports Transit and Ual wallets
     */

  }, {
    key: "signStringWithWallet",
    value: function () {
      var _signStringWithWallet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(params) {
        var account, walletType, chainNetwork, signResult, provider;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                account = params.account, walletType = params.walletType, chainNetwork = params.chainNetwork;

                if (this.isAValidExternalWalletType(walletType)) {
                  _context3.next = 3;
                  break;
                }

                throw new Error("signStringWithWallet not supported for external wallet type: ".concat(walletType));

              case 3:
                provider = _utils_helpers__WEBPACK_IMPORTED_MODULE_3__["default"].toEnumValue(_models__WEBPACK_IMPORTED_MODULE_4__.AuthProvider, walletType);

                if (!this._transitHelper.hasTransitProvider(walletType)) {
                  _context3.next = 14;
                  break;
                }

                if (this._transitHelper.canSignString(walletType)) {
                  _context3.next = 7;
                  break;
                }

                throw Error("The walletType ".concat(walletType, " does not support signString"));

              case 7:
                _context3.next = 9;
                return this._transitHelper.signStringWithTransitProvider(params);

              case 9:
                signResult = _context3.sent;
                _context3.next = 12;
                return this._transitHelper.callDiscoverAfterSign({
                  account: account,
                  chainNetwork: chainNetwork,
                  signOptions: {
                    provider: provider
                  }
                });

              case 12:
                _context3.next = 20;
                break;

              case 14:
                if (!this._ualHelper.hasUalProvider(walletType)) {
                  _context3.next = 20;
                  break;
                }

                if (this._ualHelper.canSignString(walletType)) {
                  _context3.next = 17;
                  break;
                }

                throw Error("The walletType ".concat(walletType, " does not support signString"));

              case 17:
                _context3.next = 19;
                return this._ualHelper.signStringWithUalProvider(params);

              case 19:
                signResult = _context3.sent;

              case 20:
                return _context3.abrupt("return", signResult);

              case 21:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function signStringWithWallet(_x4) {
        return _signStringWithWallet.apply(this, arguments);
      }

      return signStringWithWallet;
    }()
    /** Throw if the provider doesnt support the specified chainNetwork */

  }, {
    key: "assertWalletTypeValidForChainNetwork",
    value: function () {
      var _assertWalletTypeValidForChainNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(walletType, chainNetwork, externalWalletInterface) {
        var _this$getExternalWall, chainType, networks, isValid;

        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _this$getExternalWall = this.getExternalWalletInfo(walletType, externalWalletInterface), chainType = _this$getExternalWall.chainType;
                _context4.next = 3;
                return this._oreIdContext.settings.getAllChainNetworkSettings();

              case 3:
                networks = _context4.sent;
                isValid = !!networks.find(function (n) {
                  return n.network === chainNetwork && n.type === chainType;
                });

                if (isValid) {
                  _context4.next = 7;
                  break;
                }

                throw Error("External Wallet Type: ".concat(walletType, " doesnt support chainNetwork ").concat(chainNetwork, ". Hint: It supports networks of type ").concat(chainType, "."));

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function assertWalletTypeValidForChainNetwork(_x5, _x6, _x7) {
        return _assertWalletTypeValidForChainNetwork.apply(this, arguments);
      }

      return assertWalletTypeValidForChainNetwork;
    }() // Supported features by wallet provider

    /** whether discovery is supported by the provider */

  }, {
    key: "canDiscover",
    value: function canDiscover(walletType, externalWalletInterface) {
      var _this$getExternalWall2;

      return ((_this$getExternalWall2 = this.getExternalWalletInfo(walletType, externalWalletInterface)) === null || _this$getExternalWall2 === void 0 ? void 0 : _this$getExternalWall2.supportsDiscovery) || false;
    }
    /** whether signString is supported by the provider */

  }, {
    key: "canSignString",
    value: function canSignString(walletType, externalWalletInterface) {
      var _this$getExternalWall3;

      return ((_this$getExternalWall3 = this.getExternalWalletInfo(walletType, externalWalletInterface)) === null || _this$getExternalWall3 === void 0 ? void 0 : _this$getExternalWall3.supportsSignArbitrary) || false;
    }
    /** whether call to discover is required by provider before login */

  }, {
    key: "requiresDiscoverToLogin",
    value: function requiresDiscoverToLogin(walletType, externalWalletInterface) {
      var _this$getExternalWall4;

      return ((_this$getExternalWall4 = this.getExternalWalletInfo(walletType, externalWalletInterface)) === null || _this$getExternalWall4 === void 0 ? void 0 : _this$getExternalWall4.requiresDiscoverToLogin) || false;
    }
    /** whether call to logout then login is required by provider before discover */

  }, {
    key: "requiresLogoutLoginToDiscover",
    value: function requiresLogoutLoginToDiscover(walletType, externalWalletInterface) {
      var _this$getExternalWall5;

      return ((_this$getExternalWall5 = this.getExternalWalletInfo(walletType, externalWalletInterface)) === null || _this$getExternalWall5 === void 0 ? void 0 : _this$getExternalWall5.requiresLogoutLoginToDiscover) || false;
    }
    /** default path index for provider (if any) */

  }, {
    key: "defaultDiscoveryPathIndexList",
    value: function defaultDiscoveryPathIndexList(walletType, externalWalletInterface) {
      var _this$getExternalWall6;

      return ((_this$getExternalWall6 = this.getExternalWalletInfo(walletType, externalWalletInterface)) === null || _this$getExternalWall6 === void 0 ? void 0 : _this$getExternalWall6.defaultDiscoveryPathIndexList) || null;
    }
    /** help text displayed to user for provider */

  }, {
    key: "helpTextForProvider",
    value: function helpTextForProvider(walletType, externalWalletInterface) {
      var _this$getExternalWall7;

      return ((_this$getExternalWall7 = this.getExternalWalletInfo(walletType, externalWalletInterface)) === null || _this$getExternalWall7 === void 0 ? void 0 : _this$getExternalWall7.helpText) || null;
    }
  }]);

  return WalletHelper;
}();



/***/ }),
/* 123 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTransitProviderAttributes": () => (/* reexport safe */ _transitProviders__WEBPACK_IMPORTED_MODULE_1__.getTransitProviderAttributes),
/* harmony export */   "getTransitProviderAttributesByChain": () => (/* reexport safe */ _transitProviders__WEBPACK_IMPORTED_MODULE_1__.getTransitProviderAttributesByChain),
/* harmony export */   "getTransitProviderAttributesByProviderId": () => (/* reexport safe */ _transitProviders__WEBPACK_IMPORTED_MODULE_1__.getTransitProviderAttributesByProviderId),
/* harmony export */   "supportedTransitProviders": () => (/* reexport safe */ _transitProviders__WEBPACK_IMPORTED_MODULE_1__.supportedTransitProviders),
/* harmony export */   "transitProviderAttributesData": () => (/* reexport safe */ _transitProviders__WEBPACK_IMPORTED_MODULE_1__.transitProviderAttributesData)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _transitProviders__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71);



/***/ }),
/* 124 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PluginType": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_1__.PluginType)
/* harmony export */ });
/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(125);
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(126);



/***/ }),
/* 125 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);


/***/ }),
/* 126 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PluginType": () => (/* binding */ PluginType)
/* harmony export */ });
/* harmony import */ var _popupPlugin_models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(127);

var PluginType;

(function (PluginType) {
  PluginType["Popup"] = "popup";
})(PluginType || (PluginType = {}));

/***/ }),
/* 127 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AccountType": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_7__.AccountType),
/* harmony export */   "ApiEndpoint": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_7__.ApiEndpoint),
/* harmony export */   "ApiKeyUsedFor": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_7__.ApiKeyUsedFor),
/* harmony export */   "Auth": () => (/* reexport safe */ _auth_auth__WEBPACK_IMPORTED_MODULE_0__.Auth),
/* harmony export */   "AuthProvider": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_7__.AuthProvider),
/* harmony export */   "ChainNetwork": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_7__.ChainNetwork),
/* harmony export */   "ChainPlatformType": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_7__.ChainPlatformType),
/* harmony export */   "ConfigType": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_7__.ConfigType),
/* harmony export */   "DummyStorage": () => (/* reexport safe */ _utils_storage__WEBPACK_IMPORTED_MODULE_6__.DummyStorage),
/* harmony export */   "ExternalWalletInterface": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_7__.ExternalWalletInterface),
/* harmony export */   "ExternalWalletType": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_7__.ExternalWalletType),
/* harmony export */   "Helpers": () => (/* reexport safe */ _utils_helpers__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "LoginProvider": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_7__.LoginProvider),
/* harmony export */   "MemoryStorage": () => (/* reexport safe */ _utils_storage__WEBPACK_IMPORTED_MODULE_6__.MemoryStorage),
/* harmony export */   "OreId": () => (/* reexport safe */ _core_oreId__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "PluginType": () => (/* reexport safe */ _plugins__WEBPACK_IMPORTED_MODULE_8__.PluginType),
/* harmony export */   "RecoverAccountAction": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_7__.RecoverAccountAction),
/* harmony export */   "RequestType": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_7__.RequestType),
/* harmony export */   "SignStringMethod": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_7__.SignStringMethod),
/* harmony export */   "Transaction": () => (/* reexport safe */ _transaction_transaction__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "User": () => (/* reexport safe */ _user_user__WEBPACK_IMPORTED_MODULE_3__.User),
/* harmony export */   "WebWidgetAction": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_7__.WebWidgetAction),
/* harmony export */   "WidgetVersion": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_7__.WidgetVersion),
/* harmony export */   "appendHmacToUrl": () => (/* reexport safe */ _utils_hmac__WEBPACK_IMPORTED_MODULE_5__.appendHmacToUrl),
/* harmony export */   "generateHmac": () => (/* reexport safe */ _utils_hmac__WEBPACK_IMPORTED_MODULE_5__.generateHmac),
/* harmony export */   "generateHmacWithApiKeyOrProxyServer": () => (/* reexport safe */ _utils_hmac__WEBPACK_IMPORTED_MODULE_5__.generateHmacWithApiKeyOrProxyServer)
/* harmony export */ });
/* harmony import */ var _auth_auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _core_oreId__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(78);
/* harmony import */ var _transaction_transaction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(111);
/* harmony import */ var _user_user__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(74);
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17);
/* harmony import */ var _utils_hmac__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(112);
/* harmony import */ var _utils_storage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(119);
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5);
/* harmony import */ var _plugins__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(124);










})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxDQUFD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QUEyQm5tQixVQUEzQixFQUF1QzByQix1QkFBdkMsbUZBQWlFelAsUUFBakUsS0FBNkUsSUFBcEY7SUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3TUg7Ozs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBRUFBO0FBRU8sSUFBS21RLFVBQVo7O1dBQVlBO0VBQUFBO0dBQUFBLGVBQUFBOzs7Ozs7Ozs7Ozs7O1VFRlo7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGlDQUFpQyxXQUFXO1dBQzVDO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0EsQ0FBQzs7Ozs7V0NQRDs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy8uL3NyYy9hdXRoL2F1dGgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2VuZHBvaW50cy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2VuZHBvaW50cy9hZGRQZXJtaXNzaW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9tb2RlbHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2F1dGgvbW9kZWxzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vbW9kZWxzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL21vZGVscy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdXNlci9tb2RlbHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RyYW5zYWN0aW9uL21vZGVscy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdHJhbnNpdC9tb2RlbHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3VhbC9tb2RlbHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3dhbGxldHMvbW9kZWxzLnRzIiwid2VicGFjazovLy8uL3NyYy93ZWJXaWRnZXQvbW9kZWxzLnRzIiwid2VicGFjazovLy8uL3NyYy9hcGkvaGVscGVycy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvaGVscGVycy50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2Fub25pY2FsaXplL2xpYi9jYW5vbmljYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2p3dC1kZWNvZGUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qd3QtZGVjb2RlL2xpYi9iYXNlNjRfdXJsX2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvand0LWRlY29kZS9saWIvYXRvYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMtYmFzZTY0L2Jhc2U2NC5tanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JuZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL2J5dGVzVG9VdWlkLmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvZW5kcG9pbnRzL2FwcFRva2VuLnRzIiwid2VicGFjazovLy8uL3NyYy9hcGkvZW5kcG9pbnRzL2NhbkF1dG9TaWduLnRzIiwid2VicGFjazovLy8uL3NyYy9hcGkvZW5kcG9pbnRzL2NvbnZlcnRPYXV0aC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2VuZHBvaW50cy9jdXN0b2RpYWxNaWdyYXRlQWNjb3VudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2VuZHBvaW50cy9jdXN0b2RpYWxOZXdBY2NvdW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcGkvZW5kcG9pbnRzL2N1c3RvZGlhbFNpZ25TdHJpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9lbmRwb2ludHMvZGVsZXRlVGVzdFVzZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9lbmRwb2ludHMvZ2V0Q29uZmlnLnRzIiwid2VicGFjazovLy8uL3NyYy9hcGkvZW5kcG9pbnRzL2dldFVzZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9lbmRwb2ludHMvbG9naW5Vc2VyV2l0aFRva2VuLnRzIiwid2VicGFjazovLy8uL3NyYy9hcGkvZW5kcG9pbnRzL25ld1VzZXJXaXRoVG9rZW4udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9lbmRwb2ludHMvcGFzc3dvcmRMZXNzU2VuZENvZGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9lbmRwb2ludHMvcGFzc3dvcmRMZXNzVmVyaWZ5Q29kZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2VuZHBvaW50cy9zaWduVHJhbnNhY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdXJsR2VuZXJhdG9ycy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdHJhbnNpdC9UcmFuc2l0SGVscGVyLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYWlrb24vZW9zLXRyYW5zaXQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYWlrb24vZW9zLXRyYW5zaXQvbGliL3dhbGxldEFjY2Vzc0NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Vvc2pzL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Vvc2pzL2Rpc3QvZW9zanMtYXBpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lb3Nqcy9kaXN0L2Vvc2pzLXNlcmlhbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW9zanMvZGlzdC9lb3Nqcy1udW1lcmljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lb3Nqcy9kaXN0L3JpcGVtZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW9zanMvZGlzdC9lb3Nqcy1hcGktaW50ZXJmYWNlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW9zanMvZGlzdC9lb3Nqcy1qc29ucnBjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lb3Nqcy9kaXN0L2Vvc2pzLXJwY2Vycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lb3Nqcy9kaXN0L2Vvc2pzLXJwYy1pbnRlcmZhY2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYWlrb24vZW9zLXRyYW5zaXQvbGliL3N0YXRlQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYWlrb24vZW9zLXRyYW5zaXQvbGliL3dhbGxldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFpa29uL2Vvcy10cmFuc2l0L25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYWlrb24vZW9zLXRyYW5zaXQvbm9kZV9tb2R1bGVzL3V1aWQvbGliL3JuZy1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYWlrb24vZW9zLXRyYW5zaXQvbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYWlrb24vZW9zLXRyYW5zaXQvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2NoYWluVXRpbHMudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svZGlzdC5lczUrZXNtL2VuY29kZS5tanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svZGlzdC5lczUrZXNtL0VuY29kZXIubWpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL2Rpc3QuZXM1K2VzbS9FeHRlbnNpb25Db2RlYy5tanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svZGlzdC5lczUrZXNtL3RpbWVzdGFtcC5tanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svZGlzdC5lczUrZXNtL3V0aWxzL2ludC5tanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svZGlzdC5lczUrZXNtL0RlY29kZUVycm9yLm1qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9kaXN0LmVzNStlc20vRXh0RGF0YS5tanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svZGlzdC5lczUrZXNtL3V0aWxzL3V0ZjgubWpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL2Rpc3QuZXM1K2VzbS91dGlscy90eXBlZEFycmF5cy5tanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RyYW5zaXQvdHJhbnNpdFByb3ZpZGVycy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdWFsL1VhbEhlbHBlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdWFsL3VhbFByb3ZpZGVycy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdXNlci91c2VyLnRzIiwid2VicGFjazovLy8uL3NyYy91dGlscy9vYnNlcnZhYmxlLnRzIiwid2VicGFjazovLy8uL3NyYy9hcGkvZW5kcG9pbnRzL3VwZGF0ZURlbGF5V2FsbGV0U2V0dXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2F1dGgvYWNjZXNzVG9rZW5IZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvb3JlSWQudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy90cmFuc2l0aW9uYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy92YWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9lbnYvZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnN0YW50cy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2htYWMudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9obWFjLXNoYTI1Ni5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanMiLCJ3ZWJwYWNrOi8vL2lnbm9yZWR8L1VzZXJzL2plcmVteWR1bm4vYWlrb24vb3JlaWQtanMvbm9kZV9tb2R1bGVzL2NyeXB0by1qc3xjcnlwdG8iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEyNTYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9obWFjLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy9sb2NhbFN0YXRlLnRzIiwid2VicGFjazovLy8uL3NyYy91dGlscy9zdG9yYWdlLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy1jb29raWUvc3JjL2pzLmNvb2tpZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9TZXR0aW5ncy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvd2FsbGV0cy9XYWxsZXRIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RyYW5zaXQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsdWdpbnMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsdWdpbnMvcGx1Z2luLnRzIiwid2VicGFjazovLy8uL3NyYy9wbHVnaW5zL21vZGVscy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcGx1Z2lucy9wb3B1cFBsdWdpbi9tb2RlbHMudHMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJvcmVpZEpzXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIm9yZWlkSnNcIl0gPSBmYWN0b3J5KCk7XG59KShzZWxmLCAoKSA9PiB7XG5yZXR1cm4gIiwiaW1wb3J0IHtcbiAgQXBpQ29udmVydE9hdXRoVG9rZW5zUGFyYW1zLFxuICBBcGlMb2dpblVzZXJXaXRoVG9rZW5QYXJhbXMsXG4gIEFwaU1lc3NhZ2VSZXN1bHQsXG4gIEFwaU5ld1VzZXJXaXRoVG9rZW5QYXJhbXMsXG4gIGNhbGxBcGlDb252ZXJ0T2F1dGhUb2tlbnMsXG4gIGNhbGxBcGlMb2dpblVzZXJXaXRoVG9rZW4sXG4gIGNhbGxBcGlOZXdVc2VyV2l0aFRva2VuLFxufSBmcm9tICcuLi9hcGknXG5pbXBvcnQgT3JlSWRDb250ZXh0IGZyb20gJy4uL2NvcmUvSU9yZWlkQ29udGV4dCdcbmltcG9ydCB7IGdldE9yZUlkQXV0aFVybCB9IGZyb20gJy4uL2NvcmUvdXJsR2VuZXJhdG9ycydcbmltcG9ydCBUcmFuc2l0SGVscGVyIGZyb20gJy4uL3RyYW5zaXQvVHJhbnNpdEhlbHBlcidcbmltcG9ydCBVYWxIZWxwZXIgZnJvbSAnLi4vdWFsL1VhbEhlbHBlcidcbmltcG9ydCB7IFVzZXIgfSBmcm9tICcuLi91c2VyL3VzZXInXG5pbXBvcnQgSGVscGVycyBmcm9tICcuLi91dGlscy9oZWxwZXJzJ1xuaW1wb3J0IExvY2FsU3RhdGUgZnJvbSAnLi4vdXRpbHMvbG9jYWxTdGF0ZSdcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi91dGlscy9vYnNlcnZhYmxlJ1xuaW1wb3J0IHsgQWNjZXNzVG9rZW5IZWxwZXIgfSBmcm9tICcuL2FjY2Vzc1Rva2VuSGVscGVyJ1xuaW1wb3J0IHsgQXV0aFJlc3VsdCwgTG9naW5XaXRoT3JlSWRSZXN1bHQgfSBmcm9tICcuLi9jb3JlL21vZGVscydcbmltcG9ydCB7IExvZ2luT3B0aW9ucywgTG9naW5XaXRoVG9rZW5PcHRpb25zLCBMb2dpbldpdGhXYWxsZXRPcHRpb25zLCBOZXdVc2VyV2l0aFRva2VuT3B0aW9ucyB9IGZyb20gJy4vbW9kZWxzJ1xuXG5leHBvcnQgdHlwZSBTdWJzY3JpYmVyQXV0aCA9IChhdXRoOiBBdXRoKSA9PiB2b2lkXG5cbmV4cG9ydCBjbGFzcyBBdXRoIGV4dGVuZHMgT2JzZXJ2YWJsZTxTdWJzY3JpYmVyQXV0aD4ge1xuICBjb25zdHJ1Y3RvcihhcmdzOiB7IG9yZUlkQ29udGV4dDogT3JlSWRDb250ZXh0IH0pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fb3JlSWRDb250ZXh0ID0gYXJncy5vcmVJZENvbnRleHRcbiAgICB0aGlzLl9sb2NhbFN0YXRlID0gdGhpcy5fb3JlSWRDb250ZXh0LmxvY2FsU3RhdGVcbiAgICB0aGlzLl90cmFuc2l0SGVscGVyID0gbmV3IFRyYW5zaXRIZWxwZXIoeyBvcmVJZENvbnRleHQ6IHRoaXMuX29yZUlkQ29udGV4dCwgdXNlcjogdGhpcy5fdXNlciB9KVxuICAgIHRoaXMuX3VhbEhlbHBlciA9IG5ldyBVYWxIZWxwZXIoeyBvcmVJZENvbnRleHQ6IHRoaXMuX29yZUlkQ29udGV4dCwgdXNlcjogdGhpcy5fdXNlciB9KVxuICAgIHRoaXMuaW5pdEFjY2Vzc1Rva2VuSGVscGVyKClcbiAgfVxuXG4gIHByaXZhdGUgX2FjY2Vzc1Rva2VuSGVscGVyOiBBY2Nlc3NUb2tlbkhlbHBlclxuXG4gIHByaXZhdGUgX2xvY2FsU3RhdGU6IExvY2FsU3RhdGVcblxuICBwcml2YXRlIF9vcmVJZENvbnRleHQ6IE9yZUlkQ29udGV4dFxuXG4gIHByaXZhdGUgX3RyYW5zaXRIZWxwZXI6IFRyYW5zaXRIZWxwZXJcblxuICBwcml2YXRlIF91YWxIZWxwZXI6IFVhbEhlbHBlclxuXG4gIHByaXZhdGUgX3VzZXI6IFVzZXJcblxuICAvKiogVXNlcidzIE9yZUlEIChhY2NvdW50TmFtZSkgKi9cbiAgZ2V0IGFjY2Vzc1Rva2VuSGVscGVyKCk6IEFjY2Vzc1Rva2VuSGVscGVyIHtcbiAgICByZXR1cm4gdGhpcy5fYWNjZXNzVG9rZW5IZWxwZXJcbiAgfVxuXG4gIHByaXZhdGUgaW5pdEFjY2Vzc1Rva2VuSGVscGVyKCkge1xuICAgIHRoaXMuX2FjY2Vzc1Rva2VuSGVscGVyID0gbmV3IEFjY2Vzc1Rva2VuSGVscGVyKClcbiAgICBjb25zdCBzYXZlZFRva2VuID0gdGhpcy5fbG9jYWxTdGF0ZT8uYWNjZXNzVG9rZW5cbiAgICB0aGlzLmFjY2Vzc1Rva2VuID0gc2F2ZWRUb2tlblxuICAgIHRoaXMuc2F2ZUFjY2Vzc1Rva2VuQW5kTm90aWZ5U3Vic2NyaWJlcnMoc2F2ZWRUb2tlbikgLy8gaWYgc2F2ZWRUb2tlbiBpcyBleHBpcmVkLCBpdCB3aWxsIGJlIG5vdCBzZXQgaGVyZVxuICAgIC8vIGxpc3RlbiBmb3IgZnV0dXJlIGNoYW5nZXMgdG8gYWNjZXNzVG9rZW5IZWxwZXJcbiAgICB0aGlzLl9hY2Nlc3NUb2tlbkhlbHBlci5zdWJzY3JpYmUodGhpcy5vblVwZGF0ZUFjY2Vzc1Rva2VuSGVscGVyKVxuICB9XG5cbiAgLyoqIFVzZXIncyBPcmVJRCAoYWNjb3VudE5hbWUpICovXG4gIGdldCBhY2NvdW50TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9hY2Nlc3NUb2tlbkhlbHBlcj8uYWNjZXNzVG9rZW4gPyB0aGlzLl9hY2Nlc3NUb2tlbkhlbHBlcj8uYWNjb3VudE5hbWUgOiBudWxsXG4gIH1cblxuICBnZXQgaWRUb2tlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYWNjZXNzVG9rZW5IZWxwZXI/LmlkVG9rZW5cbiAgfVxuXG4gIC8qKiByZXRyaWV2ZSBhY2Nlc3NUb2tlbiBzYXZlZCBpbiBsb2NhbCBzdG9yYWdlIC0gaXMgYXV0b21hdGljYWxseSBkZWxldGVkIHdoZW4gdG9rZW4gZXhwaXJlcyAqL1xuICBnZXQgYWNjZXNzVG9rZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjY2Vzc1Rva2VuSGVscGVyPy5hY2Nlc3NUb2tlblxuICB9XG5cbiAgLyoqIFNldHMgdGhlIGFjY2VzcyB0b2tlbiBpbiBsb2NhbCBzdG9yYWdlIChhbmQgaW4gYWNjZXNzVG9rZW5IZWxwZXIpXG4gICAqIHRoaXMgdG9rZW4gd2lsbCBiZSB1c2VkIHRvIGNhbGwgT1JFIElEIEFQSXMgKG9uIGJlaGFsZiBvZiB0aGUgdXNlcilcbiAgICogVGhpcyB0b2tlbiBpcyB1c2VyLXNwZWNpZmljIC0gY2FsbCBsb2dvdXQgdG8gY2xlYXIgaXQgdXBvbiB1c2VyIGxvZy1vdXRcbiAgICogV2hlbiB0aGUgYWNjZXNzVG9rZW4gdG9rZW4gZXhwaXJlcywgaXQgd2lsbCBiZSBkZWxldGVkIGZyb20gbG9jYWwgc3RvcmFnZSBhbmQgdXNlciB3aWxsIGJlIGNsZWFyZWRcbiAgICovXG4gIHNldCBhY2Nlc3NUb2tlbihhY2Nlc3NUb2tlbjogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGRlY29kZXMgYW5kIHZhbGlkYXRlcyBhY2Nlc3NUb2tlbiBpcyBhIHZhbGlkIHRva2VuXG4gICAgICAvLyBpZiBpbmNvbWluZyB0b2tlbiBoYXMgZXhwaXJlZCwgX2FjY2Vzc1Rva2VuSGVscGVyIHdpbGwgdGhyb3cgKGFuZCB0b2tlbiB3b250IGJlIHNhdmVkKVxuICAgICAgdGhpcy5fYWNjZXNzVG9rZW5IZWxwZXIuc2V0QWNjZXNzVG9rZW4oYWNjZXNzVG9rZW4pXG4gICAgICAvLyBOT1RFOiBXZSBkb250IHNhdmUgdGhlIGFjY2VzcyB0b2tlbiB0byBsb2NhbCBzdG9yYWdlIGhlcmUgYXMgdGhhdCB3aWxsIGhhcHBlbiB3aGVuIG9uVXBkYXRlQWNjZXNzVG9rZW5IZWxwZXIgaXMgY2FsbGVkXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdDYW50IHNldCBhY2Nlc3NUb2tlbi4nLCBlcnJvci5tZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIC8qKiBzZXQgcHJpdmF0ZSB2YXJpYWJsZSBhbmQgc2F2ZSB0byBsb2NhbFN0YXRlXG4gICAqIE5PVEU6IFRoaXMgaXMgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhpcy5fYWNjZXNzVG9rZW5IZWxwZXIuYWNjZXNzVG9rZW4gY2hhbmdlcyAob3IgZXhwaXJlcylcbiAgICovXG4gIHByaXZhdGUgc2F2ZUFjY2Vzc1Rva2VuQW5kTm90aWZ5U3Vic2NyaWJlcnMoYWNjZXNzVG9rZW46IHN0cmluZykge1xuICAgIGlmICh0aGlzLl9sb2NhbFN0YXRlPy5hY2Nlc3NUb2tlbiAhPT0gYWNjZXNzVG9rZW4pIHtcbiAgICAgIHRoaXMuX2xvY2FsU3RhdGUuc2F2ZUFjY2Vzc1Rva2VuKGFjY2Vzc1Rva2VuKVxuICAgICAgdGhpcy5fdXNlciA9IG51bGxcbiAgICB9XG4gICAgc3VwZXIuY2FsbFN1YnNjcmliZXJzKClcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHVzZXIgb2JqZWN0IG1hdGNoaW5nIGN1cnJlbnQgYWNjZXNzVG9rZW5cbiAgICogIEEgbmV3bHkgY3JlYXRlZCBvYmplY3Qgb2JqZWN0IHdvbid0IGhhdmUgdXNlci5pbmZvIHBvcHVsYXRlZCwgY2FsbCB1c2VyLmdldERhdGEoKSB0byByZXRyaWV2ZVxuICAgKi9cbiAgZ2V0IHVzZXIoKSB7XG4gICAgaWYgKCF0aGlzLl91c2VyKSB7XG4gICAgICB0aGlzLl91c2VyID0gbmV3IFVzZXIoe1xuICAgICAgICBvcmVJZENvbnRleHQ6IHRoaXMuX29yZUlkQ29udGV4dCxcbiAgICAgICAgYWNjZXNzVG9rZW5IZWxwZXI6IHRoaXMuX2FjY2Vzc1Rva2VuSGVscGVyLCAvLyBhY2Nlc3NUb2tlbiBoZWxwZXJcbiAgICAgICAgYWNjb3VudE5hbWU6IHRoaXMuYWNjb3VudE5hbWUsIC8vIGFjY291bnROYW1lXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdXNlclxuICB9XG5cbiAgLyoqIFdlIGhhdmUgYSB2YWxpZCBhY2Nlc3MgdG9rZW4gZm9yIHRoZSBjdXJyZW50IHVzZXIgKi9cbiAgZ2V0IGlzTG9nZ2VkSW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5hY2Nlc3NUb2tlblxuICB9XG5cbiAgLyoqIHJ1bnMgd2hlbiBhY2Nlc3NUb2tlbkhlbHBlciBjaGFuZ2VzICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcHJpdmF0ZSBvblVwZGF0ZUFjY2Vzc1Rva2VuSGVscGVyID0gKG5ld0FjY2Vzc1Rva2VuSGVscGVyOiBBY2Nlc3NUb2tlbkhlbHBlcikgPT4ge1xuICAgIC8vIHNhdmUgbmV3IGFjY2VzcyB0b2tlblxuICAgIHRoaXMuc2F2ZUFjY2Vzc1Rva2VuQW5kTm90aWZ5U3Vic2NyaWJlcnModGhpcy5fYWNjZXNzVG9rZW5IZWxwZXIuYWNjZXNzVG9rZW4pXG4gIH1cblxuICBwcml2YXRlIGNsZWFyQWNjZXNzVG9rZW4oKSB7XG4gICAgLy8gY2xlYXIgYWNjZXNzVG9rZW4gYW5kIHVzZXJcbiAgICB0aGlzLl9sb2NhbFN0YXRlLmNsZWFyQWNjZXNzVG9rZW4oKVxuICAgIHRoaXMuX2FjY2Vzc1Rva2VuSGVscGVyLmNsZWFyQWNjZXNzVG9rZW4oKVxuICAgIHN1cGVyLmNhbGxTdWJzY3JpYmVycygpXG4gIH1cblxuICAvKiogQ2FsbHMgdGhlICdjb25uZWN0JyBmdW5jdGlvbiBvbiBhIGV4dGVybmFsIHdhbGxldCAoZS5nLiBNZXRhbWFzaylcbiAgICogIEZvciBtb3N0LCBob3dldmVyLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGNoYWluQWNjb3VudCBzZWxlY3RlZCBieSB0aGUgdXNlciBpbiB0aGUgd2FsbGV0IGFwcFxuICAgKiAgRGlmZmVyZW50IHdhbGxldHMgaGF2ZSBkaWZmZXJlbnQgYmVoYXZpb3IuIFNvbWUgZG8gbm90IHN1cHBvcnQgdGhpcyBmZWF0dXJlLiAqL1xuICBhc3luYyBjb25uZWN0V2l0aFdhbGxldChsb2dpbk9wdGlvbnM6IExvZ2luV2l0aFdhbGxldE9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHdhbGxldFR5cGUgfSA9IGxvZ2luT3B0aW9uc1xuXG4gICAgaWYgKCF0aGlzLl9vcmVJZENvbnRleHQud2FsbGV0SGVscGVyLmlzQVZhbGlkRXh0ZXJuYWxXYWxsZXRUeXBlKHdhbGxldFR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZ2luV2l0aFdhbGxldCBub3Qgc3VwcG9ydGVkIGZvciBleHRlcm5hbCB3YWxsZXQgdHlwZTogJHt3YWxsZXRUeXBlfWApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdFRvV2FsbGV0UHJvdmlkZXIobG9naW5PcHRpb25zKVxuICB9XG5cbiAgLyoqIENvbm5lY3QgdG8gdGhlIHdhbGxldCBwcm92aWRlclxuICAgKiAgRm9yIHNvbWUgd2FsbGV0IHR5cGVzLCB0aGlzIHdpbGwgaW5jbHVkZSBhbiB1bmxvY2sgYW5kICdsb2dpbicgZmxvdyB0byBzZWxlY3QgYSBjaGFpbiBhY2NvdW50XG4gICAqICBJZiBhIGNoYWluQWNjb3VudCBpcyBzZWxlY3RlZCwgaXQgYW5kIGl0J3MgYXNzb2NpYXRlZCBwdWJsaWNLZXkgKGlmIGF2YWlsYWJsZSkgd2lsbCBiZSBzYXZlZCB0byB0aGUgdXNlcidzIE9yZUlkIHdhbGxldCBhcyBhbiAnZXh0ZXJuYWwga2V5JyAqL1xuICBwcml2YXRlIGFzeW5jIGNvbm5lY3RUb1dhbGxldFByb3ZpZGVyKGxvZ2luT3B0aW9uczogTG9naW5XaXRoV2FsbGV0T3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9vcmVJZENvbnRleHQud2FsbGV0SGVscGVyLmNvbm5lY3RUb1dhbGxldFByb3ZpZGVyKGxvZ2luT3B0aW9ucylcbiAgfVxuXG4gIC8qKiBDYWxscyB0aGUgYWNjb3VudC9jb252ZXJ0LW9hdXRoIGFwaVxuICAgKiBDb252ZXJ0cyBPQXV0aCB0b2tlbnMgZnJvbSBzb21lIDNyZC1wYXJ0eSBzb3VyY2UgdG8gT1JFSUQgT2F1dGggdG9rZW5zXG4gICAqIFRoZSB0aGlyZC1wYXJ0eSAoZS5nLiBBdXRoMCBvciBHb29nbGUpIG11c3QgYmUgcmVnaXN0ZXJlZCBpbiB0aGUgQXBwUmVnaXN0cmF0aW9uLm9hdXRoU2V0dGluZ3NcbiAgICogUmV0dXJuczogT3JlSWQgaXNzdWVkIGFjY2Vzc1Rva2VuIGFuZCBpZFRva2VuXG4gICAqICovXG4gIHByaXZhdGUgYXN5bmMgY29udmVydE9hdXRoVG9rZW5zKHBhcm1zOiBBcGlDb252ZXJ0T2F1dGhUb2tlbnNQYXJhbXMpIHtcbiAgICByZXR1cm4gY2FsbEFwaUNvbnZlcnRPYXV0aFRva2Vucyh0aGlzLl9vcmVJZENvbnRleHQsIHBhcm1zKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIE9BdXRoIGFjY2Vzc1Rva2VuIG9yIGlkVG9rZW4gZnJvbSBzb21lIDNyZC1wYXJ0eSBzb3VyY2UgKGUuZy4gR29vZ2xlKSB0byBPcmVJZCBPQXV0aCBhY2Nlc3NUb2tlblxuICAgKiBUaGUgdGhpcmQtcGFydHkgKGUuZy4gQXV0aDAgb3IgR29vZ2xlKSBtdXN0IGJlIHJlZ2lzdGVyZWQgaW4gdGhlIEFwcCBSZWdpc3RyYXRpb24ncyBvYXV0aFNldHRpbmdzXG4gICAqIElmIGEgdXNlciBkb2VzIG5vdCBjdXJlbnRseSBleGlzdCB0aGF0IG1hdGNoZXMgdGhlIGluZm8gaW4gdGhlIGluY29taW5nIGlkVG9rZW4sIGFuIGVycm9yIGlzIHRocm93blxuICAgKiBEb2VzIG5vdCByZXF1aXJlcyBhIHVzZXIgdG8gYmUgbG9nZ2VkLWluIChubyBjdXJyZW50IGFjY2Vzc1Rva2VuKSBvciBhcGlLZXlcbiAgICogUmV0dXJuczogT3JlSWQgaXNzdWVkIGFjY2Vzc1Rva2VuXG4gICAqICovXG4gIGFzeW5jIGxvZ2luV2l0aFRva2VuKGxvZ2luT3B0aW9uczogTG9naW5XaXRoVG9rZW5PcHRpb25zKTogUHJvbWlzZTxMb2dpbldpdGhPcmVJZFJlc3VsdD4ge1xuICAgIGlmICghbG9naW5PcHRpb25zPy5pZFRva2VuICYmICFsb2dpbk9wdGlvbnM/LmFjY2Vzc1Rva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbnQgbG9naW5XaXRoVG9rZW4gLSBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogYWNjZXNzVG9rZW4gT1IgaWRUb2tlbicpXG4gICAgfVxuICAgIGNvbnN0IHsgYWNjZXNzVG9rZW4sIGVycm9yLCBwcm9jZXNzSWQgfSA9IGF3YWl0IHRoaXMubG9naW5XaXRoQWNjZXNzT3JJZFRva2VuVG9rZW4obG9naW5PcHRpb25zKVxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbiAvLyBzYXZlcyBpbiBjYWNoZSBhbmQgaW4gbG9jYWwgc3RvcmFnZVxuICAgICAgYXdhaXQgdGhpcy51c2VyLmdldERhdGEoKVxuICAgIH1cbiAgICByZXR1cm4geyBhY2Nlc3NUb2tlbiwgZXJyb3JzOiBlcnJvciwgcHJvY2Vzc0lkIH1cbiAgfVxuXG4gIC8qKiBDb252ZXJ0cyBPQXV0aCBpZFRva2VuIGZyb20gc29tZSAzcmQtcGFydHkgc291cmNlIHRvIE9SRUlEIE9hdXRoIGFjY2Vzc1Rva2Vuc1xuICAgKiBUaGUgdGhpcmQtcGFydHkgKGUuZy4gQXV0aDAgb3IgR29vZ2xlKSBtdXN0IGJlIHJlZ2lzdGVyZWQgaW4gdGhlIEFwcFJlZ2lzdHJhdGlvbi5vYXV0aFNldHRpbmdzXG4gICAqIENyZWF0ZXMgYSBuZXcgT3JlSWQgdXNlciBhbmQgYWNjb3VudCBmcm9tIGluZm8gaW4gdGhlIGluY29taW5nIGlkVG9rZW5cbiAgICogSWYgYSBtYXRjaGluZyB1c2VyIGFscmVhZHkgZXhpc3QsIGFuZCBlcnJvciBpcyByZXR1cm5lZFxuICAgKiBSZXF1aXJlcyBhIHZhbGlkIGlkVG9rZW4gYnV0IG5vIGN1cnJlbnQgYWNjZXNzVG9rZW4gb3IgYXBpS2V5XG4gICAqIFJldHVybnM6IE9yZUlkIGlzc3VlZCBhY2Nlc3NUb2tlblxuICAgKiAqL1xuICBhc3luYyBuZXdVc2VyV2l0aFRva2VuKHVzZXJPcHRpb25zOiBOZXdVc2VyV2l0aFRva2VuT3B0aW9ucyk6IFByb21pc2U8TG9naW5XaXRoT3JlSWRSZXN1bHQ+IHtcbiAgICBjb25zdCB7IGFjY2Vzc1Rva2VuLCBlcnJvciwgcHJvY2Vzc0lkIH0gPSBhd2FpdCB0aGlzLm5ld0FjY291bnRXaXRoSWRUb2tlbih1c2VyT3B0aW9ucylcbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4gLy8gc2F2ZXMgaW4gY2FjaGUgYW5kIGluIGxvY2FsIHN0b3JhZ2VcbiAgICAgIGF3YWl0IHRoaXMudXNlci5nZXREYXRhKClcbiAgICB9XG4gICAgcmV0dXJuIHsgYWNjZXNzVG9rZW4sIGVycm9yczogZXJyb3IsIHByb2Nlc3NJZCB9XG4gIH1cblxuICAvKiogQ2FsbHMgYXBpIGFjY291bnQvbG9naW4tdXNlci13aXRoLXRva2VuIGZvciBsb2dpbldpdGhUb2tlbigpIChhZnRlciBjaGVja2luZyBmb3IgdmFsaWQgdG9rZW4gKi9cbiAgc3RhdGljIGNoZWNrSnd0VG9rZW5BbmRSZXR1cm5FcnJvcihqd3RUb2tlblN0cmluZzogc3RyaW5nKTogeyBlcnJvcj86IHN0cmluZzsgbWVzc2FnZT86IHN0cmluZyB9IHtcbiAgICB0cnkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgY29uc3QgYWNjZXNzVG9rZW5IZWxwZXIgPSBuZXcgQWNjZXNzVG9rZW5IZWxwZXIoand0VG9rZW5TdHJpbmcsIHRydWUpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiAndG9rZW5faW52YWxpZCcsXG4gICAgICAgIG1lc3NhZ2U6ICd0b2tlbiBpbnZhbGlkIG9yIGNvcnJ1cHQgLSBtdXN0IGJlIGEgSldUIE9hdXRoMiB0b2tlbicsXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKiBDYWxscyBhcGkgYWNjb3VudC9sb2dpbi11c2VyLXdpdGgtdG9rZW4gZm9yIGxvZ2luV2l0aFRva2VuKCkgKGFmdGVyIGNoZWNraW5nIGZvciB2YWxpZCB0b2tlbiAqL1xuICBwcml2YXRlIGFzeW5jIGxvZ2luV2l0aEFjY2Vzc09ySWRUb2tlblRva2VuKFxuICAgIHBhcmFtczogQXBpTG9naW5Vc2VyV2l0aFRva2VuUGFyYW1zLFxuICApOiBQcm9taXNlPHsgYWNjZXNzVG9rZW46IHN0cmluZyB9ICYgQXBpTWVzc2FnZVJlc3VsdD4ge1xuICAgIGNvbnN0IHsgYWNjZXNzVG9rZW4sIGlkVG9rZW4gfSA9IHBhcmFtc1xuICAgIGxldCB0b2tlbkNoZWNrRXJyb3JcblxuICAgIC8vIGNoZWNrIHZhbGlkIEpXVCB0b2tlbnMgKE5vdGU6IGFjY2Vzc1Rva2VuIGNhbiBiZSBhIEpXVCBvciBub3QpXG4gICAgaWYgKGFjY2Vzc1Rva2VuICYmIEhlbHBlcnMuand0RGVjb2RlU2FmZShhY2Nlc3NUb2tlbikpIHtcbiAgICAgIHRva2VuQ2hlY2tFcnJvciA9IGFjY2Vzc1Rva2VuID8gQXV0aC5jaGVja0p3dFRva2VuQW5kUmV0dXJuRXJyb3IoYWNjZXNzVG9rZW4pIDogbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICB0b2tlbkNoZWNrRXJyb3IgPSBpZFRva2VuID8gQXV0aC5jaGVja0p3dFRva2VuQW5kUmV0dXJuRXJyb3IoaWRUb2tlbikgOiBudWxsXG4gICAgfVxuXG4gICAgaWYgKHRva2VuQ2hlY2tFcnJvcikgcmV0dXJuIHsgYWNjZXNzVG9rZW46IG51bGwsIC4uLnRva2VuQ2hlY2tFcnJvciB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhbGxBcGlMb2dpblVzZXJXaXRoVG9rZW4odGhpcy5fb3JlSWRDb250ZXh0LCBwYXJhbXMpXG4gICAgaWYgKCFyZXNwb25zZT8uZXJyb3JDb2RlKSB7XG4gICAgICB0aGlzLnNldEF1dGhSZXN1bHQoeyBhY2Nlc3NUb2tlbjogcmVzcG9uc2U/LmFjY2Vzc1Rva2VuIH0pXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhY2Nlc3NUb2tlbjogcmVzcG9uc2UuYWNjZXNzVG9rZW4sXG4gICAgICBlcnJvcjogcmVzcG9uc2U/LmVycm9yQ29kZSxcbiAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlPy5lcnJvck1lc3NhZ2UsXG4gICAgICBwcm9jZXNzSWQ6IHJlc3BvbnNlPy5wcm9jZXNzSWQsXG4gICAgfVxuICB9XG5cbiAgLyoqIENhbGxzIGFwaSBhY2NvdW50L25ldy11c2VyLXdpdGgtdG9rZW4gZm9yIG5ld1VzZXJXaXRoVG9rZW4oKSAoYWZ0ZXIgY2hlY2tpbmcgZm9yIHZhbGlkIHRva2VuICovXG4gIHByaXZhdGUgYXN5bmMgbmV3QWNjb3VudFdpdGhJZFRva2VuKFxuICAgIHBhcmFtczogQXBpTmV3VXNlcldpdGhUb2tlblBhcmFtcyxcbiAgKTogUHJvbWlzZTx7IGFjY2Vzc1Rva2VuOiBzdHJpbmcgfSAmIEFwaU1lc3NhZ2VSZXN1bHQ+IHtcbiAgICBjb25zdCB7IGlkVG9rZW4gfSA9IHBhcmFtc1xuICAgIC8vIGNoZWNrIHZhbGlkIGlmVG9rZW5cbiAgICBjb25zdCBpZFRva2VuQ2hlY2tFcnJvciA9IGlkVG9rZW4gPyBBdXRoLmNoZWNrSnd0VG9rZW5BbmRSZXR1cm5FcnJvcihpZFRva2VuKSA6IG51bGxcbiAgICBpZiAoaWRUb2tlbkNoZWNrRXJyb3IpIHJldHVybiB7IGFjY2Vzc1Rva2VuOiBudWxsLCAuLi5pZFRva2VuQ2hlY2tFcnJvciB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhbGxBcGlOZXdVc2VyV2l0aFRva2VuKHRoaXMuX29yZUlkQ29udGV4dCwgcGFyYW1zKVxuICAgIGlmICghcmVzcG9uc2U/LmVycm9yQ29kZSkge1xuICAgICAgdGhpcy5zZXRBdXRoUmVzdWx0KHsgYWNjZXNzVG9rZW46IHJlc3BvbnNlPy5hY2Nlc3NUb2tlbiB9KVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYWNjZXNzVG9rZW46IHJlc3BvbnNlLmFjY2Vzc1Rva2VuLFxuICAgICAgZXJyb3I6IHJlc3BvbnNlPy5lcnJvckNvZGUsXG4gICAgICBtZXNzYWdlOiByZXNwb25zZT8uZXJyb3JNZXNzYWdlLFxuICAgICAgcHJvY2Vzc0lkOiByZXNwb25zZT8ucHJvY2Vzc0lkLFxuICAgIH1cbiAgfVxuXG4gIC8qKiBjbGVhciBhY2Nlc3NUb2tlbiBhbmQgdXNlciAqL1xuICBsb2dvdXQoKSB7XG4gICAgdGhpcy5jbGVhckFjY2Vzc1Rva2VuKClcbiAgICB0aGlzLl91c2VyID0gbnVsbFxuICB9XG5cbiAgLyoqIFJldHVybnMgYSBmdWxseSBmb3JtZWQgdXJsIHRvIHJlZGlyZWN0IHRoZSB1c2VyJ3MgYnJvd3NlciB0byBsb2dpbiB1c2luZyBPUkUgSURcbiAgICogIFRoaXMgZnVuY3Rpb24gY2FsbHMgdGhlIC9hdXRoIHdlYiBlbmRwb2ludFxuICAgKiAgUmV0dXJuczogQ2FsbGJhY2sgcmV0dXJucyBhY2NvdW50LCBhbmQgb3B0aW9uYWxseSBhY2Nlc3NUb2tlbiBhbmQvb3IgaWRUb2tlbiBmb3IgdXNlciAqL1xuICBhc3luYyBnZXRMb2dpblVybChsb2dpbk9wdGlvbnM6IExvZ2luT3B0aW9ucyk6IFByb21pc2U8TG9naW5XaXRoT3JlSWRSZXN1bHQ+IHtcbiAgICBjb25zdCB7IGNvZGUsIGVtYWlsLCBpZFRva2VuLCBwaG9uZSwgcHJvdmlkZXIsIHN0YXRlLCBsaW5rVG9BY2NvdW50LCByZXR1cm5BY2Nlc3NUb2tlbiwgcmV0dXJuSWRUb2tlbiB9ID1cbiAgICAgIGxvZ2luT3B0aW9ucyB8fCB7fVxuICAgIGNvbnN0IHsgYXV0aENhbGxiYWNrVXJsLCBiYWNrZ3JvdW5kQ29sb3IgfSA9IHRoaXMuX29yZUlkQ29udGV4dC5vcHRpb25zXG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIGNvZGUsXG4gICAgICBlbWFpbCxcbiAgICAgIGlkVG9rZW4sXG4gICAgICBwaG9uZSxcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgYmFja2dyb3VuZENvbG9yLFxuICAgICAgY2FsbGJhY2tVcmw6IGF1dGhDYWxsYmFja1VybCxcbiAgICAgIHN0YXRlLFxuICAgICAgbGlua1RvQWNjb3VudCxcbiAgICAgIHJldHVybkFjY2Vzc1Rva2VuOiBIZWxwZXJzLmlzTnVsbE9yRW1wdHkocmV0dXJuQWNjZXNzVG9rZW4pID8gdHJ1ZSA6IHJldHVybkFjY2Vzc1Rva2VuLCAvLyBpZiByZXR1cm5BY2Nlc3NUb2tlbiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0IHRvIHRydWVcbiAgICAgIHJldHVybklkVG9rZW4sXG4gICAgfVxuICAgIGNvbnN0IGxvZ2luVXJsID0gYXdhaXQgZ2V0T3JlSWRBdXRoVXJsKHRoaXMuX29yZUlkQ29udGV4dCwgYXJncylcbiAgICByZXR1cm4geyBsb2dpblVybCwgZXJyb3JzOiBudWxsIH1cbiAgfVxuXG4gIC8qKiBFeHRyYWN0cyBhbmQgcmV0dXJucyB0aGUgcmVzcG9uc2UgcGFyYW1ldGVycyBvbiB0aGUgL2F1dGggY2FsbGJhY2sgVVJMIHN0cmluZ1xuICAgKiAgQXBwbGllcyBhY2Nlc3NUb2tlbiBhbmQgaWRUb2tlbiAoaWYgaW5jbHVkZWQgb24gdGhlIHVybCkgdG8gbG9jYWwgc3RhdGVcbiAgICovXG4gIGhhbmRsZUF1dGhDYWxsYmFjayhjYWxsYmFja1VybFN0cmluZzogc3RyaW5nKTogQXV0aFJlc3VsdCB7XG4gICAgLy8gUGFyc2VzIGVycm9yIGNvZGVzIGFuZCByZXR1cm5zIGFuIGVycm9ycyBhcnJheVxuICAgIC8vIChpZiB0aGVyZSBpcyBhbiBlcnJvcl9jb2RlIHBhcmFtIHNlbnQgYmFjayAtIGNhbiBoYXZlIG1vcmUgdGhhbiBvbmUgZXJyb3IgY29kZSAtIHNlcGVyYXRlZCBieSBhIOKAmCbigJkgZGVsaW1ldGVyXG4gICAgY29uc3Qge1xuICAgICAgYWNjZXNzX3Rva2VuOiBhY2Nlc3NUb2tlbixcbiAgICAgIGFjY291bnQsXG4gICAgICBpZF90b2tlbjogaWRUb2tlbixcbiAgICAgIGVycm9ycyxcbiAgICAgIHByb2Nlc3NfaWQ6IHByb2Nlc3NJZCxcbiAgICAgIHN0YXRlLFxuICAgIH0gPSBIZWxwZXJzLmV4dHJhY3REYXRhRnJvbUNhbGxiYWNrVXJsKGNhbGxiYWNrVXJsU3RyaW5nKVxuICAgIGNvbnN0IHJlc3BvbnNlOiBBdXRoUmVzdWx0ID0geyBhY2NvdW50IH1cblxuICAgIGlmIChlcnJvcnMpIHJlc3BvbnNlLmVycm9ycyA9IGVycm9yc1xuICAgIGlmIChwcm9jZXNzSWQpIHJlc3BvbnNlLnByb2Nlc3NJZCA9IHByb2Nlc3NJZFxuICAgIGlmIChzdGF0ZSkgcmVzcG9uc2Uuc3RhdGUgPSBzdGF0ZVxuICAgIGlmIChhY2Nlc3NUb2tlbikgcmVzcG9uc2UuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlblxuICAgIGlmIChpZFRva2VuKSByZXNwb25zZS5pZFRva2VuID0gaWRUb2tlblxuXG4gICAgaWYgKCFlcnJvcnMpIHtcbiAgICAgIHRoaXMuc2V0QXV0aFJlc3VsdChyZXNwb25zZSlcbiAgICB9XG5cbiAgICAvLyBjbGVhciB0aGUgYnVzeSBpbmRpY2F0b3Igbm93IHRoYXQgd2UndmUgZmluc2loZWQgdGhlIGF1dGggZmxvd1xuICAgIHRoaXMuX29yZUlkQ29udGV4dC5zZXRJc0J1c3koZmFsc2UpXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKiogc3RvcmUgcmVzcG9uc2UgZnJvbSBhdXRoIGZsb3cgKGFjY291bnROYW1lLCBhY2Nlc3NUb2tlbiwgaWRUb2tlbikgaW4gbG9jYWxTdGF0ZSAqL1xuICBzZXRBdXRoUmVzdWx0KGF1dGhSZXNwb25zZTogQXV0aFJlc3VsdCkge1xuICAgIGNvbnN0IHsgYWNjZXNzVG9rZW4sIGlkVG9rZW4gfSA9IGF1dGhSZXNwb25zZVxuICAgIGlmICghYWNjZXNzVG9rZW4pIHRocm93IEVycm9yKCdDYW50IHNldEF1dGhSZXN1bHQuIGFjY2Vzc1Rva2VuIGlzIG1pc3NpbmcnKVxuICAgIHRoaXMuX2FjY2Vzc1Rva2VuSGVscGVyLnNldElkVG9rZW4obnVsbCkgLy8gY2xlYXIgdGhlIGV4aXN0aW5nIGlkVG9rZW4gZmlyc3QgKHNvIHNldCBhY2Nlc3NUb2tlbiB3b250IHRocm93IGEgbWlzbWF0Y2ggd2hlbiBzZXQpXG4gICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuIC8vIHNhdmVzIHRoZSB0b2tlbiB0byBsb2NhbHN0b3JhZ2VcbiAgICBpZiAoaWRUb2tlbikge1xuICAgICAgdGhpcy5fYWNjZXNzVG9rZW5IZWxwZXIuc2V0SWRUb2tlbihpZFRva2VuKVxuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9lbmRwb2ludHMnXG5leHBvcnQgKiBmcm9tICcuL2hlbHBlcnMnXG5leHBvcnQgKiBmcm9tICcuL21vZGVscydcbiIsImV4cG9ydCAqIGZyb20gJy4vYWRkUGVybWlzc2lvbidcbmV4cG9ydCAqIGZyb20gJy4vYXBwVG9rZW4nXG5leHBvcnQgKiBmcm9tICcuL2NhbkF1dG9TaWduJ1xuZXhwb3J0ICogZnJvbSAnLi9jb252ZXJ0T2F1dGgnXG5leHBvcnQgKiBmcm9tICcuL2N1c3RvZGlhbE1pZ3JhdGVBY2NvdW50J1xuZXhwb3J0ICogZnJvbSAnLi9jdXN0b2RpYWxOZXdBY2NvdW50J1xuZXhwb3J0ICogZnJvbSAnLi9jdXN0b2RpYWxTaWduU3RyaW5nJ1xuZXhwb3J0ICogZnJvbSAnLi9kZWxldGVUZXN0VXNlcidcbmV4cG9ydCAqIGZyb20gJy4vZ2V0Q29uZmlnJ1xuZXhwb3J0ICogZnJvbSAnLi9nZXRVc2VyJ1xuZXhwb3J0ICogZnJvbSAnLi9sb2dpblVzZXJXaXRoVG9rZW4nXG5leHBvcnQgKiBmcm9tICcuL25ld1VzZXJXaXRoVG9rZW4nXG5leHBvcnQgKiBmcm9tICcuL3Bhc3N3b3JkTGVzc1NlbmRDb2RlJ1xuZXhwb3J0ICogZnJvbSAnLi9wYXNzd29yZExlc3NWZXJpZnlDb2RlJ1xuZXhwb3J0ICogZnJvbSAnLi9zaWduVHJhbnNhY3Rpb24nXG4iLCJpbXBvcnQgT3JlSWRDb250ZXh0IGZyb20gJy4uLy4uL2NvcmUvSU9yZWlkQ29udGV4dCdcbmltcG9ydCB7XG4gIEFjY291bnROYW1lLFxuICBBcGlFbmRwb2ludCxcbiAgQ2hhaW5BY2NvdW50LFxuICBDaGFpbk5ldHdvcmssXG4gIEV4dGVybmFsV2FsbGV0VHlwZSxcbiAgUHVibGljS2V5LFxuICBSZXF1ZXN0VHlwZSxcbn0gZnJvbSAnLi4vLi4vbW9kZWxzJ1xuaW1wb3J0IHsgYXNzZXJ0SGFzQXBpS2V5T3JBY2Nlc3NUb2tlbiwgYXNzZXJ0UGFyYW1zSGF2ZVJlcXVpcmVkVmFsdWVzIH0gZnJvbSAnLi4vaGVscGVycydcbmltcG9ydCB7IEFwaU1lc3NhZ2VSZXN1bHQgfSBmcm9tICcuLi9tb2RlbHMnXG5cbmV4cG9ydCB0eXBlIEFwaUFkZFBlcm1pc3Npb25QYXJhbXMgPSB7XG4gIGFjY291bnQ6IEFjY291bnROYW1lXG4gIGNoYWluQWNjb3VudDogQ2hhaW5BY2NvdW50XG4gIGNoYWluTmV0d29yazogQ2hhaW5OZXR3b3JrXG4gIHBhcmVudFBlcm1pc3Npb24/OiBQZXJtaXNzaW9uTmFtZVxuICBwZXJtaXNzaW9uOiBQZXJtaXNzaW9uTmFtZVxuICBwcm92aWRlcj86IEV4dGVybmFsV2FsbGV0VHlwZVxuICBwdWJsaWNLZXk6IFB1YmxpY0tleVxufVxuXG4vKipcbiAqICBDYWxsIGFwaSBhY2NvdW50L2FkZFBlcm1pc3Npb25cbiAqICBBZGRzIGEgcHVibGljIGtleSB0byBhIHVzZXIgYWNjb3VudCB3aXRoIGEgc3BlY2lmaWMgcGVybWlzc2lvbiBuYW1lXG4gKiBUaGUgcGVybWlzc2lvbiBuYW1lIG11c3QgYmUgb25lIGRlZmluZWQgaW4gdGhlIEFwcCBSZWdpc3RyYXRpb24gcmVjb3JkIChXaGljaCBkZWZpbmVzIGl0cyBwYXJlbnQgcGVybWlzc2lvbiBhcyB3ZWxsIGFzIHByZXZlbnRpbmcgYWRkaW5nIHJvdWd1ZSBwZXJtaXNzaW9ucylcbiAqIFRoaXMgZmVhdHVyZSBhbGxvd3MgeW91ciBhcHAgdG8gaG9sZCBwcml2YXRlIGtleXMgbG9jYWxseSAoZm9yIGNlcnRhaW4gYWN0aW9ucyBlbmFibGVkIGJ5IHRoZSBwZXJtaXNzaW9uKSB3aGlsZSBoYXZpbmcgdGhlIGFzc29jaWF0ZWQgcHVibGljIGtleSBpbiB0aGUgdXNlcidzIGFjY291bnRcbiAqIGNoYWluQWNjb3VudCA9IG5hbWUgb2YgdGhlIGFjY291bnQgb24gdGhlIGNoYWluIC0gMTIvMTMtZGlnaXQgc3RyaW5nIG9uIEVPUyBhbmQgRXRoZXJldW0gQWRkcmVzcyBvbiBFVEggLSBpdCBtYXkgYmUgdGhlIHNhbWUgYXMgdGhlIGFjY291bnRcbiAqIGNoYWluTmV0d29yayA9IG9uZSBvZiB0aGUgdmFsaWQgb3B0aW9ucyBkZWZpbmVkIGJ5IHRoZSBzeXN0ZW0gLSBFeDogJ2Vvc19tYWluJywgJ2Vvc19qdW5nbGUnLCAnZW9zX2t5bGluXCIsICdvcmVfbWFpbicsICdlb3NfdGVzdCcsIGV0Yy5cbiAqICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbEFwaUFkZFBlcm1pc3Npb24oXG4gIG9yZUlkQ29udGV4dDogT3JlSWRDb250ZXh0LFxuICBwYXJhbXM6IEFwaUFkZFBlcm1pc3Npb25QYXJhbXMsXG4pOiBQcm9taXNlPEFwaU1lc3NhZ2VSZXN1bHQ+IHtcbiAgY29uc3QgYXBpTmFtZSA9IEFwaUVuZHBvaW50LkFkZFBlcm1pc3Npb25cblxuICBhc3NlcnRIYXNBcGlLZXlPckFjY2Vzc1Rva2VuKG9yZUlkQ29udGV4dCwgYXBpTmFtZSlcbiAgYXNzZXJ0UGFyYW1zSGF2ZVJlcXVpcmVkVmFsdWVzKFxuICAgIHBhcmFtcyxcbiAgICBbJ2FjY291bnQnLCAnY2hhaW5BY2NvdW50JywgJ2NoYWluTmV0d29yaycsICdwZXJtaXNzaW9uJywgJ3B1YmxpY0tleSddLFxuICAgIGFwaU5hbWUsXG4gIClcblxuICBjb25zdCB7IGFjY291bnQsIHBlcm1pc3Npb24sIHByb3ZpZGVyLCBwYXJlbnRQZXJtaXNzaW9uIH0gPSBwYXJhbXNcblxuICBjb25zdCBvcHRpb25hbFBhcmFtczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9XG4gIGlmIChwcm92aWRlcikgb3B0aW9uYWxQYXJhbXNbJ3dhbGxldC10eXBlJ10gPSBwcm92aWRlclxuICBpZiAocGFyZW50UGVybWlzc2lvbikgb3B0aW9uYWxQYXJhbXNbJ3BhcmVudC1wZXJtaXNzaW9uJ10gPSBwYXJlbnRQZXJtaXNzaW9uXG5cbiAgY29uc3QgcXVlcnlQYXJhbXMgPSB7XG4gICAgYWNjb3VudCxcbiAgICAnY2hhaW4tYWNjb3VudCc6IHBhcmFtcy5jaGFpbkFjY291bnQsXG4gICAgJ2NoYWluLW5ldHdvcmsnOiBwYXJhbXMuY2hhaW5OZXR3b3JrLFxuICAgICdwdWJsaWMta2V5JzogcGFyYW1zLnB1YmxpY0tleSxcbiAgICBwZXJtaXNzaW9uLFxuICAgIC4uLm9wdGlvbmFsUGFyYW1zLFxuICB9XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvcmVJZENvbnRleHQuY2FsbE9yZUlkQXBpKFJlcXVlc3RUeXBlLkdldCwgQXBpRW5kcG9pbnQuQWRkUGVybWlzc2lvbiwgcXVlcnlQYXJhbXMsIG51bGwpXG4gIHJldHVybiByZXNwb25zZSBhcyBBcGlNZXNzYWdlUmVzdWx0XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL2FwaS9tb2RlbHMnXG5leHBvcnQgKiBmcm9tICcuL2F1dGgvbW9kZWxzJ1xuZXhwb3J0ICogZnJvbSAnLi9jb21tb24vbW9kZWxzJ1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL21vZGVscydcbmV4cG9ydCAqIGZyb20gJy4vdXNlci9tb2RlbHMnXG5leHBvcnQgKiBmcm9tICcuL3RyYW5zYWN0aW9uL21vZGVscydcbmV4cG9ydCAqIGZyb20gJy4vdHJhbnNpdC9tb2RlbHMnXG5leHBvcnQgKiBmcm9tICcuL3VhbC9tb2RlbHMnXG5leHBvcnQgKiBmcm9tICcuL3dhbGxldHMvbW9kZWxzJ1xuZXhwb3J0ICogZnJvbSAnLi93ZWJXaWRnZXQvbW9kZWxzJ1xuIiwiaW1wb3J0IHsgQWNjb3VudE5hbWUsIEFjY291bnRUeXBlLCBDaGFpbkFjY291bnQsIENoYWluTmV0d29yayB9IGZyb20gJy4uL2NvbW1vbi9tb2RlbHMnXG5cbmV4cG9ydCBlbnVtIFJlcXVlc3RUeXBlIHtcbiAgR2V0ID0gJ2dldCcsXG4gIFBvc3QgPSAncHV0Jyxcbn1cblxuZXhwb3J0IGVudW0gQXBpRW5kcG9pbnQge1xuICBBZGRQZXJtaXNzaW9uID0gJ2FjY291bnQvYWRkLXBlcm1pc3Npb24nLFxuICBBcHBUb2tlbiA9ICdhcHAtdG9rZW4nLFxuICBDYW5BdXRvU2lnbiA9ICd0cmFuc2FjdGlvbi9jYW4tYXV0by1zaWduJyxcbiAgQ29udmVydE9hdXRoVG9rZW5zID0gJ2FjY291bnQvY29udmVydC1vYXV0aCcsXG4gIEN1c3RvZGlhbE1pZ3JhdGVBY2NvdW50ID0gJ2N1c3RvZGlhbC9taWdyYXRlLWFjY291bnQnLFxuICBDdXN0b2RpYWxOZXdBY2NvdW50ID0gJ2N1c3RvZGlhbC9uZXctdXNlcicsXG4gIEN1c3RvZGlhbFNpZ25TdHJpbmcgPSAnY3VzdG9kaWFsL3NpZ24tc3RyaW5nJyxcbiAgRGVsZXRlVGVzdFVzZXIgPSAnYWNjb3VudC9kZWxldGUtdGVzdC11c2VyJyxcbiAgQ3VzdG9kaWFsU2lnbiA9ICdjdXN0b2RpYWwvc2lnbicsXG4gIEdldFVzZXIgPSAnYWNjb3VudC91c2VyJyxcbiAgR2V0Q29uZmlnID0gJ3NlcnZpY2VzL2NvbmZpZycsXG4gIExvZ2luVXNlcldpdGhUb2tlbiA9ICdhY2NvdW50L2xvZ2luLXVzZXItd2l0aC10b2tlbicsXG4gIE5ld1VzZXJXaXRoVG9rZW4gPSAnYWNjb3VudC9uZXctdXNlci13aXRoLXRva2VuJyxcbiAgUGFzc3dvcmRMZXNzU2VuZENvZGUgPSAnYWNjb3VudC9sb2dpbi1wYXNzd29yZGxlc3Mtc2VuZC1jb2RlJyxcbiAgUGFzc3dvcmRMZXNzVmVyaWZ5Q29kZSA9ICdhY2NvdW50L2xvZ2luLXBhc3N3b3JkbGVzcy12ZXJpZnktY29kZScsXG4gIFRyYW5zYWN0aW9uU2lnbiA9ICd0cmFuc2FjdGlvbi9zaWduJyxcbiAgVXBkYXRlRGVsYXlXYWxsZXRTZXR1cCA9ICdhY2NvdW50L3VwZGF0ZS1kZWxheS13YWxsZXQtc2V0dXAnLFxufVxuXG4vKiogVHlwaWNhbCBBUEkgUmVzcG9uc2UgKHdoZW4gbm8gZGF0YSByZXR1cm5lZCkgKi9cbmV4cG9ydCB0eXBlIEFwaU1lc3NhZ2VSZXN1bHQgPSB7XG4gIG1lc3NhZ2U/OiBzdHJpbmdcbiAgZXJyb3I/OiBzdHJpbmdcbiAgcHJvY2Vzc0lkPzogc3RyaW5nXG4gIHN1Y2Nlc3M/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgQXBpUmVzdWx0V2l0aEVycm9yQ29kZSA9IHtcbiAgbWVzc2FnZT86IHN0cmluZ1xuICBwcm9jZXNzSWQ/OiBzdHJpbmdcbiAgZXJyb3JDb2RlPzogc3RyaW5nXG4gIGVycm9yTWVzc2FnZT86IHN0cmluZ1xufVxuXG4vLyBBUEkgcGFyYW1zXG5cbmV4cG9ydCB0eXBlIEN1c3RvZGlhbE1pZ3JhdGVBY2NvdW50UGFyYW1zID0ge1xuICBhY2NvdW50OiBBY2NvdW50TmFtZVxuICBjaGFpbkFjY291bnQ6IENoYWluQWNjb3VudFxuICBjaGFpbk5ldHdvcms6IENoYWluTmV0d29ya1xuICB0b1R5cGU6IEFjY291bnRUeXBlXG4gIHVzZXJQYXNzd29yZDogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIEN1c3RvZGlhbE1pZ3JhdGVBY2NvdW50QXBpQm9keVBhcmFtcyA9IHtcbiAgYWNjb3VudDogQWNjb3VudE5hbWVcbiAgY2hhaW5fYWNjb3VudDogQ2hhaW5BY2NvdW50XG4gIGNoYWluX25ldHdvcms6IENoYWluTmV0d29ya1xuICB0b190eXBlOiBBY2NvdW50VHlwZVxuICB1c2VyX3Bhc3N3b3JkOiBzdHJpbmdcbn1cbiIsImltcG9ydCB7IEF1dGhQcm92aWRlciwgQ2hhaW5BY2NvdW50LCBDaGFpbk5ldHdvcmssIEV4dGVybmFsV2FsbGV0VHlwZSB9IGZyb20gJy4uL2NvbW1vbi9tb2RlbHMnXG5cbi8qKiBSYXcgZGF0YSBleHRyYWN0ZWQgZnJvbSBPQXV0aCBJRFRva2VuICovXG5leHBvcnQgdHlwZSBJZFRva2VuID0ge1xuICBzdWI6IHN0cmluZ1xuICBuaWNrbmFtZTogc3RyaW5nXG4gIHBob25lX251bWJlcjogc3RyaW5nXG4gIGVtYWlsOiBzdHJpbmdcbiAgcGljdHVyZTogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBlbWFpbF92ZXJpZmllZD86IGJvb2xlYW5cbn1cblxuLyoqIE9hdXRoIEpXVFRva2VuICovXG5leHBvcnQgdHlwZSBKV1RUb2tlbiA9IHtcbiAgaXNzOiBzdHJpbmdcbiAgc3ViOiBzdHJpbmdcbiAgYXVkOiBzdHJpbmdcbiAgZXhwOiBudW1iZXJcbiAgbmJmOiBudW1iZXJcbiAgaWF0OiBudW1iZXJcbiAganRpOiBzdHJpbmdcbn0gJiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG5cbmV4cG9ydCB0eXBlIExvZ2luT3B0aW9ucyA9IHtcbiAgcHJvdmlkZXI/OiBBdXRoUHJvdmlkZXJcbiAgaWRUb2tlbj86IHN0cmluZ1xuICBjaGFpbkFjY291bnQ/OiBDaGFpbkFjY291bnRcbiAgY2hhaW5OZXR3b3JrPzogQ2hhaW5OZXR3b3JrXG4gIGNvZGU/OiBzdHJpbmdcbiAgZW1haWw/OiBzdHJpbmdcbiAgcGhvbmU/OiBzdHJpbmdcbiAgc3RhdGU/OiBzdHJpbmdcbiAgbGlua1RvQWNjb3VudD86IGJvb2xlYW5cbiAgcmV0dXJuQWNjZXNzVG9rZW4/OiBib29sZWFuXG4gIHJldHVybklkVG9rZW4/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIExvZ2luV2l0aFdhbGxldE9wdGlvbnMgPSB7XG4gIC8qKiBPcHRpb25hbGx5IHNwZWNpZnkgYSBzcGVjaWZpYyBhY2NvdW50IHRvIHNlbGVjdCBmcm9tIHdhbGxldCAoc29tZSB3YWxsZXRzIGRvbid0IHN1cHBvcnQgdGhpcykgKi9cbiAgY2hhaW5BY2NvdW50PzogQ2hhaW5BY2NvdW50XG4gIC8qKiBPcHRpb25hbGx5IHNwZWNpZnkgYSBzcGVjaWZpYyBibG9ja2NoYWluIHRvIHNlbGVjdCBmcm9tIHdhbGxldCAoc29tZSB3YWxsZXRzIGRvbid0IHN1cHBvcnQgdGhpcykgKi9cbiAgY2hhaW5OZXR3b3JrPzogQ2hhaW5OZXR3b3JrXG4gIHdhbGxldFR5cGU/OiBFeHRlcm5hbFdhbGxldFR5cGVcbn1cblxuZXhwb3J0IHR5cGUgTG9naW5XaXRoVG9rZW5PcHRpb25zID0ge1xuICAvKiogYWNjZXNzVG9rZW4gaXNzdWVkIGJ5IHByb3ZpZGVyIHNwZWNpZmllZCAob3IgT1JFIElEIGlmIG5vIHByb3ZpZGVyIHNwZWNpZmllZCkgKi9cbiAgYWNjZXNzVG9rZW4/OiBzdHJpbmdcbiAgaWRUb2tlbj86IHN0cmluZ1xuICAvKiogdGhlIE9BdXRoIHByb3ZpZGVyIHRoYXQgaXNzdWVkIHRoZSBhY2Nlc3NUb2tlbiAqL1xuICBwcm92aWRlcj86IEF1dGhQcm92aWRlclxufVxuXG5leHBvcnQgdHlwZSBOZXdVc2VyV2l0aFRva2VuT3B0aW9ucyA9IHtcbiAgLyoqIGFjY2Vzc1Rva2VuIGlzc3VlZCBieSBwcm92aWRlciBzcGVjaWZpZWQgKi9cbiAgYWNjZXNzVG9rZW4/OiBzdHJpbmdcbiAgaWRUb2tlbj86IHN0cmluZ1xuICAvKiogdGhlIE9BdXRoIHByb3ZpZGVyIHRoYXQgaXNzdWVkIHRoZSBhY2Nlc3NUb2tlbiAqL1xuICBwcm92aWRlcj86IEF1dGhQcm92aWRlclxuICAvKiogd2hldGhlciB1c2VyIGlzIHVzZWQgb25seSBmb3IgdGVzdGluZyAtIHVzZXIgbWF5IGJlIGRlbGV0ZWQgd2l0aCBkZWxldGVUZXN0VXNlciAqL1xuICBpc1Rlc3RVc2VyPzogYm9vbGVhblxuICAvKiogd2hldGhlciB3ZSBzaG91bGQgc2tpcCBjcmVhdGlvbiBvZiBibG9ja2NoYWluIGFjY291bnRzIGZvciBhIG5ldyB1c2VyICovXG4gIGRlbGF5V2FsbGV0U2V0dXA/OiBib29sZWFuXG59XG4iLCJleHBvcnQgdHlwZSBQcm9jZXNzSWQgPSBzdHJpbmdcbmV4cG9ydCB0eXBlIEFwcEFjY2Vzc1Rva2VuID0gc3RyaW5nXG5leHBvcnQgdHlwZSBBY2NvdW50TmFtZSA9IHN0cmluZ1xuZXhwb3J0IHR5cGUgQ2hhaW5BY2NvdW50ID0gc3RyaW5nXG5leHBvcnQgdHlwZSBQdWJsaWNLZXkgPSBzdHJpbmdcbmV4cG9ydCB0eXBlIFBlcm1pc3Npb25OYW1lID0gc3RyaW5nXG5leHBvcnQgdHlwZSBDb2xvciA9IHN0cmluZ1xuXG5leHBvcnQgZW51bSBDb25maWdUeXBlIHtcbiAgQ2hhaW5zID0gJ2NoYWlucycsXG59XG5cbi8qKiBGbGF2b3Igb2YgY2hhaW4gbmV0d29yayAqL1xuZXhwb3J0IGVudW0gQ2hhaW5QbGF0Zm9ybVR5cGUge1xuICBhbGdvcmFuZCA9ICdhbGdvcmFuZCcsXG4gIGVvcyA9ICdlb3MnLFxuICBldGhlcmV1bSA9ICdldGhlcmV1bScsXG4gIG9yZSA9ICdvcmUnLFxufVxuXG4vKiogTmFtZWQgY2hhaW4gbmV0d29yayAqL1xuZXhwb3J0IGVudW0gQ2hhaW5OZXR3b3JrIHtcbiAgLy8gQWxnb1xuICBBbGdvTWFpbiA9ICdhbGdvX21haW4nLFxuICBBbGdvQmV0YSA9ICdhbGdvX2JldGEnLFxuICBBbGdvVGVzdCA9ICdhbGdvX3Rlc3QnLFxuICAvLyBBVkFMQU5DSEVcbiAgQXZhbGFuY2hlQ19NYWluID0gJ2F2YWxhbmNoZWNfbWFpbicsXG4gIEF2YWxhbmNoZUNfRnVqaSA9ICdhdmFsYW5jaGVjX2Z1amknLFxuICAvLyBEc3AvRU9TXG4gIERzcEVvc0t5bGluMSA9ICdreWxpbi1kc3AtMS5saXF1aWRhcHBzLmlvJyxcbiAgRHNwRW9zS3lsaW4yID0gJ2t5bGluLWRzcC0yLmxpcXVpZGFwcHMuaW8nLFxuICBEc3BNb29ubGlnaHRpbmcgPSAnZW9zX21vb25fYmxvY2tzdGFydGRzcF9jb20nLFxuICBEc3BNb29ubGlnaHRpbmdUZXN0ID0gJ2Vvc19tb29udGVzdF9ibG9ja3N0YXJ0ZHNwX2NvbScsXG4gIC8vIERPU1xuICBEb3NNYWluID0gJ2Rvc19tYWluJyxcbiAgRG9zVGVzdCA9ICdkb3NfdGVzdCcsXG4gIC8vIEVUSFxuICBFdGhNYWluID0gJ2V0aF9tYWluJyxcbiAgRXRoUm9wc3RlbiA9ICdldGhfcm9wc3RlbicsXG4gIEV0aFJpbmtlYnkgPSAnZXRoX3JpbmtlYnknLFxuICBFdGhHb2VybGkgPSAnZXRoX2dvZXJsaScsXG4gIC8vIEVPU1xuICBFb3NNYWluID0gJ2Vvc19tYWluJyxcbiAgRW9zS3lsaW4gPSAnZW9zX2t5bGluJyxcbiAgRW9zSnVuZ2xlID0gJ2Vvc19qdW5nbGUnLFxuICBNaWdyYXRlRW9zTWFpbiA9ICdtaWdyYXRlX2Vvc19tYWluJyxcbiAgLy8gT1JFXG4gIE9yZU1haW4gPSAnb3JlX21haW4nLFxuICBPcmVUZXN0ID0gJ29yZV90ZXN0JyxcbiAgLy8gUG9seWdvblxuICBQb2x5Z29uTWFpbiA9ICdwb2x5Z29uX21haW4nLFxuICBQb2x5Z29uTXVtYmFpID0gJ3BvbHlnb25fbXVtYmFpJyxcbiAgLy8gVEVMT1NcbiAgVGVsb3NNYWluID0gJ3RlbG9zX21haW4nLFxuICBUZWxvc1Rlc3QgPSAndGVsb3NfdGVzdCcsXG4gIC8vIFRFTE9TIEVWTVxuICBUZWxvc0V2bU1haW4gPSAndGVsb3Nldm1fbWFpbicsXG4gIFRlbG9zRXZtVGVzdCA9ICd0ZWxvc2V2bV90ZXN0JyxcbiAgLy8gVVhcbiAgVXhNYWluID0gJ3V4X21haW4nLFxuICAvLyBVeFRlc3QgPSAndXhfdGVzdCcsICh0aGVyZSBpcyBubyB0ZXN0IG5ldHdvcmspIC0gdGhpcyBpcyBsZWZ0IGhlcmUgYXMgYSBwbGFjZWhvbGRlclxuICAvLyBXQVhcbiAgV2F4TWFpbiA9ICd3YXhfbWFpbicsXG4gIFdheFRlc3QgPSAnd2F4X3Rlc3QnLFxufVxuXG4vKiogUGh5c2ljYWwgc3RydWN0dXJlIG9mIGFjY291bnQgKi9cbmV4cG9ydCBlbnVtIEFjY291bnRUeXBlIHtcbiAgTmF0aXZlID0gJ25hdGl2ZScsXG4gIFBlbmRpbmcgPSAncGVuZGluZycsXG4gIFZpcnR1YWxMaXF1aWQgPSAnbGlxdWlkJyxcbiAgVmlydHVhbE5lc3RlZCA9ICduZXN0ZWQnLFxufVxuXG5leHBvcnQgZW51bSBMb2dpblByb3ZpZGVyIHtcbiAgQ3VzdG9kaWFsID0gJ2N1c3RvZGlhbCcsXG4gIEFwcGxlID0gJ2FwcGxlJyxcbiAgRW1haWwgPSAnZW1haWwnLFxuICBGYWNlYm9vayA9ICdmYWNlYm9vaycsXG4gIEdpdGh1YiA9ICdnaXRodWInLFxuICBHb29nbGUgPSAnZ29vZ2xlJyxcbiAgSW5zdGFncmFtID0gJ2luc3RhZ3JhbScsXG4gIEtha2FvID0gJ2tha2FvJyxcbiAgTGluZSA9ICdsaW5lJyxcbiAgTGlua2VkSW4gPSAnbGlua2VkaW4nLFxuICBQaG9uZSA9ICdwaG9uZScsXG4gIFR3aXRjaCA9ICd0d2l0Y2gnLFxuICBUd2l0dGVyID0gJ3R3aXR0ZXInLFxufVxuXG5leHBvcnQgZW51bSBFeHRlcm5hbFdhbGxldFR5cGUge1xuICBBbGdvU2lnbmVyID0gJ2FsZ29zaWduZXInLFxuICBBbmNob3IgPSAnYW5jaG9yJyxcbiAgS2V5Y2F0ID0gJ2tleWNhdCcsXG4gIExlZGdlciA9ICdsZWRnZXInLFxuICBMeW54ID0gJ2x5bngnLFxuICBNZWV0b25lID0gJ21lZXRvbmUnLFxuICBNZXRybyA9ICdtZXRybycsXG4gIFBvcnRpcyA9ICdwb3J0aXMnLFxuICBTY2F0dGVyID0gJ3NjYXR0ZXInLFxuICBTaW1wbGVFb3MgPSAnc2ltcGxlb3MnLFxuICBUb2tlblBvY2tldCA9ICd0b2tlbnBvY2tldCcsXG4gIFdhbGxldENvbm5lY3QgPSAnd2FsbGV0Y29ubmVjdCcsXG4gIFdlYjMgPSAnd2ViMycsXG4gIFdoYWxlVmF1bHQgPSAnd2hhbGV2YXVsdCcsXG4gIFdvbWJhdCA9ICd3b21iYXQnLFxufVxuXG4vKiogQWxsIGF1dGggcHJvdmlkZXJzIC0gaW5jbHVkaW5nIE9yZUlkIGxvZ2luIHR5cGVzIChlZyAnRmFjZWJvb2snKSBhbmQgd2FsbGV0cyAoZWcgJ1NjYXR0ZXInKSAqL1xuZXhwb3J0IGVudW0gQXV0aFByb3ZpZGVyIHtcbiAgLy8gT1JFIElEIExvZ2luUHJvdmlkZXJcbiAgQ3VzdG9kaWFsID0gJ2N1c3RvZGlhbCcsXG4gIEFwcGxlID0gJ2FwcGxlJyxcbiAgRW1haWwgPSAnZW1haWwnLFxuICBGYWNlYm9vayA9ICdmYWNlYm9vaycsXG4gIEdpdGh1YiA9ICdnaXRodWInLFxuICBHb29nbGUgPSAnZ29vZ2xlJyxcbiAgSW5zdGFncmFtID0gJ2luc3RhZ3JhbScsXG4gIEtha2FvID0gJ2tha2FvJyxcbiAgTGluZSA9ICdsaW5lJyxcbiAgTGlua2VkSW4gPSAnbGlua2VkaW4nLFxuICBQaG9uZSA9ICdwaG9uZScsXG4gIFR3aXRjaCA9ICd0d2l0Y2gnLFxuICBUd2l0dGVyID0gJ3R3aXR0ZXInLFxuICAvLyBFeHRlcm5hbFdhbGxldFR5cGVcbiAgQWxnb1NpZ25lciA9ICdhbGdvc2lnbmVyJyxcbiAgQW5jaG9yID0gJ2FuY2hvcicsXG4gIEtleWNhdCA9ICdrZXljYXQnLFxuICBMZWRnZXIgPSAnbGVkZ2VyJyxcbiAgTHlueCA9ICdseW54JyxcbiAgTWVldG9uZSA9ICdtZWV0b25lJyxcbiAgTWV0cm8gPSAnbWV0cm8nLFxuICBQb3J0aXMgPSAncG9ydGlzJyxcbiAgU2NhdHRlciA9ICdzY2F0dGVyJyxcbiAgU2ltcGxlRW9zID0gJ3NpbXBsZW9zJyxcbiAgVG9rZW5Qb2NrZXQgPSAndG9rZW5wb2NrZXQnLFxuICBXYWxsZXRDb25uZWN0ID0gJ3dhbGxldGNvbm5lY3QnLFxuICBXZWIzID0gJ3dlYjMnLFxuICBXaGFsZVZhdWx0ID0gJ3doYWxldmF1bHQnLFxuICBXb21iYXQgPSAnd29tYmF0JyxcbiAgLy8gcGxhY2Vob2xkZXIgZm9yIHNpZ25pbmcgLSBtZWFuaW5nIG5vbiBhbiBleHRlcm5hbCB3YWxsZXRcbiAgT3JlSWQgPSAnb3JlaWQnLFxufVxuXG5leHBvcnQgZW51bSBBcGlLZXlVc2VkRm9yIHtcbiAgQWNjb3VudE1pZ3JhdGlvbiA9ICdhY2NvdW50TWlncmF0aW9uJyxcbiAgQWlyZHJvcCA9ICdhaXJkcm9wJyxcbiAgQWRtaW5BY2Nlc3MgPSAnYWRtaW5BY2Nlc3MnLFxuICBBdXRvU2lnbmluZyA9ICdhdXRvU2lnbmluZycsXG4gIENoYW5nZVBhc3N3b3JkID0gJ2NoYW5nZVBhc3N3b3JkJyxcbiAgQ3JlYXRlVXNlciA9ICdjcmVhdGVVc2VyJyxcbiAgUHJveHlTaWduaW5nID0gJ3Byb3h5U2lnbmluZycsXG4gIFRva2VuRnVuZGluZyA9ICd0b2tlbkZ1bmRpbmcnLFxufVxuXG4vKiogdHlwZSByZXR1cm5lZCBieSBvcmVpZCBzZXZpY2UgY29uZmlnIGVuZHBvaW50IGZvciBjaGFpbnMgKi9cbmV4cG9ydCB0eXBlIFNldHRpbmdDaGFpbk5ldHdvcmsgPSB7XG4gIGJsb2NrRXhwbG9yZXJBY2NvdW50VXJsOiBzdHJpbmdcbiAgYmxvY2tFeHBsb3JlclR4VXJsOiBzdHJpbmdcbiAgY2hhaW5Db21tdW5pY2F0aW9uU2V0dGluZ3M6IGFueVxuICBjcmVhdGVCcmlkZ2VDb250cmFjdDogc3RyaW5nXG4gIGRlZmF1bHRUcmFuc2FjdGlvblNldHRpbmdzPzogYW55XG4gIC8qKiBVcmwgb2YgbW9uaXRvciAqL1xuICBkZnVzZU5ldHdvcms/OiBzdHJpbmdcbiAgaG9zdHM6IFNldHRpbmdDaGFpbk5ldHdvcmtIb3N0W11cbiAgaXNUZXN0TmV0d29yazogYm9vbGVhblxuICBtb25pdG9yQ29uZmlnPzoge1xuICAgIGRmdXNlU3VwcG9ydGVkOiBib29sZWFuXG4gICAgZW5kcG9pbnQ6IHN0cmluZ1xuICB9XG4gIG5hbWU6IHN0cmluZ1xuICBsb2dvVXJsOiBzdHJpbmdcbiAgbmV0d29yazogQ2hhaW5OZXR3b3JrXG4gIHR5cGU6IENoYWluUGxhdGZvcm1UeXBlXG59XG5cbmV4cG9ydCB0eXBlIFNldHRpbmdDaGFpbk5ldHdvcmtIb3N0ID0ge1xuICBjaGFpbklkOiBzdHJpbmdcbiAgLyoqIGZvcmsgbmFtZSB1c2VkIHRvIGRlc2lnbmF0ZSBhIG1ham9yIHZlcnNpb24gKi9cbiAgZm9ya05hbWU/OiBzdHJpbmdcbiAgaG9zdDogc3RyaW5nXG4gIHBvcnQ6IG51bWJlclxuICBwcm90b2NvbDogJ2h0dHBzJyB8ICdodHRwJ1xufVxuXG4vLyBDaGFpbiBzcGVjaWZpY1xuXG5leHBvcnQgdHlwZSBBbGdvcmFuZE11bHRpU2lnT3B0aW9ucyA9IHtcbiAgdmVyc2lvbjogbnVtYmVyXG4gIHRocmVzaG9sZDogbnVtYmVyXG4gIGFkZHJzOiBzdHJpbmdbXVxufVxuXG4vKiogaGVscGVyIHR5cGUgdG8gaW5kZXggYSBKU09OIG9iamVjdCAqL1xuZXhwb3J0IGludGVyZmFjZSBMb29rdXAge1xuICBba2V5OiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgSlNPTkFycmF5ID0gQXJyYXk8SlNPTlZhbHVlPlxuXG5leHBvcnQgdHlwZSBKU09OVmFsdWUgPSBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRnVuY3Rpb24gfCBKU09OT2JqZWN0IHwgSlNPTkFycmF5XG5cbmV4cG9ydCBpbnRlcmZhY2UgSlNPTk9iamVjdCB7XG4gIFt4OiBzdHJpbmddOiBKU09OVmFsdWVcbn1cbiIsImltcG9ydCB7IFJlcXVlc3QsIFJlc3BvbnNlIH0gZnJvbSAnZXhwcmVzcycgLy8gTk9URTogV2UgYXJlIG9ubHkgdXNpbmcgdHlwZXMgaGVyZSAtIEV4cHJlc3MgbGlicmFyeSB3b24ndCBiZSBlbWl0dGVkIGluIHRoZSBidWlsZCBoZXJlXG5pbXBvcnQgeyBMb2dpbk9wdGlvbnMgfSBmcm9tICcuLi9hdXRoL21vZGVscydcbmltcG9ydCB7XG4gIEFjY291bnROYW1lLFxuICBBY2NvdW50VHlwZSxcbiAgQWxnb3JhbmRNdWx0aVNpZ09wdGlvbnMsXG4gIEFwcEFjY2Vzc1Rva2VuLFxuICBBdXRoUHJvdmlkZXIsXG4gIENoYWluQWNjb3VudCxcbiAgQ2hhaW5OZXR3b3JrLFxuICBFeHRlcm5hbFdhbGxldFR5cGUsXG4gIFByb2Nlc3NJZCxcbiAgUHVibGljS2V5LFxufSBmcm9tICcuLi9jb21tb24vbW9kZWxzJ1xuaW1wb3J0IHsgVXNlckRhdGEgfSBmcm9tICcuLi91c2VyL21vZGVscydcblxuZXhwb3J0IGVudW0gUmVjb3ZlckFjY291bnRBY3Rpb24ge1xuICBSZXB1YmxpYyA9ICdyZXB1YmxpYycsXG59XG5cbi8qKiBGb3IgY3JlYXRpbmcgYSBuZXcgY2hhaW5BY2NvdW50IGluIGFuIGV4aXN0aW5nIHdhbGxldCAqL1xuZXhwb3J0IHR5cGUgTmV3QWNjb3VudE9wdGlvbnMgPSB7XG4gIGFjY291bnQ6IEFjY291bnROYW1lIC8vIGV4aXN0aW5nIHdhbGxldCBhY2NvdW50IG5hbWUgKG9yZSBhY2NvdW50KVxuICBhY2NvdW50T3B0aW9ucz86IENyZWF0ZU9uQ2hhaW5BY2NvdW50c09wdGlvbnNcbiAgYWNjb3VudFR5cGU6IEFjY291bnRUeXBlXG4gIGNoYWluTmV0d29yaz86IENoYWluTmV0d29ya1xuICBwcm92aWRlcj86IEF1dGhQcm92aWRlciAvLyBUT0RPOiBjb25maXJtIGlmIHdlIG5lZWQgdGhpc1xuICBzdGF0ZT86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBEaXNjb3Zlck9wdGlvbnMgPSB7XG4gIHdhbGxldFR5cGU6IEV4dGVybmFsV2FsbGV0VHlwZVxuICBjaGFpbk5ldHdvcms/OiBDaGFpbk5ldHdvcmtcbiAgb3JlQWNjb3VudD86IENoYWluQWNjb3VudFxuICBkaXNjb3ZlcnlQYXRoSW5kZXhMaXN0PzogbnVtYmVyW11cbn1cblxuZXhwb3J0IHR5cGUgQXV0aFJlc3VsdCA9IHtcbiAgYWNjb3VudD86IEFjY291bnROYW1lXG4gIGFjY2Vzc1Rva2VuPzogc3RyaW5nXG4gIGlkVG9rZW4/OiBzdHJpbmdcbiAgZXJyb3JzPzogc3RyaW5nW11cbiAgcHJvY2Vzc0lkPzogUHJvY2Vzc0lkXG4gIHN0YXRlPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIE5ld0FjY291bnRSZXN1bHQgPSB7XG4gIGNoYWluQWNjb3VudD86IHN0cmluZ1xuICBlcnJvcnM/OiBzdHJpbmdbXVxuICBwcm9jZXNzSWQ/OiBQcm9jZXNzSWRcbiAgc3RhdGU/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgU2lnblJlc3VsdCA9IHtcbiAgc2lnbmVkVHJhbnNhY3Rpb24/OiBzdHJpbmdcbiAgdHJhbnNhY3Rpb25JZDogc3RyaW5nXG4gIGVycm9ycz86IHN0cmluZ1tdXG4gIHByb2Nlc3NJZD86IFByb2Nlc3NJZFxuICBzdGF0ZT86IHN0cmluZ1xufVxuXG4vLyBUb2RvOiBpbXBsZW1lbnQgcGFzc3dvcmRSZXNldCBmbG93L3VybFxuZXhwb3J0IHR5cGUgUGFzc3dvcmRSZXNldE9wdGlvbnMgPSB7XG4gIHByb3ZpZGVyOiBBdXRoUHJvdmlkZXJcbiAgY2hhaW5BY2NvdW50PzogQ2hhaW5BY2NvdW50XG4gIGNoYWluTmV0d29yaz86IENoYWluTmV0d29ya1xuICBzdGF0ZT86IHN0cmluZ1xuICBjdXJyZW50QWNjb3VudFBhc3N3b3JkPzogc3RyaW5nIC8vIGlmIHRoZSB1c2VyJ3MgY3VycmVudCBwYXNzd29yZCBpcyBrbm93biwgaXQgY2FuIGJlIHBhc3NlZCBpbiB0byBhcHBBY2Nlc3NUb2tlbiByZXF1ZXN0XG59XG5cbmV4cG9ydCB0eXBlIEdldFJlY292ZXJBY2NvdW50VXJsUmVzdWx0ID0gc3RyaW5nXG5cbmV4cG9ydCB0eXBlIExvZ2luV2l0aE9yZUlkUmVzdWx0ID0ge1xuICBhY2Nlc3NUb2tlbj86IHN0cmluZ1xuICBsb2dpblVybD86IHN0cmluZ1xuICBlcnJvcnM/OiBzdHJpbmdcbiAgcHJvY2Vzc0lkPzogUHJvY2Vzc0lkXG59XG5cbmV4cG9ydCB0eXBlIE5ld0FjY291bnRXaXRoT3JlSWRSZXN1bHQgPSB7XG4gIG5ld0FjY291bnRVcmw6IHN0cmluZ1xuICBlcnJvcnM/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgU2lnbldpdGhPcmVJZFJlc3VsdCA9IHtcbiAgcHJvY2Vzc0lkPzogUHJvY2Vzc0lkXG4gIHNpZ25lZFRyYW5zYWN0aW9uPzogc3RyaW5nXG4gIHRyYW5zYWN0aW9uSWQ/OiBzdHJpbmdcbiAgc2lnblVybD86IHN0cmluZ1xuICBlcnJvcnM/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgU2lnblN0cmluZ1BhcmFtcyA9IHtcbiAgYWNjb3VudDogQWNjb3VudE5hbWVcbiAgd2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlXG4gIGNoYWluQWNjb3VudD86IENoYWluQWNjb3VudFxuICBjaGFpbk5ldHdvcms6IENoYWluTmV0d29ya1xuICBzdHJpbmc6IHN0cmluZ1xuICBtZXNzYWdlOiBzdHJpbmdcbiAgbWV0YWRhdGE/OiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgU2lnblN0cmluZ1Jlc3VsdCA9IHtcbiAgc2lnbmVkU3RyaW5nOiBzdHJpbmdcbn1cblxuLy8gRnVuY3Rpb24gUGFyYW1zXG5cbmV4cG9ydCB0eXBlIEdldE9yZUlkTmV3Q2hhaW5BY2NvdW50VXJsUGFyYW1zID0gTmV3QWNjb3VudE9wdGlvbnMgJiB7XG4gIGNhbGxiYWNrVXJsOiBzdHJpbmdcbiAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIEdldE9yZUlkQXV0aFVybFBhcmFtcyA9IExvZ2luT3B0aW9ucyAmIHtcbiAgY2FsbGJhY2tVcmw6IHN0cmluZ1xuICBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgR2V0T3JlSWRSZWNvdmVyQWNjb3VudFVybFBhcmFtcyA9IExvZ2luT3B0aW9ucyAmIHtcbiAgYWNjb3VudDogQWNjb3VudE5hbWVcbiAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nXG4gIGNhbGxiYWNrVXJsOiBzdHJpbmdcbiAgcmVjb3ZlckFjdGlvbj86IFJlY292ZXJBY2NvdW50QWN0aW9uXG4gIG92ZXJyaWRlQXBwQWNjZXNzVG9rZW4/OiBBcHBBY2Nlc3NUb2tlblxufVxuXG5leHBvcnQgdHlwZSBBcHBBY2Nlc3NUb2tlbk1ldGFkYXRhID0ge1xuICBwYXJhbXNOZXdBY2NvdW50PzogTmV3QWNjb3VudEFwcFRva2VuUGFyYW1zXG4gIG5ld0FjY291bnRQYXNzd29yZD86IHN0cmluZ1xuICBjdXJyZW50QWNjb3VudFBhc3N3b3JkPzogc3RyaW5nXG4gIHNlY3JldHM/OiB7XG4gICAgdHlwZTogc3RyaW5nXG4gICAgdmFsdWU6IHN0cmluZ1xuICB9W11cbn1cblxuLyoqIHBhcmFtcyBmb3IgY2FsbGluZyBuZXctYWNjb3VudCBzZXJ2aWNlIHdlYiBlbmRwb2ludCAoc2VudCB2aWEgQXBwQWNjZXNzVG9rZW4gcmVxdWVzdCkgKi9cbmV4cG9ydCB0eXBlIE5ld0FjY291bnRBcHBUb2tlblBhcmFtcyA9IHtcbiAgYWNjb3VudDogQWNjb3VudE5hbWUgLy8gd2FsbGV0IGFjY291bnQgKG9yZSBhY2NvdW50IG5hbWUpXG4gIGFjY291bnRUeXBlOiBBY2NvdW50VHlwZVxuICBjaGFpbk5ldHdvcms/OiBDaGFpbk5ldHdvcmsgLy8gY2hhaW5OZXR3b3JrIHRvIGNyZWF0ZSBuZXcgYWNjb3VudCBvblxuICBhY2NvdW50T3B0aW9uczogQ3JlYXRlT25DaGFpbkFjY291bnRzT3B0aW9uc1xufVxuXG5leHBvcnQgdHlwZSBDcmVhdGVPbkNoYWluQWNjb3VudHNPcHRpb25zID0ge1xuICBrZXlzPzoge1xuICAgIHB1YmxpY0tleXM6IHtcbiAgICAgIG93bmVyPzogUHVibGljS2V5XG4gICAgICBhY3RpdmU6IFB1YmxpY0tleVxuICAgIH1cbiAgfVxuICBtdWx0aXNpZ09wdGlvbnM/OiBBbGdvcmFuZE11bHRpU2lnT3B0aW9ucyAvLyB8fCBmdXR1cmUgbXVsdGlzaWcgb3B0aW9uIHR5cGVzXG59XG5cbnR5cGUgUGFyYW1zRm9yUmVxdWVzdCA9IHtcbiAgYXBwSWQ/OiBzdHJpbmdcbiAgYWNjZXNzVG9rZW4/OiBzdHJpbmdcbiAgY2hhaW5BY2NvdW50Pzogc3RyaW5nXG4gIGlkVG9rZW4/OiBzdHJpbmdcbiAgcHJvY2Vzc0lkPzogUHJvY2Vzc0lkXG4gIHN0YXRlPzogc3RyaW5nXG4gIHNpZ25lZFRyYW5zYWN0aW9uPzogc3RyaW5nXG4gIHRyYW5zYWN0aW9uSWQ/OiBzdHJpbmdcbiAgdXNlcj86IFVzZXJEYXRhXG59XG5cbnR5cGUgUGFyYW1zRm9yUmVzcG9uc2UgPSB7XG4gIG15RmllbGQ/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgUmVxdWVzdFdpdGhQYXJhbXMgPSBSZXF1ZXN0ICYgUGFyYW1zRm9yUmVxdWVzdFxuZXhwb3J0IHR5cGUgUmVzcG9uc2VXaXRoUGFyYW1zID0gUmVzcG9uc2UgJiBQYXJhbXNGb3JSZXNwb25zZVxuXG4vKiogR2VuZXJpYyBTaWduYXR1cmVQcm92aWRlciBpbnRlcmZhY2UgKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbmF0dXJlUHJvdmlkZXIge1xuICAvKiogUHVibGljIGtleXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcml2YXRlIGtleXMgdGhhdCB0aGUgYFNpZ25hdHVyZVByb3ZpZGVyYCBob2xkcyAqL1xuICBnZXRBdmFpbGFibGVLZXlzOiAoKSA9PiBQcm9taXNlPHN0cmluZ1tdPlxuICAvKiogU2lnbiBhIHRyYW5zYWN0aW9uICovXG4gIHNpZ246IChhcmdzOiBTaWduYXR1cmVQcm92aWRlckFyZ3MpID0+IFByb21pc2U8U2lnbmF0dXJlUHJvdmlkZXJTaWduUmVzdWx0PlxufVxuXG4vKiogU2lnbmF0dXJlUHJvdmlkZXIgcGFyYW1zIGZvciBzaWduKCkgZnVuY3Rpb24gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbmF0dXJlUHJvdmlkZXJBcmdzIHtcbiAgLyoqIENoYWluIHRyYW5zYWN0aW9uIGlzIGZvciAqL1xuICBjaGFpbklkOiBzdHJpbmdcbiAgLyoqIFB1YmxpYyBrZXlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJpdmF0ZSBrZXlzIG5lZWRlZCB0byBzaWduIHRoZSB0cmFuc2FjdGlvbiAqL1xuICByZXF1aXJlZEtleXM6IHN0cmluZ1tdXG4gIC8qKiBUcmFuc2FjdGlvbiB0byBzaWduICovXG4gIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbjogVWludDhBcnJheVxuICAvKiogQUJJcyBmb3IgYWxsIGNvbnRyYWN0cyB3aXRoIGFjdGlvbnMgaW5jbHVkZWQgaW4gYHNlcmlhbGl6ZWRUcmFuc2FjdGlvbmAgKi9cbiAgYWJpczogQmluYXJ5QWJpW11cbn1cblxuLyoqIFJlc3VsdHMgZnJvbSBleHRlcm5hbCB3YWxsZXQgc2lnblRyYW5zY3Rpb24oKSAtIGUuZy4gdmlhIFRyYW5zaXQgb3IgVUFMICovXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25hdHVyZVByb3ZpZGVyU2lnblJlc3VsdCB7XG4gIHNpZ25hdHVyZXM6IHN0cmluZ1tdXG4gIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbjogVWludDhBcnJheVxufVxuXG4vKiogU3RydWN0dXJlIGZvciB0aGUgcmF3IGZvcm0gb2YgQUJJcyAqL1xuZXhwb3J0IGludGVyZmFjZSBCaW5hcnlBYmkge1xuICAvKiogYWNjb3VudCB3aGljaCBoYXMgZGVwbG95ZWQgdGhlIEFCSSAqL1xuICBhY2NvdW50TmFtZTogc3RyaW5nXG4gIC8qKiBhYmkgaW4gYmluYXJ5IGZvcm0gKi9cbiAgYWJpOiBVaW50OEFycmF5XG59XG4iLCJpbXBvcnQge1xuICBBY2NvdW50TmFtZSxcbiAgQ2hhaW5BY2NvdW50LFxuICBDaGFpbk5ldHdvcmssXG4gIEV4dGVybmFsV2FsbGV0VHlwZSxcbiAgUGVybWlzc2lvbk5hbWUsXG4gIFB1YmxpY0tleSxcbn0gZnJvbSAnLi4vY29tbW9uL21vZGVscydcblxuLy8gT1JFIElEIFR5cGVzXG5cbi8qKiBBbGwgVXNlciBkYXRhIHJldHJpZXZlZCBpbmNsdWRpbmcgcGVybWlzc2lvbnMgKi9cbmV4cG9ydCB0eXBlIFVzZXJTb3VyY2VEYXRhID0ge1xuICBhY2NvdW50TmFtZTogQWNjb3VudE5hbWVcbiAgZW1haWw6IHN0cmluZ1xuICBwaWN0dXJlOiBVUkxbJ2hyZWYnXVxuICBuYW1lOiBzdHJpbmdcbiAgdXNlcm5hbWU6IHN0cmluZ1xuICBwZXJtaXNzaW9uczogVXNlclBlcm1pc3Npb25EYXRhW11cbiAgZGVsYXlXYWxsZXRTZXR1cD86IGJvb2xlYW5cbn1cblxuLyoqIFVzZXIgcGVyc29uYWwgYW5kIGJsb2NrY2hhaW4gYWNjb3VudCBpbmZvcm1hdGlvbiAqL1xuZXhwb3J0IHR5cGUgVXNlckRhdGEgPSBPbWl0PFVzZXJTb3VyY2VEYXRhLCAncGVybWlzc2lvbnMnPiAmIHtcbiAgY2hhaW5BY2NvdW50czogVXNlckNoYWluQWNjb3VudFtdXG59XG5cbi8qKiBCbG9ja2NoYWluIGFjY291bnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlcidzIE9yZUlkIGFjY291bnRcbiAqICBQZXJtaXNzaW9ucyBhcmUgbmFtZXMgZm9yIHB1YmxpY0tleXMgdXNlZCB3aXRoIHRoZSBjaGFpbkFjY291bnRcbiAqICBUaGUgZGVmYXVsdCBwZXJtaXNzaW9uIGlzIHRoZSBvbmUgbW9zdCBjb21tb25seSB1c2VkIHRvIHNpZ24gdHJhbnNhY3Rpb25zIGZvciB0aGUgY2hhaW4gYWNjb3VudFxuICovXG5leHBvcnQgdHlwZSBVc2VyQ2hhaW5BY2NvdW50ID0ge1xuICBjaGFpbk5ldHdvcms6IENoYWluTmV0d29ya1xuICBjaGFpbkFjY291bnQ6IENoYWluQWNjb3VudFxuICAvKiBUaGUgZGVmYXVsdCBwZXJtaXNzaW9uIGlzIHRoZSBvbmUgbW9zdCBjb21tb25seSB1c2VkIHRvIHNpZ24gdHJhbnNhY3Rpb25zIGZvciB0aGUgY2hhaW4gYWNjb3VudCAqL1xuICBkZWZhdWx0UGVybWlzc2lvbjogVXNlclBlcm1pc3Npb25Gb3JDaGFpbkFjY291bnRcbiAgLyoqIFBlcm1pc3Npb25zIGFyZSBwdWJsaWNLZXlzIHVzZWQgd2l0aCB0aGUgY2hhaW5BY2NvdW50IC0gd2hpY2ggaGF2ZSBiZWVuIGdpdmVuIGEgbmFtZVxuICAgKiBGb3IgbW9zdCBjaGFpbnMsIHRoZXJlIGlzIG9ubHkgb25lIHBlcm1pc3Npb24gbmFtZWQgJ2FjdGl2ZScgKi9cbiAgcGVybWlzc2lvbnM6IFVzZXJQZXJtaXNzaW9uRm9yQ2hhaW5BY2NvdW50W11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VyUGVybWlzc2lvbiBleHRlbmRzIE9taXQ8VXNlclBlcm1pc3Npb25EYXRhLCAncGVybWlzc2lvbic+IHtcbiAgbmFtZTogUGVybWlzc2lvbk5hbWUgLy8gcmVuYW1lIHBlcm1pc3Npb24ucGVybWlzc2lvbiB0byBwZXJtaXNzaW9uLm5hbWVcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VyUGVybWlzc2lvbkZvckNoYWluQWNjb3VudCBleHRlbmRzIE9taXQ8VXNlclBlcm1pc3Npb24sICdjaGFpbkFjY291bnQnIHwgJ2NoYWluTmV0d29yayc+IHtcbiAgbmFtZTogUGVybWlzc2lvbk5hbWUgLy8gcmVuYW1lIHBlcm1pc3Npb24ucGVybWlzc2lvbiB0byBwZXJtaXNzaW9uLm5hbWVcbn1cblxuZXhwb3J0IHR5cGUgVXNlclBlcm1pc3Npb25EYXRhID0ge1xuICBjaGFpbk5ldHdvcms6IENoYWluTmV0d29ya1xuICBjaGFpbkFjY291bnQ6IENoYWluQWNjb3VudFxuICBleHRlcm5hbFdhbGxldFR5cGU/OiBFeHRlcm5hbFdhbGxldFR5cGVcbiAgaXNEZWZhdWx0PzogYm9vbGVhblxuICBpc1ZlcmlmaWVkPzogYm9vbGVhblxuICBuaWNrbmFtZT86IHN0cmluZ1xuICBwZXJtaXNzaW9uOiBQZXJtaXNzaW9uTmFtZVxuICBwcml2YXRlS2V5U3RvcmVkRXh0ZXJhbGx5PzogYm9vbGVhblxuICBwdWJsaWNLZXk/OiBQdWJsaWNLZXlcbn1cblxuZXhwb3J0IHR5cGUgV2FsbGV0UGVybWlzc2lvbiA9IHtcbiAgYWNjb3VudD86IEFjY291bnROYW1lXG4gIG5hbWU6IFBlcm1pc3Npb25OYW1lXG4gIHBhcmVudD86IFBlcm1pc3Npb25OYW1lXG4gIHB1YmxpY0tleTogUHVibGljS2V5XG59XG4iLCJpbXBvcnQgeyBBY2NvdW50TmFtZSwgQXV0aFByb3ZpZGVyLCBDaGFpbkFjY291bnQsIENoYWluTmV0d29yaywgSlNPTk9iamVjdCB9IGZyb20gJy4uL2NvbW1vbi9tb2RlbHMnXG5pbXBvcnQgeyBTaWduU3RyaW5nTWV0aG9kIH0gZnJvbSAnLi4vd2ViV2lkZ2V0L21vZGVscydcblxuLy8gT1JFIElEIFR5cGVzXG5cbmV4cG9ydCB0eXBlIFNpZ25TdHJpbmdEYXRhID0ge1xuICBhY2NvdW50PzogQWNjb3VudE5hbWVcbiAgY2hhaW5BY2NvdW50PzogQ2hhaW5BY2NvdW50IHwgc3RyaW5nXG4gIGNoYWluTmV0d29yazogQ2hhaW5OZXR3b3JrIHwgc3RyaW5nXG4gIC8qKiBvcHRpb25hbCAtIGFsdGVybmF0aXZlIG1ldGhvZCBvZiBzaWduaW5nIChjaGFpbi1zcGVjaWZpYykgKi9cbiAgc2lnbk1ldGhvZD86IFNpZ25TdHJpbmdNZXRob2RcbiAgc3RyaW5nPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIFRyYW5zYWN0aW9uRGF0YSA9IHtcbiAgYWNjb3VudD86IEFjY291bnROYW1lIC8vIHVzZXIncyBvcmVpZCAtIHNldCBhdXRvbWF0aWNhbGx5IGJ5IFRyYW5zYWN0aW9uIG9iamVjdFxuICBjaGFpbkFjY291bnQ/OiBDaGFpbkFjY291bnQgLy8gY2hhaW5BY2NvdW50IG5vdCByZXF1aXJlZCBmb3IgRXRoZXJldW0gLSBpdCBjYW4gYmUgZGVmaW5lZCBieSB0aGUgYWNjb3VudCB0aGF0IHNpZ25lZCB0aGUgdHJhbnNhY3Rpb25cbiAgY2hhaW5OZXR3b3JrOiBDaGFpbk5ldHdvcmtcbiAgZXhwaXJlU2Vjb25kcz86IG51bWJlclxuICBzaWduZWRUcmFuc2FjdGlvbj86IEpTT05PYmplY3QgLy8gJ3JhdycgdHJhbnNhY3Rpb24gdGhhdCBwb3RlbnRpYWxseSBpbmNsdWRlcyBzaWduYXR1cmVzIHRvb1xuICB0cmFuc2FjdGlvbj86IEpTT05PYmplY3QgLy8gZWl0aGVyIHRyYW5zYWN0aW9uIG9yIHNpZ25lZFRyYW5zYWN0aW9uIC0gbm90IGJvdGhcbiAgZW5jb2RlZFNpZ25lZFRyYW5zYWN0aW9uPzogc3RyaW5nIC8vIFN0cmluZ2lmaWVkLGJhc2U2NCBlbmNvZGVkIHNpZ25lZFRyYW5zYWN0aW9uXG4gIGVuY29kZWRUcmFuc2FjdGlvbj86IHN0cmluZyAvLyBTdHJpbmdpZmllZCxiYXNlNjQgZW5jb2RlZCB0cmFuc2FjdGlvblxuICB0cmFuc2FjdGlvbkNoYWluQWNjb3VudD86IHN0cmluZyAvLyB1c2VkIHRvIHNlcGVjaWZ5IGEgc3BlY2lmaWMgJ2Zyb20nIGFjY291bnQgZm9yIG11bHRpc2lnIHR4XG4gIHRyYW5zYWN0aW9uUmVjb3JkSWQ/OiBzdHJpbmcgLy8gd2hlbiBzZXQsIHNwZWNpZmllcyB0byB1c2UgYSB0cmFuc2FjdGlvbiBzYXZlZCBpbiBPUkVJRFxuICBzaWduT3B0aW9ucz86IFRyYW5zYWN0aW9uU2lnbk9wdGlvbnNcbn1cblxuZXhwb3J0IHR5cGUgVHJhbnNhY3Rpb25TaWduT3B0aW9ucyA9IHtcbiAgYWxsb3dDaGFpbkFjY291bnRTZWxlY3Rpb24/OiBib29sZWFuXG4gIGJyb2FkY2FzdD86IGJvb2xlYW5cbiAgZ2VuZXJhdGVBdXRvU2lnbkNyZWRlbnRpYWw/OiBib29sZWFuXG4gIG11bHRpU2lnQ2hhaW5BY2NvdW50cz86IHN0cmluZyAvLyBDb21tYSBzZXBlcmF0ZWQgc3RyaW5nIG9mIGFjY291bnRzIC0gZm9yIHdoaWNoIE9SRUlEIHNob3VsZCBhZGQgc2lnbmF0dXJlc1xuICAvKiogUHJldmVudHMgdGhlIHVzZSBvZiBhdXRvIHNpZ24gZnVuY3Rpb25hbGl0eSB3aGlsZSBzaWduaW5nIHRoZSB0cmFuc2FjdGlvbiAqL1xuICBwcmV2ZW50QXV0b3NpZ24/OiBib29sZWFuXG4gIHJldHVyblNpZ25lZFRyYW5zYWN0aW9uPzogYm9vbGVhblxuICBzaWduYXR1cmVPbmx5PzogYm9vbGVhblxuICB1c2VyUGFzc3dvcmQ/OiBzdHJpbmcgLy8gY3VzdG9kaWFsXG4gIHVzZXJQYXNzd29yZEVuY3J5cHRlZD86IHN0cmluZyAvLyBwb3NzaWJseSBmcm9tIGxvY2FsIHN0b3JhZ2UgLSBub24gbmVjZXNzYXJpbHkgY3VzdG9kaWFsXG4gIC8vIG5vdCBmb3Igd2lkZ2V0XG4gIGFjY2Vzc1Rva2VuPzogc3RyaW5nXG4gIGNhbGxiYWNrVXJsPzogc3RyaW5nXG4gIHByb3ZpZGVyPzogQXV0aFByb3ZpZGVyIC8vIGZvcmNlIGxvZ2luIHdpdGggdGhpcyBwcm92aWRlclxuICBzaWduRXh0ZXJuYWxXaXRoT3JlSWQ/OiBib29sZWFuIC8vIFJlbW92ZTogb3BlbmluZyB3aWRnZXQgbWVhbnMgdXNpbmcgb3JlaWRcbiAgc3RhdGU/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVUcmFuc2FjdGlvbkRhdGFcbiAgZXh0ZW5kcyBPbWl0PFRyYW5zYWN0aW9uRGF0YSwgJ2FjY291bnQnIHwgJ2VuY29kZWRTaWduZWRUcmFuc2FjdGlvbicgfCAnZW5jb2RlZFRyYW5zYWN0aW9uJz4ge31cbiIsImltcG9ydCB7XG4gIERpc2NvdmVyeUFjY291bnQsXG4gIERpc2NvdmVyQ29udGludWVDYWxsYmFjayxcbiAgRGlzY292ZXJ5T3B0aW9ucyxcbiAgS2V5TG9va3VwQ2FsbGJhY2ssXG4gIFdhbGxldFByb3ZpZGVyLFxuICBNYWtlV2FsbGV0UHJvdmlkZXJGbixcbiAgV2FsbGV0QWNjZXNzQ29udGV4dCxcbiAgV2FsbGV0LFxufSBmcm9tICdAYWlrb24vZW9zLXRyYW5zaXQvbGliJ1xuXG5pbXBvcnQgeyBDaGFpbkFjY291bnQsIENoYWluTmV0d29yaywgRXh0ZXJuYWxXYWxsZXRUeXBlIH0gZnJvbSAnLi4vY29tbW9uL21vZGVscydcbmltcG9ydCB7IFdhbGxldFByb3ZpZGVyQXR0cmlidXRlcyB9IGZyb20gJy4uL3dhbGxldHMvbW9kZWxzJ1xuXG5leHBvcnQgdHlwZSBUcmFuc2l0RGlzY292ZXJ5QWNjb3VudCA9IERpc2NvdmVyeUFjY291bnRcbmV4cG9ydCB0eXBlIFRyYW5zaXREaXNjb3ZlckNvbnRpbnVlQ2FsbGJhY2sgPSBEaXNjb3ZlckNvbnRpbnVlQ2FsbGJhY2tcbmV4cG9ydCB0eXBlIFRyYW5zaXREaXNjb3ZlcktleUxvb2t1cENhbGxiYWNrID0gS2V5TG9va3VwQ2FsbGJhY2tcbmV4cG9ydCB0eXBlIFRyYW5zaXREaXNjb3ZlcnlPcHRpb25zID0gRGlzY292ZXJ5T3B0aW9uc1xuZXhwb3J0IHR5cGUgVHJhbnNpdFdhbGxldFByb3ZpZGVyRmFjdG9yeSA9IE1ha2VXYWxsZXRQcm92aWRlckZuXG5leHBvcnQgdHlwZSBUcmFuc2l0V2FsbGV0UHJvdmlkZXIgPSBXYWxsZXRQcm92aWRlclxuZXhwb3J0IHR5cGUgVHJhbnNpdFdhbGxldEFjY2Vzc0NvbnRleHQgPSBXYWxsZXRBY2Nlc3NDb250ZXh0XG5leHBvcnQgdHlwZSBUcmFuc2l0V2FsbGV0ID0gV2FsbGV0XG5cbmV4cG9ydCB0eXBlIFRyYW5zaXRQcm92aWRlckF0dHJpYnV0ZXMgPSBXYWxsZXRQcm92aWRlckF0dHJpYnV0ZXMgJiB7XG4gIGRpc2NvdmVyeUtleUxvb2t1cEZ1bmM/OiBUcmFuc2l0RGlzY292ZXJLZXlMb29rdXBDYWxsYmFja1xufVxuXG4vLyBUaGUgRGlzY292ZXJ5RGF0YSB0eXBlIGlzIG1pc3NpbmcgJ25vdGUnIGZpZWxkIGluIHRoZSBUcmFuc2l0IExpYnJhcnkgLSByZXBsaWNhdGluZyB0aGUgdHlwZSBoZXJlIGFuZCBhZGRpbmcgbm90ZVxuZXhwb3J0IHR5cGUgVHJhbnNpdERpc2NvdmVyeURhdGEgPSB7XG4gIGtleVRvQWNjb3VudE1hcDogRGlzY292ZXJ5QWNjb3VudFtdXG4gIGtleXM/OiB7XG4gICAgaW5kZXg6IG51bWJlclxuICAgIGtleTogc3RyaW5nXG4gICAgbm90ZT86IHN0cmluZ1xuICB9W11cbn1cblxuLy8gTm90IHN1cmUgd2hhdCB0aGlzIHR5cGUgaXMgLSBwZXJoYXBzIHdoYXQgaXMgcmV0dXJuZWQgZnJvbSB0aGUgd2FsbGV0IGFmdGVyIGxvZ2luP1xuZXhwb3J0IHR5cGUgVHJhbnNpdEFjY291bnRJbmZvID0gYW55XG5cbmV4cG9ydCB0eXBlIENvbm5lY3RUb1RyYW5zaXRQcm92aWRlclBhcmFtcyA9IHtcbiAgY2hhaW5BY2NvdW50PzogQ2hhaW5BY2NvdW50XG4gIGNoYWluTmV0d29yaz86IENoYWluTmV0d29ya1xuICB3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGVcbn1cblxuZXhwb3J0IHR5cGUgU2V0dXBUcmFuc2l0V2FsbGV0UGFyYW1zID0ge1xuICBjaGFpbk5ldHdvcms/OiBDaGFpbk5ldHdvcmtcbiAgd2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlXG59XG4iLCJpbXBvcnQgeyBBdXRoZW50aWNhdG9yLCBDaGFpbiwgVXNlciB9IGZyb20gJ3VuaXZlcnNhbC1hdXRoZW50aWNhdG9yLWxpYnJhcnknXG5pbXBvcnQgeyBDaGFpbkFjY291bnQsIENoYWluTmV0d29yaywgRXh0ZXJuYWxXYWxsZXRUeXBlLCBQdWJsaWNLZXkgfSBmcm9tICcuLi9jb21tb24vbW9kZWxzJ1xuaW1wb3J0IHsgV2FsbGV0UHJvdmlkZXJBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vd2FsbGV0cy9tb2RlbHMnXG5pbXBvcnQgeyBXYWxsZXRQZXJtaXNzaW9uIH0gZnJvbSAnLi4vdXNlci9tb2RlbHMnXG5cbmV4cG9ydCB0eXBlIFVhbFByb3ZpZGVyQXR0cmlidXRlcyA9IFdhbGxldFByb3ZpZGVyQXR0cmlidXRlc1xuXG4vLyBUT0RPOiBSZWRlZmluZSBDaGFpblxuZXhwb3J0IHR5cGUgVWFsQ2hhaW4gPSBDaGFpblxuZXhwb3J0IHR5cGUgVWFsVXNlciA9IFVzZXJcblxuLy8gVE9ETzogdHlwZSB0aGlzLiBMaWtsZXkgc2hvdWxkIGJlIEF1dGhlbnRpY2F0b3IgZnJvbSBFT1NJTyB1bml2ZXJzYWwtYXV0aGVudGljYXRvci1saWJyYXJ5XG5leHBvcnQgdHlwZSBVYWxBdXRoZW50aWNhdG9yRmFjdG9yeSA9IHtcbiAgbmV3IChjaGFpbnM6IFVhbENoYWluW10sIG9wdGlvbnM/OiBhbnkpOiBVYWxBdXRoZW50aWNhdG9yXG4gIG5hbWU6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBVYWxBdXRoZW50aWNhdG9yID0gQXV0aGVudGljYXRvclxuXG5leHBvcnQgdHlwZSBDb25uZWN0VG9VYWxQcm92aWRlclBhcmFtcyA9IHtcbiAgY2hhaW5BY2NvdW50PzogQ2hhaW5BY2NvdW50XG4gIGNoYWluTmV0d29yazogQ2hhaW5OZXR3b3JrXG4gIHdhbGxldFR5cGU6IEV4dGVybmFsV2FsbGV0VHlwZVxufVxuXG5leHBvcnQgdHlwZSBDb25uZWN0VG9VYWxQcm92aWRlclJlc3VsdCA9IHtcbiAgaXNMb2dnZWRJbj86IGJvb2xlYW5cbiAgY2hhaW5BY2NvdW50PzogQ2hhaW5BY2NvdW50XG4gIGNoYWluTmV0d29yaz86IENoYWluTmV0d29ya1xuICBwZXJtaXNzaW9ucz86IHsgbmFtZTogc3RyaW5nOyBwdWJsaWNLZXk6IFB1YmxpY0tleSB9W11cbiAgYXV0aGVudGljYXRvcj86IFVhbEF1dGhlbnRpY2F0b3JcbiAgd2FsbGV0VHlwZT86IEV4dGVybmFsV2FsbGV0VHlwZVxuICB1YWxVc2VyPzogVWFsVXNlclxufVxuXG5leHBvcnQgdHlwZSBTZXR1cFVhbFdhbGxldFBhcmFtcyA9IHtcbiAgY2hhaW5OZXR3b3JrPzogQ2hhaW5OZXR3b3JrXG4gIHdhbGxldFR5cGU6IEV4dGVybmFsV2FsbGV0VHlwZVxufVxuXG5leHBvcnQgdHlwZSBVc2VyQWNjb3VudFBlcm1pc3Npb25zID0ge1xuICBjaGFpbkFjY291bnQ6IENoYWluQWNjb3VudFxuICBjaGFpbk5ldHdvcms6IENoYWluTmV0d29ya1xuICBwZXJtaXNzaW9uczogV2FsbGV0UGVybWlzc2lvbltdXG59XG4iLCJpbXBvcnQgeyBFeHRlcm5hbFdhbGxldFR5cGUsIENoYWluUGxhdGZvcm1UeXBlIH0gZnJvbSAnLi4vY29tbW9uL21vZGVscydcblxuZXhwb3J0IGVudW0gRXh0ZXJuYWxXYWxsZXRJbnRlcmZhY2Uge1xuICBUcmFuc2l0ID0gJ3RyYW5zaXQnLFxuICBVYWwgPSAndWFsJyxcbn1cblxuZXhwb3J0IHR5cGUgV2FsbGV0UHJvdmlkZXJBdHRyaWJ1dGVzID0ge1xuICBwcm92aWRlck5hbWU6IEV4dGVybmFsV2FsbGV0VHlwZVxuICBjaGFpblR5cGU6IENoYWluUGxhdGZvcm1UeXBlXG4gIHByb3ZpZGVySWQ6IHN0cmluZ1xuICByZXF1aXJlc0xvZ2luOiBib29sZWFuXG4gIHN1cHBvcnRzRGlzY292ZXJ5OiBib29sZWFuXG4gIHN1cHBvcnRzU2lnbkFyYml0cmFyeTogYm9vbGVhblxuICByZXF1aXJlc0xvZ291dExvZ2luVG9EaXNjb3ZlcjogYm9vbGVhblxuICByZXF1aXJlc0Rpc2NvdmVyVG9Mb2dpbjogYm9vbGVhblxuICBkZWZhdWx0RGlzY292ZXJ5UGF0aEluZGV4TGlzdD86IG51bWJlcltdXG4gIGhlbHBUZXh0OiB7XG4gICAgbG9naW46IHN0cmluZ1xuICAgIHNpZ246IHN0cmluZ1xuICAgIGRpc2NvdmVyOiBzdHJpbmdcbiAgICB2ZXJzaW9uc1JlcXVpcmVkOiBzdHJpbmdcbiAgfVxuICBsb2dvVXJsOiBzdHJpbmdcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9pbmRlbnQgKi9cblxuaW1wb3J0IHsgQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi4vY29tbW9uL21vZGVscydcblxuLy8gSU1QT1JUQU5UOiBUaGVzZSB0eXBlcyBhcmUgY29waWVkIGZyb20gb3JlaWQtc2VydmljZSB3ZWJ3aWRnZXQgY29kZVxuXG4vKiogdmVyc2lvbiBvZiB3aWRnZXQgc2VydmVkIGJ5IHNlcnZlciB0aGF0IG1hdGNoZXMgdGhlc2UgdHlwZXMgKi9cbmV4cG9ydCBjb25zdCBXaWRnZXRWZXJzaW9uID0gJzEnXG5cbi8qKiBTdWJzZXQgb2YgT3JlSWRPcHRpb25zIHVzZWQgYnkgd2lkZ2V0ICovXG5leHBvcnQgdHlwZSBXZWJXaWRnZXRPcmVJZE9wdGlvbnMgPSB7XG4gIGFjY2Vzc1Rva2VuPzogc3RyaW5nXG4gIGFwcElkOiBzdHJpbmdcbiAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nXG4gIG9yZUlkVXJsPzogc3RyaW5nXG4gIHNldEJ1c3lDYWxsYmFjaz86IChpc0J1c3k6IGJvb2xlYW4pID0+IHZvaWRcbiAgZW9zVHJhbnNpdFdhbGxldFByb3ZpZGVycz86IGFueVtdIC8vIFRPRE86IHJlbW92ZSB0aGVzZSBmcm9tIGJlaW5nIHBhc3NlZCB0byB3ZWJ3aWRnZXRcbn1cblxuZXhwb3J0IHR5cGUgV2ViV2lkZ2V0T25TdWNjZXNzID0gKHsgZGF0YSB9OiB7IGRhdGE/OiBhbnkgfSkgPT4gdm9pZFxuZXhwb3J0IHR5cGUgV2ViV2lkZ2V0T25FcnJvciA9IChlcnJvcjogRXJyb3IpID0+IHZvaWRcblxuZXhwb3J0IHR5cGUgV2ViV2lkZ2V0UHJvcHMgPSB7XG4gIG9yZUlkT3B0aW9uczogV2ViV2lkZ2V0T3JlSWRPcHRpb25zXG4gIGFjdGlvbjoge1xuICAgIG5hbWU6IFdlYldpZGdldEFjdGlvbiB8IHN0cmluZ1xuICAgIHBhcmFtczogV2ViV2lkZ2V0QWN0aW9uUGFyYW1zXG4gIH0gfCBudWxsXG4gIC8qKiBjYWxsYmFjayBvbiBzdWNjZXNzICovXG4gIG9uU3VjY2VzczogV2ViV2lkZ2V0T25TdWNjZXNzXG4gIC8qKiBjYWxsYmFjayBpZiBlcnJvciAtIGVycm9yIG1lc3NhZ2UgaXMgYSBkZWxpbWl0ZWQgc3RyaW5nIG9mIGVycm9yIGNvZGVzIGFuZC9vciBhbiBlcnJvciBtZXNzYWdlICovXG4gIG9uRXJyb3I6IFdlYldpZGdldE9uRXJyb3JcbiAgLyoqIHNvdXJjZSB1cmwgZm9yIHJlcXVlc3QgKGUuZy4gaHR0cHM6Ly95b3VyYXBwLmNvbSkgKi9cbiAgb3JpZ2luOiBzdHJpbmdcbiAgdGltZW91dD86IG51bWJlclxuICAvKiogdGhlIHRpbWUgb2YgdGhlIHJlcXVlc3QgKEVwb2NoIHRpbWUpICovXG4gIHRpbWVzdGFtcD86IG51bWJlclxuICAvKiogdGhlIHNpZ250dXJlIG9mIHRoZSByZXF1ZXN0IGJvZHkgKi9cbiAgc2lnbmF0dXJlPzogc3RyaW5nXG59XG5cbi8qKiBBY3Rpb25zIHN1cHBvcnRlZCBieSB3aWRnZXQgKi9cbmV4cG9ydCBlbnVtIFdlYldpZGdldEFjdGlvbiB7XG4gIEF1dGggPSAnYXV0aCcsXG4gIExvZ291dCA9ICdsb2dvdXQnLFxuICBOZXdDaGFpbkFjY291bnQgPSAnbmV3Q2hhaW5BY2NvdW50JyxcbiAgUmVjb3ZlckFjY291bnQgPSAncmVjb3ZlckFjY291bnQnLFxuICBTaWduID0gJ3NpZ24nLFxuICBCdXkgPSAnYnV5JyxcbiAgS2V5RXhwb3J0ID0gJ2tleUV4cG9ydCcsXG59XG5cbi8qKiBBbHRlcm5hdGl2ZSBtZXRob2QgdG8gc2lnbiBhIHRyYW5zYWN0aW9uIG9yIHN0cmluZyAoY2hhaW4gc3BlY2lmaWMpICovXG5leHBvcnQgZW51bSBTaWduU3RyaW5nTWV0aG9kIHtcbiAgLy8gU2lnbiBTdHJpbmcgbWV0aG9kc1xuICBFdGhlcmV1bVBlcnNvbmFsU2lnbiA9ICdldGhlcmV1bS5wZXJzb25hbC1zaWduJyxcbiAgRXRoZXJldW1TaWduVHlwZWREYXRhID0gJ2V0aGVyZXVtLnNpZ24tdHlwZWQtZGF0YScsXG4gIEV0aGVyZXVtU2lnbiA9ICdldGhlcmV1bS5ldGgtc2lnbicsXG59XG5cbi8qKiBwYXJhbXMgZm9yIExvZ291dCBhY3Rpb24gKi9cbmV4cG9ydCB0eXBlIFdlYldpZGdldExvZ291dFBhcmFtcyA9IHtcbiAgLyoqIGNvbW1hIHNlcGVyYXRlZCBsaXN0IG9mIGxvZ2luIHByb3ZpZGVycyBlLmcuICdnb29nbGUsIGZhY2Vib29rJyBvciAnYWxsJyAqL1xuICBwcm92aWRlcnM/OiBzdHJpbmdcbn1cblxuLyoqIHZhbGlkIGFjdGlvbiBwYXJhbSB0eXBlcyAqL1xuZXhwb3J0IHR5cGUgV2ViV2lkZ2V0QWN0aW9uUGFyYW1zID1cbiAgfCBXZWJXaWRnZXRBdXRoUGFyYW1zXG4gIHwgV2ViV2lkZ2V0TG9nb3V0UGFyYW1zXG4gIHwgV2ViV2lkZ2V0TmV3Q2hhaW5BY2NvdW50UGFyYW1zXG4gIHwgV2ViV2lkZ2V0UmVjb3ZlckFjY291bnRQYXJhbXNcbiAgfCBXZWJXaWRnZXRTaWduUGFyYW1zXG4gIHwgYW55XG5cbi8qKiBwYXJhbXMgZm9yIEF1dGggYWN0aW9uICovXG5leHBvcnQgdHlwZSBXZWJXaWRnZXRBdXRoUGFyYW1zID0ge1xuICAvKiogTG9naW4gcHJvdmlkZXIgKGUuZy4gZ29vZ2xlLCBlbWFpbCkgKi9cbiAgcHJvdmlkZXI/OiBBdXRoUHJvdmlkZXJcbiAgLyoqIHVzZXIncyBpZFRva2VuIC0gY2FuIGJlIGZyb20gYSAzcmQtcGFydHkgKGUuZy4gR29vZ2xlKSAtIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIG5ldyB1c2VyIGFjY291bnQgKi9cbiAgaWRUb2tlbj86IHN0cmluZ1xuICAvKiogcGFzc3dvcmRsZXNzIGxvZ2luIC0gZW1haWwgdG8gbG9naW4gd2l0aCAoYW5kIHRvIHNlbmQgYSB2ZXJpZmljYXRpb24gY29kZSB0bykgKi9cbiAgZW1haWw/OiBzdHJpbmdcbiAgLyoqIHBhc3N3b3JkbGVzcyBsb2dpbiAtIHBob25lIHRvIGxvZ2luIHdpdGggKGFuZCB0byBzZW5kIGEgdmVyaWZpY2F0aW9uIGNvZGUgdG8pICovXG4gIHBob25lPzogc3RyaW5nXG4gIC8qKiB3aGV0aGVyIHdlIHNob3VsZCBsaW5rIHRoaXMgbG9naW4gYXR0ZW1wdCB0byBhbiBleGlzdGluZyB1c2VyICovXG4gIGxpbmtUb0FjY291bnQ/OiBib29sZWFuXG4gIC8qKiB3aGV0aGVyIHdlIHNob3VsZCBza2lwIGNyZWF0aW9uIG9mIGJsb2NrY2hhaW4gYWNjb3VudHMgZm9yIGEgbmV3IHVzZXIgKi9cbiAgZGVsYXlXYWxsZXRTZXR1cD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgV2ViV2lkZ2V0QnV5UGFyYW1zID0ge1xuICAvKiogQmxvY2tjaGFpbiBhY2NvdW50ICh1c3VhbGx5IHRoZSBhY2NvdW50IHNpZ25pbmcgdGhlIHRyYW5zYWN0aW9uKSAqL1xuICBjaGFpbkFjY291bnQ6IHN0cmluZ1xuICAvKiogQSB2YWxpZCBjaGFpbiBuZXR3b3JrIG5hbWUgKGUuZy4gZXRoX21haW4pICovXG4gIGNoYWluTmV0d29yazogc3RyaW5nXG4gIC8qKiBhbGxvd2VkIGNoYWluIG5ldHdvcmtzIGZvciBidXlpbmcgKi9cbiAgbGltaXRUb0NoYWlucz86IHN0cmluZ1tdXG4gIC8qKiBhbGxvd2VkIHN5bWJvbHMgdG8gYmUgYm91Z2h0ICovXG4gIGxpbWl0VG9TeW1ib2xzPzogc3RyaW5nW11cbiAgLyoqIHdoZW4gdHJ1ZSwgYWNjZXB0cyB0ZXN0IGNyZWRpdCBjYXJkIG51bWJlciAgKi9cbiAgdXNlVGVzdE1vZGU/OiBib29sZWFuXG59XG5cbi8qKiBwYXJhbXMgZm9yIE5ldyBBY2NvdW50IGFjdGlvbiAtIHRvIGNyZWF0ZSBhIG5ldyBibG9ja2NoYWluIGFjY291bnQgJ3dpdGhpbicgYSB1c2VyJ3MgT3JlSUQgYWNjb3VudCAqL1xuZXhwb3J0IHR5cGUgV2ViV2lkZ2V0TmV3Q2hhaW5BY2NvdW50UGFyYW1zID0ge1xuICAvKiogVXNlcidzIE9yZUlEIGFjY291bnQgKGFrYSB3YWxsZXQgYWNjb3VudCBuYW1lKSAqL1xuICBhY2NvdW50OiBzdHJpbmdcbiAgLyoqIE9wdGlvbmFsIEpTT04gb2JqZWN0IG9mIGFjY291bnQgY3JlYXRpb24gb3B0aW9ucyAoYmxvY2tjaGFpbi1zcGVjaWZpYykgKi9cbiAgYWNjb3VudE9wdGlvbnM/OiBhbnlcbiAgLyoqIFR5cGUgb2YgYmxvY2tjaGFpbiBhY2NvdW50IHRvIGNyZWF0ZSAtIHVzdWFsbHkgJ25hdGl2ZScgKi9cbiAgYWNjb3VudFR5cGU6IHN0cmluZ1xuICAvKiogQSB2YWxpZCBjaGFpbiBuZXR3b3JrIG5hbWUgKGUuZy4gZXRoX21haW4pICovXG4gIGNoYWluTmV0d29yazogc3RyaW5nXG59XG5cbi8qKiBwYXJhbXMgZm9yIFJlY292ZXIgQWNjb3VudCBhY3Rpb24gKi9cbmV4cG9ydCB0eXBlIFdlYldpZGdldFJlY292ZXJBY2NvdW50UGFyYW1zID0ge1xuICAvKiogVXNlcidzIE9yZUlEIGFjY291bnQgKGFrYSB3YWxsZXQgYWNjb3VudCBuYW1lKSAqL1xuICBhY2NvdW50OiBzdHJpbmdcbiAgLyoqIExvZ2luIHByb3ZpZGVyIChlLmcuIGVtYWlsKSAtIGZvcmNlcyB1c2VyIHRvIGhhdmVkIGxvZ2dlZC1pbiB1c2luZyB0aGlzIHByb3ZpZGVyIGJlZm9yZSByZWNvdmVyeSAqL1xuICBwcm92aWRlcj86IHN0cmluZ1xuICAvKiogVHlwZSBvZiBhY2NvdW50IHJlY292ZXJ5IHJlcXVlc3RlZCAqL1xuICByZWNvdmVyQWN0aW9uPzogc3RyaW5nXG59XG5cbi8qKiBwYXJhbXMgZm9yIFNpZ24gYWN0aW9uICovXG5leHBvcnQgdHlwZSBXZWJXaWRnZXRTaWduUGFyYW1zID0ge1xuICAvKiogVXNlcidzIE9yZUlEIGFjY291bnQgKGFrYSB3YWxsZXQgYWNjb3VudCBuYW1lKSAqL1xuICBhY2NvdW50OiBzdHJpbmdcbiAgLyoqIEJsb2NrY2hhaW4gYWNjb3VudCAodXN1YWxseSB0aGUgYWNjb3VudCBzaWduaW5nIHRoZSB0cmFuc2FjdGlvbikgKi9cbiAgY2hhaW5BY2NvdW50Pzogc3RyaW5nXG4gIC8qKiBBIHZhbGlkIGNoYWluIG5ldHdvcmsgbmFtZSAoZS5nLiBldGhfbWFpbikgKi9cbiAgY2hhaW5OZXR3b3JrOiBzdHJpbmdcbiAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzZWNvbmRzIGZvciB3aGljaCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSB2YWxpZCAoZGVwZW5kcyBvbiBibG9ja2NoYWluLXNwZWNpZmljIGxpbWl0cykgKi9cbiAgZXhwaXJlU2Vjb25kcz86IG51bWJlclxuICAvKiogQSBiYXNlNjQsIHN0cmluZ2lmaWVkLCBKU09OIG9iamVjdCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gc2lnbiAtIHdoaWNoIGFscmVhZHkgaW5jbHVkZXMgb25lIG9yIG1vcmUgc2lnbmF0dXJlcyAqL1xuICBlbmNvZGVkU2lnbmVkVHJhbnNhY3Rpb24/OiBzdHJpbmdcbiAgLyoqIEEgYmFzZTY0LCBzdHJpbmdpZmllZCwgSlNPTiBvYmplY3Qgb2YgdGhlIHRyYW5zYWN0aW9uIHRvIHNpZ24gKGZvcm1hdCBkZXBlbmRzIG9uIGJsb2NrY2hhaW4gdHlwZSkgKi9cbiAgZW5jb2RlZFRyYW5zYWN0aW9uPzogc3RyaW5nXG4gIC8qKiBPcHRpb25hbCAtIHByb3ZpZGVkIGluc3RlYWQgb2YgdHJhbnNhY3Rpb24gLSBPcmVJRCBtdXN0IGhhdmUgdGhpcyB0cmFuc2FjdGlvbiBzYXZlZCBpbiBpdHMgZGF0YWJhc2UgKG9ubHkgYXBwbGllcyB0byBzcGVjaWFsIHNpdHVhdGlvbnMpICovXG4gIHRyYW5zYWN0aW9uUmVjb3JkSWQ/OiBzdHJpbmdcbiAgLyoqIE9wdGlvbmFsIHBhcmFtcyBmb3Igc2lnbmluZyAqL1xuICBzaWduT3B0aW9ucz86IHtcbiAgICAvKiogV2hldGhlciBhbiBvcHRpb24gaXMgZGlzcGxheWVkIHRvIHRoZSB1c2VyIHRvIHNpZ24gd2l0aCBhIGtleSBpbiBhbiBleHRlcm5hbCB3YWxsZXQgKGUuZy4gTWV0YW1hc2spICovXG4gICAgYWxsb3dDaGFpbkFjY291bnRTZWxlY3Rpb24/OiBib29sZWFuXG4gICAgLyoqIFdoZXRoZXIgc2lnbmVkIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IHNlbnQgdG8gdGhlIGNoYWluICovXG4gICAgYnJvYWRjYXN0PzogYm9vbGVhblxuICAgIC8qKiBDb21tYSBzZXBlcmF0ZWQgc3RyaW5nIG9mIGFjY291bnRzIGZvciB3aGljaCBPcmVJRCBzaG91bGQgYWRkIHNpZ25hdHVyZXMgLSBvbmx5IHZhbGlkIGZvciBhY2NvdW50cyBtYW5hZ2VkIGJ5IE9yZUlkICovXG4gICAgbXVsdGlzaWdDaGFpbkFjY291bnRzPzogc3RyaW5nXG4gICAgLyoqIFByZXZlbnRzIHRoZSB1c2Ugb2YgYXV0byBzaWduIGZ1bmN0aW9uYWxpdHkgd2hpbGUgc2lnbmluZyB0aGUgdHJhbnNhY3Rpb24gKi9cbiAgICBwcmV2ZW50QXV0b3NpZ24/OiBib29sZWFuXG4gICAgLyoqIHdoZXRoZXIgdGhlIGNvbXBsZXRlIHNpZ25lZCB0cmFuc2FjdGlvbiBzaG91bGQgYmUgcmV0dXJuZWQgKi9cbiAgICByZXR1cm5TaWduZWRUcmFuc2FjdGlvbj86IGJvb2xlYW5cbiAgICAvKiogb3B0aW9uYWwgc2lnbk1ldGhvZCAtIHVzZXMgZGVmYXVsdCBtZXRob2QgaWYgbm90IHByb3ZpZGVkICovXG4gICAgLy8gc2lnbk1ldGhvZD86IFNpZ25UcmFuc2FjdGlvbk1ldGhvZCAgLy8gRXhwZWN0ZWQgdG8gYmUgdXNlZCBmb3IgRVJDLTcxMiwgZXRjLlxuICB9XG4gIC8qKiBwb3B1bGF0ZWQgaWYgc2lnbmluZyBhIHN0cmluZyBpbnN0ZWFkIG9mIGEgdHJhbnNhY3Rpb24gKi9cbiAgc3RyaW5nVG9TaWduPzogc3RyaW5nXG4gIHNpZ25TdHJpbmdNZXRob2Q/OiBTaWduU3RyaW5nTWV0aG9kXG59XG5cbmV4cG9ydCB0eXBlIFdlYldpZGdldEtleUV4cG9ydFBhcmFtcyA9IHt9XG5cbi8qKiBSZXN1bHQgZm9yIEF1dGggYWN0aW9uICovXG5leHBvcnQgdHlwZSBXZWJXaWRnZXRBdXRoUmVzdWx0ID0ge1xuICAvKiogVXNlcidzIE9yZUlEIGFjY291bnQgKGFrYSB3YWxsZXQgYWNjb3VudCBuYW1lKSAqL1xuICBhY2NvdW50OiBzdHJpbmdcbiAgLyoqIHVzZXIncyBhY2Nlc3NUb2tlbiBzaWduZWQgYnkgT1JFIElEIChpbiBKV1QgZm9ybWF0KSAqL1xuICBhY2Nlc3NUb2tlbj86IHN0cmluZ1xuICAvKiogdXNlcidzIGlkVG9rZW4gc2lnbmVkIGJ5IE9SRSBJRCAoaW4gSldUIGZvcm1hdCkgKi9cbiAgaWRUb2tlbj86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBXZWJXaWRnZXRCdXlSZXN1bHQgPSB7XG4gIC8qKiB1aWQgZm9yIHRyYWNraW5nIGJ1eSByZXF1ZXN0ZWQgKi9cbiAgcmVxdWVzdGVJZDogc3RyaW5nXG4gIC8qKiBvcGVyYXRpb24gc3VjY2VzcyAqL1xuICBzdWNjZXNzOiBib29sZWFuXG4gIC8qKiBlcnJvciBjb2RlIGlmIGFueSAqL1xuICBlcnJvckNvZGU/OiBzdHJpbmdcbiAgLyoqIGVycm9yIG1lc3NhZ2UgaWYgYW55ICovXG4gIGVycm9yTWVzc2FnZT86IHN0cmluZ1xufVxuXG4vKiogUmVzdWx0IGZvciBhIHNlcnZlci1zaWRlIExvZ291dCBhY3Rpb24gKERlcHJpY2F0ZWQpICovXG5leHBvcnQgdHlwZSBXZWJXaWRnZXRMb2dvdXRSZXN1bHQgPSB7fVxuXG4vKiogUmVzdWx0IGZvciBOZXcgQ2hhaW4gQWNjb3VudCBhY3Rpb24gKi9cbmV4cG9ydCB0eXBlIFdlYldpZGdldE5ld0NoYWluQWNjb3VudFJlc3VsdCA9IHtcbiAgLyoqIFVzZXIncyBuZXcgYmxvY2tjaGFpbiBhY2NvdW50IG5hbWUgKi9cbiAgY2hhaW5BY2NvdW50OiBzdHJpbmdcbn1cblxuLyoqIFJlc3VsdCBmb3IgYSBSZWNvdmVyIEFjY291bnQgYWN0aW9uICovXG5leHBvcnQgdHlwZSBXZWJXaWRnZXRSZWNvdmVyQWNjb3VudFJlc3VsdCA9IFdlYldpZGdldEF1dGhSZXN1bHRcblxuLyoqIFJlc3VsdCBmb3IgU2lnbiB0cmFuc2FjdGlvbiBhY3Rpb24gKi9cbmV4cG9ydCB0eXBlIFdlYldpZGdldFNpZ25SZXN1bHQgPSB7XG4gIC8qKiBhcnJheSBvZiBzaWduYXR1cmVzIGNyZWF0ZWQgZHVyaW5nIHNpZ24gZmxvdyAtIHNpZ25hdHVyZXMgbWlnaHQgYmUgc3RyaW5naWZpZWQgb2JqZWN0cyBvciBwdXJlIHN0cmluZ3MgKi9cbiAgc2lnbmF0dXJlcz86IHN0cmluZ1tdXG4gIC8qKiBjb21wbGV0ZWQgc2lnbmVkIHRyYW5zYWN0aW9uIChzdHJpbmdpZmllZCkgKi9cbiAgc2lnbmVkVHJhbnNhY3Rpb24/OiBzdHJpbmdcbiAgLyoqIHRyYW5zYWN0aW9uSWQgdG8gaWRlbnRpZnkgdHJhbnNhY3Rpb24gb24gYmxvY2tjaGFpbiAoaWYgcmV0dXJuZWQpICovXG4gIHRyYW5zYWN0aW9uSWQ/OiBzdHJpbmdcbn1cblxuLyoqIFJlc3VsdCBmb3IgS2V5IEV4cG9ydCBhY3Rpb24gKi9cbmV4cG9ydCB0eXBlIFdlYldpZGdldEtleUV4cG9ydFJlc3VsdCA9IHtcbiAgLy8gIG5vIHJlc3VsdCAtIGp1c3Qgc3VjY2VzcyBvciBlcnJvclxufVxuXG5leHBvcnQgdHlwZSBXZWJXaWRnZXRBY3Rpb25SZXN1bHQgPVxuICB8IFdlYldpZGdldEF1dGhSZXN1bHRcbiAgfCBXZWJXaWRnZXRMb2dvdXRSZXN1bHRcbiAgfCBXZWJXaWRnZXROZXdDaGFpbkFjY291bnRSZXN1bHRcbiAgfCBXZWJXaWRnZXRSZWNvdmVyQWNjb3VudFJlc3VsdFxuICB8IFdlYldpZGdldFNpZ25SZXN1bHRcbiAgfCBXZWJXaWRnZXRLZXlFeHBvcnRSZXN1bHRcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9kZWZhdWx0LXBhcmFtLWxhc3QgKi9cbmltcG9ydCBIZWxwZXJzIGZyb20gJy4uL3V0aWxzL2hlbHBlcnMnXG5pbXBvcnQgeyBKU09OT2JqZWN0LCBBcGlLZXlVc2VkRm9yIH0gZnJvbSAnLi4vbW9kZWxzJ1xuaW1wb3J0IE9yZUlkQ29udGV4dCBmcm9tICcuLi9jb3JlL0lPcmVpZENvbnRleHQnXG5cbmNvbnN0IHsgaXNOdWxsT3JFbXB0eSB9ID0gSGVscGVyc1xuXG4vLyAtLS0tIEFQSSBIZWxwZXIgZnVuY3Rpb25zXG5cbi8qKiBjaGVjayB0aGUgaGVhZGVyIG9mIHRoZSByZXF1ZXN0IGZvciBlYWNoIHJlcXVpcmVkIHBhcmFtIGluIHBhcmFtTmFtZXMgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRIZWFkZXJoYXNSZXF1aXJlZFZhbHVlcyhwYXJhbXM6IEpTT05PYmplY3QgPSB7fSwgcGFyYW1OYW1lczogYW55W10sIGFwaU5hbWU6IHN0cmluZykge1xuICBjb25zdCBtaXNzaW5nOiBhbnlbXSA9IFtdXG4gIHBhcmFtTmFtZXMuZm9yRWFjaChwID0+IHtcbiAgICBpZiAoaXNOdWxsT3JFbXB0eShwYXJhbXNbcF0pKSB7XG4gICAgICBtaXNzaW5nLnB1c2gocClcbiAgICB9XG4gIH0pXG4gIGlmICghaXNOdWxsT3JFbXB0eShtaXNzaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIocykgaW4gcmVxdWVzdCBoZWFkZXIgZm9yIEFQSSAke2FwaU5hbWV9OiAke21pc3Npbmcuam9pbignLCAnKX1gKVxuICB9XG59XG5cbi8qKiBDaGVjayB0aGF0IHdlIGhhdmUgYW4gYXBpS2V5IG9yIGFjY2Vzc1Rva2VuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SGFzQXBpS2V5T3JBY2Nlc3NUb2tlbihvcmVJZENvbnRleHQ6IE9yZUlkQ29udGV4dCwgYXBpTmFtZTogc3RyaW5nKSB7XG4gIGlmICghb3JlSWRDb250ZXh0LmFjY2Vzc1Rva2VuICYmICFvcmVJZENvbnRleHQub3B0aW9ucz8uYXBpS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVpcmVkIGhlYWRlciBmb3IgQVBJICR7YXBpTmFtZX06IE11c3QgaGF2ZSBhIHZhbGlkIHVzZXIgYWNjZXNzVG9rZW4gb3Igb3B0aW9ucy5hcGlLZXlgKVxuICB9XG59XG5cbi8qKiBDaGVjayB0aGF0IHdlIGhhdmUgYW4gYWNjZXNzVG9rZW4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRIYXNBY2Nlc3NUb2tlbihvcmVJZENvbnRleHQ6IE9yZUlkQ29udGV4dCwgYXBpTmFtZTogc3RyaW5nKSB7XG4gIGlmICghb3JlSWRDb250ZXh0LmFjY2Vzc1Rva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVpcmVkIGhlYWRlciBmb3IgQVBJICR7YXBpTmFtZX06IE11c3QgaGF2ZSBhIHZhbGlkIHVzZXIgYWNjZXNzVG9rZW5gKVxuICB9XG59XG5cbi8qKiBDaGVjayB0aGF0IHdlIGhhdmUgYW4gYXBpS2V5ICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SGFzQXBpS2V5KG9yZUlkQ29udGV4dDogT3JlSWRDb250ZXh0LCB1c2VkRm9yOiBBcGlLZXlVc2VkRm9yLCBhcGlOYW1lOiBzdHJpbmcpIHtcbiAgaWYgKCFvcmVJZENvbnRleHQub3B0aW9ucz8uYXBpS2V5KSB7XG4gICAgY29uc3QgdXNlZEZwck1zZyA9IHVzZWRGb3IgPyBgIC0gd2l0aCAke3VzZWRGb3J9IHJpZ2h0LmAgOiAnLidcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgcmVxdWlyZWQgaGVhZGVyIGZvciBBUEkgJHthcGlOYW1lfTogTXVzdCBoYXZlIGFuIG9wdGlvbnMuYXBpS2V5JHt1c2VkRnByTXNnfWApXG4gIH1cbn1cblxuLyoqIENoZWNrIEFQSSBwYXJhbXMgZm9yIGVhY2ggcmVxdWlyZWQgcGFyYW0gaW4gcGFyYW1OYW1lcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFBhcmFtc0hhdmVSZXF1aXJlZFZhbHVlcyhwYXJhbXM6IEpTT05PYmplY3QgPSB7fSwgcGFyYW1OYW1lczogYW55W10sIGFwaU5hbWU6IHN0cmluZykge1xuICBjb25zdCBtaXNzaW5nOiBhbnlbXSA9IFtdXG4gIHBhcmFtTmFtZXMuZm9yRWFjaChwID0+IHtcbiAgICBpZiAoaXNOdWxsT3JFbXB0eShwYXJhbXNbcF0pKSB7XG4gICAgICBtaXNzaW5nLnB1c2gocClcbiAgICB9XG4gIH0pXG4gIGlmICghaXNOdWxsT3JFbXB0eShtaXNzaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIocykgZm9yIEFQSSAke2FwaU5hbWV9OiAke21pc3Npbmcuam9pbignLCAnKX1gKVxuICB9XG59XG5cbi8qKiBDaGVjayBBUEkgcGFyYW1zIC0gbXVzdCBpbmNsdWRlIGF0IGxlYXN0IG9uZSBvZiB0aGUgcGFyYW1zIGluIHRoZSBsaXN0ICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UGFyYW1zSGF2ZUF0TGVhc3RPbmVPZlZhbHVlcyhwYXJhbXM6IEpTT05PYmplY3QgPSB7fSwgcGFyYW1OYW1lczogYW55W10sIGFwaU5hbWU6IHN0cmluZykge1xuICBjb25zdCBtYXRjaGVzID0gcGFyYW1OYW1lcy5maWx0ZXIocCA9PiB7XG4gICAgcmV0dXJuICFpc051bGxPckVtcHR5KHBhcmFtc1twXSlcbiAgfSlcbiAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGF0IGxlYXN0IG9uZSBvZiB0aGVzZSBwYXJhbWV0ZXIocykgZm9yIEFQSSAke2FwaU5hbWV9OiAke3BhcmFtTmFtZXMuam9pbignLCAnKX1gKVxuICB9XG59XG5cbi8qKiBDaGVjayBBUEkgcGFyYW1zIC0gbXVzdCBpbmNsdWRlIG9uZSBhbmQgb25seSBvbmUgb2YgcGFyYW1zIGluIHRoZSBsaXN0ICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UGFyYW1zSGF2ZU9ubHlPbmVPZlZhbHVlcyhwYXJhbXM6IEpTT05PYmplY3QgPSB7fSwgcGFyYW1OYW1lczogYW55W10sIGFwaU5hbWU6IHN0cmluZykge1xuICBjb25zdCBtYXRjaGVzID0gcGFyYW1OYW1lcy5maWx0ZXIocCA9PiB7XG4gICAgcmV0dXJuICFpc051bGxPckVtcHR5KHBhcmFtc1twXSlcbiAgfSlcbiAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbiBvbmx5IHByb3ZpZGUgb25lIG9mIHRoZXNlIHBhcmFtZXRlcihzKSBmb3IgQVBJICR7YXBpTmFtZX06ICR7cGFyYW1OYW1lcy5qb2luKCcsICcpfWApXG4gIH1cbn1cblxuLyoqIHJlbW92ZSBwcm9jZXNzSWQgZnJvbSBkYXRhICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFByb2Nlc3NJZEZyb21EYXRhKGRhdGE6IGFueSkge1xuICBsZXQgcHJvY2Vzc0lkXG4gIGlmIChkYXRhPy5wcm9jZXNzSWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICBwcm9jZXNzSWQgPSBkYXRhLnByb2Nlc3NJZFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGRlbGV0ZSBkYXRhLnByb2Nlc3NJZFxuICB9XG4gIHJldHVybiB7IGRhdGEsIHByb2Nlc3NJZCB9XG59XG4iLCIvKlxuICAgIGhlbHBlciBmdW5jdGlvbnNcbiAqL1xuaW1wb3J0IHsgQXhpb3NFcnJvciB9IGZyb20gJ2F4aW9zJ1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCdcbmltcG9ydCBjYW5vbmljYWxpemUgZnJvbSAnY2Fub25pY2FsaXplJ1xuaW1wb3J0IGp3dERlY29kZSBmcm9tICdqd3QtZGVjb2RlJ1xuaW1wb3J0IHsgQmFzZTY0IH0gZnJvbSAnanMtYmFzZTY0J1xuaW1wb3J0IHsgSldUVG9rZW4gfSBmcm9tICcuLi9hdXRoL21vZGVscydcbmltcG9ydCB7IEF1dGhQcm92aWRlciwgRXh0ZXJuYWxXYWxsZXRUeXBlLCBKU09OT2JqZWN0LCBMb29rdXAgfSBmcm9tICcuLi9jb21tb24vbW9kZWxzJ1xuXG5jb25zdCBUUkFDSU5HID0gZmFsc2UgLy8gZW5hYmxlIHdoZW4gZGVidWdnaW5nIHRvIHNlZSBkZXRhaWxlZCBvdXRwdXRzXG5cbi8vIHNwbGl0IGEgc3RyaW5nIG9yIGFycmF5IGF0IGEgZ2l2ZW4gaW5kZXggcG9zaXRpb25cbmV4cG9ydCBjb25zdCBzcGxpdEF0ID0gKGluZGV4OiBudW1iZXIsIGRyb3BDaGFyczogbnVtYmVyKSA9PiAoeDogc3RyaW5nKSA9PlxuICBbeC5zbGljZSgwLCBpbmRleCksIHguc2xpY2UoaW5kZXggKyBkcm9wQ2hhcnMpXVxuXG5jb25zdCByZXBsYWNlQWxsID0gKGluU3RyaW5nOiBzdHJpbmcsIHNlYXJjaDogc3RyaW5nLCByZXBsYWNlbWVudDogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBpblN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAoc2VhcmNoLCAnZycpLCByZXBsYWNlbWVudClcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscGVycyB7XG4gIHN0YXRpYyBpc0luQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG5cbiAgc3RhdGljIGlzTnVsbE9yRW1wdHkob2JqOiBhbnkpIHtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIENoZWNrIGZvciBhbiBlbXB0eSBhcnJheSB0b29cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICBpZiAob2JqLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDAgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3RcbiAgfVxuXG4gIC8vIGxvZyBkYXRhXG4gIHN0YXRpYyBsb2cobWVzc2FnZTogc3RyaW5nLCBkYXRhPzogYW55KSB7XG4gICAgaWYgKFRSQUNJTkcpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZyhtZXNzYWdlLCBkYXRhKVxuICAgIH1cbiAgfVxuXG4gIC8qKiBEZWNvZGVzIGEgSldUIHRva2VuIHN0cmluZ1xuICAgKiAgSWYgdG9rZW4gY2FuJ3QgYmUgZGVjb2RlZCAoZS5nLiBjb3JydXB0ZWQpLCByZXR1cm5zIG51bGwgKi9cbiAgc3RhdGljIGp3dERlY29kZVNhZmUodG9rZW46IHN0cmluZyk6IFBhcnRpYWw8SldUVG9rZW4+IHtcbiAgICBsZXQgZGVjb2RlZDogSldUVG9rZW5cbiAgICBpZiAodGhpcy5pc051bGxPckVtcHR5KHRva2VuKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRlY29kZWQgPSBqd3REZWNvZGUodG9rZW4pIGFzIEpXVFRva2VuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHRocm93IEVycm9yKGBQcm9ibGVtIGRlY29kaW5nIG9yIHZhbGlkYXRpbmcgSldUIHRva2VuOiAke3Rva2VufSBlcnJvcjoke2Vycm9yfWApXG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkXG4gIH1cblxuICAvKiogIFRha2VzIGEgdXJsIHN0cmluZyBhbmQgY29udmVydHMgaXQgdG8gYW4gb2JqZWN0IG9mIHtwYXJhbU5hbmUsIHBhcmFtVmFsdWV9XG4gICAqIGUuZyBpbnB1dDogaHR0cHM6Ly94eHg/ZW5hYmxlZCZuYW1lPXZhbHVlJm5hbWUyPXZhbDJcbiAgICogICByZXR1cm5zOiB7ICdlbmFibGVkJzogdHJ1ZSwgJ25hbWUnOid2YWx1ZScsICduYW1lMic6J3ZhbDInIH1cbiAgICogaWYgdGhlIHBhcmFtZXRlciBvbmx5IGhhcyBhIG5hbWUgYW5kIG5vIHZhbHVlLCB0aGVuIGl0cyB2YWx1ZSBpcyBzZXQgdG8gJ3RydWUnXG4gICAqICovXG4gIHN0YXRpYyBwYXJzZVVybFBhcmFtcyhmdWxsUGF0aDogc3RyaW5nKSB7XG4gICAgY29uc3QgdXJsUGFyYW1zT2JqZWN0OiBKU09OT2JqZWN0ID0ge31cbiAgICBsZXQgc2VhcmNoU3RyaW5nXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwoZnVsbFBhdGgpXG4gICAgICBpZiAodXJsT2JqZWN0Lmhhc2gpIHtcbiAgICAgICAgc2VhcmNoU3RyaW5nID0gdXJsT2JqZWN0Lmhhc2guc2xpY2UoMSkgLy8gcmVtb3ZlICNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlYXJjaFN0cmluZyA9IHVybE9iamVjdC5zZWFyY2hcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc2VhcmNoU3RyaW5nID0gZnVsbFBhdGggLy8gdHJlYXQgYXMgcGFydGlhbCB1cmwgc3RyaW5nIEUuZy4gJz9wYXJhbTE9dmFsdWUxLi4uJ1xuICAgIH1cblxuICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoU3RyaW5nKVxuICAgIHVybFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICB1cmxQYXJhbXNPYmplY3Rba2V5XSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgfHwgJ3RydWUnXG4gICAgfSlcblxuICAgIHJldHVybiB1cmxQYXJhbXNPYmplY3RcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIE51bGwgaWYgcGFyc2UgZmFpbHNcbiAgICogIFJlaW5mbGF0ZXMgYSBzZXJpYWxpemVkIG9iamVjdCAoZS5nLiBVSW50OEFycmF5KSBpZiBmb3VuZCBpbiBKU09OXG4gICAqL1xuICBzdGF0aWMgdHJ5UGFyc2VKU09OKGpzb25TdHJpbmc6IGFueSwgdW5lc2NhcGUgPSBmYWxzZSwgcmVwbGFjZVF1b3RlcyA9IGZhbHNlKSB7XG4gICAgbGV0IGZpbmFsSnNvblN0cmluZyA9ICcnXG4gICAgaWYgKCFqc29uU3RyaW5nIHx8ICFIZWxwZXJzLmlzQVN0cmluZyhqc29uU3RyaW5nKSB8fCBqc29uU3RyaW5nLnRyaW0oKSA9PT0gJycpIHJldHVybiBudWxsXG4gICAgdHJ5IHtcbiAgICAgIGlmICh1bmVzY2FwZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAganNvblN0cmluZyA9IGRlY29kZVVSSShqc29uU3RyaW5nKVxuICAgICAgfVxuICAgICAgZmluYWxKc29uU3RyaW5nID0ganNvblN0cmluZ1xuICAgICAgaWYgKHJlcGxhY2VRdW90ZXMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHF1b3Rlc1xuICAgICAgICBmaW5hbEpzb25TdHJpbmcgPSByZXBsYWNlQWxsKGpzb25TdHJpbmcsIFwiJ1wiLCAnXCInKVxuICAgICAgICBmaW5hbEpzb25TdHJpbmcgPSByZXBsYWNlQWxsKGZpbmFsSnNvblN0cmluZywgJ2AnLCAnXCInKVxuICAgICAgfVxuICAgICAgY29uc3QgbyA9IEpTT04ucGFyc2UoZmluYWxKc29uU3RyaW5nLCBIZWxwZXJzLmpzb25QYXJzZUNvbXBsZXhPYmplY3RSZXZpdmVyKVxuICAgICAgLy8gSGFuZGxlIG5vbi1leGNlcHRpb24tdGhyb3dpbmcgY2FzZXM6XG4gICAgICAvLyBOZWl0aGVyIEpTT04ucGFyc2UoZmFsc2UpIG9yIEpTT04ucGFyc2UoMTIzNCkgdGhyb3cgZXJyb3JzLCBoZW5jZSB0aGUgdHlwZS1jaGVja2luZyxcbiAgICAgIC8vIGJ1dC4uLiBKU09OLnBhcnNlKG51bGwpIHJldHVybnMgbnVsbCwgYW5kIHR5cGVvZiBudWxsID09PSBcIm9iamVjdFwiLFxuICAgICAgLy8gc28gd2UgbXVzdCBjaGVjayBmb3IgdGhhdCwgdG9vLiBUaGFua2Z1bGx5LCBudWxsIGlzIGZhbHNleSwgc28gdGhpcyBzdWZmaWNlczpcbiAgICAgIGlmIChvICYmIHR5cGVvZiBvID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gb1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBUT0RPOiBzaG91bGQgbG9nIHRyYWNlIHRoaXMgZGV0YWlsOiAoJ2Vycm9yIHBhcnNpbmcgSlNPTicsIHsganNvblN0cmluZywgZG91YmxlUXVvdGVzLCBlcnJvciB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByZXZpdmVyIGZ1bmN0aW9uIHBhc3NlZCBpbnRvIEpTT04ucGFyc2UgdG8gaW1wbGVtZW50IGN1c3RvbSB0eXBlIGNvbnZlcnNpb25zLlxuICAgKiBJZiB0aGUgdmFsdWUgaXMgYSBwcmV2aW91c2x5IHN0cmluZ2lmaWVkIGJ1ZmZlciB3ZSBjb252ZXJ0IGl0IHRvIGEgQnVmZmVyLFxuICAgKiBJZiBpdHMgYW4gb2JqZWN0IG9mIG51bWJlcnMsIHdlIGNvbnZlcnQgdG8gVUludDhBcnJheSB7XCIwXCI6MixcIjFcIjoyMDksXCIyXCI6OCAuLi59XG4gICAqIG90aGVyd2lzZSByZXR1cm4gdGhlIHZhbHVlXG4gICAqL1xuICBzdGF0aWMganNvblBhcnNlQ29tcGxleE9iamVjdFJldml2ZXIoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICAvLyBDb252ZXJ0IEJ1ZmZlclxuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAndHlwZScgaW4gdmFsdWUgJiZcbiAgICAgIHZhbHVlLnR5cGUgPT09ICdCdWZmZXInICYmXG4gICAgICAnZGF0YScgaW4gdmFsdWUgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUuZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZS5kYXRhKVxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgbnVtYmVyIGFycmF5IHRvIFVJbnQ4QXJyYXkgZS5nLiB7XCIwXCI6MixcIjFcIjoyMDksXCIyXCI6OCAuLi59XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgICAgJzAnIGluIHZhbHVlICYmXG4gICAgICBIZWxwZXJzLmlzQU51bWJlcih2YWx1ZVsnMCddKVxuICAgICkge1xuICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoWywgdmFsXSkgPT4gdmFsKVxuICAgICAgLy8gaWYgYXJyYXkgb25seSBoYXMgOC1iaXQgbnVtYmVycywgY29udmVydCBpdCB0byBVSW50OEFycmF5XG4gICAgICBpZiAodmFsdWVzLmV2ZXJ5KHZhbCA9PiBIZWxwZXJzLmlzQU51bWJlcih2YWwpIHx8IHZhbCA8IDI1NikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbHVlcyBhcyBudW1iZXJbXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gcGFyc2VkIHZhbHVlIHdpdGhvdXQgbW9kaWZ5aW5nXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBzdGF0aWMgYmFzZTY0RGVjb2RlU2FmZShlbmNvZGVkU3RyaW5nOiBzdHJpbmcpIHtcbiAgICBsZXQgZGVjb2RlZDogYW55ID0ge31cbiAgICBpZiAodGhpcy5pc051bGxPckVtcHR5KGVuY29kZWRTdHJpbmcpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB0cnkge1xuICAgICAgZGVjb2RlZCA9IEJhc2U2NC5kZWNvZGUoZW5jb2RlZFN0cmluZylcbiAgICAgIC8vIGlmIGRlY29kZWQgdmFsdWUgaXMgYSBzdHJpbmdpZmllZCBKU09OIG9iamVjdCwgcmV0dXJuIHRoZSBvYmplY3RcbiAgICAgIGlmIChIZWxwZXJzLnRyeVBhcnNlSlNPTihkZWNvZGVkKSkge1xuICAgICAgICBkZWNvZGVkID0gSlNPTi5wYXJzZShkZWNvZGVkKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBsb2dFcnJvcignUHJvYmxlbSBkZWNvZGluZyBiYXNlNjREZWNvZGVTYWZlOicsZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWRcbiAgfVxuXG4gIC8qKiAgQmFzZTY0IGVuY29kZXMgYSBzdHJpbmdcbiAgICogaWYgdmFsdWUgcGFzc2VkIGluIGlzIGFuIE9iamVjdCBvciBKU09OLCBpdCB3aWxsIGJlIHN0cmluZ2lmaWVkIGZpcnN0XG4gICAqIGlmIHZhbHVlIGlzIG51bGwsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBudWxsICovXG4gIHN0YXRpYyBiYXNlNjRFbmNvZGUodmFsdWVJbjogYW55KSB7XG4gICAgaWYgKCF2YWx1ZUluKSByZXR1cm4gbnVsbFxuICAgIGxldCB2YWx1ZSA9IHZhbHVlSW5cbiAgICBpZiAoSGVscGVycy5pc0FuT2JqZWN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIEJhc2U2NC5lbmNvZGUodmFsdWUpXG4gIH1cblxuICBzdGF0aWMgc2xlZXAobXM6IG51bWJlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUd1aWQoKSB7XG4gICAgcmV0dXJuIHV1aWR2NCgpXG4gIH1cblxuICAvKiogVHlwZXNjcmlwdCBUeXBlZ3VhcmQgdG8gdmVyaWZ5IHRoYXQgdGhlIHZhbHVlIGlzIGluIHRoZSBlbnVtVHlwZSBzcGVjaWZpZWQgICovXG4gIHN0YXRpYyBpc0luRW51bTxUPihlbnVtVHlwZTogVCwgdmFsdWU6IGFueSk6IHZhbHVlIGlzIFRba2V5b2YgVF0ge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKGVudW1UeXBlKS5pbmNsdWRlcyh2YWx1ZSBhcyBUW2tleW9mIFRdKVxuICB9XG5cbiAgLyoqIFR5cGVzY3JpcHQgVHlwZWd1YXJkIGhlbHBlciB0byBlbnN1cmUgdGhhdCBhIHN0cmluZyB2YWx1ZSBjYW4gYmUgYXNzaWduZWQgdG8gYW4gRW51bSB0eXBlXG4gICAqICBJZiBhIHZhbHVlIGNhbid0IGJlIG1hdGNoZWQgdG8gYSB2YWxpZCBvcHRpb24gaW4gdGhlIGVudW0sIHJldHVybnMgbnVsbCAob3IgdGhyb3dzIGlmIHRocm93SWZJbnZhbGlkID0gdHJ1ZSkgKi9cbiAgc3RhdGljIHRvRW51bVZhbHVlPFQ+KGU6IFQsIHZhbHVlOiBhbnksIHRocm93SWZJbnZhbGlkID0gZmFsc2UpOiBUW2tleW9mIFRdIHtcbiAgICBpZiAodGhpcy5pc051bGxPckVtcHR5KHZhbHVlKSkgcmV0dXJuIG51bGxcbiAgICBpZiAodGhpcy5pc0luRW51bTxUPihlLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICBjb25zdCBlcnJNc2cgPSBgVmFsdWUgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9IGlzIG5vdCBhIHZhbGlkIG1lbWJlciBvZiBlbnVtICR7SlNPTi5zdHJpbmdpZnkoZSl9LmBcbiAgICBpZiAodGhyb3dJZkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKiogUGFyc2VzIGNvbW1hLXNlcGVyYXRlZCBlcnJvcl9jb2RlcyBmcm9tIHVybCByZXNwb25zZVxuICAgKiBSZXR1cm5zOiBhcnJheSBvZiBlcnJvciBjb2RlIHN0cmluZ3NcbiAgICogTm90ZTogUGFyYW1zIGlzIGEgamF2YXNjcmlwdCBvYmplY3QgcGFyc2VkIGZyb20gY2FsbGJhY2sgVVJMIHN0cmluZyAqL1xuICBzdGF0aWMgZ2V0RXJyb3JDb2Rlc0Zyb21QYXJhbXMocGFyYW1zOiBhbnkpIHtcbiAgICBsZXQgZXJyb3JDb2Rlczogc3RyaW5nW11cbiAgICBjb25zdCBlcnJvclN0cmluZyA9IHBhcmFtcy5lcnJvcl9jb2RlIHx8IHBhcmFtcy5lcnJvckNvZGVcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBwYXJhbXMuZXJyb3JfbWVzc2FnZSB8fCBwYXJhbXMuZXJyb3JNZXNzYWdlXG4gICAgaWYgKGVycm9yU3RyaW5nKSB7XG4gICAgICBlcnJvckNvZGVzID0gZXJyb3JTdHJpbmcuc3BsaXQoL1svPy8kJl0vKVxuICAgIH1cbiAgICBpZiAoZXJyb3JDb2RlcyB8fCBlcnJvck1lc3NhZ2UpIHtcbiAgICAgIGVycm9yQ29kZXMgPSBlcnJvckNvZGVzIHx8IFtdXG4gICAgICBlcnJvckNvZGVzLnB1c2goZXJyb3JNZXNzYWdlKVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3JDb2Rlc1xuICB9XG5cbiAgLyoqIFJldHJpZXZlIHZhbHVlcyBmcm9tIGEgdXJsIHF1ZXJ5IHN0cmluZyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVtXG4gICAqICBBbHNvIHBhcnNlcyBlcnJvciBjb2RlcyByZXR1cm5lZCBpbnRvIGFuIGFycmF5IG9mIGVycm9ycyBjb2Rlcy9tZXNzYWdlc1xuICAgKi9cbiAgc3RhdGljIGV4dHJhY3REYXRhRnJvbUNhbGxiYWNrVXJsKHVybDogc3RyaW5nKSB7XG4gICAgbGV0IHBhcmFtczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9XG4gICAgaWYgKHVybCkge1xuICAgICAgcGFyYW1zID0gdGhpcy5wYXJzZVVybFBhcmFtcyh1cmwpXG4gICAgICBjb25zdCBlcnJvcnMgPSB0aGlzLmdldEVycm9yQ29kZXNGcm9tUGFyYW1zKHBhcmFtcylcbiAgICAgIHJldHVybiB7IC4uLnBhcmFtcywgZXJyb3JzIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG5cbiAgLyoqIENhbGwgdGhlIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkgYW5kIGF3YWl0IGZvciBlYWNoIHRvIGZpbmlzaCBpbiB0dXJuICovXG4gIHN0YXRpYyBhc3luYyBhc3luY0ZvckVhY2goYXJyYXk6IGFueVtdLCBjYWxsYmFjazogKGl0ZW06IGFueSwgaW5kZXg6IG51bWJlciwgYXJyYXk6IGFueVtdKSA9PiBQcm9taXNlPGFueT4pIHtcbiAgICBpZiAoSGVscGVycy5pc051bGxPckVtcHR5KGFycmF5KSkgcmV0dXJuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5Lmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zZW1pXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgYXdhaXQgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpXG4gICAgfVxuICB9XG5cbiAgLyoqIFJldHVybiBhIHZhbHVlIGluIGEgY3VzdG9tIGNsYWltIGluIGEgSldUIHRva2VuIGJ5IHVzaW5nIGEgcGFydGlhbCBjbGFpbSBuYW1lXG4gICAqICBlLmcuIGZ1bmN0aW9uKHRva2VuLCAnYXBwSWQnKSA9PiB2YWx1ZSBmb3IgY2xhaW0gaHR0cHM6Ly9vcmVpZC5pby9hcHBJZCAqL1xuICBzdGF0aWMgZ2V0Q2xhaW1Gcm9tSnd0VG9rZW5CeVNlYXJjaFN0cmluZyhkZWNvZGVkVG9rZW46IEpXVFRva2VuLCBzZWFyY2hTdHJpbmc6IHN0cmluZykge1xuICAgIGxldCB2YWx1ZTogc3RyaW5nXG4gICAgaWYgKCF0aGlzLmlzQW5PYmplY3QoZGVjb2RlZFRva2VuKSkgcmV0dXJuIG51bGxcbiAgICAvLyBsb29wIHRocm91Z2ggaXRlbXMgaW4gdG9rZW4gdG8gZmluZCBtYXRjaGluZyBzdHJpbmdcbiAgICBPYmplY3Qua2V5cyhkZWNvZGVkVG9rZW4pLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpZiAoaXRlbS5pbmNsdWRlcyhzZWFyY2hTdHJpbmcpKSB7XG4gICAgICAgIHZhbHVlID0gKGRlY29kZWRUb2tlbiBhcyBMb29rdXApW2l0ZW1dXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKiBnZXQgZXJyb3IgZnJvbSBpbnNpZGUgYSBuZXR3b3JrIHJlcXVlc3QgKEF4aW9zIEVycm9yIG9iamVjdCkgYW5kIHJldHVybiBpdCAqL1xuICBzdGF0aWMgZ2V0RXJyb3JGcm9tQXhpb3NFcnJvcihlcnJvcjogQXhpb3NFcnJvcikge1xuICAgIC8vIEJyb3dzZXIgdGhyZSBhbiBlcnJvciBkdXJpbmcgQ09SUyBwcmVmbGlnaHQgcG9zdCAtIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYXhpb3MvYXhpb3MvaXNzdWVzLzExNDNcbiAgICBpZiAoZXJyb3I/Lm1lc3NhZ2UudG9Mb3dlckNhc2UoKSA9PT0gJ25ldHdvcmsgZXJyb3InKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdCcm93c2VyIHRocmV3IGEgTmV0d29yayBFcnJvci4gVGhpcyBpcyBsaWtlbHkgYmVjYXVzZSBvZiBDT1JTIGVycm9yLiBNYWtlIHN1cmUgdGhhdCB5b3UgYXJlIG5vdCBzZW5kaW5nIGFuIGFwaS1rZXkgaW4gdGhlIGhlYWRlciBvZiB0aGUgcmVxdWVzdC4nLFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAoZXJyb3I/LmNvZGUgPT09ICdFQ09OTlJFRlVTRUQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBjb25uZWN0IHRvIE9SRSBJRCBzZXJ2aWNlLiAke2Vycm9yLm1lc3NhZ2V9LmApXG4gICAgfVxuXG4gICAgaWYgKCFIZWxwZXJzLmlzQXhpb3NFcnJvcihlcnJvcikpIHtcbiAgICAgIHJldHVybiBlcnJvclxuICAgIH1cbiAgICAvLyBleHRyYWN0IGVycm9yIG1lc3NhZ2UgZnJvbSBBeGlvcyBFcnJvciBhbmQgcmV0dXJuIG5ldyBFcnJvclxuICAgIGNvbnN0IHsgZGF0YSA9IHt9IH0gPSBlcnJvcj8ucmVzcG9uc2UgfHwge31cbiAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IGRhdGFcbiAgICBjb25zdCBlcnJvckNvZGVzID0gdGhpcy5nZXRFcnJvckNvZGVzRnJvbVBhcmFtcyhkYXRhKVxuICAgIC8vIG9yZWlkIGFwaXMgcGFzcyBiYWNrIGVycm9yQ29kZS9lcnJvck1lc3NhZ2VzXG4gICAgLy8gYWxzbyBoYW5kbGUgd2hlbiBhIHN0YW5kYXJkIGVycm9yIG1lc3NhZ2UgaXMgdGhyb3duXG4gICAgY29uc3QgZXJyb3JDb2Rlc0xpc3QgPSBlcnJvckNvZGVzICYmIGVycm9yQ29kZXM/Lmxlbmd0aCA+IDEgPyBlcnJvckNvZGVzLmpvaW4oJywgJykgOiBlcnJvckNvZGVzXG4gICAgY29uc3QgZXJyb3JTdHJpbmcgPSBlcnJvckNvZGVzTGlzdCB8fCBtZXNzYWdlIHx8ICd1bmtub3duIGVycm9yJ1xuICAgIHJldHVybiBFcnJvcihlcnJvclN0cmluZylcbiAgfVxuXG4gIHN0YXRpYyBpc0F4aW9zRXJyb3IoZXJyb3I6IGFueSk6IGVycm9yIGlzIEF4aW9zRXJyb3Ige1xuICAgIHJldHVybiAoZXJyb3IgYXMgQXhpb3NFcnJvcikuaXNBeGlvc0Vycm9yICE9PSB1bmRlZmluZWRcbiAgfVxuXG4gIHN0YXRpYyBpc0FTdHJpbmcodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZ1xuICB9XG5cbiAgc3RhdGljIGlzQURhdGUodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGVcbiAgfVxuXG4gIHN0YXRpYyBpc0FCb29sZWFuKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuXG4gIH1cblxuICBzdGF0aWMgaXNBTnVtYmVyKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbHVlKSkgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXJcbiAgfVxuXG4gIHN0YXRpYyBpc0FuT2JqZWN0KG9iajogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xuICB9XG5cbiAgLyoqIHRocm93IGVycm9yIGlmIGludmFsaWQgcHJvdmlkZXIgKi9cbiAgc3RhdGljIGFzc2VydFZhbGlkUHJvdmlkZXIocHJvdmlkZXI6IEF1dGhQcm92aWRlcikge1xuICAgIGlmIChIZWxwZXJzLmlzSW5FbnVtKEF1dGhQcm92aWRlciwgcHJvdmlkZXIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dGggcHJvdmlkZXIgJHtwcm92aWRlcn0gaXMgbm90IGEgdmFsaWQgb3B0aW9uYClcbiAgfVxuXG4gIC8qKiBDb252ZXJ0IGFuIEF1dGhQcm92aWRlciB0byB0aGUgRXh0ZXJuYWxXYWxsZXRUeXBlIHN1YnNldFxuICAgKiAgUmV0dXJucyBudWxsIGlmIGNhbid0IGNvbnZlcnQgbWVtYmVyICovXG4gIHN0YXRpYyBtYXBBdXRoUHJvdmlkZXJUb1dhbGxldFR5cGUocHJvdmlkZXI6IEF1dGhQcm92aWRlciB8IEV4dGVybmFsV2FsbGV0VHlwZSkge1xuICAgIGlmICghcHJvdmlkZXIpIHJldHVybiBudWxsXG4gICAgcmV0dXJuIEhlbHBlcnMudG9FbnVtVmFsdWUoRXh0ZXJuYWxXYWxsZXRUeXBlLCBwcm92aWRlcilcbiAgfVxuXG4gIHN0YXRpYyBpc0N1c3RvZGlhbChwcm92aWRlcjogQXV0aFByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIHByb3ZpZGVyID09PSBBdXRoUHJvdmlkZXIuQ3VzdG9kaWFsXG4gIH1cblxuICBzdGF0aWMgaXNWYWxpZEVtYWlsKGVtYWlsOiBhbnkpOiBib29sZWFuIHtcbiAgICBpZiAoIWVtYWlsKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBlbWFpbFJlZ2V4ID1cbiAgICAgIC9eKChbXjw+KClbXVxcXFwuLDs6XFxzQF0rKFxcLltePD4oKVtdXFxcXC4sOzpcXHNAXSspKil8KC4rKSlAKChbWzAtOV17MSwzfVxcWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC9cbiAgICByZXR1cm4gZW1haWxSZWdleC50ZXN0KGVtYWlsKVxuICB9XG5cbiAgLyoqIFNvcnQgSlNPTiBpbiBhIGRldGVybWluaXN0aWMgd2F5ICovXG4gIHN0YXRpYyBzb3J0SnNvbih2YWx1ZTogYW55KTogYW55IHtcbiAgICBpZiAoIXZhbHVlKSByZXR1cm4gdmFsdWVcbiAgICBjb25zdCBzdHJpbmdpZmllZCA9IGNhbm9uaWNhbGl6ZSh2YWx1ZSlcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmdpZmllZClcbiAgfVxuXG4gIC8qKiBmaWx0ZXIgY29tcGxleCB2YWx1ZXMgaW4gYXJyYXkgZG93biB0byBhbiBhcnJheSBvZiBhIHNpbmdsZSwgdW5pcXVlcyB2YWx1ZXNcbiAgICogZS5nLiBpZiBhcnJheSA9IFt7dmFsdWU6J0EnLCBvdGhlcn0sIHt2YWx1ZTonQicsIHNvbWV0aGluZ30sIHt2YWx1ZTonQScsIG90aGVyfV1cbiAgICogICAgICAgPT4gW3t2YWx1ZTonQScsIG90aGVyfSwge3ZhbHVlOidCJywgc29tZXRoaW5nfV0gKi9cbiAgc3RhdGljIGdldFVuaXF1ZVZhbHVlczxUPihhcnJheTogVFtdKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChhcnJheS5tYXAoaXRlbSA9PiBKU09OLnN0cmluZ2lmeShpdGVtKSkpKS5tYXAoaXRlbSA9PiBKU09OLnBhcnNlKGl0ZW0pKVxuICB9XG5cbiAgLyoqIEV4ZWN1dGUgYSBjYWxsYmFjayBmdW5jdGlvbiBhdCBhIGdpdmVuIFVuaXggRXBvY2ggdGltZSAqL1xuICBzdGF0aWMgcnVuQXRUaW1lKGNhbGxiYWNrOiBGdW5jdGlvbiwgZXhlY3V0aW9uRW9vY2hUaW1lOiBudW1iZXIpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgcnVuQXRUaW1lID0gTWF0aC5tYXgoZXhlY3V0aW9uRW9vY2hUaW1lLCBub3cpIC8vIGlmIGV4ZWN1dGlvbkVvb2NoVGltZSBpcyBpbiB0aGUgcGFzdCwgdXNlIHRoZSBjdXJyZW50IHRpbWUgdG8gcnVuIHRoZSBmdW5jdGlvbiBpbW1lZGlhdGVseVxuICAgIHJldHVybiBzZXRUaW1lb3V0KGNhbGxiYWNrLCBydW5BdFRpbWUgLSBub3cpXG4gIH1cblxuICAvKiogd2hldGhlciBvYmplY3RzIGFyZSAnZXF1YWwnIGJ5IGRlZXAgY29tcGFyaW5nIGFsbCBtZW1iZXJzICovXG4gIHN0YXRpYyBvYmplY3RzQXJlRXF1YWwoYTogYW55LCBiOiBhbnkpIHtcbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWVcbiAgICBpZiAodHlwZW9mIGEgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9PSAnb2JqZWN0JyB8fCBhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKGEpXG4gICAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhiKVxuICAgIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5c0EpIHtcbiAgICAgIGlmICgha2V5c0IuaW5jbHVkZXMoa2V5KSkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAodHlwZW9mIGFba2V5XSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYltrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChhW2tleV0udG9TdHJpbmcoKSAhPT0gYltrZXldLnRvU3RyaW5nKCkpIHJldHVybiBmYWxzZVxuICAgICAgfSBlbHNlIGlmICghSGVscGVycy5vYmplY3RzQXJlRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuIiwiLyoganNoaW50IGVzdmVyc2lvbjogNiAqL1xuLyoganNsaW50IG5vZGU6IHRydWUgKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXJpYWxpemUgKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnIHx8IG9iamVjdC50b0pTT04gIT0gbnVsbCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmplY3QpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIHJldHVybiAnWycgKyBvYmplY3QucmVkdWNlKCh0LCBjdiwgY2kpID0+IHtcbiAgICAgIGNvbnN0IGNvbW1hID0gY2kgPT09IDAgPyAnJyA6ICcsJztcbiAgICAgIGNvbnN0IHZhbHVlID0gY3YgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY3YgPT09ICdzeW1ib2wnID8gbnVsbCA6IGN2O1xuICAgICAgcmV0dXJuIHQgKyBjb21tYSArIHNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgfSwgJycpICsgJ10nO1xuICB9XG5cbiAgcmV0dXJuICd7JyArIE9iamVjdC5rZXlzKG9iamVjdCkuc29ydCgpLnJlZHVjZSgodCwgY3YsIGNpKSA9PiB7XG4gICAgaWYgKG9iamVjdFtjdl0gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICB0eXBlb2Ygb2JqZWN0W2N2XSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICBjb25zdCBjb21tYSA9IHQubGVuZ3RoID09PSAwID8gJycgOiAnLCc7XG4gICAgcmV0dXJuIHQgKyBjb21tYSArIHNlcmlhbGl6ZShjdikgKyAnOicgKyBzZXJpYWxpemUob2JqZWN0W2N2XSk7XG4gIH0sICcnKSArICd9Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiYXNlNjRfdXJsX2RlY29kZSA9IHJlcXVpcmUoJy4vYmFzZTY0X3VybF9kZWNvZGUnKTtcblxuZnVuY3Rpb24gSW52YWxpZFRva2VuRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5JbnZhbGlkVG9rZW5FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbkludmFsaWRUb2tlbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0ludmFsaWRUb2tlbkVycm9yJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodG9rZW4sb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVG9rZW5FcnJvcignSW52YWxpZCB0b2tlbiBzcGVjaWZpZWQnKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcG9zID0gb3B0aW9ucy5oZWFkZXIgPT09IHRydWUgPyAwIDogMTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShiYXNlNjRfdXJsX2RlY29kZSh0b2tlbi5zcGxpdCgnLicpW3Bvc10pKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVG9rZW5FcnJvcignSW52YWxpZCB0b2tlbiBzcGVjaWZpZWQ6ICcgKyBlLm1lc3NhZ2UpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5JbnZhbGlkVG9rZW5FcnJvciA9IEludmFsaWRUb2tlbkVycm9yO1xuIiwidmFyIGF0b2IgPSByZXF1aXJlKCcuL2F0b2InKTtcblxuZnVuY3Rpb24gYjY0RGVjb2RlVW5pY29kZShzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChhdG9iKHN0cikucmVwbGFjZSgvKC4pL2csIGZ1bmN0aW9uIChtLCBwKSB7XG4gICAgdmFyIGNvZGUgPSBwLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKGNvZGUubGVuZ3RoIDwgMikge1xuICAgICAgY29kZSA9ICcwJyArIGNvZGU7XG4gICAgfVxuICAgIHJldHVybiAnJScgKyBjb2RlO1xuICB9KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciBvdXRwdXQgPSBzdHIucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gIHN3aXRjaCAob3V0cHV0Lmxlbmd0aCAlIDQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBvdXRwdXQgKz0gXCI9PVwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgb3V0cHV0ICs9IFwiPVwiO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IFwiSWxsZWdhbCBiYXNlNjR1cmwgc3RyaW5nIVwiO1xuICB9XG5cbiAgdHJ5e1xuICAgIHJldHVybiBiNjREZWNvZGVVbmljb2RlKG91dHB1dCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBhdG9iKG91dHB1dCk7XG4gIH1cbn07XG4iLCIvKipcbiAqIFRoZSBjb2RlIHdhcyBleHRyYWN0ZWQgZnJvbTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGNoYW1iZXJzL0Jhc2U2NC5qc1xuICovXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEludmFsaWRDaGFyYWN0ZXJFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkludmFsaWRDaGFyYWN0ZXJFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbkludmFsaWRDaGFyYWN0ZXJFcnJvci5wcm90b3R5cGUubmFtZSA9ICdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InO1xuXG5mdW5jdGlvbiBwb2x5ZmlsbCAoaW5wdXQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhpbnB1dCkucmVwbGFjZSgvPSskLywgJycpO1xuICBpZiAoc3RyLmxlbmd0aCAlIDQgPT0gMSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IoXCInYXRvYicgZmFpbGVkOiBUaGUgc3RyaW5nIHRvIGJlIGRlY29kZWQgaXMgbm90IGNvcnJlY3RseSBlbmNvZGVkLlwiKTtcbiAgfVxuICBmb3IgKFxuICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyc1xuICAgIHZhciBiYyA9IDAsIGJzLCBidWZmZXIsIGlkeCA9IDAsIG91dHB1dCA9ICcnO1xuICAgIC8vIGdldCBuZXh0IGNoYXJhY3RlclxuICAgIGJ1ZmZlciA9IHN0ci5jaGFyQXQoaWR4KyspO1xuICAgIC8vIGNoYXJhY3RlciBmb3VuZCBpbiB0YWJsZT8gaW5pdGlhbGl6ZSBiaXQgc3RvcmFnZSBhbmQgYWRkIGl0cyBhc2NpaSB2YWx1ZTtcbiAgICB+YnVmZmVyICYmIChicyA9IGJjICUgNCA/IGJzICogNjQgKyBidWZmZXIgOiBidWZmZXIsXG4gICAgICAvLyBhbmQgaWYgbm90IGZpcnN0IG9mIGVhY2ggNCBjaGFyYWN0ZXJzLFxuICAgICAgLy8gY29udmVydCB0aGUgZmlyc3QgOCBiaXRzIHRvIG9uZSBhc2NpaSBjaGFyYWN0ZXJcbiAgICAgIGJjKysgJSA0KSA/IG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSAmIGJzID4+ICgtMiAqIGJjICYgNikpIDogMFxuICApIHtcbiAgICAvLyB0cnkgdG8gZmluZCBjaGFyYWN0ZXIgaW4gdGFibGUgKDAtNjMsIG5vdCBmb3VuZCA9PiAtMSlcbiAgICBidWZmZXIgPSBjaGFycy5pbmRleE9mKGJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hdG9iICYmIHdpbmRvdy5hdG9iLmJpbmQod2luZG93KSB8fCBwb2x5ZmlsbDtcbiIsIi8qKlxuICogIGJhc2U2NC50c1xuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQlNEIDMtQ2xhdXNlIExpY2Vuc2UuXG4gKiAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogIFJlZmVyZW5jZXM6XG4gKiAgICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NFxuICpcbiAqIEBhdXRob3IgRGFuIEtvZ2FpIChodHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkpXG4gKi9cbmNvbnN0IHZlcnNpb24gPSAnMy43LjInO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgbG93ZXJjYXNlIGB2ZXJzaW9uYC5cbiAqL1xuY29uc3QgVkVSU0lPTiA9IHZlcnNpb247XG5jb25zdCBfaGFzYXRvYiA9IHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nO1xuY29uc3QgX2hhc2J0b2EgPSB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IF9oYXNCdWZmZXIgPSB0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nO1xuY29uc3QgX1REID0gdHlwZW9mIFRleHREZWNvZGVyID09PSAnZnVuY3Rpb24nID8gbmV3IFRleHREZWNvZGVyKCkgOiB1bmRlZmluZWQ7XG5jb25zdCBfVEUgPSB0eXBlb2YgVGV4dEVuY29kZXIgPT09ICdmdW5jdGlvbicgPyBuZXcgVGV4dEVuY29kZXIoKSA6IHVuZGVmaW5lZDtcbmNvbnN0IGI2NGNoID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcbmNvbnN0IGI2NGNocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGI2NGNoKTtcbmNvbnN0IGI2NHRhYiA9ICgoYSkgPT4ge1xuICAgIGxldCB0YWIgPSB7fTtcbiAgICBhLmZvckVhY2goKGMsIGkpID0+IHRhYltjXSA9IGkpO1xuICAgIHJldHVybiB0YWI7XG59KShiNjRjaHMpO1xuY29uc3QgYjY0cmUgPSAvXig/OltBLVphLXpcXGQrXFwvXXs0fSkqPyg/OltBLVphLXpcXGQrXFwvXXsyfSg/Oj09KT98W0EtWmEtelxcZCtcXC9dezN9PT8pPyQvO1xuY29uc3QgX2Zyb21DQyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYmluZChTdHJpbmcpO1xuY29uc3QgX1U4QWZyb20gPSB0eXBlb2YgVWludDhBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nXG4gICAgPyBVaW50OEFycmF5LmZyb20uYmluZChVaW50OEFycmF5KVxuICAgIDogKGl0LCBmbiA9ICh4KSA9PiB4KSA9PiBuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpdCwgMCkubWFwKGZuKSk7XG5jb25zdCBfbWtVcmlTYWZlID0gKHNyYykgPT4gc3JjXG4gICAgLnJlcGxhY2UoLz0vZywgJycpLnJlcGxhY2UoL1srXFwvXS9nLCAobTApID0+IG0wID09ICcrJyA/ICctJyA6ICdfJyk7XG5jb25zdCBfdGlkeUI2NCA9IChzKSA9PiBzLnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXS9nLCAnJyk7XG4vKipcbiAqIHBvbHlmaWxsIHZlcnNpb24gb2YgYGJ0b2FgXG4gKi9cbmNvbnN0IGJ0b2FQb2x5ZmlsbCA9IChiaW4pID0+IHtcbiAgICAvLyBjb25zb2xlLmxvZygncG9seWZpbGxlZCcpO1xuICAgIGxldCB1MzIsIGMwLCBjMSwgYzIsIGFzYyA9ICcnO1xuICAgIGNvbnN0IHBhZCA9IGJpbi5sZW5ndGggJSAzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDspIHtcbiAgICAgICAgaWYgKChjMCA9IGJpbi5jaGFyQ29kZUF0KGkrKykpID4gMjU1IHx8XG4gICAgICAgICAgICAoYzEgPSBiaW4uY2hhckNvZGVBdChpKyspKSA+IDI1NSB8fFxuICAgICAgICAgICAgKGMyID0gYmluLmNoYXJDb2RlQXQoaSsrKSkgPiAyNTUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGNoYXJhY3RlciBmb3VuZCcpO1xuICAgICAgICB1MzIgPSAoYzAgPDwgMTYpIHwgKGMxIDw8IDgpIHwgYzI7XG4gICAgICAgIGFzYyArPSBiNjRjaHNbdTMyID4+IDE4ICYgNjNdXG4gICAgICAgICAgICArIGI2NGNoc1t1MzIgPj4gMTIgJiA2M11cbiAgICAgICAgICAgICsgYjY0Y2hzW3UzMiA+PiA2ICYgNjNdXG4gICAgICAgICAgICArIGI2NGNoc1t1MzIgJiA2M107XG4gICAgfVxuICAgIHJldHVybiBwYWQgPyBhc2Muc2xpY2UoMCwgcGFkIC0gMykgKyBcIj09PVwiLnN1YnN0cmluZyhwYWQpIDogYXNjO1xufTtcbi8qKlxuICogZG9lcyB3aGF0IGB3aW5kb3cuYnRvYWAgb2Ygd2ViIGJyb3dzZXJzIGRvLlxuICogQHBhcmFtIHtTdHJpbmd9IGJpbiBiaW5hcnkgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQtZW5jb2RlZCBzdHJpbmdcbiAqL1xuY29uc3QgX2J0b2EgPSBfaGFzYnRvYSA/IChiaW4pID0+IGJ0b2EoYmluKVxuICAgIDogX2hhc0J1ZmZlciA/IChiaW4pID0+IEJ1ZmZlci5mcm9tKGJpbiwgJ2JpbmFyeScpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICA6IGJ0b2FQb2x5ZmlsbDtcbmNvbnN0IF9mcm9tVWludDhBcnJheSA9IF9oYXNCdWZmZXJcbiAgICA/ICh1OGEpID0+IEJ1ZmZlci5mcm9tKHU4YSkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgOiAodThhKSA9PiB7XG4gICAgICAgIC8vIGNmLiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjcxMDAwMS9ob3ctdG8tY29udmVydC11aW50OC1hcnJheS10by1iYXNlNjQtZW5jb2RlZC1zdHJpbmcvMTI3MTMzMjYjMTI3MTMzMjZcbiAgICAgICAgY29uc3QgbWF4YXJncyA9IDB4MTAwMDtcbiAgICAgICAgbGV0IHN0cnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB1OGEubGVuZ3RoOyBpIDwgbDsgaSArPSBtYXhhcmdzKSB7XG4gICAgICAgICAgICBzdHJzLnB1c2goX2Zyb21DQy5hcHBseShudWxsLCB1OGEuc3ViYXJyYXkoaSwgaSArIG1heGFyZ3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9idG9hKHN0cnMuam9pbignJykpO1xuICAgIH07XG4vKipcbiAqIGNvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1cmxzYWZlXSBVUkwtYW5kLWZpbGVuYW1lLXNhZmUgYSBsYSBSRkM0NjQ4IMKnNVxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IHN0cmluZ1xuICovXG5jb25zdCBmcm9tVWludDhBcnJheSA9ICh1OGEsIHVybHNhZmUgPSBmYWxzZSkgPT4gdXJsc2FmZSA/IF9ta1VyaVNhZmUoX2Zyb21VaW50OEFycmF5KHU4YSkpIDogX2Zyb21VaW50OEFycmF5KHU4YSk7XG4vLyBUaGlzIHRyaWNrIGlzIGZvdW5kIGJyb2tlbiBodHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtYmFzZTY0L2lzc3Vlcy8xMzBcbi8vIGNvbnN0IHV0b2IgPSAoc3JjOiBzdHJpbmcpID0+IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzcmMpKTtcbi8vIHJldmVydGluZyBnb29kIG9sZCBmYXRpb25lZCByZWdleHBcbmNvbnN0IGNiX3V0b2IgPSAoYykgPT4ge1xuICAgIGlmIChjLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdmFyIGNjID0gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICByZXR1cm4gY2MgPCAweDgwID8gY1xuICAgICAgICAgICAgOiBjYyA8IDB4ODAwID8gKF9mcm9tQ0MoMHhjMCB8IChjYyA+Pj4gNikpXG4gICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoY2MgJiAweDNmKSkpXG4gICAgICAgICAgICAgICAgOiAoX2Zyb21DQygweGUwIHwgKChjYyA+Pj4gMTIpICYgMHgwZikpXG4gICAgICAgICAgICAgICAgICAgICsgX2Zyb21DQygweDgwIHwgKChjYyA+Pj4gNikgJiAweDNmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoY2MgJiAweDNmKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGNjID0gMHgxMDAwMFxuICAgICAgICAgICAgKyAoYy5jaGFyQ29kZUF0KDApIC0gMHhEODAwKSAqIDB4NDAwXG4gICAgICAgICAgICArIChjLmNoYXJDb2RlQXQoMSkgLSAweERDMDApO1xuICAgICAgICByZXR1cm4gKF9mcm9tQ0MoMHhmMCB8ICgoY2MgPj4+IDE4KSAmIDB4MDcpKVxuICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoKGNjID4+PiAxMikgJiAweDNmKSlcbiAgICAgICAgICAgICsgX2Zyb21DQygweDgwIHwgKChjYyA+Pj4gNikgJiAweDNmKSlcbiAgICAgICAgICAgICsgX2Zyb21DQygweDgwIHwgKGNjICYgMHgzZikpKTtcbiAgICB9XG59O1xuY29uc3QgcmVfdXRvYiA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZGXXxbXlxceDAwLVxceDdGXS9nO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBzaG91bGQgaGF2ZSBiZWVuIGludGVybmFsIHVzZSBvbmx5LlxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyBVVEYtOCBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVURi0xNiBzdHJpbmdcbiAqL1xuY29uc3QgdXRvYiA9ICh1KSA9PiB1LnJlcGxhY2UocmVfdXRvYiwgY2JfdXRvYik7XG4vL1xuY29uc3QgX2VuY29kZSA9IF9oYXNCdWZmZXJcbiAgICA/IChzKSA9PiBCdWZmZXIuZnJvbShzLCAndXRmOCcpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIDogX1RFXG4gICAgICAgID8gKHMpID0+IF9mcm9tVWludDhBcnJheShfVEUuZW5jb2RlKHMpKVxuICAgICAgICA6IChzKSA9PiBfYnRvYSh1dG9iKHMpKTtcbi8qKlxuICogY29udmVydHMgYSBVVEYtOC1lbmNvZGVkIHN0cmluZyB0byBhIEJhc2U2NCBzdHJpbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1cmxzYWZlXSBpZiBgdHJ1ZWAgbWFrZSB0aGUgcmVzdWx0IFVSTC1zYWZlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgc3RyaW5nXG4gKi9cbmNvbnN0IGVuY29kZSA9IChzcmMsIHVybHNhZmUgPSBmYWxzZSkgPT4gdXJsc2FmZVxuICAgID8gX21rVXJpU2FmZShfZW5jb2RlKHNyYykpXG4gICAgOiBfZW5jb2RlKHNyYyk7XG4vKipcbiAqIGNvbnZlcnRzIGEgVVRGLTgtZW5jb2RlZCBzdHJpbmcgdG8gVVJMLXNhZmUgQmFzZTY0IFJGQzQ2NDggwqc1LlxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IHN0cmluZ1xuICovXG5jb25zdCBlbmNvZGVVUkkgPSAoc3JjKSA9PiBlbmNvZGUoc3JjLCB0cnVlKTtcbi8vIFRoaXMgdHJpY2sgaXMgZm91bmQgYnJva2VuIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1iYXNlNjQvaXNzdWVzLzEzMFxuLy8gY29uc3QgYnRvdSA9IChzcmM6IHN0cmluZykgPT4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzcmMpKTtcbi8vIHJldmVydGluZyBnb29kIG9sZCBmYXRpb25lZCByZWdleHBcbmNvbnN0IHJlX2J0b3UgPSAvW1xceEMwLVxceERGXVtcXHg4MC1cXHhCRl18W1xceEUwLVxceEVGXVtcXHg4MC1cXHhCRl17Mn18W1xceEYwLVxceEY3XVtcXHg4MC1cXHhCRl17M30vZztcbmNvbnN0IGNiX2J0b3UgPSAoY2NjYykgPT4ge1xuICAgIHN3aXRjaCAoY2NjYy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdmFyIGNwID0gKCgweDA3ICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCAxOClcbiAgICAgICAgICAgICAgICB8ICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkgPDwgMTIpXG4gICAgICAgICAgICAgICAgfCAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpIDw8IDYpXG4gICAgICAgICAgICAgICAgfCAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgzKSksIG9mZnNldCA9IGNwIC0gMHgxMDAwMDtcbiAgICAgICAgICAgIHJldHVybiAoX2Zyb21DQygob2Zmc2V0ID4+PiAxMCkgKyAweEQ4MDApXG4gICAgICAgICAgICAgICAgKyBfZnJvbUNDKChvZmZzZXQgJiAweDNGRikgKyAweERDMDApKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9mcm9tQ0MoKCgweDBmICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCAxMilcbiAgICAgICAgICAgICAgICB8ICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkgPDwgNilcbiAgICAgICAgICAgICAgICB8ICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDIpKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gX2Zyb21DQygoKDB4MWYgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDYpXG4gICAgICAgICAgICAgICAgfCAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkpO1xuICAgIH1cbn07XG4vKipcbiAqIEBkZXByZWNhdGVkIHNob3VsZCBoYXZlIGJlZW4gaW50ZXJuYWwgdXNlIG9ubHkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFVURi0xNiBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVURi04IHN0cmluZ1xuICovXG5jb25zdCBidG91ID0gKGIpID0+IGIucmVwbGFjZShyZV9idG91LCBjYl9idG91KTtcbi8qKlxuICogcG9seWZpbGwgdmVyc2lvbiBvZiBgYXRvYmBcbiAqL1xuY29uc3QgYXRvYlBvbHlmaWxsID0gKGFzYykgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKCdwb2x5ZmlsbGVkJyk7XG4gICAgYXNjID0gYXNjLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIGlmICghYjY0cmUudGVzdChhc2MpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYWxmb3JtZWQgYmFzZTY0LicpO1xuICAgIGFzYyArPSAnPT0nLnNsaWNlKDIgLSAoYXNjLmxlbmd0aCAmIDMpKTtcbiAgICBsZXQgdTI0LCBiaW4gPSAnJywgcjEsIHIyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXNjLmxlbmd0aDspIHtcbiAgICAgICAgdTI0ID0gYjY0dGFiW2FzYy5jaGFyQXQoaSsrKV0gPDwgMThcbiAgICAgICAgICAgIHwgYjY0dGFiW2FzYy5jaGFyQXQoaSsrKV0gPDwgMTJcbiAgICAgICAgICAgIHwgKHIxID0gYjY0dGFiW2FzYy5jaGFyQXQoaSsrKV0pIDw8IDZcbiAgICAgICAgICAgIHwgKHIyID0gYjY0dGFiW2FzYy5jaGFyQXQoaSsrKV0pO1xuICAgICAgICBiaW4gKz0gcjEgPT09IDY0ID8gX2Zyb21DQyh1MjQgPj4gMTYgJiAyNTUpXG4gICAgICAgICAgICA6IHIyID09PSA2NCA/IF9mcm9tQ0ModTI0ID4+IDE2ICYgMjU1LCB1MjQgPj4gOCAmIDI1NSlcbiAgICAgICAgICAgICAgICA6IF9mcm9tQ0ModTI0ID4+IDE2ICYgMjU1LCB1MjQgPj4gOCAmIDI1NSwgdTI0ICYgMjU1KTtcbiAgICB9XG4gICAgcmV0dXJuIGJpbjtcbn07XG4vKipcbiAqIGRvZXMgd2hhdCBgd2luZG93LmF0b2JgIG9mIHdlYiBicm93c2VycyBkby5cbiAqIEBwYXJhbSB7U3RyaW5nfSBhc2MgQmFzZTY0LWVuY29kZWQgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBiaW5hcnkgc3RyaW5nXG4gKi9cbmNvbnN0IF9hdG9iID0gX2hhc2F0b2IgPyAoYXNjKSA9PiBhdG9iKF90aWR5QjY0KGFzYykpXG4gICAgOiBfaGFzQnVmZmVyID8gKGFzYykgPT4gQnVmZmVyLmZyb20oYXNjLCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpXG4gICAgICAgIDogYXRvYlBvbHlmaWxsO1xuLy9cbmNvbnN0IF90b1VpbnQ4QXJyYXkgPSBfaGFzQnVmZmVyXG4gICAgPyAoYSkgPT4gX1U4QWZyb20oQnVmZmVyLmZyb20oYSwgJ2Jhc2U2NCcpKVxuICAgIDogKGEpID0+IF9VOEFmcm9tKF9hdG9iKGEpLCBjID0+IGMuY2hhckNvZGVBdCgwKSk7XG4vKipcbiAqIGNvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIFVpbnQ4QXJyYXkuXG4gKi9cbmNvbnN0IHRvVWludDhBcnJheSA9IChhKSA9PiBfdG9VaW50OEFycmF5KF91blVSSShhKSk7XG4vL1xuY29uc3QgX2RlY29kZSA9IF9oYXNCdWZmZXJcbiAgICA/IChhKSA9PiBCdWZmZXIuZnJvbShhLCAnYmFzZTY0JykudG9TdHJpbmcoJ3V0ZjgnKVxuICAgIDogX1REXG4gICAgICAgID8gKGEpID0+IF9URC5kZWNvZGUoX3RvVWludDhBcnJheShhKSlcbiAgICAgICAgOiAoYSkgPT4gYnRvdShfYXRvYihhKSk7XG5jb25zdCBfdW5VUkkgPSAoYSkgPT4gX3RpZHlCNjQoYS5yZXBsYWNlKC9bLV9dL2csIChtMCkgPT4gbTAgPT0gJy0nID8gJysnIDogJy8nKSk7XG4vKipcbiAqIGNvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIFVURi04IHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgQmFzZTY0IHN0cmluZy4gIEJvdGggbm9ybWFsIGFuZCBVUkwtc2FmZSBhcmUgc3VwcG9ydGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBVVEYtOCBzdHJpbmdcbiAqL1xuY29uc3QgZGVjb2RlID0gKHNyYykgPT4gX2RlY29kZShfdW5VUkkoc3JjKSk7XG4vKipcbiAqIGNoZWNrIGlmIGEgdmFsdWUgaXMgYSB2YWxpZCBCYXNlNjQgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3JjIGEgdmFsdWUgdG8gY2hlY2tcbiAgKi9cbmNvbnN0IGlzVmFsaWQgPSAoc3JjKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcyA9IHNyYy5yZXBsYWNlKC9cXHMrL2csICcnKS5yZXBsYWNlKC89ezAsMn0kLywgJycpO1xuICAgIHJldHVybiAhL1teXFxzMC05YS16QS1aXFwrL10vLnRlc3QocykgfHwgIS9bXlxcczAtOWEtekEtWlxcLV9dLy50ZXN0KHMpO1xufTtcbi8vXG5jb25zdCBfbm9FbnVtID0gKHYpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9O1xufTtcbi8qKlxuICogZXh0ZW5kIFN0cmluZy5wcm90b3R5cGUgd2l0aCByZWxldmFudCBtZXRob2RzXG4gKi9cbmNvbnN0IGV4dGVuZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBfYWRkID0gKG5hbWUsIGJvZHkpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCBuYW1lLCBfbm9FbnVtKGJvZHkpKTtcbiAgICBfYWRkKCdmcm9tQmFzZTY0JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlKHRoaXMpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NCcsIGZ1bmN0aW9uICh1cmxzYWZlKSB7IHJldHVybiBlbmNvZGUodGhpcywgdXJsc2FmZSk7IH0pO1xuICAgIF9hZGQoJ3RvQmFzZTY0VVJJJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlKHRoaXMsIHRydWUpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NFVSTCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZSh0aGlzLCB0cnVlKTsgfSk7XG4gICAgX2FkZCgndG9VaW50OEFycmF5JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMpOyB9KTtcbn07XG4vKipcbiAqIGV4dGVuZCBVaW50OEFycmF5LnByb3RvdHlwZSB3aXRoIHJlbGV2YW50IG1ldGhvZHNcbiAqL1xuY29uc3QgZXh0ZW5kVWludDhBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBfYWRkID0gKG5hbWUsIGJvZHkpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVaW50OEFycmF5LnByb3RvdHlwZSwgbmFtZSwgX25vRW51bShib2R5KSk7XG4gICAgX2FkZCgndG9CYXNlNjQnLCBmdW5jdGlvbiAodXJsc2FmZSkgeyByZXR1cm4gZnJvbVVpbnQ4QXJyYXkodGhpcywgdXJsc2FmZSk7IH0pO1xuICAgIF9hZGQoJ3RvQmFzZTY0VVJJJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJvbVVpbnQ4QXJyYXkodGhpcywgdHJ1ZSk7IH0pO1xuICAgIF9hZGQoJ3RvQmFzZTY0VVJMJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJvbVVpbnQ4QXJyYXkodGhpcywgdHJ1ZSk7IH0pO1xufTtcbi8qKlxuICogZXh0ZW5kIEJ1aWx0aW4gcHJvdG90eXBlcyB3aXRoIHJlbGV2YW50IG1ldGhvZHNcbiAqL1xuY29uc3QgZXh0ZW5kQnVpbHRpbnMgPSAoKSA9PiB7XG4gICAgZXh0ZW5kU3RyaW5nKCk7XG4gICAgZXh0ZW5kVWludDhBcnJheSgpO1xufTtcbmNvbnN0IGdCYXNlNjQgPSB7XG4gICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICBWRVJTSU9OOiBWRVJTSU9OLFxuICAgIGF0b2I6IF9hdG9iLFxuICAgIGF0b2JQb2x5ZmlsbDogYXRvYlBvbHlmaWxsLFxuICAgIGJ0b2E6IF9idG9hLFxuICAgIGJ0b2FQb2x5ZmlsbDogYnRvYVBvbHlmaWxsLFxuICAgIGZyb21CYXNlNjQ6IGRlY29kZSxcbiAgICB0b0Jhc2U2NDogZW5jb2RlLFxuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGVuY29kZVVSSTogZW5jb2RlVVJJLFxuICAgIGVuY29kZVVSTDogZW5jb2RlVVJJLFxuICAgIHV0b2I6IHV0b2IsXG4gICAgYnRvdTogYnRvdSxcbiAgICBkZWNvZGU6IGRlY29kZSxcbiAgICBpc1ZhbGlkOiBpc1ZhbGlkLFxuICAgIGZyb21VaW50OEFycmF5OiBmcm9tVWludDhBcnJheSxcbiAgICB0b1VpbnQ4QXJyYXk6IHRvVWludDhBcnJheSxcbiAgICBleHRlbmRTdHJpbmc6IGV4dGVuZFN0cmluZyxcbiAgICBleHRlbmRVaW50OEFycmF5OiBleHRlbmRVaW50OEFycmF5LFxuICAgIGV4dGVuZEJ1aWx0aW5zOiBleHRlbmRCdWlsdGlucyxcbn07XG4vLyBtYWtlY2pzOkNVVCAvL1xuZXhwb3J0IHsgdmVyc2lvbiB9O1xuZXhwb3J0IHsgVkVSU0lPTiB9O1xuZXhwb3J0IHsgX2F0b2IgYXMgYXRvYiB9O1xuZXhwb3J0IHsgYXRvYlBvbHlmaWxsIH07XG5leHBvcnQgeyBfYnRvYSBhcyBidG9hIH07XG5leHBvcnQgeyBidG9hUG9seWZpbGwgfTtcbmV4cG9ydCB7IGRlY29kZSBhcyBmcm9tQmFzZTY0IH07XG5leHBvcnQgeyBlbmNvZGUgYXMgdG9CYXNlNjQgfTtcbmV4cG9ydCB7IHV0b2IgfTtcbmV4cG9ydCB7IGVuY29kZSB9O1xuZXhwb3J0IHsgZW5jb2RlVVJJIH07XG5leHBvcnQgeyBlbmNvZGVVUkkgYXMgZW5jb2RlVVJMIH07XG5leHBvcnQgeyBidG91IH07XG5leHBvcnQgeyBkZWNvZGUgfTtcbmV4cG9ydCB7IGlzVmFsaWQgfTtcbmV4cG9ydCB7IGZyb21VaW50OEFycmF5IH07XG5leHBvcnQgeyB0b1VpbnQ4QXJyYXkgfTtcbmV4cG9ydCB7IGV4dGVuZFN0cmluZyB9O1xuZXhwb3J0IHsgZXh0ZW5kVWludDhBcnJheSB9O1xuZXhwb3J0IHsgZXh0ZW5kQnVpbHRpbnMgfTtcbi8vIGFuZCBmaW5hbGx5LFxuZXhwb3J0IHsgZ0Jhc2U2NCBhcyBCYXNlNjQgfTtcbiIsImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IGJ5dGVzVG9VdWlkIGZyb20gJy4vYnl0ZXNUb1V1aWQuanMnO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ3N0cmluZycpIHtcbiAgICBidWYgPSBvcHRpb25zID09PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7ICsraWkpIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCBieXRlc1RvVXVpZChybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7IiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uIEFsc28sXG4vLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxudmFyIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSB8fCB0eXBlb2YgbXNDcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcbnZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59IiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb1V1aWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGJ0aCA9IGJ5dGVUb0hleDsgLy8gam9pbiB1c2VkIHRvIGZpeCBtZW1vcnkgaXNzdWUgY2F1c2VkIGJ5IGNvbmNhdGVuYXRpb246IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxNzUjYzRcblxuICByZXR1cm4gW2J0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJywgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJywgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXV0uam9pbignJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJ5dGVzVG9VdWlkOyIsImltcG9ydCBPcmVJZENvbnRleHQgZnJvbSAnLi4vLi4vY29yZS9JT3JlaWRDb250ZXh0J1xuaW1wb3J0IHsgQXBpRW5kcG9pbnQsIEFwcEFjY2Vzc1Rva2VuTWV0YWRhdGEsIFJlcXVlc3RUeXBlLCBBcGlLZXlVc2VkRm9yIH0gZnJvbSAnLi4vLi4vbW9kZWxzJ1xuaW1wb3J0IHsgYXNzZXJ0SGFzQXBpS2V5IH0gZnJvbSAnLi4vaGVscGVycydcbmltcG9ydCBIZWxwZXJzIGZyb20gJy4uLy4uL3V0aWxzL2hlbHBlcnMnXG5cbmV4cG9ydCB0eXBlIEFwaUdldEFwcFRva2VuUGFyYW1zID0ge1xuICBhcHBBY2Nlc3NUb2tlbk1ldGFkYXRhPzogQXBwQWNjZXNzVG9rZW5NZXRhZGF0YVxufVxuXG4vKipcbiAqICBDYWxsIGFwaSBhcHAtdG9rZW4gdG8gZ2V0IGEgbmV3IGFwcEFjY2Vzc1Rva2VuXG4gKiAgQW4gYXBpS2V5IGlzIGFsd2F5cyByZXF1aXJlZCB0byBjYWxsIHRoaXMgZW5kcG9pbnRcbiAqICBSZXR1cm5zOiBhcHBBY2Nlc3NUb2tlblxuICogKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxsQXBpR2V0QXBwVG9rZW4ob3JlSWRDb250ZXh0OiBPcmVJZENvbnRleHQsIHBhcmFtczogQXBpR2V0QXBwVG9rZW5QYXJhbXMpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBhcGlOYW1lID0gQXBpRW5kcG9pbnQuQXBwVG9rZW5cbiAgY29uc3QgeyBhcHBBY2Nlc3NUb2tlbk1ldGFkYXRhIH0gPSBwYXJhbXNcblxuICAvLyB0byB1c2UgYXBwQWNjZXNzVG9rZW5NZXRhZGF0YSwgd2UgcmVxdWlyZSBhIGFwaUtleSB3aXRoICdjcmVhdGVVc2VyJyByaWdodFxuICBpZiAoIUhlbHBlcnMuaXNOdWxsT3JFbXB0eShhcHBBY2Nlc3NUb2tlbk1ldGFkYXRhKSkge1xuICAgIGFzc2VydEhhc0FwaUtleShvcmVJZENvbnRleHQsIEFwaUtleVVzZWRGb3IuQ3JlYXRlVXNlciwgYXBpTmFtZSlcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnRIYXNBcGlLZXkob3JlSWRDb250ZXh0LCBudWxsLCBhcGlOYW1lKVxuICB9XG4gIGNvbnN0IHsgYXBwQWNjZXNzVG9rZW4gfSA9IGF3YWl0IG9yZUlkQ29udGV4dC5jYWxsT3JlSWRBcGkoXG4gICAgUmVxdWVzdFR5cGUuUG9zdCxcbiAgICBBcGlFbmRwb2ludC5BcHBUb2tlbixcbiAgICBhcHBBY2Nlc3NUb2tlbk1ldGFkYXRhLFxuICAgIG51bGwsXG4gIClcbiAgcmV0dXJuIGFwcEFjY2Vzc1Rva2VuIGFzIHN0cmluZ1xufVxuIiwiaW1wb3J0IE9yZUlkQ29udGV4dCBmcm9tICcuLi8uLi9jb3JlL0lPcmVpZENvbnRleHQnXG5pbXBvcnQge1xuICBBY2NvdW50TmFtZSxcbiAgQXBpRW5kcG9pbnQsXG4gIENoYWluQWNjb3VudCxcbiAgQ2hhaW5OZXR3b3JrLFxuICBQcm9jZXNzSWQsXG4gIFJlcXVlc3RUeXBlLFxuICBBcGlLZXlVc2VkRm9yLFxuICBUcmFuc2FjdGlvbkRhdGEsXG59IGZyb20gJy4uLy4uL21vZGVscydcbmltcG9ydCB7IGFzc2VydEhhc0FwaUtleSwgYXNzZXJ0UGFyYW1zSGF2ZU9ubHlPbmVPZlZhbHVlcywgYXNzZXJ0UGFyYW1zSGF2ZVJlcXVpcmVkVmFsdWVzIH0gZnJvbSAnLi4vaGVscGVycydcbmltcG9ydCBIZWxwZXJzIGZyb20gJy4uLy4uL3V0aWxzL2hlbHBlcnMnXG5cbmV4cG9ydCB0eXBlIEFwaUNhbkF1dG9zaWduVHJhbnNhY3Rpb25Cb2R5UGFyYW1zID0ge1xuICBhY2NvdW50OiBBY2NvdW50TmFtZVxuICBjaGFpbl9hY2NvdW50OiBDaGFpbkFjY291bnRcbiAgY2hhaW5fbmV0d29yazogQ2hhaW5OZXR3b3JrXG4gIHNpZ25lZF90cmFuc2FjdGlvbj86IHN0cmluZ1xuICB0cmFuc2FjdGlvbj86IHN0cmluZ1xuICB0cmFuc2FjdGlvbl9jaGFpbl9hY2Njb3VudD86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBBcGlDYW5BdXRvc2lnblRyYW5zYWN0aW9uUmVzdWx0ID0ge1xuICBhdXRvU2lnbkNyZWRlbnRpYWxzRXhpc3Q6IGJvb2xlYW5cbiAgY2FuQ3JlYXRlQXV0b1NpZ25DcmVkZW50aWFsczogYm9vbGVhblxuICBtYXhBdXRvU2lnblZhbGlkRm9ySW5TZWNvbmRzOiBudW1iZXJcbiAgcHJvY2Vzc0lkOiBQcm9jZXNzSWRcbn1cblxuLyoqIENhbGwgYXBpIHRyYW5zYWN0aW9uL2Nhbi1hdXRvLXNpZ25cbiAqIFJlcXVpcmVzIGEgYXBpS2V5IHdpdGggdGhlIGF1dG9TaWduIHJpZ2h0XG4gKiBSZXR1cm5zOiB0cnVlIGlmIHRyYW5zYWN0aW9uIHByb3ZpZGVkIGNhbiBiZSBzaWduZWQgdXNpbmcgdGhlIHNpZ25UcmFuc2FjdGlvbihhdXRvc2lnbjp0cnVlKVxuICogKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxsQXBpQ2FuQXV0b3NpZ25UcmFuc2FjdGlvbihcbiAgb3JlSWRDb250ZXh0OiBPcmVJZENvbnRleHQsXG4gIHBhcmFtczogVHJhbnNhY3Rpb25EYXRhLFxuKTogUHJvbWlzZTxBcGlDYW5BdXRvc2lnblRyYW5zYWN0aW9uUmVzdWx0PiB7XG4gIGNvbnN0IGFwaU5hbWUgPSBBcGlFbmRwb2ludC5DYW5BdXRvU2lnblxuICBjb25zdCB7IGFjY291bnQsIGNoYWluQWNjb3VudCwgY2hhaW5OZXR3b3JrLCBzaWduZWRUcmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uQ2hhaW5BY2NvdW50IH0gPSBwYXJhbXNcblxuICBhc3NlcnRIYXNBcGlLZXkob3JlSWRDb250ZXh0LCBBcGlLZXlVc2VkRm9yLkF1dG9TaWduaW5nLCBhcGlOYW1lKVxuICBhc3NlcnRQYXJhbXNIYXZlUmVxdWlyZWRWYWx1ZXMocGFyYW1zLCBbJ2FjY291bnQnLCAnY2hhaW5OZXR3b3JrJywgJ2NoYWluQWNjb3VudCddLCBhcGlOYW1lKVxuICBhc3NlcnRQYXJhbXNIYXZlT25seU9uZU9mVmFsdWVzKHBhcmFtcywgWyd0cmFuc2FjdGlvbicsICdzaWduZWRUcmFuc2FjdGlvbiddLCBhcGlOYW1lKVxuXG4gIGNvbnN0IGJvZHk6IEFwaUNhbkF1dG9zaWduVHJhbnNhY3Rpb25Cb2R5UGFyYW1zID0ge1xuICAgIGFjY291bnQsXG4gICAgY2hhaW5fYWNjb3VudDogY2hhaW5BY2NvdW50LFxuICAgIGNoYWluX25ldHdvcms6IGNoYWluTmV0d29yayxcbiAgfVxuXG4gIGlmICh0cmFuc2FjdGlvbikgYm9keS50cmFuc2FjdGlvbiA9IEhlbHBlcnMuYmFzZTY0RW5jb2RlKHRyYW5zYWN0aW9uKVxuICBpZiAoc2lnbmVkVHJhbnNhY3Rpb24pIGJvZHkuc2lnbmVkX3RyYW5zYWN0aW9uID0gSGVscGVycy5iYXNlNjRFbmNvZGUoc2lnbmVkVHJhbnNhY3Rpb24pXG4gIGlmICh0cmFuc2FjdGlvbikgYm9keS50cmFuc2FjdGlvbl9jaGFpbl9hY2Njb3VudCA9IHRyYW5zYWN0aW9uQ2hhaW5BY2NvdW50XG5cbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IG9yZUlkQ29udGV4dC5jYWxsT3JlSWRBcGkoUmVxdWVzdFR5cGUuUG9zdCwgQXBpRW5kcG9pbnQuQ2FuQXV0b1NpZ24sIGJvZHksIG51bGwpXG4gIHJldHVybiByZXN1bHRzXG59XG4iLCJpbXBvcnQgT3JlSWRDb250ZXh0IGZyb20gJy4uLy4uL2NvcmUvSU9yZWlkQ29udGV4dCdcbmltcG9ydCB7IEFwaUVuZHBvaW50LCBQcm9jZXNzSWQsIFJlcXVlc3RUeXBlIH0gZnJvbSAnLi4vLi4vbW9kZWxzJ1xuaW1wb3J0IHsgYXNzZXJ0SGFzQXBpS2V5T3JBY2Nlc3NUb2tlbiwgYXNzZXJ0UGFyYW1zSGF2ZVJlcXVpcmVkVmFsdWVzIH0gZnJvbSAnLi4vaGVscGVycydcblxuZXhwb3J0IHR5cGUgQXBpQ29udmVydE9hdXRoVG9rZW5zUGFyYW1zID0ge1xuICBhY2Nlc3NUb2tlbj86IHN0cmluZ1xuICBpZFRva2VuPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIEFwaUNvbnZlcnRPYXV0aFRva2Vuc0JvZHlQYXJhbXMgPSB7XG4gIGFjY2Vzc190b2tlbj86IHN0cmluZ1xuICBpZF90b2tlbj86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBDYWxsQXBpQ29udmVydE9hdXRoVG9rZW5zUmVzdWx0ID0ge1xuICBhY2Nlc3NUb2tlbjogc3RyaW5nXG4gIGlkVG9rZW46IHN0cmluZ1xuICBwcm9jZXNzSWQ6IFByb2Nlc3NJZFxufVxuXG4vKiogQ2FsbCB0aGUgYWNjb3VudC9jb252ZXJ0LW9hdXRoIGFwaVxuICogQ29udmVydHMgT0F1dGggdG9rZW5zIGZyb20gc29tZSAzcmQtcGFydHkgc291cmNlIHRvIE9SRUlEIE9hdXRoIHRva2Vuc1xuICogVGhlIHRoaXJkLXBhcnR5IChlLmcuIEF1dGgwIG9yIEdvb2dsZSkgbXVzdCBiZSByZWdpc3RlcmVkIGluIHRoZSBBcHBSZWdpc3RyYXRpb24ub2F1dGhTZXR0aW5nc1xuICogUmV0dXJuczogT3JlSWQgaXNzdWVkIGFjY2Vzc1Rva2VuIGFuZCBpZFRva2VuXG4gKiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGxBcGlDb252ZXJ0T2F1dGhUb2tlbnMoXG4gIG9yZUlkQ29udGV4dDogT3JlSWRDb250ZXh0LFxuICBwYXJhbXM6IEFwaUNvbnZlcnRPYXV0aFRva2Vuc1BhcmFtcyxcbik6IFByb21pc2U8Q2FsbEFwaUNvbnZlcnRPYXV0aFRva2Vuc1Jlc3VsdD4ge1xuICBjb25zdCBhcGlOYW1lID0gQXBpRW5kcG9pbnQuQ29udmVydE9hdXRoVG9rZW5zXG4gIGNvbnN0IHsgYWNjZXNzVG9rZW4sIGlkVG9rZW4gfSA9IHBhcmFtc1xuXG4gIGFzc2VydEhhc0FwaUtleU9yQWNjZXNzVG9rZW4ob3JlSWRDb250ZXh0LCBhcGlOYW1lKVxuICAvLyBhc3NlcnRQYXJhbXNIYXZlT25seU9uZU9mVmFsdWVzKHBhcmFtcywgWydhY2Nlc3NUb2tlbicsICdpZFRva2VuJ10sIGFwaU5hbWUpXG4gIGFzc2VydFBhcmFtc0hhdmVSZXF1aXJlZFZhbHVlcyhwYXJhbXMsIFsnaWRUb2tlbiddLCBhcGlOYW1lKVxuXG4gIGNvbnN0IGJvZHk6IEFwaUNvbnZlcnRPYXV0aFRva2Vuc0JvZHlQYXJhbXMgPSB7fVxuICBpZiAoYWNjZXNzVG9rZW4pIGJvZHkuYWNjZXNzX3Rva2VuID0gYWNjZXNzVG9rZW5cbiAgaWYgKGlkVG9rZW4pIGJvZHkuaWRfdG9rZW4gPSBpZFRva2VuXG5cbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IG9yZUlkQ29udGV4dC5jYWxsT3JlSWRBcGkoUmVxdWVzdFR5cGUuUG9zdCwgQXBpRW5kcG9pbnQuQ29udmVydE9hdXRoVG9rZW5zLCBib2R5LCBudWxsKVxuICByZXR1cm4gcmVzdWx0cyAvLyBhY2Nlc3NUb2tlbiBhbmQgaWRUb2tlblxufVxuIiwiaW1wb3J0IE9yZUlkQ29udGV4dCBmcm9tICcuLi8uLi9jb3JlL0lPcmVpZENvbnRleHQnXG5pbXBvcnQge1xuICBBY2NvdW50TmFtZSxcbiAgQWNjb3VudFR5cGUsXG4gIEFwaUVuZHBvaW50LFxuICBDaGFpbkFjY291bnQsXG4gIENoYWluTmV0d29yayxcbiAgUmVxdWVzdFR5cGUsXG4gIEFwaUtleVVzZWRGb3IsXG59IGZyb20gJy4uLy4uL21vZGVscydcbmltcG9ydCB7IGFzc2VydEhhc0FwaUtleSwgYXNzZXJ0UGFyYW1zSGF2ZU9ubHlPbmVPZlZhbHVlcywgYXNzZXJ0UGFyYW1zSGF2ZVJlcXVpcmVkVmFsdWVzIH0gZnJvbSAnLi4vaGVscGVycydcbmltcG9ydCB7IEFwaVJlc3VsdFdpdGhFcnJvckNvZGUgfSBmcm9tICcuLi9tb2RlbHMnXG5cbmV4cG9ydCB0eXBlIEFwaUN1c3RvZGlhbE1pZ3JhdGVBY2NvdW50UGFyYW1zID0ge1xuICBhY2NvdW50OiBBY2NvdW50TmFtZVxuICBjaGFpbkFjY291bnQ6IENoYWluQWNjb3VudFxuICBjaGFpbk5ldHdvcms6IENoYWluTmV0d29ya1xuICB0b1R5cGU6IEFjY291bnRUeXBlXG4gIHVzZXJQYXNzd29yZDogc3RyaW5nXG4gIHVzZXJQYXNzd29yZEVuY3J5cHRlZDogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIEFwaUN1c3RvZGlhbE1pZ3JhdGVBY2NvdW50Qm9keVBhcmFtcyA9IHtcbiAgYWNjb3VudDogQWNjb3VudE5hbWVcbiAgY2hhaW5fYWNjb3VudDogQ2hhaW5BY2NvdW50XG4gIGNoYWluX25ldHdvcms6IENoYWluTmV0d29ya1xuICB0b190eXBlOiBBY2NvdW50VHlwZVxuICB1c2VyX3Bhc3N3b3JkPzogc3RyaW5nXG4gIHVzZXJfcGFzc3dvcmRfZW5jcnlwdGVkPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIEFwaUN1c3RvZGlhbE1pZ3JhdGVBY2NvdW50UmVzdWx0ID0ge1xuICBhY2NvdW50OiBBY2NvdW50TmFtZVxufSAmIEFwaVJlc3VsdFdpdGhFcnJvckNvZGVcblxuLyoqIENhbGwgdGhlIGN1c3RvZGlhbC9taWdyYXRlLXVzZXIgYXBpXG4gKiBDb252ZXJ0cyBhIHVzZXIgYWNjb3VudCB0byBhIG5ldyBhY2NvdW50IHR5cGVcbiAqIFVzdWFsbHkgdXNlZCB0byBjb252ZXJ0IGEgdmlydGFsIGFjY291bnQgdG8gYSBuYXRpdmUgYWNjb3VudCAob24tY2hhaW4pXG4gKiAuLiBhbmQgZXhwZWN0cyB0aGUgYWNjb3VudCB0byBiZSBhIG1hbmFnZWQgKGN1c3RvZGlhbCkgYWNjb3VudFxuICogUmVxdWlyZXMgYSB3YWxsZXQgcGFzc3dvcmQgKHVzZXJQYXNzd29yZCkgb24gYmVoYWxmIG9mIHRoZSB1c2VyXG4gKiBSZXF1aXJlcyBhbiBhcGlLZXkgd2l0aCB0aGUgYWNjb3VudE1pZ3JhdGlvbiByaWdodFxuICogUmV0dXJuczogYWNjb3VudCBuYW1lIG9mIG1pZ3JhdGVkIGFjY291bnRcbiAqICAgICAgIE9SIGVycm9yQ29kZSwgZXJyb3JNZXNzYWdlLCBhbmQgbWVzc2FnZSBpZiBhbnkgcHJvYmxlbXMgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxsQXBpQ3VzdG9kaWFsTWlncmF0ZUFjY291bnQoXG4gIG9yZUlkQ29udGV4dDogT3JlSWRDb250ZXh0LFxuICBwYXJhbXM6IEFwaUN1c3RvZGlhbE1pZ3JhdGVBY2NvdW50UGFyYW1zLFxuKTogUHJvbWlzZTxBcGlDdXN0b2RpYWxNaWdyYXRlQWNjb3VudFJlc3VsdD4ge1xuICBjb25zdCBhcGlOYW1lID0gQXBpRW5kcG9pbnQuQ3VzdG9kaWFsTWlncmF0ZUFjY291bnRcblxuICBjb25zdCB7IGFjY291bnQsIGNoYWluQWNjb3VudCwgY2hhaW5OZXR3b3JrLCB0b1R5cGUsIHVzZXJQYXNzd29yZCwgdXNlclBhc3N3b3JkRW5jcnlwdGVkIH0gPSBwYXJhbXNcbiAgY29uc3QgYm9keTogQXBpQ3VzdG9kaWFsTWlncmF0ZUFjY291bnRCb2R5UGFyYW1zID0ge1xuICAgIGFjY291bnQsXG4gICAgY2hhaW5fYWNjb3VudDogY2hhaW5BY2NvdW50LFxuICAgIGNoYWluX25ldHdvcms6IGNoYWluTmV0d29yayxcbiAgICB0b190eXBlOiB0b1R5cGUsXG4gICAgdXNlcl9wYXNzd29yZDogdXNlclBhc3N3b3JkLFxuICAgIHVzZXJfcGFzc3dvcmRfZW5jcnlwdGVkOiB1c2VyUGFzc3dvcmRFbmNyeXB0ZWQsXG4gIH1cblxuICBhc3NlcnRIYXNBcGlLZXkob3JlSWRDb250ZXh0LCBBcGlLZXlVc2VkRm9yLkFjY291bnRNaWdyYXRpb24sIGFwaU5hbWUpXG4gIGFzc2VydFBhcmFtc0hhdmVSZXF1aXJlZFZhbHVlcyhwYXJhbXMsIFsnYWNjb3VudCcsICdjaGFpbkFjY291bnQnLCAnY2hhaW5OZXR3b3JrJywgJ3RvVHlwZSddLCBhcGlOYW1lKVxuICBhc3NlcnRQYXJhbXNIYXZlT25seU9uZU9mVmFsdWVzKHBhcmFtcywgWyd1c2VyX3Bhc3N3b3JkJywgJ3VzZXJfcGFzc3dvcmRfZW5jcnlwdGVkJ10sIGFwaU5hbWUpXG5cbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IG9yZUlkQ29udGV4dC5jYWxsT3JlSWRBcGkoUmVxdWVzdFR5cGUuUG9zdCwgQXBpRW5kcG9pbnQuQ3VzdG9kaWFsTWlncmF0ZUFjY291bnQsIGJvZHksIG51bGwpXG4gIHJldHVybiByZXN1bHRzXG59XG4iLCJpbXBvcnQgT3JlSWRDb250ZXh0IGZyb20gJy4uLy4uL2NvcmUvSU9yZWlkQ29udGV4dCdcbmltcG9ydCB7IEFjY291bnROYW1lLCBBY2NvdW50VHlwZSwgQXBpRW5kcG9pbnQsIFJlcXVlc3RUeXBlLCBBcGlLZXlVc2VkRm9yIH0gZnJvbSAnLi4vLi4vbW9kZWxzJ1xuaW1wb3J0IHsgYXNzZXJ0SGFzQXBpS2V5LCBhc3NlcnRQYXJhbXNIYXZlT25seU9uZU9mVmFsdWVzLCBhc3NlcnRQYXJhbXNIYXZlUmVxdWlyZWRWYWx1ZXMgfSBmcm9tICcuLi9oZWxwZXJzJ1xuaW1wb3J0IHsgQXBpUmVzdWx0V2l0aEVycm9yQ29kZSB9IGZyb20gJy4uL21vZGVscydcblxuZXhwb3J0IHR5cGUgQXBpQ3VzdG9kaWFsTmV3QWNjb3VudFBhcmFtcyA9IHtcbiAgYWNjb3VudFR5cGU6IEFjY291bnRUeXBlXG4gIC8qKiB3aGV0aGVyIHdlIHNob3VsZCBza2lwIGNyZWF0aW9uIG9mIGJsb2NrY2hhaW4gYWNjb3VudHMgZm9yIGEgbmV3IHVzZXIgKi9cbiAgZGVsYXlXYWxsZXRTZXR1cD86IGJvb2xlYW5cbiAgZW1haWw/OiBzdHJpbmdcbiAgZW1haWxWZXJpZmllZD86IGJvb2xlYW5cbiAgaWRUb2tlbj86IHN0cmluZ1xuICBpc1Rlc3RVc2VyPzogYm9vbGVhblxuICBuYW1lPzogc3RyaW5nXG4gIHBpY3R1cmU/OiBzdHJpbmdcbiAgcGhvbmU/OiBzdHJpbmdcbiAgcGhvbmVWZXJpZmllZD86IGJvb2xlYW5cbiAgdXNlck5hbWU/OiBzdHJpbmdcbiAgdXNlclBhc3N3b3JkPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIEFwaUN1c3RvZGlhbE5ld0FjY291bnRCb2R5UGFyYW1zID0ge1xuICBhY2NvdW50X3R5cGU6IEFjY291bnRUeXBlXG4gIC8qKiB3aGV0aGVyIHdlIHNob3VsZCBza2lwIGNyZWF0aW9uIG9mIGJsb2NrY2hhaW4gYWNjb3VudHMgZm9yIGEgbmV3IHVzZXIgKi9cbiAgZGVsYXlfd2FsbGV0X3NldHVwPzogYm9vbGVhblxuICBlbWFpbD86IHN0cmluZ1xuICBlbWFpbF92ZXJpZmllZD86IGJvb2xlYW5cbiAgaWRfdG9rZW4/OiBzdHJpbmdcbiAgaXNfdGVzdF91c2VyPzogYm9vbGVhblxuICBuYW1lPzogc3RyaW5nXG4gIHBpY3R1cmU/OiBzdHJpbmdcbiAgcGhvbmU/OiBzdHJpbmdcbiAgcGhvbmVfdmVyaWZpZWQ/OiBib29sZWFuXG4gIHVzZXJfbmFtZT86IHN0cmluZ1xuICB1c2VyX3Bhc3N3b3JkPzogc3RyaW5nXG4gIHVzZXJfcGFzc3dvcmRfZW5jcnlwdGVkPzogc3RyaW5nXG4gIHVzZXJfcGFzc3dvcmRfZW5jcnlwdGVkX2JhY2t1cD86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBBcGlDdXN0b2RpYWxOZXdBY2NvdW50UmVzdWx0ID0ge1xuICBhY2NvdW50TmFtZTogQWNjb3VudE5hbWVcbn0gJiBBcGlSZXN1bHRXaXRoRXJyb3JDb2RlXG5cbi8qKiBDYWxsIHRoZSBjdXN0b2RpYWwvbmV3LXVzZXIgYXBpXG4gKiBDcmVhdGUgYSBuZXcgdXNlciBhY2NvdW50IHRoYXQgaXMgbWFuYWdlZCBieSB5b3VyIGFwcFxuICogUmVxdWlyZXMgYSB3YWxsZXQgcGFzc3dvcmQgKHVzZXJQYXNzd29yZCkgb24gYmVoYWxmIG9mIHRoZSB1c2VyXG4gKiBSZXF1aXJlcyBhbiBhcGlLZXkgd2l0aCB0aGUgY3JlYXRlVXNlciByaWdodFxuICogUmV0dXJuczogYWNjb3VudE5hbWUgb2YgbmV3bHkgY3JlYXRlZCBhY2NvdW50XG4gKiAgICAgICBPUiBlcnJvckNvZGUsIGVycm9yTWVzc2FnZSwgYW5kIG1lc3NhZ2UgaWYgYW55IHByb2JsZW1zICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbEFwaUN1c3RvZGlhbE5ld0FjY291bnQoXG4gIG9yZUlkQ29udGV4dDogT3JlSWRDb250ZXh0LFxuICBwYXJhbXM6IEFwaUN1c3RvZGlhbE5ld0FjY291bnRQYXJhbXMsXG4pOiBQcm9taXNlPEFwaUN1c3RvZGlhbE5ld0FjY291bnRSZXN1bHQ+IHtcbiAgY29uc3QgYXBpTmFtZSA9IEFwaUVuZHBvaW50LkN1c3RvZGlhbE5ld0FjY291bnRcblxuICBjb25zdCB7XG4gICAgYWNjb3VudFR5cGUsXG4gICAgZGVsYXlXYWxsZXRTZXR1cCxcbiAgICBlbWFpbCxcbiAgICBlbWFpbFZlcmlmaWVkLFxuICAgIGlkVG9rZW4sXG4gICAgaXNUZXN0VXNlcixcbiAgICBuYW1lLFxuICAgIHBpY3R1cmUsXG4gICAgcGhvbmUsXG4gICAgcGhvbmVWZXJpZmllZCxcbiAgICB1c2VyTmFtZSxcbiAgICB1c2VyUGFzc3dvcmQsXG4gIH0gPSBwYXJhbXNcbiAgY29uc3QgYm9keTogQXBpQ3VzdG9kaWFsTmV3QWNjb3VudEJvZHlQYXJhbXMgPSB7XG4gICAgYWNjb3VudF90eXBlOiBhY2NvdW50VHlwZSxcbiAgICBkZWxheV93YWxsZXRfc2V0dXA6IGRlbGF5V2FsbGV0U2V0dXAsXG4gICAgZW1haWwsXG4gICAgZW1haWxfdmVyaWZpZWQ6IGVtYWlsVmVyaWZpZWQsXG4gICAgaWRfdG9rZW46IGlkVG9rZW4sXG4gICAgaXNfdGVzdF91c2VyOiBpc1Rlc3RVc2VyLFxuICAgIG5hbWUsXG4gICAgcGhvbmUsXG4gICAgcGhvbmVfdmVyaWZpZWQ6IHBob25lVmVyaWZpZWQsXG4gICAgcGljdHVyZSxcbiAgICB1c2VyX25hbWU6IHVzZXJOYW1lLFxuICAgIHVzZXJfcGFzc3dvcmQ6IHVzZXJQYXNzd29yZCxcbiAgfVxuXG4gIGFzc2VydEhhc0FwaUtleShvcmVJZENvbnRleHQsIEFwaUtleVVzZWRGb3IuQ3JlYXRlVXNlciwgYXBpTmFtZSlcbiAgYXNzZXJ0UGFyYW1zSGF2ZVJlcXVpcmVkVmFsdWVzKHBhcmFtcywgWydhY2NvdW50VHlwZSddLCBhcGlOYW1lKVxuICBhc3NlcnRQYXJhbXNIYXZlT25seU9uZU9mVmFsdWVzKFxuICAgIHBhcmFtcyxcbiAgICBbJ3VzZXJfcGFzc3dvcmQnLCAndXNlcl9wYXNzd29yZF9lbmNyeXB0ZWQnLCAndXNlcl9wYXNzd29yZF9lbmNyeXB0ZWRfYmFja3VwJ10sXG4gICAgYXBpTmFtZSxcbiAgKVxuXG4gIGlmICghaWRUb2tlbiAmJiAhKGVtYWlsICYmIG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcihzKSBmb3IgQVBJICR7YXBpTmFtZX06IE11c3QgaW5jbHVkZSBlbWFpbCBBTkQgbmFtZSBvciBhbiBpZFRva2VuYClcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBvcmVJZENvbnRleHQuY2FsbE9yZUlkQXBpKFJlcXVlc3RUeXBlLlBvc3QsIEFwaUVuZHBvaW50LkN1c3RvZGlhbE5ld0FjY291bnQsIGJvZHksIG51bGwpXG4gIHJldHVybiByZXN1bHRzIC8vIGFjY2Vzc1Rva2VuIGFuZCBpZFRva2VuXG59XG4iLCJpbXBvcnQgT3JlSWRDb250ZXh0IGZyb20gJy4uLy4uL2NvcmUvSU9yZWlkQ29udGV4dCdcbmltcG9ydCB7IEFwaUVuZHBvaW50LCBBcGlLZXlVc2VkRm9yLCBSZXF1ZXN0VHlwZSwgU2lnblN0cmluZ01ldGhvZCB9IGZyb20gJy4uLy4uL21vZGVscydcbmltcG9ydCB7IGFzc2VydEhhc0FwaUtleSwgYXNzZXJ0UGFyYW1zSGF2ZU9ubHlPbmVPZlZhbHVlcywgYXNzZXJ0UGFyYW1zSGF2ZVJlcXVpcmVkVmFsdWVzIH0gZnJvbSAnLi4vaGVscGVycydcbmltcG9ydCB7IEFwaVJlc3VsdFdpdGhFcnJvckNvZGUgfSBmcm9tICcuLi9tb2RlbHMnXG5cbmV4cG9ydCB0eXBlIEFwaUN1c3RvZGlhbFNpZ25TdHJpbmdQYXJhbXMgPSB7XG4gIGNoYWluQWNjb3VudDogc3RyaW5nXG4gIGNoYWluTmV0d29yazogc3RyaW5nXG4gIHBlcm1pc3Npb24/OiBzdHJpbmdcbiAgc3RyaW5nVG9TaWduOiBzdHJpbmdcbiAgLyoqIG9wdGlvbmFsIC0gYWx0ZXJuYXRpdmUgbWV0aG9kIG9mIHNpZ25pbmcgKGNoYWluLXNwZWNpZmljKSAqL1xuICBzaWduTWV0aG9kPzogU2lnblN0cmluZ01ldGhvZFxuICB1c2VyUGFzc3dvcmQ/OiBzdHJpbmdcbiAgdXNlclBhc3N3b3JkRW5jcnlwdGVkPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIEFwaUN1c3RvZGlhbFNpZ25TdHJpbmdCb2R5UGFyYW1zID0ge1xuICBjaGFpbl9hY2NvdW50OiBzdHJpbmdcbiAgY2hhaW5fbmV0d29yazogc3RyaW5nXG4gIHBlcm1pc3Npb24/OiBzdHJpbmdcbiAgc3RyaW5nX3RvX3NpZ246IHN0cmluZ1xuICBzaWduX21ldGhvZD86IFNpZ25TdHJpbmdNZXRob2RcbiAgdXNlcl9wYXNzd29yZD86IHN0cmluZ1xuICB1c2VyX3Bhc3N3b3JkX2VuY3J5cHRlZD86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBBcGlDdXN0b2RpYWxTaWduU3RyaW5nUmVzdWx0ID0ge1xuICBzaWduYXR1cmU6IHN0cmluZ1xufSAmIEFwaVJlc3VsdFdpdGhFcnJvckNvZGVcblxuLyoqIENhbGwgdGhlIGN1c3RvaWRhbC9zaWduLXN0cmluZyBhcGlcbiAqIFNpZ25zIGEgc3RyaW5nIChha2EgbWVzc2FnZSkgdXNpbmcgdGhlIHVzZXIncyBwcml2YXRlIGtleVxuICogUmVxdWlyZXMgYSB3YWxsZXQgcGFzc3dvcmQgKHVzZXJQYXNzd29yZCkgb24gYmVoYWxmIG9mIHRoZSB1c2VyXG4gKiBSZXF1aXJlcyBhbiBhcGlLZXkgd2l0aCB0aGUgY3JlYXRlVXNlciByaWdodFxuICogT3B0aW9uYWw6IG9wdGlvbnMgLSBkZXNpZ25hdGVzIHRoZSBtZXRob2Qgb2Ygc2lnbmluZyB0byBwZXJmb3JtIChlLmcuIGV0aGVyZXVtLmV0aF9zaWduLCBldGhlcmV1bS5ldGhfc2lnblR5cGVkRGF0YSkgYW5kIHJlbGF0ZWQgbWV0YWRhdGEgKGUuZy4gRVJDNzEyIHR5cGVzKVxuICogUmV0dXJuczogc2lnbmF0dXJlXG4gKiAgICAgICBPUiBlcnJvckNvZGUsIGVycm9yTWVzc2FnZSwgYW5kIG1lc3NhZ2UgaWYgYW55IHByb2JsZW1zICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbEFwaUN1c3RvZGlhbFNpZ25TdHJpbmcoXG4gIG9yZUlkQ29udGV4dDogT3JlSWRDb250ZXh0LFxuICBwYXJhbXM6IEFwaUN1c3RvZGlhbFNpZ25TdHJpbmdQYXJhbXMsXG4pOiBQcm9taXNlPEFwaUN1c3RvZGlhbFNpZ25TdHJpbmdSZXN1bHQ+IHtcbiAgY29uc3QgYXBpTmFtZSA9IEFwaUVuZHBvaW50LkN1c3RvZGlhbFNpZ25TdHJpbmdcblxuICBjb25zdCB7IGNoYWluQWNjb3VudCwgY2hhaW5OZXR3b3JrLCBwZXJtaXNzaW9uLCBzdHJpbmdUb1NpZ24sIHNpZ25NZXRob2QsIHVzZXJQYXNzd29yZCB9ID0gcGFyYW1zXG4gIGNvbnN0IGJvZHk6IEFwaUN1c3RvZGlhbFNpZ25TdHJpbmdCb2R5UGFyYW1zID0ge1xuICAgIGNoYWluX2FjY291bnQ6IGNoYWluQWNjb3VudCxcbiAgICBjaGFpbl9uZXR3b3JrOiBjaGFpbk5ldHdvcmssXG4gICAgcGVybWlzc2lvbixcbiAgICBzdHJpbmdfdG9fc2lnbjogc3RyaW5nVG9TaWduLFxuICAgIHVzZXJfcGFzc3dvcmQ6IHVzZXJQYXNzd29yZCxcbiAgfVxuXG4gIGlmIChzaWduTWV0aG9kKSBib2R5LnNpZ25fbWV0aG9kID0gc2lnbk1ldGhvZFxuXG4gIGFzc2VydEhhc0FwaUtleShvcmVJZENvbnRleHQsIEFwaUtleVVzZWRGb3IuUHJveHlTaWduaW5nLCBhcGlOYW1lKVxuICBhc3NlcnRQYXJhbXNIYXZlUmVxdWlyZWRWYWx1ZXMocGFyYW1zLCBbJ2NoYWluQWNjb3VudCcsICdjaGFpbk5ldHdvcmsnLCAnc3RyaW5nVG9TaWduJ10sIGFwaU5hbWUpXG4gIGFzc2VydFBhcmFtc0hhdmVPbmx5T25lT2ZWYWx1ZXMocGFyYW1zLCBbJ3VzZXJfcGFzc3dvcmQnLCAndXNlcl9wYXNzd29yZF9lbmNyeXB0ZWQnXSwgYXBpTmFtZSlcblxuICBjb25zdCByZXN1bHRzID0gYXdhaXQgb3JlSWRDb250ZXh0LmNhbGxPcmVJZEFwaShSZXF1ZXN0VHlwZS5Qb3N0LCBBcGlFbmRwb2ludC5DdXN0b2RpYWxTaWduU3RyaW5nLCBib2R5LCBudWxsKVxuICByZXR1cm4gcmVzdWx0c1xufVxuIiwiaW1wb3J0IE9yZUlkQ29udGV4dCBmcm9tICcuLi8uLi9jb3JlL0lPcmVpZENvbnRleHQnXG5pbXBvcnQgeyBBY2NvdW50TmFtZSwgQXBpRW5kcG9pbnQsIFJlcXVlc3RUeXBlIH0gZnJvbSAnLi4vLi4vbW9kZWxzJ1xuaW1wb3J0IHsgYXNzZXJ0SGFzQXBpS2V5T3JBY2Nlc3NUb2tlbiwgYXNzZXJ0UGFyYW1zSGF2ZVJlcXVpcmVkVmFsdWVzLCBleHRyYWN0UHJvY2Vzc0lkRnJvbURhdGEgfSBmcm9tICcuLi9oZWxwZXJzJ1xuaW1wb3J0IHsgQXBpUmVzdWx0V2l0aEVycm9yQ29kZSB9IGZyb20gJy4uL21vZGVscydcblxuZXhwb3J0IHR5cGUgQXBpRGVsZXRlVGVzdFVzZXJQYXJhbXMgPSB7XG4gIGFjY291bnQ6IEFjY291bnROYW1lXG59XG5cbmV4cG9ydCB0eXBlIEFwaURlbGV0ZVRlc3RVc2VyUmVzdWx0ID0ge1xuICBzdWNjZXNzOiBib29sZWFuXG59ICYgQXBpUmVzdWx0V2l0aEVycm9yQ29kZVxuXG4vKipcbiAqICBEZWxldGUgYSB1c2VyIHNwZWNpZmljYWxseSBjcmVhdGVkIGFzIGEgdGVzdCB1c2VyIHZpYSBhcGkgYWNjb3VudC9kZWxldGUtdGVzdC11c2VyIGVuZHBvaW50XG4gKiAgUmV0dXJuczogc3VjY2VzcyBvciBlcnJvckNvZGUsIGVycm9yTWVzc2FnZSwgaWYgYW55IHByb2JsZW1zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxsQXBpRGVsZXRlVGVzdFVzZXIoXG4gIG9yZUlkQ29udGV4dDogT3JlSWRDb250ZXh0LFxuICBwYXJhbXM6IEFwaURlbGV0ZVRlc3RVc2VyUGFyYW1zLFxuKTogUHJvbWlzZTxBcGlEZWxldGVUZXN0VXNlclJlc3VsdD4ge1xuICBjb25zdCBhcGlOYW1lID0gQXBpRW5kcG9pbnQuRGVsZXRlVGVzdFVzZXJcbiAgY29uc3QgeyBhY2NvdW50IH0gPSBwYXJhbXNcbiAgYXNzZXJ0SGFzQXBpS2V5T3JBY2Nlc3NUb2tlbihvcmVJZENvbnRleHQsIGFwaU5hbWUpXG4gIGFzc2VydFBhcmFtc0hhdmVSZXF1aXJlZFZhbHVlcyhwYXJhbXMsIFsnYWNjb3VudCddLCBhcGlOYW1lKVxuICBjb25zdCBib2R5ID0geyBhY2NvdW50IH1cblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9yZUlkQ29udGV4dC5jYWxsT3JlSWRBcGkoUmVxdWVzdFR5cGUuUG9zdCwgQXBpRW5kcG9pbnQuRGVsZXRlVGVzdFVzZXIsIGJvZHkpXG4gIGNvbnN0IHsgZGF0YSB9ID0gZXh0cmFjdFByb2Nlc3NJZEZyb21EYXRhKHJlc3BvbnNlKVxuICByZXR1cm4gZGF0YSBhcyBBcGlEZWxldGVUZXN0VXNlclJlc3VsdFxufVxuIiwiaW1wb3J0IE9yZUlkQ29udGV4dCBmcm9tICcuLi8uLi9jb3JlL0lPcmVpZENvbnRleHQnXG5pbXBvcnQgeyBBcGlFbmRwb2ludCwgQ29uZmlnVHlwZSwgUmVxdWVzdFR5cGUgfSBmcm9tICcuLi8uLi9tb2RlbHMnXG5pbXBvcnQgeyBhc3NlcnRIYXNBcGlLZXlPckFjY2Vzc1Rva2VuLCBhc3NlcnRQYXJhbXNIYXZlUmVxdWlyZWRWYWx1ZXMgfSBmcm9tICcuLi9oZWxwZXJzJ1xuXG5leHBvcnQgdHlwZSBBcGlHZXRDb25maWdQYXJhbXMgPSB7XG4gIGNvbmZpZ1R5cGU6IENvbmZpZ1R5cGUuQ2hhaW5zXG59XG5cbi8qKlxuICogIENhbGwgYXBpIHNlcnZpY2VzL2NvbmZpZyB0byBnZXQgY29uZmlndXJhdGlvbiB2YWx1ZXMgb2YgYSBzcGVjaWZpYyB0eXBlXG4gKiAgUmV0dXJuczogZm9yIGNvbmZpZ1R5cGU6Q29uZmlnLkNoYWlucywgcmV0dXJucyBhcnJheSBvZiBTZXR0aW5nQ2hhaW5OZXR3b3JrIG9iamVjdHMgZm9yIGFsbCBjaGFpbnMgc3Vwb3J0ZWQgYnkgdGhlIHNlcnZpY2VcbiAqICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbEFwaUdldENvbmZpZyhvcmVJZENvbnRleHQ6IE9yZUlkQ29udGV4dCwgcGFyYW1zOiBBcGlHZXRDb25maWdQYXJhbXMpOiBQcm9taXNlPGFueT4ge1xuICBjb25zdCBhcGlOYW1lID0gQXBpRW5kcG9pbnQuR2V0Q29uZmlnXG5cbiAgYXNzZXJ0SGFzQXBpS2V5T3JBY2Nlc3NUb2tlbihvcmVJZENvbnRleHQsIGFwaU5hbWUpXG4gIGFzc2VydFBhcmFtc0hhdmVSZXF1aXJlZFZhbHVlcyhwYXJhbXMsIFsnY29uZmlnVHlwZSddLCBhcGlOYW1lKVxuXG4gIGNvbnN0IHsgY29uZmlnVHlwZSB9ID0gcGFyYW1zXG4gIGNvbnN0IHF1ZXJ5UGFyYW1zID0geyB0eXBlOiBjb25maWdUeXBlIH1cbiAgY29uc3QgeyB2YWx1ZXMgfSA9IGF3YWl0IG9yZUlkQ29udGV4dC5jYWxsT3JlSWRBcGkoUmVxdWVzdFR5cGUuR2V0LCBBcGlFbmRwb2ludC5HZXRDb25maWcsIHF1ZXJ5UGFyYW1zLCBudWxsKVxuICByZXR1cm4gdmFsdWVzXG59XG4iLCJpbXBvcnQgT3JlSWRDb250ZXh0IGZyb20gJy4uLy4uL2NvcmUvSU9yZWlkQ29udGV4dCdcbmltcG9ydCB7IEFjY291bnROYW1lLCBBcGlFbmRwb2ludCwgUmVxdWVzdFR5cGUsIFVzZXJTb3VyY2VEYXRhIH0gZnJvbSAnLi4vLi4vbW9kZWxzJ1xuaW1wb3J0IHsgYXNzZXJ0SGFzQXBpS2V5T3JBY2Nlc3NUb2tlbiwgYXNzZXJ0UGFyYW1zSGF2ZVJlcXVpcmVkVmFsdWVzLCBleHRyYWN0UHJvY2Vzc0lkRnJvbURhdGEgfSBmcm9tICcuLi9oZWxwZXJzJ1xuXG5leHBvcnQgdHlwZSBBcGlHZXRVc2VyUGFyYW1zID0ge1xuICBhY2NvdW50OiBBY2NvdW50TmFtZVxufVxuXG4vKipcbiAqICBGZXRjaCB1c2VyIGZyb20gYXBpIGFjY291bnQvdXNlciBlbmRwb2ludFxuICogIFJldHVybnM6IFVzZXJTb3VyY2VEYXRhIGZvciBzcGVjaWZpZWQgYWNjb3VudFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbEFwaUdldFVzZXIob3JlSWRDb250ZXh0OiBPcmVJZENvbnRleHQsIHBhcmFtczogQXBpR2V0VXNlclBhcmFtcyk6IFByb21pc2U8VXNlclNvdXJjZURhdGE+IHtcbiAgY29uc3QgYXBpTmFtZSA9IEFwaUVuZHBvaW50LkdldFVzZXJcbiAgY29uc3QgeyBhY2NvdW50IH0gPSBwYXJhbXNcbiAgYXNzZXJ0SGFzQXBpS2V5T3JBY2Nlc3NUb2tlbihvcmVJZENvbnRleHQsIGFwaU5hbWUpXG4gIGFzc2VydFBhcmFtc0hhdmVSZXF1aXJlZFZhbHVlcyhwYXJhbXMsIFsnYWNjb3VudCddLCBhcGlOYW1lKVxuICBjb25zdCBxdWVyeVBhcmFtcyA9IHsgYWNjb3VudCB9XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvcmVJZENvbnRleHQuY2FsbE9yZUlkQXBpKFJlcXVlc3RUeXBlLkdldCwgQXBpRW5kcG9pbnQuR2V0VXNlciwgcXVlcnlQYXJhbXMpXG4gIGNvbnN0IHsgZGF0YSB9ID0gZXh0cmFjdFByb2Nlc3NJZEZyb21EYXRhKHJlc3BvbnNlKVxuICByZXR1cm4gZGF0YSBhcyBVc2VyU291cmNlRGF0YVxufVxuIiwiaW1wb3J0IE9yZUlkQ29udGV4dCBmcm9tICcuLi8uLi9jb3JlL0lPcmVpZENvbnRleHQnXG5pbXBvcnQgeyBBcGlFbmRwb2ludCwgUmVxdWVzdFR5cGUgfSBmcm9tICcuLi8uLi9tb2RlbHMnXG5pbXBvcnQgeyBhc3NlcnRIYXNBcGlLZXksIGFzc2VydFBhcmFtc0hhdmVPbmx5T25lT2ZWYWx1ZXMsIGFzc2VydFBhcmFtc0hhdmVSZXF1aXJlZFZhbHVlcyB9IGZyb20gJy4uL2hlbHBlcnMnXG5pbXBvcnQgSGVscGVycyBmcm9tICcuLi8uLi91dGlscy9oZWxwZXJzJ1xuaW1wb3J0IHsgQXBpUmVzdWx0V2l0aEVycm9yQ29kZSB9IGZyb20gJy4uL21vZGVscydcblxuZXhwb3J0IHR5cGUgQXBpTG9naW5Vc2VyV2l0aFRva2VuUGFyYW1zID0ge1xuICBhY2Nlc3NUb2tlbj86IHN0cmluZ1xuICBpZFRva2VuPzogc3RyaW5nXG4gIHByb3ZpZGVyPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIEFwaUxvZ2luVXNlcldpdGhUb2tlbkJvZHlQYXJhbXMgPSB7XG4gIGlkX3Rva2VuPzogc3RyaW5nXG4gIGFjY2Vzc190b2tlbj86IHN0cmluZ1xuICBwcm92aWRlcj86IHN0cmluZ1xufVxuXG4vKiogQ2FsbCBhcGkgYWNjb3VudC9sb2dpbi11c2VyLXdpdGgtdG9rZW5cbiAqIENvbnZlcnRzIE9BdXRoIGFjY2Vzc3Rva2VuIG9yIGlkVG9rZW4gZnJvbSBzb21lIDNyZC1wYXJ0eSBzb3VyY2UgdG8gT1JFSUQgT2F1dGggYWNjZXNzVG9rZW5zXG4gKiBUaGUgdGhpcmQtcGFydHkgKGUuZy4gQXV0aDAgb3IgR29vZ2xlKSBtdXN0IGJlIHJlZ2lzdGVyZWQgaW4gdGhlIEFwcFJlZ2lzdHJhdGlvbi5vYXV0aFNldHRpbmdzXG4gKiBJZiBhIHVzZXIgZG9lcyBub3QgY3VyZW50bHkgZXhpc3QgdGhhdCBtYXRjaGVzIHRoZSBpbmZvIGluIHRoZSBpbmNvbWluZyBpZFRva2VuLCBhIG5ldyBPcmVJRCB1c2VyIGFuZCBhY2NvdW50IGlzIGNyZWF0ZWRcbiAqIFJlcXVpcmVzIGVpdGhlcjpcbiAqICAxKSBhIHZhbGlkIGlkVG9rZW4gKG5lZWRzIG5vIGFjY2Vzc1Rva2VuIG9yIGFwaUtleSBpbiBoZWFkZXIpXG4gKiAgMikgYW4gT3JlSWQgaXNzdWVkIEpXVCBhY2Nlc3NUb2tlbiAobmVlZHMgbm8gYWNjZXNzVG9rZW4gb3IgYXBpS2V5IGluIGhlYWRlcilcbiAqICAzKSBhIDNyZC1wYXJ0eSBhY2Nlc3NUb2tlbiAodXN1YWxseSBub3QgYSBKV1QpIGFuZCBwcm92aWRlciBwYXJhbSAoZS5nLiAnZ29vZ2xlJykgLSBSZXF1aXJlcyBhcGkta2V5IGluIGhlYWRlclxuICogUmV0dXJuczogT3JlSWQgaXNzdWVkIGFjY2Vzc1Rva2VuIGFuZCB1c2VyJ3MgYWNjb3VudCBuYW1lIChpZiBuZXcgYWNjb3VudCBjcmVhdGVkLCB0aGlzIGlzIGEgbmV3IGFjY291bnQgbmFtZSlcbiAqICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbEFwaUxvZ2luVXNlcldpdGhUb2tlbihcbiAgb3JlSWRDb250ZXh0OiBPcmVJZENvbnRleHQsXG4gIHBhcmFtczogQXBpTG9naW5Vc2VyV2l0aFRva2VuUGFyYW1zLFxuKTogUHJvbWlzZTx7IGFjY2Vzc1Rva2VuOiBzdHJpbmcgfSAmIEFwaVJlc3VsdFdpdGhFcnJvckNvZGU+IHtcbiAgY29uc3QgYXBpTmFtZSA9IEFwaUVuZHBvaW50LkxvZ2luVXNlcldpdGhUb2tlblxuICBjb25zdCB7IGFjY2Vzc1Rva2VuLCBpZFRva2VuLCBwcm92aWRlciB9ID0gcGFyYW1zXG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZXF1aXJlIGF1dGhlbnRpY2F0aW9uIChhcGkta2V5IG9yIGFjY2Vzc1Rva2VuKSBpbiByZXF1ZXN0IGhlYWRlciAtIHdoZW4gdXNpbmcgYSBzaWduZWQgSldUIGFjY2Vzc1Rva2VuIG9yIGlkVG9rZW5cbiAgLy8gSXQgZG9lcyByZXF1aXJlIGFuIGFwaS1rZXkgd2hlbiB1c2luZyBhIG5vbi1KV1QgKHRoaXJkLXBhcnR5KSBhY2Nlc3NUb2tlblxuXG4gIGFzc2VydFBhcmFtc0hhdmVPbmx5T25lT2ZWYWx1ZXMocGFyYW1zLCBbJ2FjY2Vzc1Rva2VuJywgJ2lkVG9rZW4nXSwgYXBpTmFtZSlcbiAgYXNzZXJ0UGFyYW1zSGF2ZU9ubHlPbmVPZlZhbHVlcyhwYXJhbXMsIFsnaWRUb2tlbicsICdwcm92aWRlciddLCBhcGlOYW1lKVxuICBpZiAoYWNjZXNzVG9rZW4gJiYgIUhlbHBlcnMuand0RGVjb2RlU2FmZShhY2Nlc3NUb2tlbikpIHtcbiAgICBhc3NlcnRQYXJhbXNIYXZlUmVxdWlyZWRWYWx1ZXMocGFyYW1zLCBbJ3Byb3ZpZGVyJ10sIGFwaU5hbWUpXG4gICAgLy8gaWYgd2UgaGF2ZSBub24tSldUIGFjY2VzcyB0b2tlbiwgd2UgbXVzdCBpbmNsdWRlIGFuIGFwaS1rZXlcbiAgICBhc3NlcnRIYXNBcGlLZXkob3JlSWRDb250ZXh0LCBudWxsLCAnbG9naW4tdXNlci13aXRoLXRva2VuJylcbiAgfVxuXG4gIGNvbnN0IGJvZHk6IEFwaUxvZ2luVXNlcldpdGhUb2tlbkJvZHlQYXJhbXMgPSB7fVxuXG4gIGlmIChpZFRva2VuKSB7XG4gICAgYm9keS5pZF90b2tlbiA9IGlkVG9rZW5cbiAgfSBlbHNlIHtcbiAgICBib2R5LmFjY2Vzc190b2tlbiA9IGFjY2Vzc1Rva2VuXG4gICAgYm9keS5wcm92aWRlciA9IHByb3ZpZGVyXG4gIH1cblxuICBjb25zdCByZXN1bHRzID0gYXdhaXQgb3JlSWRDb250ZXh0LmNhbGxPcmVJZEFwaShcbiAgICBSZXF1ZXN0VHlwZS5Qb3N0LFxuICAgIEFwaUVuZHBvaW50LkxvZ2luVXNlcldpdGhUb2tlbixcbiAgICBib2R5LFxuICAgIG51bGwsIC8vIGFuIGFwaSBrZXkgaXMgTk9UIHJlcXVpcmVkIHRvIGNhbGwgdGhpcyBhcGkgZW5kcG9pbnRcbiAgKVxuICByZXR1cm4gcmVzdWx0cyAvLyBhY2Nlc3NUb2tlbiBhbmQgaWRUb2tlblxufVxuIiwiaW1wb3J0IE9yZUlkQ29udGV4dCBmcm9tICcuLi8uLi9jb3JlL0lPcmVpZENvbnRleHQnXG5pbXBvcnQgeyBBcGlFbmRwb2ludCwgQXV0aFByb3ZpZGVyLCBSZXF1ZXN0VHlwZSB9IGZyb20gJy4uLy4uL21vZGVscydcbmltcG9ydCB7XG4gIGFzc2VydEhhc0FwaUtleSxcbiAgYXNzZXJ0UGFyYW1zSGF2ZUF0TGVhc3RPbmVPZlZhbHVlcyxcbiAgYXNzZXJ0UGFyYW1zSGF2ZU9ubHlPbmVPZlZhbHVlcyxcbiAgYXNzZXJ0UGFyYW1zSGF2ZVJlcXVpcmVkVmFsdWVzLFxufSBmcm9tICcuLi9oZWxwZXJzJ1xuaW1wb3J0IHsgQXBpUmVzdWx0V2l0aEVycm9yQ29kZSB9IGZyb20gJy4uL21vZGVscydcblxuZXhwb3J0IHR5cGUgQXBpTmV3VXNlcldpdGhUb2tlblBhcmFtcyA9IHtcbiAgYWNjZXNzVG9rZW4/OiBzdHJpbmdcbiAgLyoqIHdoZXRoZXIgd2Ugc2hvdWxkIHNraXAgY3JlYXRpb24gb2YgYmxvY2tjaGFpbiBhY2NvdW50cyBmb3IgYSBuZXcgdXNlciAqL1xuICBkZWxheVdhbGxldFNldHVwPzogYm9vbGVhblxuICBpc1Rlc3RVc2VyPzogYm9vbGVhblxuICBpZFRva2VuPzogc3RyaW5nXG4gIHByb3ZpZGVyPzogQXV0aFByb3ZpZGVyXG59XG5cbmV4cG9ydCB0eXBlIEFwaU5ld1VzZXJXaXRoVG9rZW5Cb2R5UGFyYW1zID0ge1xuICBhY2Nlc3NfdG9rZW4/OiBzdHJpbmdcbiAgLyoqIHdoZXRoZXIgd2Ugc2hvdWxkIHNraXAgY3JlYXRpb24gb2YgYmxvY2tjaGFpbiBhY2NvdW50cyBmb3IgYSBuZXcgdXNlciAqL1xuICBkZWxheV93YWxsZXRfc2V0dXA/OiBib29sZWFuXG4gIGlzX3Rlc3RfdXNlcj86IGJvb2xlYW5cbiAgaWRfdG9rZW4/OiBzdHJpbmdcbiAgcHJvdmlkZXI/OiBzdHJpbmdcbn1cblxuLyoqIENhbGwgYXBpIGFjY291bnQvbmV3LXVzZXItd2l0aC10b2tlblxuICogQ29udmVydHMgT0F1dGggYWNjZXNzdG9rZW4gb3IgaWRUb2tlbiBmcm9tIHNvbWUgM3JkLXBhcnR5IHNvdXJjZSB0byBPUkVJRCBPYXV0aCBhY2Nlc3NUb2tlbnNcbiAqIFRoZSB0aGlyZC1wYXJ0eSAoZS5nLiBBdXRoMCBvciBHb29nbGUpIG11c3QgYmUgcmVnaXN0ZXJlZCBpbiB0aGUgQXBwUmVnaXN0cmF0aW9uLm9hdXRoU2V0dGluZ3NcbiAqIElmIGEgdXNlciBkb2VzIG5vdCBjdXJlbnRseSBleGlzdCB0aGF0IG1hdGNoZXMgdGhlIGluZm8gaW4gdGhlIGluY29taW5nIGlkVG9rZW4sIGEgbmV3IE9yZUlEIHVzZXIgYW5kIGFjY291bnQgaXMgY3JlYXRlZFxuICogUmVxdWlyZXMgZXRoZXI6XG4gKiAgMSkgYSB2YWxpZCBpZFRva2VuIChuZWVkcyBubyBhY2Nlc3NUb2tlbiBvciBhcGlLZXkgaW4gaGVhZGVyKVxuICogIDIpIGEgM3JkLXBhcnR5IGFjY2Vzc1Rva2VuICh1c3VhbGx5IG5vdCBhIEpXVCkgYW5kIHByb3ZpZGVyIHBhcmFtIChlLmcuICdnb29nbGUnKSAtIFJlcXVpcmVzIGFwaS1rZXkgaW4gaGVhZGVyXG4gKiBTZXQgaXNUZXN0VXNlciB0byB0cnVlIHRvIGNyZWF0ZSBhIHRlc3QgdXNlciAtIGEgdGVzdCB1c2VyIGNhbiBiZSBkZWxldGVkIHVzaW5nIHVzZXIuZGVsZXRlVGVzdFVzZXIoKSAtIHRoaXMgaXMgaGVscGZ1bCBmb3IgdGVzdGluZ1xuICogUmV0dXJuczogT3JlSWQgaXNzdWVkIGFjY2Vzc1Rva2VuIGFuZCB1c2VyJ3MgYWNjb3VudCBuYW1lIChpZiBuZXcgYWNjb3VudCBjcmVhdGVkLCB0aGlzIGlzIGEgbmV3IGFjY291bnQgbmFtZSlcbiAqICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbEFwaU5ld1VzZXJXaXRoVG9rZW4oXG4gIG9yZUlkQ29udGV4dDogT3JlSWRDb250ZXh0LFxuICBwYXJhbXM6IEFwaU5ld1VzZXJXaXRoVG9rZW5QYXJhbXMsXG4pOiBQcm9taXNlPHsgYWNjZXNzVG9rZW46IHN0cmluZyB9ICYgQXBpUmVzdWx0V2l0aEVycm9yQ29kZT4ge1xuICBjb25zdCBhcGlOYW1lID0gQXBpRW5kcG9pbnQuTmV3VXNlcldpdGhUb2tlblxuICBjb25zdCB7IGFjY2Vzc1Rva2VuLCBkZWxheVdhbGxldFNldHVwLCBpc1Rlc3RVc2VyLCBpZFRva2VuLCBwcm92aWRlciB9ID0gcGFyYW1zXG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZXF1aXJlIGF1dGhlbnRpY2F0aW9uIG9mIGFueSBraW5kIC0gc2luY2UgaXQgYWxsb3dzIGF1dGggYnkgdXNpbmcgYW55IGFjY2Vzc1Rva2VuIG9yIGlkVG9rZW5cbiAgYXNzZXJ0UGFyYW1zSGF2ZUF0TGVhc3RPbmVPZlZhbHVlcyhwYXJhbXMsIFsnaWRUb2tlbicsICdhY2Nlc3NUb2tlbiddLCBhcGlOYW1lKVxuICBhc3NlcnRQYXJhbXNIYXZlT25seU9uZU9mVmFsdWVzKHBhcmFtcywgWydpZFRva2VuJywgJ3Byb3ZpZGVyJ10sIGFwaU5hbWUpIC8vIGlmIGlkVG9rZW4sIHRoZW4gbm8gcHJvdmlkZXIgc2hvdWxkIGJlIGdpdmVuXG4gIGlmIChhY2Nlc3NUb2tlbikge1xuICAgIGFzc2VydFBhcmFtc0hhdmVSZXF1aXJlZFZhbHVlcyhwYXJhbXMsIFsnYWNjZXNzVG9rZW4nLCAncHJvdmlkZXInXSwgYXBpTmFtZSlcbiAgICAvLyBpZiB3ZSBoYXZlIGEgM3JkIHBhcnR5IGFjY2VzcyB0b2tlbiwgd2UgbXVzdCBpbmNsdWRlIGFuIGFwaS1rZXlcbiAgICBhc3NlcnRIYXNBcGlLZXkob3JlSWRDb250ZXh0LCBudWxsLCAnbmV3LXVzZXItd2l0aC10b2tlbicpXG4gIH1cblxuICBjb25zdCBib2R5OiBBcGlOZXdVc2VyV2l0aFRva2VuQm9keVBhcmFtcyA9IHt9XG5cbiAgaWYgKGlkVG9rZW4pIHtcbiAgICBib2R5LmlkX3Rva2VuID0gaWRUb2tlblxuICB9IGVsc2Uge1xuICAgIGJvZHkuYWNjZXNzX3Rva2VuID0gYWNjZXNzVG9rZW5cbiAgICBib2R5LnByb3ZpZGVyID0gcHJvdmlkZXJcbiAgfVxuXG4gIGlmIChpc1Rlc3RVc2VyID09PSB0cnVlKSBib2R5LmlzX3Rlc3RfdXNlciA9IHRydWVcbiAgaWYgKGRlbGF5V2FsbGV0U2V0dXAgPT09IHRydWUpIGJvZHkuZGVsYXlfd2FsbGV0X3NldHVwID0gdHJ1ZVxuXG4gIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBvcmVJZENvbnRleHQuY2FsbE9yZUlkQXBpKFxuICAgIFJlcXVlc3RUeXBlLlBvc3QsXG4gICAgQXBpRW5kcG9pbnQuTmV3VXNlcldpdGhUb2tlbixcbiAgICBib2R5LFxuICAgIG51bGwsIC8vIGFuIGFwaSBrZXkgaXMgTk9UIHJlcXVpcmVkIHRvIGNhbGwgdGhpcyBhcGkgZW5kcG9pbnRcbiAgKVxuICByZXR1cm4gcmVzdWx0cyAvLyBhY2Nlc3NUb2tlbiBhbmQgaWRUb2tlblxufVxuIiwiaW1wb3J0IE9yZUlkQ29udGV4dCBmcm9tICcuLi8uLi9jb3JlL0lPcmVpZENvbnRleHQnXG5pbXBvcnQgeyBBcGlFbmRwb2ludCwgQXV0aFByb3ZpZGVyLCBSZXF1ZXN0VHlwZSB9IGZyb20gJy4uLy4uL21vZGVscydcbmltcG9ydCB7XG4gIGFzc2VydEhhc0FwaUtleU9yQWNjZXNzVG9rZW4sXG4gIGFzc2VydFBhcmFtc0hhdmVPbmx5T25lT2ZWYWx1ZXMsXG4gIGFzc2VydFBhcmFtc0hhdmVSZXF1aXJlZFZhbHVlcyxcbn0gZnJvbSAnLi4vaGVscGVycydcbmltcG9ydCB7IEFwaU1lc3NhZ2VSZXN1bHQgfSBmcm9tICcuLi9tb2RlbHMnXG5cbmV4cG9ydCB0eXBlIEFwaVBhc3N3b3JkTGVzc1NlbmRDb2RlUGFyYW1zID0ge1xuICBlbWFpbD86IHN0cmluZ1xuICBwaG9uZT86IHN0cmluZ1xuICBwcm92aWRlcjogQXV0aFByb3ZpZGVyXG59XG5cbi8qKlxuICogIENhbGwgYXBpIGFjY291bnQvbG9naW4tcGFzc3dvcmRsZXNzLXNlbmQtY29kZVxuICogIFJldHVybnMgeyBzdWNjZXNzOiB0cnVlIH0gaWYgdmVyaWZpY2F0aW9uIGNvZGUgaXMgc2VudCB0byBlbWFpbC9waG9uZVxuICogKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxsQXBpUGFzc3dvcmRMZXNzU2VuZENvZGUoXG4gIG9yZUlkQ29udGV4dDogT3JlSWRDb250ZXh0LFxuICBwYXJhbXM6IEFwaVBhc3N3b3JkTGVzc1NlbmRDb2RlUGFyYW1zLFxuKTogUHJvbWlzZTxBcGlNZXNzYWdlUmVzdWx0PiB7XG4gIGNvbnN0IGFwaU5hbWUgPSBBcGlFbmRwb2ludC5QYXNzd29yZExlc3NTZW5kQ29kZVxuXG4gIGFzc2VydEhhc0FwaUtleU9yQWNjZXNzVG9rZW4ob3JlSWRDb250ZXh0LCBhcGlOYW1lKVxuICBhc3NlcnRQYXJhbXNIYXZlUmVxdWlyZWRWYWx1ZXMocGFyYW1zLCBbJ3Byb3ZpZGVyJ10sIGFwaU5hbWUpXG4gIGFzc2VydFBhcmFtc0hhdmVPbmx5T25lT2ZWYWx1ZXMocGFyYW1zLCBbJ2VtYWlsJywgJ3Bob25lJ10sIGFwaU5hbWUpXG5cbiAgY29uc3QgeyBlbWFpbCwgcGhvbmUsIHByb3ZpZGVyIH0gPSBwYXJhbXNcblxuICBjb25zdCBxdWVyeVBhcmFtczogUGFydGlhbDxBcGlQYXNzd29yZExlc3NTZW5kQ29kZVBhcmFtcz4gPSB7XG4gICAgcHJvdmlkZXIsXG4gIH1cblxuICBpZiAoZW1haWwpIHF1ZXJ5UGFyYW1zLmVtYWlsID0gZW5jb2RlVVJJQ29tcG9uZW50KGVtYWlsKVxuICBpZiAocGhvbmUpIHF1ZXJ5UGFyYW1zLnBob25lID0gZW5jb2RlVVJJQ29tcG9uZW50KHBob25lKSAvLyBpZiB1c2VyIHBhc3NlcyBpbiArMTIxMDMzMzQ0NDQsIHRoZSBwbHVzIHNpZ24gbmVlZHMgdG8gYmUgVVJMIGVuY29kZWRcblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9yZUlkQ29udGV4dC5jYWxsT3JlSWRBcGkoUmVxdWVzdFR5cGUuR2V0LCBBcGlFbmRwb2ludC5QYXNzd29yZExlc3NTZW5kQ29kZSwgcXVlcnlQYXJhbXMsIG51bGwpXG4gIHJldHVybiByZXNwb25zZSBhcyBBcGlNZXNzYWdlUmVzdWx0XG59XG4iLCJpbXBvcnQgT3JlSWRDb250ZXh0IGZyb20gJy4uLy4uL2NvcmUvSU9yZWlkQ29udGV4dCdcbmltcG9ydCB7IEFwaUVuZHBvaW50LCBBdXRoUHJvdmlkZXIsIFJlcXVlc3RUeXBlIH0gZnJvbSAnLi4vLi4vbW9kZWxzJ1xuaW1wb3J0IHtcbiAgYXNzZXJ0SGFzQXBpS2V5T3JBY2Nlc3NUb2tlbixcbiAgYXNzZXJ0UGFyYW1zSGF2ZU9ubHlPbmVPZlZhbHVlcyxcbiAgYXNzZXJ0UGFyYW1zSGF2ZVJlcXVpcmVkVmFsdWVzLFxufSBmcm9tICcuLi9oZWxwZXJzJ1xuaW1wb3J0IHsgQXBpTWVzc2FnZVJlc3VsdCB9IGZyb20gJy4uL21vZGVscydcblxuZXhwb3J0IHR5cGUgQXBpUGFzc3dvcmRMZXNzVmVyaWZ5Q29kZVBhcmFtcyA9IHtcbiAgY29kZT86IHN0cmluZ1xuICBlbWFpbD86IHN0cmluZ1xuICBwaG9uZT86IHN0cmluZ1xuICBwcm92aWRlcjogQXV0aFByb3ZpZGVyXG59XG5cbi8qKlxuICogIENhbGwgYXBpIGFjY291bnQvbG9naW4tcGFzc3dvcmRsZXNzLXZlcmlmeS1jb2RlXG4gKiAgUmV0dXJucyB7IHN1Y2Nlc3M6IHRydWUgfSBpZiBjb2RlIGlzIHZlcmlmaWVkLCB0aHJvd3MgaWYgY29kZS92ZXJpZmljYXRpb24gZmFpbHNcbiAqICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbEFwaVBhc3N3b3JkTGVzc1ZlcmlmeUNvZGUoXG4gIG9yZUlkQ29udGV4dDogT3JlSWRDb250ZXh0LFxuICBwYXJhbXM6IEFwaVBhc3N3b3JkTGVzc1ZlcmlmeUNvZGVQYXJhbXMsXG4pOiBQcm9taXNlPEFwaU1lc3NhZ2VSZXN1bHQ+IHtcbiAgY29uc3QgYXBpTmFtZSA9IEFwaUVuZHBvaW50LlBhc3N3b3JkTGVzc1ZlcmlmeUNvZGVcblxuICBhc3NlcnRIYXNBcGlLZXlPckFjY2Vzc1Rva2VuKG9yZUlkQ29udGV4dCwgYXBpTmFtZSlcbiAgYXNzZXJ0UGFyYW1zSGF2ZVJlcXVpcmVkVmFsdWVzKHBhcmFtcywgWydjb2RlJywgJ3Byb3ZpZGVyJ10sIGFwaU5hbWUpXG4gIGFzc2VydFBhcmFtc0hhdmVPbmx5T25lT2ZWYWx1ZXMocGFyYW1zLCBbJ2VtYWlsJywgJ3Bob25lJ10sIGFwaU5hbWUpXG5cbiAgY29uc3QgeyBjb2RlLCBlbWFpbCwgcGhvbmUsIHByb3ZpZGVyIH0gPSBwYXJhbXNcblxuICBjb25zdCBxdWVyeVBhcmFtczogUGFydGlhbDxBcGlQYXNzd29yZExlc3NWZXJpZnlDb2RlUGFyYW1zPiA9IHtcbiAgICBjb2RlLFxuICAgIHByb3ZpZGVyLFxuICB9XG5cbiAgaWYgKGVtYWlsKSBxdWVyeVBhcmFtcy5lbWFpbCA9IGVuY29kZVVSSUNvbXBvbmVudChlbWFpbClcbiAgaWYgKHBob25lKSBxdWVyeVBhcmFtcy5waG9uZSA9IGVuY29kZVVSSUNvbXBvbmVudChwaG9uZSkgLy8gaWYgdXNlciBwYXNzZXMgaW4gKzEyMTAzMzM0NDQ0LCB0aGUgcGx1cyBzaWduIG5lZWRzIHRvIGJlIFVSTCBlbmNvZGVkXG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvcmVJZENvbnRleHQuY2FsbE9yZUlkQXBpKFxuICAgIFJlcXVlc3RUeXBlLkdldCxcbiAgICBBcGlFbmRwb2ludC5QYXNzd29yZExlc3NWZXJpZnlDb2RlLFxuICAgIHF1ZXJ5UGFyYW1zLFxuICAgIG51bGwsXG4gIClcbiAgcmV0dXJuIHJlc3BvbnNlIGFzIEFwaU1lc3NhZ2VSZXN1bHRcbn1cbiIsImltcG9ydCBPcmVJZENvbnRleHQgZnJvbSAnLi4vLi4vY29yZS9JT3JlaWRDb250ZXh0J1xuaW1wb3J0IHtcbiAgQWNjb3VudE5hbWUsXG4gIEFwaUVuZHBvaW50LFxuICBDaGFpbkFjY291bnQsXG4gIENoYWluTmV0d29yayxcbiAgUmVxdWVzdFR5cGUsXG4gIEFwaUtleVVzZWRGb3IsXG4gIFRyYW5zYWN0aW9uRGF0YSxcbn0gZnJvbSAnLi4vLi4vbW9kZWxzJ1xuaW1wb3J0IHsgQXBpUmVzdWx0V2l0aEVycm9yQ29kZSB9IGZyb20gJy4uL21vZGVscydcbmltcG9ydCB7XG4gIGFzc2VydEhhc0FwaUtleSxcbiAgYXNzZXJ0SGFzQXBpS2V5T3JBY2Nlc3NUb2tlbixcbiAgYXNzZXJ0UGFyYW1zSGF2ZU9ubHlPbmVPZlZhbHVlcyxcbiAgYXNzZXJ0UGFyYW1zSGF2ZVJlcXVpcmVkVmFsdWVzLFxufSBmcm9tICcuLi9oZWxwZXJzJ1xuaW1wb3J0IEhlbHBlcnMgZnJvbSAnLi4vLi4vdXRpbHMvaGVscGVycydcblxuZXhwb3J0IHR5cGUgQXBpU2lnblRyYW5zYWN0aW9uUGFyYW1zID0ge1xuICBhdXRvU2lnbj86IGJvb2xlYW5cbiAgdHJhbnNhY3Rpb25EYXRhOiBUcmFuc2FjdGlvbkRhdGFcbn1cblxuZXhwb3J0IHR5cGUgQXBpU2lnblRyYW5zYWN0aW9uQm9keVBhcmFtcyA9IHtcbiAgYWNjb3VudDogQWNjb3VudE5hbWVcbiAgYWxsb3dfY2hhaW5fYWNjb3VudF9zZWxlY3Rpb24/OiBib29sZWFuXG4gIGF1dG9fc2lnbj86IGJvb2xlYW5cbiAgYnJvYWRjYXN0PzogYm9vbGVhblxuICBjaGFpbl9hY2NvdW50OiBDaGFpbkFjY291bnRcbiAgY2hhaW5fbmV0d29yazogQ2hhaW5OZXR3b3JrXG4gIGV4cGlyZV9zZWNvbmRzPzogbnVtYmVyXG4gIGdlbmVyYXRlX2F1dG9fc2lnbl9jcmVkZW50aWFsPzogYm9vbGVhblxuICBtdWx0aXNpZ19jaGFpbl9hY2NvdW50cz86IHN0cmluZ1xuICAvLyBwcm92aWRlcj86IEF1dGhQcm92aWRlclxuICByZXR1cm5fc2lnbmVkX3RyYW5zYWN0aW9uPzogYm9vbGVhblxuICBzaWduZWRfdHJhbnNhY3Rpb24/OiBzdHJpbmdcbiAgdHJhbnNhY3Rpb24/OiBzdHJpbmdcbiAgdHJhbnNhY3Rpb25fY2hhaW5fYWNjY291bnQ/OiBDaGFpbkFjY291bnRcbiAgdHJhbnNhY3Rpb25fcmVjb3JkX2lkPzogc3RyaW5nXG4gIHVzZXJfcGFzc3dvcmQ/OiBzdHJpbmdcbiAgdXNlcl9wYXNzd29yZF9lbmNyeXB0ZWQ/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgQXBpU2lnblRyYW5zYWN0aW9uUmVzdWx0ID0ge1xuICBzaWduZWRUcmFuc2FjdGlvbj86IHN0cmluZ1xuICB0cmFuc2FjdGlvbklkPzogc3RyaW5nXG59ICYgQXBpUmVzdWx0V2l0aEVycm9yQ29kZVxuXG4vKiogQ29tcG9zZSB0aGUgQVBJIGJvZHkgcGFyYW1zIGZvciBjYWxsaW5nIHNpZ25UcmFuc2FjdGlvbiAqL1xuZnVuY3Rpb24gY29tcG9zZVNpZ25Cb2R5RnJvbVRyYW5zYWN0aW9uRGF0YShwYXJhbXM6IEFwaVNpZ25UcmFuc2FjdGlvblBhcmFtcyk6IEFwaVNpZ25UcmFuc2FjdGlvbkJvZHlQYXJhbXMge1xuICBjb25zdCB7XG4gICAgYWNjb3VudCxcbiAgICBjaGFpbkFjY291bnQsXG4gICAgY2hhaW5OZXR3b3JrLFxuICAgIGV4cGlyZVNlY29uZHMsXG4gICAgc2lnbmVkVHJhbnNhY3Rpb246IHNpZ25lZFRyYW5zYWN0aW9uUGFyYW0sXG4gICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uUGFyYW0sXG4gICAgdHJhbnNhY3Rpb25DaGFpbkFjY291bnQsXG4gICAgdHJhbnNhY3Rpb25SZWNvcmRJZCxcbiAgfSA9IHBhcmFtcy50cmFuc2FjdGlvbkRhdGEgfHwge31cblxuICBjb25zdCB7XG4gICAgYWxsb3dDaGFpbkFjY291bnRTZWxlY3Rpb24sXG4gICAgYnJvYWRjYXN0LFxuICAgIGdlbmVyYXRlQXV0b1NpZ25DcmVkZW50aWFsLFxuICAgIG11bHRpU2lnQ2hhaW5BY2NvdW50cyxcbiAgICByZXR1cm5TaWduZWRUcmFuc2FjdGlvbixcbiAgICB1c2VyUGFzc3dvcmQsXG4gICAgdXNlclBhc3N3b3JkRW5jcnlwdGVkLFxuICB9ID0gcGFyYW1zLnRyYW5zYWN0aW9uRGF0YT8uc2lnbk9wdGlvbnMgfHwge31cblxuICBjb25zdCB7IGF1dG9TaWduIH0gPSBwYXJhbXNcblxuICBjb25zdCBib2R5OiBBcGlTaWduVHJhbnNhY3Rpb25Cb2R5UGFyYW1zID0ge1xuICAgIGFjY291bnQsXG4gICAgYnJvYWRjYXN0LFxuICAgIGNoYWluX2FjY291bnQ6IGNoYWluQWNjb3VudCxcbiAgICBjaGFpbl9uZXR3b3JrOiBjaGFpbk5ldHdvcmssXG4gIH1cblxuICBpZiAoYWxsb3dDaGFpbkFjY291bnRTZWxlY3Rpb24pIGJvZHkuYWxsb3dfY2hhaW5fYWNjb3VudF9zZWxlY3Rpb24gPSBhbGxvd0NoYWluQWNjb3VudFNlbGVjdGlvblxuICBpZiAoYXV0b1NpZ24pIGJvZHkuYXV0b19zaWduID0gYXV0b1NpZ25cbiAgaWYgKGV4cGlyZVNlY29uZHMpIGJvZHkuZXhwaXJlX3NlY29uZHMgPSBleHBpcmVTZWNvbmRzXG4gIGlmIChnZW5lcmF0ZUF1dG9TaWduQ3JlZGVudGlhbCkgYm9keS5nZW5lcmF0ZV9hdXRvX3NpZ25fY3JlZGVudGlhbCA9IGdlbmVyYXRlQXV0b1NpZ25DcmVkZW50aWFsXG4gIGlmIChtdWx0aVNpZ0NoYWluQWNjb3VudHMpIGJvZHkubXVsdGlzaWdfY2hhaW5fYWNjb3VudHMgPSBtdWx0aVNpZ0NoYWluQWNjb3VudHNcbiAgLy8gaWYgKHByb3ZpZGVyKSBib2R5LnByb3ZpZGVyID0gcHJvdmlkZXIgLSBubyBwcm92aWRlciBwYXJhbSBmb3IgQVBJIGNhbGxcbiAgaWYgKHJldHVyblNpZ25lZFRyYW5zYWN0aW9uKSBib2R5LnJldHVybl9zaWduZWRfdHJhbnNhY3Rpb24gPSByZXR1cm5TaWduZWRUcmFuc2FjdGlvblxuICBpZiAoc2lnbmVkVHJhbnNhY3Rpb25QYXJhbSkgYm9keS5zaWduZWRfdHJhbnNhY3Rpb24gPSBIZWxwZXJzLmJhc2U2NEVuY29kZShzaWduZWRUcmFuc2FjdGlvblBhcmFtKVxuICAvLyBpZiAoc3RhdGVQYXJhbSkgYm9keS5zdGF0ZSA9IEhlbHBlcnMuYmFzZTY0RW5jb2RlKHN0YXRlUGFyYW0pIC0gbm8gc3RhdGUgZm9yIGFuIEFQSSBjYWxsXG4gIGlmICh0cmFuc2FjdGlvbkNoYWluQWNjb3VudCkgYm9keS50cmFuc2FjdGlvbl9jaGFpbl9hY2Njb3VudCA9IHRyYW5zYWN0aW9uQ2hhaW5BY2NvdW50XG4gIGlmICh0cmFuc2FjdGlvblBhcmFtKSBib2R5LnRyYW5zYWN0aW9uID0gSGVscGVycy5iYXNlNjRFbmNvZGUodHJhbnNhY3Rpb25QYXJhbSlcbiAgaWYgKHRyYW5zYWN0aW9uUmVjb3JkSWQpIGJvZHkudHJhbnNhY3Rpb25fcmVjb3JkX2lkID0gdHJhbnNhY3Rpb25SZWNvcmRJZFxuICBpZiAodXNlclBhc3N3b3JkKSBib2R5LnVzZXJfcGFzc3dvcmQgPSB1c2VyUGFzc3dvcmQgLy8gdXNlZCBmb3IgY3VzdG9kaWFsIHNpZ25cbiAgaWYgKHVzZXJQYXNzd29yZEVuY3J5cHRlZCkgYm9keS51c2VyX3Bhc3N3b3JkX2VuY3J5cHRlZCA9IHVzZXJQYXNzd29yZEVuY3J5cHRlZCAvLyB1c2VkIGZvciBjdXN0b2RpYWwgc2lnblxuXG4gIHJldHVybiBib2R5XG59XG5cbi8qKiBjb252ZXJ0IHNuYWtlX2Nhc2UgZmllbGRzIGluIHJlc3BvbnNlIHRvIGNhbWVsQ2FzZSAqL1xuZnVuY3Rpb24gbWFwU2lnblJlc3VsdEZyb21BcGkoYXBpUmVzdWx0OiBhbnkpOiBBcGlTaWduVHJhbnNhY3Rpb25SZXN1bHQge1xuICBjb25zdCB7IHNpZ25lZF90cmFuc2FjdGlvbjogc2lnbmVkVHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uX2lkOiB0cmFuc2FjdGlvbklkLCAuLi5yZXN0IH0gPSBhcGlSZXN1bHRcbiAgcmV0dXJuIHtcbiAgICBzaWduZWRUcmFuc2FjdGlvbixcbiAgICB0cmFuc2FjdGlvbklkLFxuICAgIC4uLnJlc3QsXG4gIH1cbn1cblxuLyoqIENhbGwgYXBpIHRyYW5zYWN0aW9uL3NpZ24gLSB0byBzaWduIGEgdHJhbnNhY3Rpb24gZm9yIGEgdXNlclxuICogQ2FuIG9ubHkgc2lnbiBhIHRyYW5zYWN0aW9uIGlmIGF1dG9TaWduIHNwZWNpZmllZCAoYW5kIHByZXZpb3VzbHkgZW5hYmxlZCBieSB1c2VyKVxuICogT1IgaWYgT3JlSWQgaXMgbWFuYWdpbmcgYSBwcml2YXRlIGtleSBpdCBjYW4gc2lnbiB3aXRoIChlLmcuIG1vc3Qgb2Z0ZW4gYW4gYWNjb3VudCBpbiBtdWx0aVNpZ0NoYWluQWNjb3VudHMpXG4gKiBGb3IgYXV0b1NpZ24gcGFyYW0sIHJlcXVpcmVzIGFuIGFwaUtleSB3aXRoIHRoZSBhdXRvU2lnbiByaWdodFxuICogUmV0dXJuczogc3RyaW5naWZpZWQgc2lnbmVkVHJhbnNhY3Rpb24gKGFuZCB0cmFuc2FjdGlvbklkIGlmIGF2YWlsYWJsZSlcbiAqICAgICAgICAgIE9SIGVycm9yQ29kZSwgZXJyb3JEZXNjcmlwdGlvbiwgbWVzc2FnZSAtIGlmIGFueSBpc3N1ZXNcbiAqICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbEFwaVNpZ25UcmFuc2FjdGlvbihcbiAgb3JlSWRDb250ZXh0OiBPcmVJZENvbnRleHQsXG4gIHBhcmFtczogQXBpU2lnblRyYW5zYWN0aW9uUGFyYW1zLFxuKTogUHJvbWlzZTxBcGlTaWduVHJhbnNhY3Rpb25SZXN1bHQ+IHtcbiAgY29uc3QgYXBpTmFtZSA9IEFwaUVuZHBvaW50LlRyYW5zYWN0aW9uU2lnblxuXG4gIGlmIChwYXJhbXM/LmF1dG9TaWduKSB7XG4gICAgYXNzZXJ0SGFzQXBpS2V5KG9yZUlkQ29udGV4dCwgQXBpS2V5VXNlZEZvci5BdXRvU2lnbmluZywgYXBpTmFtZSlcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnRIYXNBcGlLZXlPckFjY2Vzc1Rva2VuKG9yZUlkQ29udGV4dCwgYXBpTmFtZSlcbiAgfVxuICBhc3NlcnRQYXJhbXNIYXZlUmVxdWlyZWRWYWx1ZXMocGFyYW1zLnRyYW5zYWN0aW9uRGF0YSwgWydhY2NvdW50JywgJ2NoYWluTmV0d29yaycsICdjaGFpbkFjY291bnQnXSwgYXBpTmFtZSlcbiAgYXNzZXJ0UGFyYW1zSGF2ZU9ubHlPbmVPZlZhbHVlcyhwYXJhbXMudHJhbnNhY3Rpb25EYXRhLCBbJ3RyYW5zYWN0aW9uJywgJ3NpZ25lZFRyYW5zYWN0aW9uJ10sIGFwaU5hbWUpXG5cbiAgY29uc3QgYm9keSA9IGNvbXBvc2VTaWduQm9keUZyb21UcmFuc2FjdGlvbkRhdGEocGFyYW1zKVxuXG4gIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBvcmVJZENvbnRleHQuY2FsbE9yZUlkQXBpKFJlcXVlc3RUeXBlLlBvc3QsIEFwaUVuZHBvaW50LlRyYW5zYWN0aW9uU2lnbiwgYm9keSwgbnVsbClcbiAgcmV0dXJuIG1hcFNpZ25SZXN1bHRGcm9tQXBpKHJlc3VsdHMpXG59XG5cbi8qKiBDYWxsIGFwaSBjdXN0b2RpYWwvc2lnbiAtIGZvciBzaWduaW5nIGEgdHJhbnNhY3Rpb24gb24gYmVoYWxmIG9mIGEgdXNlclxuICogUmVxdWlyZXMgd2FsbGV0IHBhc3N3b3JkOiBlaXRoZXIgdXNlcl9wYXNzd29yZCBvciB1c2VyX3Bhc3N3b3JkX2VuY3J5cHRlZCBwYXJhbSAodXNlZCB0byBkZWNyeXB0IHVzZXIncyBrZXkpXG4gKiBSZXF1aXJlcyBhbiBhcGlLZXkgd2l0aCB0aGUgcHJveHlTaWduIHJpZ2h0XG4gKiBSZXR1cm5zOiBzdHJpbmdpZmllZCBzaWduZWRUcmFuc2FjdGlvbiAoYW5kIHRyYW5zYWN0aW9uSWQgaWYgYXZhaWxhYmxlKVxuICogICAgICAgICAgT1IgZXJyb3JDb2RlLCBlcnJvckRlc2NyaXB0aW9uLCBtZXNzYWdlIC0gaWYgYW55IGlzc3Vlc1xuICogKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxsQXBpQ3VzdG9kaWFsU2lnblRyYW5zYWN0aW9uKFxuICBvcmVJZENvbnRleHQ6IE9yZUlkQ29udGV4dCxcbiAgcGFyYW1zOiBBcGlTaWduVHJhbnNhY3Rpb25QYXJhbXMsXG4pOiBQcm9taXNlPEFwaVNpZ25UcmFuc2FjdGlvblJlc3VsdD4ge1xuICBjb25zdCBhcGlOYW1lID0gQXBpRW5kcG9pbnQuQ3VzdG9kaWFsU2lnblxuICBjb25zdCB7IHNpZ25PcHRpb25zIH0gPSBwYXJhbXMudHJhbnNhY3Rpb25EYXRhIHx8IHt9XG5cbiAgYXNzZXJ0SGFzQXBpS2V5KG9yZUlkQ29udGV4dCwgQXBpS2V5VXNlZEZvci5Qcm94eVNpZ25pbmcsIGFwaU5hbWUpXG4gIGFzc2VydFBhcmFtc0hhdmVSZXF1aXJlZFZhbHVlcyhwYXJhbXMudHJhbnNhY3Rpb25EYXRhLCBbJ2FjY291bnQnLCAnY2hhaW5OZXR3b3JrJywgJ2NoYWluQWNjb3VudCddLCBhcGlOYW1lKVxuICBhc3NlcnRQYXJhbXNIYXZlT25seU9uZU9mVmFsdWVzKHBhcmFtcy50cmFuc2FjdGlvbkRhdGEsIFsndHJhbnNhY3Rpb24nLCAnc2lnbmVkVHJhbnNhY3Rpb24nXSwgYXBpTmFtZSlcbiAgYXNzZXJ0UGFyYW1zSGF2ZU9ubHlPbmVPZlZhbHVlcyhzaWduT3B0aW9ucywgWyd1c2VyUGFzc3dvcmQnLCAndXNlclBhc3N3b3JkRW5jcnlwdGVkJ10sIGFwaU5hbWUpXG5cbiAgY29uc3QgYm9keSA9IGNvbXBvc2VTaWduQm9keUZyb21UcmFuc2FjdGlvbkRhdGEocGFyYW1zKVxuXG4gIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBvcmVJZENvbnRleHQuY2FsbE9yZUlkQXBpKFJlcXVlc3RUeXBlLlBvc3QsIEFwaUVuZHBvaW50LkN1c3RvZGlhbFNpZ24sIGJvZHksIG51bGwpXG4gIHJldHVybiBtYXBTaWduUmVzdWx0RnJvbUFwaShyZXN1bHRzKVxufVxuIiwiaW1wb3J0IHtcbiAgQXBwQWNjZXNzVG9rZW5NZXRhZGF0YSxcbiAgR2V0T3JlSWRBdXRoVXJsUGFyYW1zLFxuICBHZXRPcmVJZE5ld0NoYWluQWNjb3VudFVybFBhcmFtcyxcbiAgR2V0T3JlSWRSZWNvdmVyQWNjb3VudFVybFBhcmFtcyxcbiAgR2V0UmVjb3ZlckFjY291bnRVcmxSZXN1bHQsXG4gIFRyYW5zYWN0aW9uRGF0YSxcbn0gZnJvbSAnLi4vbW9kZWxzJ1xuaW1wb3J0IEhlbHBlcnMgZnJvbSAnLi4vdXRpbHMvaGVscGVycydcbmltcG9ydCBPcmVJZENvbnRleHQgZnJvbSAnLi9JT3JlaWRDb250ZXh0J1xuXG5jb25zdCB7IGlzTnVsbE9yRW1wdHkgfSA9IEhlbHBlcnNcblxuLyoqIFJldHVybnMgYSBmdWxseSBmb3JtZWQgdXJsIHRvIGNyZWF0ZSBhIG5ldyBjaGFpbiBhY2NvdW50IHdpdGhpbiBhIHVzZXIncyB3YWxsZXQgYWNjb3VudFxuICogIFRoaXMgZnVuY3Rpb24gY2FsbHMgdGhlIC9uZXctYWNjb3VudCB3ZWIgZW5kcG9pbnRcbiAqICBJdCByZXF1aXJlcyBhbiBhcGlLZXkgaW4gb3JkZXIgdG8gYWRkIGFuIGFwcEFjY2Vzc1Rva2VuIHdpdGggbmV3IGFjY291bnQgbWV0YWRhdGFcbiAqICBSZXR1cm5zOiBDYWxsYmFjayByZXR1cm5zIGNoYWluQWNjb3VudCAtIGZvciB0aGUgbmV3IGFjY291bnQgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPcmVJZE5ld0NoYWluQWNjb3VudFVybChvcmVJZENvbnRleHQ6IE9yZUlkQ29udGV4dCwgYXJnczogR2V0T3JlSWROZXdDaGFpbkFjY291bnRVcmxQYXJhbXMpIHtcbiAgY29uc3QgeyBhY2NvdW50LCBhY2NvdW50VHlwZSwgY2hhaW5OZXR3b3JrLCBhY2NvdW50T3B0aW9ucywgcHJvdmlkZXIsIGNhbGxiYWNrVXJsLCBiYWNrZ3JvdW5kQ29sb3IsIHN0YXRlIH0gPSBhcmdzXG4gIGNvbnN0IHsgb3JlSWRVcmwgfSA9IG9yZUlkQ29udGV4dC5vcHRpb25zXG5cbiAgLy8gY29sbGVjdCBhZGRpdGlvbmFsIHBhcmFtcyBlbWJlZGRlZCBpbnRvIGFwcEFjY2Vzc1Rva2VuXG4gIGNvbnN0IGFwcEFjY2Vzc1Rva2VuTWV0YWRhdGE6IEFwcEFjY2Vzc1Rva2VuTWV0YWRhdGEgPSB7XG4gICAgcGFyYW1zTmV3QWNjb3VudDoge1xuICAgICAgYWNjb3VudCxcbiAgICAgIGFjY291bnRUeXBlLFxuICAgICAgY2hhaW5OZXR3b3JrLFxuICAgICAgYWNjb3VudE9wdGlvbnMsXG4gICAgfSxcbiAgfVxuXG4gIGlmICghYWNjb3VudCB8fCAhYWNjb3VudFR5cGUgfHwgIWNoYWluTmV0d29yayB8fCAhcHJvdmlkZXIgfHwgIWNhbGxiYWNrVXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGEgcmVxdWlyZWQgcGFyYW1ldGVyJylcbiAgfVxuXG4gIGNvbnN0IGFjY2Vzc1Rva2VuUGFyYW0gPSBgJm9hdXRoX2FjY2Vzc190b2tlbj0ke29yZUlkQ29udGV4dC5hY2Nlc3NUb2tlbn1gXG5cbiAgLy8gb3B0aW9uYWwgcGFyYW1zXG4gIGNvbnN0IGVuY29kZWRTdGF0ZVBhcmFtID0gc3RhdGUgPyBgJnN0YXRlPSR7c3RhdGV9YCA6ICcnXG5cbiAgY29uc3QgdXJsID1cbiAgICBgJHtvcmVJZFVybH0vbmV3LWFjY291bnQjcHJvdmlkZXI9JHtwcm92aWRlcn0mY2hhaW5fbmV0d29yaz0ke2NoYWluTmV0d29ya31gICtcbiAgICBgJmNhbGxiYWNrX3VybD0ke2VuY29kZVVSSUNvbXBvbmVudChjYWxsYmFja1VybCl9JmJhY2tncm91bmRfY29sb3I9JHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgKX0ke2VuY29kZWRTdGF0ZVBhcmFtfSR7YWNjZXNzVG9rZW5QYXJhbX1gXG4gIHJldHVybiBvcmVJZENvbnRleHQuYWRkQWNjZXNzVG9rZW5BbmRIbWFjVG9VcmwodXJsLCBhcHBBY2Nlc3NUb2tlbk1ldGFkYXRhKVxufVxuXG4vKiogUmV0dXJucyBhIGZ1bGx5IGZvcm1lZCB1cmwgdG8gbG9naW4gYSB1c2VyXG4gKiAgVGhpcyBmdW5jdGlvbiBjYWxscyB0aGUgL2F1dGggd2ViIGVuZHBvaW50XG4gKiAgUmV0dXJuczogQ2FsbGJhY2sgcmV0dXJucyBhY2NvdW50LCBhbmQgb3B0aW9uYWxseSBhY2Nlc3NUb2tlbiBhbmQvb3IgaWRUb2tlbiBmb3IgdXNlciAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9yZUlkQXV0aFVybChvcmVJZENvbnRleHQ6IE9yZUlkQ29udGV4dCwgYXJnczogR2V0T3JlSWRBdXRoVXJsUGFyYW1zKSB7XG4gIGNvbnN0IHtcbiAgICBjb2RlLFxuICAgIGVtYWlsLFxuICAgIHBob25lLFxuICAgIHByb3ZpZGVyLFxuICAgIGNhbGxiYWNrVXJsLFxuICAgIGJhY2tncm91bmRDb2xvcixcbiAgICBzdGF0ZSxcbiAgICBsaW5rVG9BY2NvdW50LFxuICAgIHJldHVybkFjY2Vzc1Rva2VuLFxuICAgIHJldHVybklkVG9rZW4sXG4gIH0gPSBhcmdzXG4gIGNvbnN0IHsgb3JlSWRVcmwgfSA9IG9yZUlkQ29udGV4dC5vcHRpb25zXG5cbiAgaWYgKCFwcm92aWRlciB8fCAhY2FsbGJhY2tVcmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgYSByZXF1aXJlZCBwYXJhbWV0ZXInKVxuICB9XG5cbiAgLy8gb3B0aW9uYWwgcGFyYW1zXG4gIGNvbnN0IGVuY29kZWRTdGF0ZVBhcmFtID0gc3RhdGUgPyBgJnN0YXRlPSR7c3RhdGV9YCA6ICcnXG4gIGNvbnN0IGxpbmtUb0FjY291bnRQYXJhbSA9IGxpbmtUb0FjY291bnQgPyBgJmxpbmtfdG9fYWNjb3VudD0ke2xpbmtUb0FjY291bnR9YCA6ICcnXG5cbiAgLy8gaGFuZGxlIHBhc3N3b3JkbGVzcyBwYXJhbXNcbiAgY29uc3QgY29kZVBhcmFtID0gY29kZSA/IGAmY29kZT0ke2NvZGV9YCA6ICcnXG4gIGNvbnN0IGVtYWlsUGFyYW0gPSBlbWFpbCA/IGAmZW1haWw9JHtlbmNvZGVVUklDb21wb25lbnQoZW1haWwpfWAgOiAnJ1xuICBjb25zdCBwaG9uZVBhcmFtID0gcGhvbmUgPyBgJnBob25lPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHBob25lKX1gIDogJycgLy8gaWYgdXNlciBwYXNzZXMgaW4gKzEyMTAzMzM0NDQ0LCB0aGUgcGx1cyBzaWduIG5lZWRzIHRvIGJlIFVSTCBlbmNvZGVkXG5cbiAgY29uc3QgcmV0dXJuQWNjZXNzVG9rZW5QYXJhbSA9IHJldHVybkFjY2Vzc1Rva2VuID8gYCZyZXR1cm5fYWNjZXNzX3Rva2VuPSR7cmV0dXJuQWNjZXNzVG9rZW59YCA6ICcnXG4gIGNvbnN0IHJldHVybklkVG9rZW5QYXJhbSA9IHJldHVybklkVG9rZW4gPyBgJnJldHVybl9pZF90b2tlbj0ke3JldHVybklkVG9rZW59YCA6ICcnXG5cbiAgY29uc3QgdXJsID1cbiAgICBgJHtvcmVJZFVybH0vYXV0aCNwcm92aWRlcj0ke3Byb3ZpZGVyfWAgK1xuICAgIGAke2NvZGVQYXJhbX0ke2VtYWlsUGFyYW19JHtwaG9uZVBhcmFtfWAgK1xuICAgIGAmY2FsbGJhY2tfdXJsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGNhbGxiYWNrVXJsKX0mYmFja2dyb3VuZF9jb2xvcj0ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgIGJhY2tncm91bmRDb2xvcixcbiAgICApfSR7bGlua1RvQWNjb3VudFBhcmFtfSR7ZW5jb2RlZFN0YXRlUGFyYW19JHtyZXR1cm5BY2Nlc3NUb2tlblBhcmFtfSR7cmV0dXJuSWRUb2tlblBhcmFtfWBcblxuICByZXR1cm4gb3JlSWRDb250ZXh0LmFkZEFjY2Vzc1Rva2VuQW5kSG1hY1RvVXJsKHVybCwgbnVsbClcbn1cblxuLyoqIFJldHVybnMgYSBmdWxseSBmb3JtZWQgdXJsIHRvIGxvZ2luIGEgdXNlclxuICogIFRoaXMgZnVuY3Rpb24gY2FsbHMgdGhlIC9zaWduIHdlYiBlbmRwb2ludFxuICogIFJldHVybnM6IENhbGxiYWNrIHJldHVybnMgdHJhbnNhY3Rpb25JZCAoaWYgYXZhaWxhYmxlKSwgYW5kIG9wdGlvbmFsbHkgc2lnbmVkVHJhbnNhY3Rpb24gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPcmVJZFNpZ25Vcmwob3JlSWRDb250ZXh0OiBPcmVJZENvbnRleHQsIHRyYW5zYWN0aW9uRGF0YTogVHJhbnNhY3Rpb25EYXRhKSB7XG4gIGNvbnN0IHsgYWNjb3VudCwgY2hhaW5OZXR3b3JrLCBleHBpcmVTZWNvbmRzLCBzaWduZWRUcmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uUmVjb3JkSWQgfSA9IHRyYW5zYWN0aW9uRGF0YVxuICBjb25zdCB7XG4gICAgYWxsb3dDaGFpbkFjY291bnRTZWxlY3Rpb24sXG4gICAgYnJvYWRjYXN0LFxuICAgIGNhbGxiYWNrVXJsLFxuICAgIG11bHRpU2lnQ2hhaW5BY2NvdW50cyxcbiAgICBwcm92aWRlcixcbiAgICByZXR1cm5TaWduZWRUcmFuc2FjdGlvbixcbiAgICBzdGF0ZSxcbiAgICAvLyB1c2VyUGFzc3dvcmQsXG4gIH0gPSB0cmFuc2FjdGlvbkRhdGE/LnNpZ25PcHRpb25zIHx8IHt9XG4gIGxldCB7IGNoYWluQWNjb3VudCB9ID0gdHJhbnNhY3Rpb25EYXRhXG4gIGNvbnN0IHsgb3JlSWRVcmwgfSA9IG9yZUlkQ29udGV4dC5vcHRpb25zXG4gIC8vIE5vdyBhbHdheXMgYXBwZW5kcyBhY2Nlc3NUb2tlbiB0byBzaWduVXJsXG4gIGlmICghYWNjb3VudCB8fCAhY2FsbGJhY2tVcmwgfHwgKCF0cmFuc2FjdGlvbiAmJiAhc2lnbmVkVHJhbnNhY3Rpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGEgcmVxdWlyZWQgcGFyYW1ldGVyJylcbiAgfVxuXG4gIC8vIGRlZmF1bHQgY2hhaW5BY2NvdW50IGlzIHRoZSBzYW1lIGFzIHRoZSB1c2VyJ3MgYWNjb3VudFxuICBpZiAoIWNoYWluQWNjb3VudCkge1xuICAgIGNoYWluQWNjb3VudCA9IGFjY291bnRcbiAgfVxuXG4gIGNvbnN0IGVuY29kZWRUcmFuc2FjdGlvbiA9IEhlbHBlcnMuYmFzZTY0RW5jb2RlKHRyYW5zYWN0aW9uKVxuICBjb25zdCBlbmNvZGVkU2lnbmVkVHJhbnNhY3Rpb24gPSBIZWxwZXJzLmJhc2U2NEVuY29kZShzaWduZWRUcmFuc2FjdGlvbilcbiAgbGV0IG9wdGlvbmFsUGFyYW1zID0gc3RhdGUgPyBgJnN0YXRlPSR7c3RhdGV9YCA6ICcnXG4gIG9wdGlvbmFsUGFyYW1zICs9ICFpc051bGxPckVtcHR5KHRyYW5zYWN0aW9uKSA/IGAmdHJhbnNhY3Rpb249JHtlbmNvZGVkVHJhbnNhY3Rpb259YCA6ICcnXG4gIG9wdGlvbmFsUGFyYW1zICs9ICFpc051bGxPckVtcHR5KHNpZ25lZFRyYW5zYWN0aW9uKSA/IGAmc2lnbmVkX3RyYW5zYWN0aW9uPSR7ZW5jb2RlZFNpZ25lZFRyYW5zYWN0aW9ufWAgOiAnJ1xuICBvcHRpb25hbFBhcmFtcyArPSAhaXNOdWxsT3JFbXB0eShhbGxvd0NoYWluQWNjb3VudFNlbGVjdGlvbilcbiAgICA/IGAmYWxsb3dfY2hhaW5fYWNjb3VudF9zZWxlY3Rpb249JHthbGxvd0NoYWluQWNjb3VudFNlbGVjdGlvbn1gXG4gICAgOiAnJ1xuICBvcHRpb25hbFBhcmFtcyArPSAhaXNOdWxsT3JFbXB0eShleHBpcmVTZWNvbmRzKSA/IGAmZXhwaXJlX3NlY29uZHM9JHtleHBpcmVTZWNvbmRzfWAgOiAnJ1xuICBvcHRpb25hbFBhcmFtcyArPSAhaXNOdWxsT3JFbXB0eShtdWx0aVNpZ0NoYWluQWNjb3VudHMpID8gYCZtdWx0aXNpZ19jaGFpbl9hY2NvdW50cz0ke211bHRpU2lnQ2hhaW5BY2NvdW50c31gIDogJydcbiAgb3B0aW9uYWxQYXJhbXMgKz0gIWlzTnVsbE9yRW1wdHkocHJvdmlkZXIpID8gYCZwcm92aWRlcj0ke3Byb3ZpZGVyfWAgOiAnJ1xuICBvcHRpb25hbFBhcmFtcyArPSAhaXNOdWxsT3JFbXB0eShyZXR1cm5TaWduZWRUcmFuc2FjdGlvbilcbiAgICA/IGAmcmV0dXJuX3NpZ25lZF90cmFuc2FjdGlvbj0ke3JldHVyblNpZ25lZFRyYW5zYWN0aW9ufWBcbiAgICA6ICcnXG4gIG9wdGlvbmFsUGFyYW1zICs9ICFpc051bGxPckVtcHR5KHRyYW5zYWN0aW9uUmVjb3JkSWQpID8gYCZ0cmFuc2FjdGlvbl9yZWNvcmRfaWQ9JHt0cmFuc2FjdGlvblJlY29yZElkfWAgOiAnJ1xuICBvcHRpb25hbFBhcmFtcyArPSBgJm9hdXRoX2FjY2Vzc190b2tlbj0ke29yZUlkQ29udGV4dC5hY2Nlc3NUb2tlbn1gXG5cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIGNvbnN0IHVybCA9IGAke29yZUlkVXJsfS9zaWduI2FjY291bnQ9JHthY2NvdW50fSZicm9hZGNhc3Q9JHticm9hZGNhc3R9JmNhbGxiYWNrX3VybD0ke2VuY29kZVVSSUNvbXBvbmVudChjYWxsYmFja1VybCl9JmNoYWluX2FjY291bnQ9JHtjaGFpbkFjY291bnR9JmNoYWluX25ldHdvcms9JHtlbmNvZGVVUklDb21wb25lbnQoY2hhaW5OZXR3b3JrKX0ke29wdGlvbmFsUGFyYW1zfWBcbiAgcmV0dXJuIG9yZUlkQ29udGV4dC5hZGRBY2Nlc3NUb2tlbkFuZEhtYWNUb1VybCh1cmwsIG51bGwpXG59XG5cbi8qKiBSZXR1cm5zIGEgZnVsbHkgZm9ybWVkIHVybCB0byByZWNvdmVyIGEgdXNlcidzIGFjY291bnQgKGUuZy4gY2hhbmdlIHBhc3N3b3JkKVxuICogIFRoaXMgZnVuY3Rpb24gY2FsbHMgdGhlIC9yZWNvdmVyLWFjY291bnQgd2ViIGVuZHBvaW50XG4gKiAgUmV0dXJuczogQ2FsbGJhY2sgcmV0dXJucyBhY2NvdW50IHVwZGF0ZWQgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWNvdmVyQWNjb3VudFVybChcbiAgb3JlSWRDb250ZXh0OiBPcmVJZENvbnRleHQsXG4gIGFyZ3M6IEdldE9yZUlkUmVjb3ZlckFjY291bnRVcmxQYXJhbXMsXG4pOiBQcm9taXNlPEdldFJlY292ZXJBY2NvdW50VXJsUmVzdWx0PiB7XG4gIGNvbnN0IHtcbiAgICBhY2NvdW50LFxuICAgIGNvZGUsXG4gICAgZW1haWwsXG4gICAgcGhvbmUsXG4gICAgcHJvdmlkZXIsXG4gICAgY2FsbGJhY2tVcmwsXG4gICAgYmFja2dyb3VuZENvbG9yLFxuICAgIHN0YXRlLFxuICAgIHJlY292ZXJBY3Rpb24sXG4gICAgb3ZlcnJpZGVBcHBBY2Nlc3NUb2tlbixcbiAgfSA9IGFyZ3NcbiAgY29uc3QgeyBvcmVJZFVybCB9ID0gb3JlSWRDb250ZXh0Lm9wdGlvbnNcblxuICBpZiAoIXByb3ZpZGVyIHx8ICFjYWxsYmFja1VybCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBhIHJlcXVpcmVkIHBhcmFtZXRlcicpXG4gIH1cblxuICBjb25zdCBhY2Nlc3NUb2tlblBhcmFtID0gYCZvYXV0aF9hY2Nlc3NfdG9rZW49JHtvcmVJZENvbnRleHQuYWNjZXNzVG9rZW59YFxuXG4gIC8vIG9wdGlvbmFsIHBhcmFtc1xuICBjb25zdCBlbmNvZGVkU3RhdGVQYXJhbSA9IHN0YXRlID8gYCZzdGF0ZT0ke3N0YXRlfWAgOiAnJ1xuICBjb25zdCBhY3Rpb25UeXBlUGFyYW0gPSByZWNvdmVyQWN0aW9uID8gYCZyZWNvdmVyX2FjdGlvbj0ke3JlY292ZXJBY3Rpb259YCA6ICcnXG5cbiAgLy8gaGFuZGxlIHBhc3N3b3JkbGVzcyBwYXJhbXNcbiAgY29uc3QgY29kZVBhcmFtID0gY29kZSA/IGAmY29kZT0ke2NvZGV9YCA6ICcnXG4gIGNvbnN0IGVtYWlsUGFyYW0gPSBlbWFpbCA/IGAmZW1haWw9JHtlbmNvZGVVUklDb21wb25lbnQoZW1haWwpfWAgOiAnJ1xuICBjb25zdCBwaG9uZVBhcmFtID0gcGhvbmUgPyBgJnBob25lPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHBob25lKX1gIDogJycgLy8gaWYgdXNlciBwYXNzZXMgaW4gKzEyMTAzMzM0NDQ0LCB0aGUgcGx1cyBzaWduIG5lZWRzIHRvIGJlIFVSTCBlbmNvZGVkXG5cbiAgY29uc3QgdXJsID1cbiAgICBgJHtvcmVJZFVybH0vcmVjb3Zlci1hY2NvdW50I3Byb3ZpZGVyPSR7cHJvdmlkZXJ9YCArXG4gICAgYCZhY2NvdW50PSR7YWNjb3VudH1gICtcbiAgICBgJHtjb2RlUGFyYW19JHtlbWFpbFBhcmFtfSR7cGhvbmVQYXJhbX1gICtcbiAgICBgJmNhbGxiYWNrX3VybD0ke2VuY29kZVVSSUNvbXBvbmVudChjYWxsYmFja1VybCl9JmJhY2tncm91bmRfY29sb3I9JHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgKX0ke2FjdGlvblR5cGVQYXJhbX0ke2VuY29kZWRTdGF0ZVBhcmFtfSR7YWNjZXNzVG9rZW5QYXJhbX1gXG5cbiAgcmV0dXJuIG9yZUlkQ29udGV4dC5hZGRBY2Nlc3NUb2tlbkFuZEhtYWNUb1VybCh1cmwsIG51bGwsIG92ZXJyaWRlQXBwQWNjZXNzVG9rZW4pXG59XG4iLCJpbXBvcnQgeyBpbml0QWNjZXNzQ29udGV4dCwgTWFrZVdhbGxldFByb3ZpZGVyRm4sIFdhbGxldCB9IGZyb20gJ0BhaWtvbi9lb3MtdHJhbnNpdCdcbmltcG9ydCB7IG1zZ1BhY2tFbmNvZGUgfSBmcm9tICcuLi91dGlscy9jaGFpblV0aWxzJ1xuaW1wb3J0IHtcbiAgZ2V0VHJhbnNpdFByb3ZpZGVyQXR0cmlidXRlcyxcbiAgZ2V0VHJhbnNpdFByb3ZpZGVyQXR0cmlidXRlc0J5UHJvdmlkZXJJZCxcbiAgc3VwcG9ydGVkVHJhbnNpdFByb3ZpZGVycyxcbn0gZnJvbSAnLi90cmFuc2l0UHJvdmlkZXJzJ1xuaW1wb3J0IE9yZUlkQ29udGV4dCBmcm9tICcuLi9jb3JlL0lPcmVpZENvbnRleHQnXG5pbXBvcnQgSGVscGVycyBmcm9tICcuLi91dGlscy9oZWxwZXJzJ1xuaW1wb3J0IHtcbiAgQWNjb3VudE5hbWUsXG4gIEF1dGhQcm92aWRlcixcbiAgQ2hhaW5BY2NvdW50LFxuICBDaGFpbk5ldHdvcmssXG4gIENoYWluUGxhdGZvcm1UeXBlLFxuICBDb25uZWN0VG9UcmFuc2l0UHJvdmlkZXJQYXJhbXMsXG4gIERpc2NvdmVyT3B0aW9ucyxcbiAgRXh0ZXJuYWxXYWxsZXRJbnRlcmZhY2UsXG4gIEV4dGVybmFsV2FsbGV0VHlwZSxcbiAgTG9naW5XaXRoV2FsbGV0T3B0aW9ucyxcbiAgUGVybWlzc2lvbk5hbWUsXG4gIFB1YmxpY0tleSxcbiAgU2V0dXBUcmFuc2l0V2FsbGV0UGFyYW1zLFxuICBTaWduYXR1cmVQcm92aWRlckFyZ3MsXG4gIFNpZ25hdHVyZVByb3ZpZGVyU2lnblJlc3VsdCxcbiAgU2lnblN0cmluZ1BhcmFtcyxcbiAgVHJhbnNhY3Rpb25EYXRhLFxuICBUcmFuc2l0QWNjb3VudEluZm8sXG4gIFRyYW5zaXRXYWxsZXQsXG4gIFdhbGxldFBlcm1pc3Npb24sXG59IGZyb20gJy4uL21vZGVscydcbmltcG9ydCB7IFRyYW5zaXREaXNjb3ZlcnlPcHRpb25zLCBUcmFuc2l0V2FsbGV0QWNjZXNzQ29udGV4dCB9IGZyb20gJy4nXG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi4vdXNlci91c2VyJ1xuXG50eXBlIENvbm5lY3RUb1RyYW5zaXRQcm92aWRlclJlc3VsdCA9IHtcbiAgaXNMb2dnZWRJbj86IGJvb2xlYW5cbiAgY2hhaW5BY2NvdW50PzogQ2hhaW5BY2NvdW50XG4gIHBlcm1pc3Npb25zPzogW3sgbmFtZTogUGVybWlzc2lvbk5hbWU7IHB1YmxpY0tleTogUHVibGljS2V5IH1dXG4gIHRyYW5zaXRXYWxsZXQ/OiBUcmFuc2l0V2FsbGV0XG4gIHByb3ZpZGVyPzogRXh0ZXJuYWxXYWxsZXRUeXBlXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zaXRIZWxwZXIge1xuICBjb25zdHJ1Y3RvcihhcmdzOiB7IG9yZUlkQ29udGV4dDogT3JlSWRDb250ZXh0OyB1c2VyOiBVc2VyIH0pIHtcbiAgICB0aGlzLl9vcmVJZENvbnRleHQgPSBhcmdzLm9yZUlkQ29udGV4dFxuICAgIHRoaXMuX3VzZXIgPSBhcmdzLnVzZXJcbiAgICB0aGlzLnRyYW5zaXRBY2Nlc3NDb250ZXh0cyA9IHt9XG4gIH1cblxuICBfb3JlSWRDb250ZXh0OiBPcmVJZENvbnRleHRcblxuICBfdXNlcjogVXNlclxuXG4gIHRyYW5zaXRBY2Nlc3NDb250ZXh0czogeyBba2V5OiBzdHJpbmddOiBUcmFuc2l0V2FsbGV0QWNjZXNzQ29udGV4dCB9XG5cbiAgLyoqIFZlcmlmaWVzIHRoYXQgYWxsIHBsdWdpbnMgcHJvdmlkZWQgd29yayAoY2FuIGJlIGNvbnN0cnVjdGVkKVxuICAgKiAgU3RvcmVzIGEgbGlzdCBvZiB0aGUgaW5zdGFsbGVkIHByb3ZpZGVyTmFtZXMgKG1hcHBlZCB0byBFeHRlcm5hbFdhbGxldFR5cGUpIGZvciBhbGwgd29ya2luZyBwbHVnaW5zIGluIHRyYW5zaXRQcm92aWRlcnNJbnN0YWxsZWRcbiAgICovXG4gIGFzeW5jIGluc3RhbGxUcmFuc2l0UHJvdmlkZXJzKGVvc1RyYW5zaXRXYWxsZXRQcm92aWRlcnM6IE1ha2VXYWxsZXRQcm92aWRlckZuW10pIHtcbiAgICAvLyBFeGVjdXRlcyBlYWNoIHByb3ZpZGVyJ3MgY29udHJ1Y3RvciB0byB2ZXJpZnkgaXQncyB3b3JraW5nXG4gICAgLy8gc3RvcmVzIGFsbCB0aGUgcHJvdmlkZXJOYW1lJ3MgZm9yIGFsbCBwbHVnaW5zIGludG8gdHJhbnNpdFByb3ZpZGVyc0luc3RhbGxlZCBhcnJheVxuICAgIHRoaXMuX29yZUlkQ29udGV4dC50cmFuc2l0UHJvdmlkZXJzSW5zdGFsbGVkID0gKGVvc1RyYW5zaXRXYWxsZXRQcm92aWRlcnMgfHwgW10pXG4gICAgICAubWFwKG1ha2VXYWxsZXRQcm92aWRlciA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gZXJyb3Igd2hpbGUgaW5pdGlhdGluZyBhIHByb3ZpZGVyIGRvbnQgYnJlYWsgdGhlIHdob2xlIHByb2Nlc3MuXG4gICAgICAgICAgcmV0dXJuIG1ha2VXYWxsZXRQcm92aWRlcihudWxsKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYENvdWxkbid0IGluaXRpYXRlIGEgd2FsbGV0IHByb3ZpZGVyLiAke2V9YClcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICB9KSAvLyBpbnN0YW50aWF0ZSB0aGUgcHJvdmlkZXIgd2l0aCBudWxsIG5ldHdvcmsgc28gd2UgY2FuIGdldCB0aGUgaWRcbiAgICAgIC5maWx0ZXIod2FsbGV0UHJvdmlkZXIgPT4gd2FsbGV0UHJvdmlkZXIgJiYgdHJ1ZSlcbiAgICAgIC5tYXAod2FsbGV0UHJvdmlkZXIgPT4ge1xuICAgICAgICByZXR1cm4gZ2V0VHJhbnNpdFByb3ZpZGVyQXR0cmlidXRlc0J5UHJvdmlkZXJJZCh3YWxsZXRQcm92aWRlci5pZCkucHJvdmlkZXJOYW1lXG4gICAgICB9KVxuICB9XG5cbiAgLyoqIEluaWFsaXplIEVPUyBUcmFuc2l0IHdhbGxldCBwcm92aWRlciBhbmQgcmV0dXJuIFRyYW5zaXRXYWxsZXQgaW5zdGFuY2UgKi9cbiAgYXN5bmMgc2V0dXBUcmFuc2l0V2FsbGV0KHsgd2FsbGV0VHlwZSwgY2hhaW5OZXR3b3JrIH06IFNldHVwVHJhbnNpdFdhbGxldFBhcmFtcyk6IFByb21pc2U8VHJhbnNpdFdhbGxldD4ge1xuICAgIHRoaXMuYXNzZXJ0SGFzUHJvdmlkZXJJbnN0YWxsZWQod2FsbGV0VHlwZSwgRXh0ZXJuYWxXYWxsZXRJbnRlcmZhY2UuVHJhbnNpdClcbiAgICB0aGlzLmFzc2VydFByb3ZpZGVyVmFsaWRGb3JDaGFpbk5ldHdvcmsod2FsbGV0VHlwZSwgY2hhaW5OZXR3b3JrKVxuICAgIGNvbnN0IHsgcHJvdmlkZXJJZCB9ID0gZ2V0VHJhbnNpdFByb3ZpZGVyQXR0cmlidXRlcyh3YWxsZXRUeXBlKVxuICAgIGNvbnN0IGNoYWluQ29udGV4dCA9IGF3YWl0IHRoaXMuZ2V0T3JDcmVhdGVUcmFuc2l0QWNjZXNzQ29udGV4dChjaGFpbk5ldHdvcmspXG4gICAgY29uc3QgdHJhbnNpdFByb3ZpZGVyID0gY2hhaW5Db250ZXh0LmdldFdhbGxldFByb3ZpZGVycygpLmZpbmQod3AgPT4gd3AuaWQgPT09IHByb3ZpZGVySWQpXG4gICAgY29uc3QgdHJhbnNpdFdhbGxldCA9IGNoYWluQ29udGV4dC5pbml0V2FsbGV0KHRyYW5zaXRQcm92aWRlcilcbiAgICBhd2FpdCB0cmFuc2l0V2FsbGV0LmNvbm5lY3QoKVxuICAgIGF3YWl0IHRoaXMud2FpdFdoaWxlV2FsbGV0SXNCdXN5KHRyYW5zaXRXYWxsZXQsIHdhbGxldFR5cGUpXG4gICAgcmV0dXJuIHRyYW5zaXRXYWxsZXRcbiAgfVxuXG4gIC8qKiBDcmVhdGVzIGFuIEVPUyBUcmFuc2l0IFdhbGxldENvbnRlbnQgZm9yIHRoZSBzcGVjaWZpZWQgbmV0d29yayBhbmQgcGx1Z2luc1xuICAgKiAgQ2FjaGVzIHRoZSBjb250ZXh0IGZvciBmdXR1cmUgY2FsbHMgdG8gdGhpcyBmdW5jdGlvbiAqL1xuICBwcml2YXRlIGFzeW5jIGdldE9yQ3JlYXRlVHJhbnNpdEFjY2Vzc0NvbnRleHQoY2hhaW5OZXR3b3JrOiBDaGFpbk5ldHdvcmspIHtcbiAgICBjb25zdCB7IGFwcE5hbWUsIGVvc1RyYW5zaXRXYWxsZXRQcm92aWRlcnMgPSBbXSB9ID0gdGhpcy5fb3JlSWRDb250ZXh0Lm9wdGlvbnNcbiAgICBpZiAodGhpcy50cmFuc2l0QWNjZXNzQ29udGV4dHNbY2hhaW5OZXR3b3JrXSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdEFjY2Vzc0NvbnRleHRzW2NoYWluTmV0d29ya11cbiAgICB9XG4gICAgY29uc3QgbmV0d29ya0NvbmZpZyA9IGF3YWl0IHRoaXMuX29yZUlkQ29udGV4dC5zZXR0aW5ncy5nZXRDaGFpbk5ldHdvcmtOZXh0d29ya0NvbmZpZyhjaGFpbk5ldHdvcmspXG4gICAgY29uc3QgaXNOb3RFb3NOZXR3b3JrID0gYXdhaXQgdGhpcy5fb3JlSWRDb250ZXh0LnNldHRpbmdzLmlzTm90RW9zTmV0d29yayhjaGFpbk5ldHdvcmspXG4gICAgY29uc3Qgd2FsbGV0Q29udGV4dCA9IGluaXRBY2Nlc3NDb250ZXh0KHtcbiAgICAgIGFwcE5hbWU6IGFwcE5hbWUgfHwgJ21pc3NpbmcgYXBwTmFtZScsXG4gICAgICBuZXR3b3JrOiBuZXR3b3JrQ29uZmlnLFxuICAgICAgd2FsbGV0UHJvdmlkZXJzOiBlb3NUcmFuc2l0V2FsbGV0UHJvdmlkZXJzLFxuICAgICAgaXNOb3RFb3NOZXR3b3JrLCAvLyBUZWxscyBlb3MtdHJhbnNpdCB0byBub3QgdXNlIEVPUyBzcGVjaWZpYyBycGMgY2FsbHNcbiAgICB9KVxuICAgIC8vIGNhY2hlIGZvciBmdXR1cmUgdXNlXG4gICAgdGhpcy50cmFuc2l0QWNjZXNzQ29udGV4dHNbY2hhaW5OZXR3b3JrXSA9IHdhbGxldENvbnRleHRcbiAgICByZXR1cm4gd2FsbGV0Q29udGV4dFxuICB9XG5cbiAgLy8gRm9yIFNjYXR0ZXI6IGNoYWluQWNjb3VudCBpcyBuZWVkZWQgc2luY2UgbG9naW4gd2lsbCB0cnkgdG8gdXNlIHRoZSBkZWZhdWx0IGFjY291bnQgKGluIHNjYXR0ZXJcbiAgLy8gYW5kIGl0IHdpbCBmYWlsIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gIC8qKiBIYW5kbGVzIHRoZSBjYWxsIHRvIGNvbm5lY3QoKSBmdW5jdGlvbiBvbiB0aGUgVHJhbnNpdCBwcm92aWRlciAqL1xuICBhc3luYyBjb25uZWN0VG9UcmFuc2l0UHJvdmlkZXIoe1xuICAgIHdhbGxldFR5cGUsXG4gICAgY2hhaW5OZXR3b3JrLFxuICAgIGNoYWluQWNjb3VudCA9IG51bGwsXG4gIH06IENvbm5lY3RUb1RyYW5zaXRQcm92aWRlclBhcmFtcyk6IFByb21pc2U8Q29ubmVjdFRvVHJhbnNpdFByb3ZpZGVyUmVzdWx0PiB7XG4gICAgbGV0IHJlc3BvbnNlOiBDb25uZWN0VG9UcmFuc2l0UHJvdmlkZXJSZXN1bHRcbiAgICB0aGlzLmFzc2VydEhhc1Byb3ZpZGVySW5zdGFsbGVkKHdhbGxldFR5cGUsIEV4dGVybmFsV2FsbGV0SW50ZXJmYWNlLlRyYW5zaXQpXG4gICAgdGhpcy5hc3NlcnRQcm92aWRlclZhbGlkRm9yQ2hhaW5OZXR3b3JrKHdhbGxldFR5cGUsIGNoYWluTmV0d29yaylcbiAgICB0cnkge1xuICAgICAgY29uc3QgdHJhbnNpdFdhbGxldDogVHJhbnNpdFdhbGxldCA9IGF3YWl0IHRoaXMuc2V0dXBUcmFuc2l0V2FsbGV0KHsgd2FsbGV0VHlwZSwgY2hhaW5OZXR3b3JrIH0pXG4gICAgICByZXNwb25zZSA9IHsgdHJhbnNpdFdhbGxldCB9XG4gICAgICAvLyBzb21lIHByb3ZpZGVycyByZXF1aXJlIGxvZ2luIGZsb3cgdG8gY29ubmVjdCAodXN1YWxseSB0aGlzIG1lYW5zIGNvbm5lY3QoKSBkb2VzIG5vdGhpbmcgYnV0IGxvZ2luIHNlbGVjdHMgYW4gYWNjb3VudClcbiAgICAgIGlmIChnZXRUcmFuc2l0UHJvdmlkZXJBdHRyaWJ1dGVzKHdhbGxldFR5cGUpLnJlcXVpcmVzTG9naW4pIHtcbiAgICAgICAgLy8gaWYgY29ubmVjdGVkLCBidXQgbm90IGF1dGhlbnRpY2F0ZWQsIHRoZW4gbG9naW5cbiAgICAgICAgaWYgKCF0cmFuc2l0V2FsbGV0LmF1dGhlbnRpY2F0ZWQpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmxvZ2luVG9UcmFuc2l0UHJvdmlkZXIodHJhbnNpdFdhbGxldCwgd2FsbGV0VHlwZSwgY2hhaW5OZXR3b3JrLCBjaGFpbkFjY291bnQpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgY29ubmVjdGluZyBhbHNvIHBlcmZvcm1zIGxvZ2luXG4gICAgICAvLyByZXR1cm4gbG9naW4gcmVzdWx0cyBvciB0aHJvdyBlcnJvclxuICAgICAgaWYgKHRyYW5zaXRXYWxsZXQuY29ubmVjdGVkKSB7XG4gICAgICAgIC8vIGlmIHdhbGxldCBoYXMgYW4gYWNjb3VudCAoYnkgbG9nZ2luZyBpbiksIGFkZCBpdCB0byBPUkVJRCBhY2NvdW50IGFkZCBhY2NvdW50IGluZm8gdG8gcmVzcG9uc2VcbiAgICAgICAgaWYgKHRyYW5zaXRXYWxsZXQuYXV0aGVudGljYXRlZCAmJiB0cmFuc2l0V2FsbGV0LmF1dGgpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZU9yZUFjY291bnRQZXJtaXNzaW9uc2Zyb21UcmFuc2l0V2FsbGV0QXV0aCh0cmFuc2l0V2FsbGV0LCB3YWxsZXRUeXBlKVxuICAgICAgICAgIGNvbnN0IHsgYWNjb3VudE5hbWUsIHBlcm1pc3Npb24sIHB1YmxpY0tleSB9ID0gdHJhbnNpdFdhbGxldC5hdXRoXG4gICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICBpc0xvZ2dlZEluOiB0cnVlLFxuICAgICAgICAgICAgY2hhaW5BY2NvdW50OiBhY2NvdW50TmFtZSxcbiAgICAgICAgICAgIHBlcm1pc3Npb25zOiBbeyBuYW1lOiBwZXJtaXNzaW9uLCBwdWJsaWNLZXkgfV0sIC8vIHRvZG86IGFkZCBwYXJlbnQgcGVybWlzc2lvbiB3aGVuIGF2YWlsYWJsZVxuICAgICAgICAgICAgdHJhbnNpdFdhbGxldCxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB3YWxsZXRUeXBlLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGVycm9yU3RyaW5nID0gYCR7d2FsbGV0VHlwZX0gbm90IGNvbm5lY3RlZCFgXG4gICAgICAgIGNvbnN0IHsgaGFzRXJyb3IsIGVycm9yTWVzc2FnZSB9ID0gdHJhbnNpdFdhbGxldFxuICAgICAgICBpZiAoaGFzRXJyb3IpIHtcbiAgICAgICAgICBlcnJvclN0cmluZyArPSBgIEVycm9yOiAke2Vycm9yTWVzc2FnZX1gXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5nKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSBgRmFpbGVkIHRvIGNvbm5lY3QgdG8gJHt3YWxsZXRUeXBlfSBvbiAke2NoYWluTmV0d29ya30uICR7ZXJyb3I/Lm1lc3NhZ2UgfHwgJyd9YFxuICAgICAgY29uc29sZS5sb2coYGNvbm5lY3RUb1RyYW5zaXRQcm92aWRlcjoke2Vyck1zZ31gLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX29yZUlkQ29udGV4dC5zZXRJc0J1c3koZmFsc2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKiogSGFuZGxlcyB0aGUgY2FsbCB0byBsb2dpbigpIGZ1bmN0aW9uIG9uIHRoZSBUcmFuc2l0IHByb3ZpZGVyXG4gICAqICBJZiByZXF1aXJlZCBieSBwcm92aWRlciwgY2FsbHMgZGlzY292ZXIoKSBhbmQvb3IgbG9nb3V0KCkgYmVmb3JlIGNhbGxpbmcgbG9naW4oKVxuICAgKiAgSU1QT1JUQU5UOiB1c2UgbG9naW5Ub1RyYW5zaXRQcm92aWRlcigpIGluc3RlYWQgb2YgdGhpcyBmdW5jdGlvbiAqL1xuICBwcml2YXRlIGFzeW5jIGRvVHJhbnNpdFByb3ZpZGVyTG9naW4oXG4gICAgdHJhbnNpdFdhbGxldDogVHJhbnNpdFdhbGxldCxcbiAgICBjaGFpbkFjY291bnQ6IENoYWluQWNjb3VudCxcbiAgICBjaGFpbk5ldHdvcms6IENoYWluTmV0d29yayxcbiAgICB3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUsXG4gICAgcmV0cnlDb3VudCA9IDAsXG4gICkge1xuICAgIGxldCBpbmZvOiBUcmFuc2l0QWNjb3VudEluZm9cbiAgICB0aGlzLmFzc2VydEhhc1Byb3ZpZGVySW5zdGFsbGVkKHdhbGxldFR5cGUsIEV4dGVybmFsV2FsbGV0SW50ZXJmYWNlLlRyYW5zaXQpXG4gICAgdGhpcy5hc3NlcnRQcm92aWRlclZhbGlkRm9yQ2hhaW5OZXR3b3JrKHdhbGxldFR5cGUsIGNoYWluTmV0d29yaylcbiAgICAvLyB3ZSBzaG91bGQgc3RvcmUgdGhlIGluZGV4IGZvciBsZWRnZXIgaW4gdGhlIGRiIGFuZCBwYXNzIGl0IGFsb25nXG4gICAgLy8gYnV0IGZvciBub3cgd2UgbmVlZCB0byBkaXNjb3ZlciB0aGUgbGVkZ2VyIGluZGV4XG4gICAgY29uc3QgeyByZXF1aXJlc0Rpc2NvdmVyVG9Mb2dpbiB9ID0gZ2V0VHJhbnNpdFByb3ZpZGVyQXR0cmlidXRlcyh3YWxsZXRUeXBlKVxuICAgIGlmIChyZXF1aXJlc0Rpc2NvdmVyVG9Mb2dpbikge1xuICAgICAgLy8gd2UgaGF2ZSB0byBkaXNjb3ZlciBvbiBsZWRnZXIgc2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgaW5kZXggb2YgdGhlIGFjY291bnRcbiAgICAgIC8vXG4gICAgICBjb25zdCBkaXNjb3ZlcnlEYXRhID0gYXdhaXQgdHJhbnNpdFdhbGxldC5kaXNjb3Zlcih0aGlzLmRpc2NvdmVyT3B0aW9uc0ZvclByb3ZpZGVyKHdhbGxldFR5cGUpKVxuICAgICAgY29uc3QgZm91bmREYXRhID0gdGhpcy5maW5kQWNjb3VudEluRGlzY292ZXJEYXRhKGRpc2NvdmVyeURhdGEsIGNoYWluQWNjb3VudClcbiAgICAgIGlmIChmb3VuZERhdGEpIHtcbiAgICAgICAgaW5mbyA9IGF3YWl0IHRyYW5zaXRXYWxsZXQubG9naW4oY2hhaW5BY2NvdW50LCBmb3VuZERhdGEuYXV0aG9yaXphdGlvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWNjb3VudCAke2NoYWluQWNjb3VudH0gbm90IGZvdW5kIGluIHdhbGxldGApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gPSBhd2FpdCB0cmFuc2l0V2FsbGV0LmxvZ2luKGNoYWluQWNjb3VudClcbiAgICB9XG5cbiAgICBpZiAocmV0cnlDb3VudCA+IDIpIHtcbiAgICAgIC8vIGRvbid0IGdldCBzdHVjayBpbiBhIGxvb3AsIGxldCB0aGUgdHJhbnNhY3Rpb24gZmFpbCBzbyB0aGUgdXNlciB3aWxsIGZpZ3VyZSBpdCBvdXRcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgeyBhY2NvdW50TmFtZTogdHJhbnNpdEFjY291bnROYW1lIH0gPSB0cmFuc2l0V2FsbGV0Py5hdXRoIHx8IHt9XG5cbiAgICBpZiAoY2hhaW5BY2NvdW50ICYmIHRyYW5zaXRBY2NvdW50TmFtZSAhPT0gY2hhaW5BY2NvdW50KSB7XG4gICAgICAvLyBrZWVwIHRyeWluZyB1bnRpbCB0aGUgdXNlciBsb2dzIGluIHdpdGggdGhlIGNvcnJlY3Qgd2FsbGV0XG4gICAgICAvLyBpbiBzY2F0dGVyLCBpdCB3aWxsIGFzayB5b3UgdG8gY2hvb3NlIGFuIGFjY291bnQgaWYgeW91IGxvZ291dCBhbmQgbG9nIGJhY2sgaW5cbiAgICAgIC8vIHdlIGNvdWxkIGFsc28gY2FsbCBkaXNjb3ZlciBhbmQgbG9naW4gdG8gdGhlIG1hdGNoaW5nIGFjY291bnQgYW5kIHRoYXQgd291bGQgYXZvaWQgYSBzdGVwXG4gICAgICBhd2FpdCB0cmFuc2l0V2FsbGV0LmxvZ291dCgpXG4gICAgICB0aGlzLmRvVHJhbnNpdFByb3ZpZGVyTG9naW4odHJhbnNpdFdhbGxldCwgY2hhaW5BY2NvdW50LCBjaGFpbk5ldHdvcmssIHdhbGxldFR5cGUsIHJldHJ5Q291bnQgKyAxKVxuICAgIH1cbiAgICByZXR1cm4gaW5mb1xuICB9XG5cbiAgLyoqIExvZ2luIHVzaW5nIHRoZSB3YWxsZXQgcHJvdmlkZXIgKi9cbiAgYXN5bmMgbG9naW5XaXRoVHJhbnNpdFByb3ZpZGVyKGxvZ2luT3B0aW9uczogTG9naW5XaXRoV2FsbGV0T3B0aW9ucykge1xuICAgIGNvbnN0IHsgd2FsbGV0VHlwZTogcHJvdmlkZXIsIGNoYWluQWNjb3VudCwgY2hhaW5OZXR3b3JrIH0gPSBsb2dpbk9wdGlvbnNcbiAgICAvLyBDb25uZWN0IHRvIFByb3ZpZGVyXG4gICAgY29uc3Qgd2FsbGV0VHlwZSA9IEhlbHBlcnMubWFwQXV0aFByb3ZpZGVyVG9XYWxsZXRUeXBlKHByb3ZpZGVyKVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb25uZWN0VG9UcmFuc2l0UHJvdmlkZXIoeyB3YWxsZXRUeXBlLCBjaGFpbkFjY291bnQsIGNoYWluTmV0d29yayB9KVxuICAgIGNvbnN0IHdhbGxldCA9IHJlc3BvbnNlPy50cmFuc2l0V2FsbGV0XG4gICAgLy8gTG9naW4gaWYgbmVlZGVkIC0gaWYgbm90IGxvZ2dlZC1pbiBieSBjb25uZWN0VG9UcmFuc2l0UHJvdmlkZXIsIHRoZW4gY2FsbCBsb2dpbiBleHBsaWNpdGx5XG4gICAgaWYgKCF3YWxsZXQ/LmF1dGgpIHtcbiAgICAgIGF3YWl0IHRoaXMubG9naW5Ub1RyYW5zaXRQcm92aWRlcih3YWxsZXQsIHByb3ZpZGVyLCBjaGFpbk5ldHdvcmssIGNoYWluQWNjb3VudClcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlT3JlQWNjb3VudFBlcm1pc3Npb25zZnJvbVRyYW5zaXRXYWxsZXRBdXRoKHdhbGxldCwgcHJvdmlkZXIpXG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgLyoqIEhhbmRsZXMgdGhlIGNhbGwgdG8gbG9naW4oKSBmdW5jdGlvbiBvbiB0aGUgVHJhbnNpdCBwcm92aWRlciAqL1xuICBwcml2YXRlIGFzeW5jIGxvZ2luVG9UcmFuc2l0UHJvdmlkZXIoXG4gICAgdHJhbnNpdFdhbGxldDogVHJhbnNpdFdhbGxldCxcbiAgICB3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUsXG4gICAgY2hhaW5OZXR3b3JrOiBDaGFpbk5ldHdvcmssXG4gICAgY2hhaW5BY2NvdW50OiBDaGFpbkFjY291bnQgPSBudWxsLFxuICApIHtcbiAgICB0aGlzLmFzc2VydEhhc1Byb3ZpZGVySW5zdGFsbGVkKHdhbGxldFR5cGUsIEV4dGVybmFsV2FsbGV0SW50ZXJmYWNlLlRyYW5zaXQpXG4gICAgdGhpcy5hc3NlcnRQcm92aWRlclZhbGlkRm9yQ2hhaW5OZXR3b3JrKHdhbGxldFR5cGUsIGNoYWluTmV0d29yaylcbiAgICB0cnkge1xuICAgICAgLy8gaWYgdGhlIGRlZmF1bHQgbG9naW4gaXMgZm9yIGEgZGlmZmVyZW50IGFjY291bnRcbiAgICAgIGF3YWl0IHRoaXMuZG9UcmFuc2l0UHJvdmlkZXJMb2dpbih0cmFuc2l0V2FsbGV0LCBjaGFpbkFjY291bnQsIGNoYWluTmV0d29yaywgd2FsbGV0VHlwZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgeyBtZXNzYWdlID0gJycgfSA9IGVycm9yXG4gICAgICBpZiAobWVzc2FnZS5pbmNsdWRlcygndW5rbm93biBrZXkgKGJvb3N0Ojp0dXBsZXM6OnR1cGxlJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgYWNjb3VudCBzZWxlY3RlZCBieSB0aGUgd2FsbGV0IGZvciBsb2dpbiBpc24ndCBvbiB0aGUgJHtjaGFpbk5ldHdvcmt9IGNoYWluYClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IHRoaXMud2FpdFdoaWxlV2FsbGV0SXNCdXN5KHRyYW5zaXRXYWxsZXQsIHdhbGxldFR5cGUpXG4gICAgfVxuICB9XG5cbiAgLyoqIFRocm93IGlmIHRoZSByZXF1aXJlZCBwbHVnLWluIGlzIG5vdCBpbnN0YWxsZWQgKi9cbiAgYXNzZXJ0SGFzUHJvdmlkZXJJbnN0YWxsZWQocHJvdmlkZXI6IEV4dGVybmFsV2FsbGV0VHlwZSwgcHJvdmlkZXJUeXBlOiBFeHRlcm5hbFdhbGxldEludGVyZmFjZSkge1xuICAgIGlmIChwcm92aWRlclR5cGUgPT09IEV4dGVybmFsV2FsbGV0SW50ZXJmYWNlLlRyYW5zaXQpIHtcbiAgICAgIGlmICghdGhpcy5oYXNUcmFuc2l0UHJvdmlkZXIocHJvdmlkZXIpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBUcmFuc2l0IHByb3ZpZGVyOlwiJHtwcm92aWRlcn1cIiBub3QgaW5zdGFsbGVkLiBQbGVhc2UgcGFzcyBpdCBpbiB2aWEgZW9zVHJhbnNpdFdhbGxldFByb3ZpZGVycy5gKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBEaXNjb3ZlcnMga2V5cyBpbiBhIHdhbGxldCBwcm92aWRlci5cbiAgICogIEFueSBuZXcga2V5cyBkaXNjb3ZlcmVkIGluIHdhbGxldCBhcmUgYWRkZWQgdG8gdXNlcidzIE9SRSBJRCByZWNvcmQuXG4gICAqICBJZiB0aGUgcHJvdmlkZXIgZG9lc250IHN1cHBvcnQgYSBkaXNjb3ZlcigpIGZ1bmN0aW9uLCBhbmQgcmVxdWlyZXNMb2dvdXRMb2dpblRvRGlzY292ZXIgPT0gdHJ1ZSwgYXR0ZW1wdHMgYSBsb2dvdXQgdGhlbiBsb2dpbiBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZGlzY292ZXJXaXRoVHJhbnNpdChkaXNjb3Zlck9wdGlvbnM6IERpc2NvdmVyT3B0aW9ucykge1xuICAgIGNvbnN0IHsgd2FsbGV0VHlwZSwgY2hhaW5OZXR3b3JrID0gQ2hhaW5OZXR3b3JrLkVvc01haW4sIG9yZUFjY291bnQsIGRpc2NvdmVyeVBhdGhJbmRleExpc3QgfSA9IGRpc2NvdmVyT3B0aW9uc1xuICAgIHRoaXMuYXNzZXJ0UHJvdmlkZXJWYWxpZEZvckNoYWluTmV0d29yayh3YWxsZXRUeXBlLCBjaGFpbk5ldHdvcmspXG4gICAgbGV0IHJlc3VsdCA9IG51bGxcbiAgICBpZiAodGhpcy5jYW5EaXNjb3Zlcih3YWxsZXRUeXBlKSkge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5kaXNjb3ZlckNyZWRlbnRpYWxzSW5UcmFuc2l0V2FsbGV0KFxuICAgICAgICBjaGFpbk5ldHdvcmssXG4gICAgICAgIHdhbGxldFR5cGUsXG4gICAgICAgIG9yZUFjY291bnQsXG4gICAgICAgIGRpc2NvdmVyeVBhdGhJbmRleExpc3QsXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHByb3ZpZGVyIGRvZXNuJ3Qgc3VwcG9ydCBhIGRpc2NvdmVyIGZ1bmN0aW9uLCB3ZSBjYW4gdXNlIGxvZ2luIHRvIHJldHJpZXZlIGEgc2luZ2xlIGFjY291bnQva2V5IGluc3RlYWRcbiAgICAgIGNvbnN0IHRyYW5zaXRXYWxsZXQgPSBhd2FpdCB0aGlzLnNldHVwVHJhbnNpdFdhbGxldCh7IHdhbGxldFR5cGUsIGNoYWluTmV0d29yayB9KVxuICAgICAgaWYgKHRoaXMucmVxdWlyZXNMb2dvdXRMb2dpblRvRGlzY292ZXIod2FsbGV0VHlwZSkpIHtcbiAgICAgICAgYXdhaXQgdHJhbnNpdFdhbGxldC5sb2dvdXQoKVxuICAgICAgICBhd2FpdCB0cmFuc2l0V2FsbGV0LmxvZ2luKClcbiAgICAgICAgdGhpcy51cGRhdGVPcmVBY2NvdW50UGVybWlzc2lvbnNmcm9tVHJhbnNpdFdhbGxldEF1dGgodHJhbnNpdFdhbGxldCwgd2FsbGV0VHlwZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdEaXNjb3ZlciBub3Qgd29ya2luZyBmb3Igd2FsbGV0VHlwZTogJywgd2FsbGV0VHlwZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKiogRGlzY292ZXIgYWxsIGFjY291bnRzIChhbmQgcmVsYXRlZCBwZXJtaXNzaW9ucykgaW4gdGhlIHdhbGxldCBhbmQgYWRkIHRoZW0gdG8gT1JFIElEXG4gICAqIE5vdGU6IE1vc3Qgd2FsbGV0cyBkb24ndCBzdXBwb3J0IGRpc2NvdmVyeSAqL1xuICBwcml2YXRlIGFzeW5jIGRpc2NvdmVyQ3JlZGVudGlhbHNJblRyYW5zaXRXYWxsZXQoXG4gICAgY2hhaW5OZXR3b3JrOiBDaGFpbk5ldHdvcmssXG4gICAgd2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlLFxuICAgIG9yZUFjY291bnQ6IEFjY291bnROYW1lLFxuICAgIGRpc2NvdmVyeVBhdGhJbmRleExpc3Q6IG51bWJlcltdLFxuICApIHtcbiAgICBsZXQgYWNjb3VudHNBbmRQZXJtaXNzaW9uczogV2FsbGV0UGVybWlzc2lvbltdID0gW11cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0cmFuc2l0V2FsbGV0ID0gYXdhaXQgdGhpcy5zZXR1cFRyYW5zaXRXYWxsZXQoeyB3YWxsZXRUeXBlLCBjaGFpbk5ldHdvcmsgfSlcbiAgICAgIHRoaXMuX29yZUlkQ29udGV4dC5zZXRJc0J1c3kodHJ1ZSlcbiAgICAgIGNvbnN0IGRpc2NvdmVyeURhdGEgPSBhd2FpdCB0cmFuc2l0V2FsbGV0LmRpc2NvdmVyKFxuICAgICAgICB0aGlzLmRpc2NvdmVyT3B0aW9uc0ZvclByb3ZpZGVyKHdhbGxldFR5cGUsIGRpc2NvdmVyeVBhdGhJbmRleExpc3QpLFxuICAgICAgKVxuICAgICAgLy8gdGhpcyBkYXRhIGxvb2tzIGxpa2UgdGhpczoga2V5VG9BY2NvdW50TWFwW2FjY291bnRzW3thY2NvdW50LHBlcm1pc3Npb259XV0gLSBlLmcuIGtleVRvQWNjb3VudE1hcFthY2NvdW50c1t7J215YWNjb3VudCc6J293bmVyJywnbXlhY2NvdW50JzonYWN0aXZlJ31dXVxuICAgICAgY29uc3QgY3JlZGVudGlhbHMgPSBkaXNjb3ZlcnlEYXRhLmtleVRvQWNjb3VudE1hcFxuICAgICAgLy8gZm9yIGVhY2ggZW50cnkgaW4gdGhlIGFycmF5LCBhZGQgcGVybWlzc2lvbiB0byBvcmUgYWNjb3VudCBpZiBub3QgYWxyZWFkeSBwcmVzZW50XG4gICAgICBhd2FpdCBIZWxwZXJzLmFzeW5jRm9yRWFjaChjcmVkZW50aWFscywgYXN5bmMgY3JlZGVudGlhbCA9PiB7XG4gICAgICAgIGNvbnN0IHsgYWNjb3VudHMgPSBbXSwga2V5OiBwdWJsaWNLZXkgfSA9IGNyZWRlbnRpYWxcbiAgICAgICAgLy8gZXRoZXJldW0gbWF5IG5vdCBoYXZlIGEgcHVibGljIGtleSAtIGRvbnQgc2F2ZSBpZiBtaXNzaW5nXG4gICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPiAwICYmICEhcHVibGljS2V5KSB7XG4gICAgICAgICAgY29uc3QgW3sgYWNjb3VudCwgYXV0aG9yaXphdGlvbiB9XSA9IGFjY291bnRzIC8vIGdldCBmaXJzdCBpdGVtIGluIGFycmF5XG4gICAgICAgICAgY29uc3QgcGVybWlzc2lvbnM6IFdhbGxldFBlcm1pc3Npb25bXSA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgcHVibGljS2V5LFxuICAgICAgICAgICAgICBuYW1lOiBhdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF1cbiAgICAgICAgICAvLyBHZXQgdGhlIGNoYWluTmV0d29yayBmcm9tIHRoZSB0cmFuc2l0V2FsbGV0IC0gaW4gY2FzZSB0aGUgd2FsbGV0IHByb3ZpZGVyIHN3aXRjaGVzIG5ldHdvcmtzIHNvbWVob3dcbiAgICAgICAgICBjb25zdCB0cmFuc2l0Q2hhaW5OZXR3b3JrID0gYXdhaXQgdGhpcy5nZXRDaGFpbk5ldHdvcmtGcm9tVHJhbnNpdFdhbGxldCh0cmFuc2l0V2FsbGV0KVxuICAgICAgICAgIGF3YWl0IHRoaXMuX3VzZXI/LmFkZFdhbGxldFBlcm1pc3Npb25zVG9PcmVJZEFjY291bnQoe1xuICAgICAgICAgICAgY2hhaW5BY2NvdW50OiBhY2NvdW50LFxuICAgICAgICAgICAgY2hhaW5OZXR3b3JrOiB0cmFuc2l0Q2hhaW5OZXR3b3JrLFxuICAgICAgICAgICAgcGVybWlzc2lvbnMsXG4gICAgICAgICAgICB3YWxsZXRUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgYWNjb3VudHNBbmRQZXJtaXNzaW9ucyA9IGFjY291bnRzQW5kUGVybWlzc2lvbnMuY29uY2F0KHBlcm1pc3Npb25zKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9vcmVJZENvbnRleHQuc2V0SXNCdXN5KGZhbHNlKVxuICAgIH1cbiAgICAvLyByZXR1cm4gYSBsaXN0IG9mIGFjY291bnQgbmFtZXMgYW5kIHJlbGF0ZWQgcGVybWlzc2lvbnMgZm91bmRcbiAgICByZXR1cm4gYWNjb3VudHNBbmRQZXJtaXNzaW9uc1xuICB9XG5cbiAgLyoqIERpc2NvdmVyIG9wdGlvbnMgY29tcG9zZWQgZm9yIHNwZWNpZmljIHByb3ZpZGVyICovXG4gIHByaXZhdGUgZGlzY292ZXJPcHRpb25zRm9yUHJvdmlkZXIoXG4gICAgcHJvdmlkZXI6IEV4dGVybmFsV2FsbGV0VHlwZSxcbiAgICBwYXRoSW5kZXhMaXN0UGFyYW06IG51bWJlcltdID0gbnVsbCxcbiAgKTogVHJhbnNpdERpc2NvdmVyeU9wdGlvbnMge1xuICAgIGxldCBwYXRoSW5kZXhMaXN0XG4gICAgbGV0IGtleUxvb2t1cEZ1bmNcbiAgICBjb25zdCB3YWxsZXRQcm92aWRlclR5cGUgPSBIZWxwZXJzLm1hcEF1dGhQcm92aWRlclRvV2FsbGV0VHlwZShwcm92aWRlcilcbiAgICBpZiAodGhpcy5oYXNUcmFuc2l0UHJvdmlkZXIod2FsbGV0UHJvdmlkZXJUeXBlKSkge1xuICAgICAgY29uc3Qgd2FsbGV0UHJvdmlkZXIgPSBIZWxwZXJzLm1hcEF1dGhQcm92aWRlclRvV2FsbGV0VHlwZShwcm92aWRlcilcbiAgICAgIGNvbnN0IHsgZGVmYXVsdERpc2NvdmVyeVBhdGhJbmRleExpc3QsIGRpc2NvdmVyeUtleUxvb2t1cEZ1bmMgfSA9IGdldFRyYW5zaXRQcm92aWRlckF0dHJpYnV0ZXMod2FsbGV0UHJvdmlkZXIpXG4gICAgICBwYXRoSW5kZXhMaXN0ID0gcGF0aEluZGV4TGlzdFBhcmFtIHx8IGRlZmF1bHREaXNjb3ZlcnlQYXRoSW5kZXhMaXN0IHx8IFtdXG4gICAgICBrZXlMb29rdXBGdW5jID0gZGlzY292ZXJ5S2V5TG9va3VwRnVuYyAvLyBvcHRpb25hbFxuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlOiBUcmFuc2l0RGlzY292ZXJ5T3B0aW9ucyA9IHsgcGF0aEluZGV4TGlzdCB9XG4gICAgaWYgKGtleUxvb2t1cEZ1bmMpIHtcbiAgICAgIHJlc3BvbnNlLmtleUxvb2t1cEZ1bmMgPSBrZXlMb29rdXBGdW5jXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICBwcml2YXRlIGZpbmRBY2NvdW50SW5EaXNjb3ZlckRhdGEoZGlzY292ZXJ5RGF0YTogYW55LCBjaGFpbkFjY291bnQ6IENoYWluQWNjb3VudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGRpc2NvdmVyeURhdGEua2V5VG9BY2NvdW50TWFwLmZpbmQoKGRhdGE6IGFueSkgPT4ge1xuICAgICAgcmV0dXJuIGRhdGEuYWNjb3VudHMuZmluZCgoYWNjdDogYW55KSA9PiB7XG4gICAgICAgIHJldHVybiBhY2N0LmFjY291bnQgPT09IGNoYWluQWNjb3VudFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgbGV0IGF1dGhvcml6YXRpb24gPSAnYWN0aXZlJ1xuXG4gICAgICAvLyBjb3VsZCBhY3RpdmUgbm90IGV4aXN0PyAgSWYgbm90LCB0aGVuIGp1c3QgZ2V0IGZpcnN0IHBlcm1pc3Npb25cbiAgICAgIC8vIHRoaXMgbWF5IGJlIGNvbXBsZXRlbHkgdW5lY2Vzc2FyeS4gcmVtb3ZlIGlmIHNvLlxuICAgICAgY29uc3QgYWN0aXZlID0gcmVzdWx0LmFjY291bnRzLmZpbmQoKGFjY3Q6IGFueSkgPT4ge1xuICAgICAgICByZXR1cm4gYWNjdC5hdXRob3JpemF0aW9uID09PSAnYWN0aXZlJ1xuICAgICAgfSlcblxuICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgY29uc3QgW2ZpcnN0XSA9IHJlc3VsdC5hY2NvdW50c1xuXG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICAgIGF1dGhvcml6YXRpb24gPSBmaXJzdC5hdXRob3JpemF0aW9uXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgaW5kZXg6IHJlc3VsdC5pbmRleCwga2V5OiByZXN1bHQua2V5LCBhdXRob3JpemF0aW9uIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqIHNpZ24gd2l0aCBhIFRyYW5zaXQgd2FsbGV0ICovXG4gIGFzeW5jIHNpZ25XaXRoVHJhbnNpdFByb3ZpZGVyKHRyYW5zYWN0aW9uRGF0YTogVHJhbnNhY3Rpb25EYXRhLCB3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUpIHtcbiAgICBsZXQgc2lnbmVkVHJhbnNhY3Rpb246IFNpZ25hdHVyZVByb3ZpZGVyU2lnblJlc3VsdFxuICAgIGNvbnN0IHsgY2hhaW5OZXR3b3JrLCBjaGFpbkFjY291bnQgfSA9IHRyYW5zYWN0aW9uRGF0YVxuICAgIHRoaXMuYXNzZXJ0SGFzUHJvdmlkZXJJbnN0YWxsZWQod2FsbGV0VHlwZSwgRXh0ZXJuYWxXYWxsZXRJbnRlcmZhY2UuVHJhbnNpdClcbiAgICB0aGlzLmFzc2VydFByb3ZpZGVyVmFsaWRGb3JDaGFpbk5ldHdvcmsod2FsbGV0VHlwZSwgY2hhaW5OZXR3b3JrKVxuICAgIC8vIGNvbm5lY3QgdG8gd2FsbGV0XG4gICAgY29uc3QgeyB0cmFuc2l0V2FsbGV0IH0gPSBhd2FpdCB0aGlzLmNvbm5lY3RUb1RyYW5zaXRQcm92aWRlcih7XG4gICAgICB3YWxsZXRUeXBlLFxuICAgICAgY2hhaW5OZXR3b3JrLFxuICAgICAgY2hhaW5BY2NvdW50LFxuICAgIH0pXG5cbiAgICB0cnkge1xuICAgICAgLy8gc2lnbiB3aXRoIHRyYW5zaXQgd2FsbGV0XG4gICAgICB0aGlzLl9vcmVJZENvbnRleHQuc2V0SXNCdXN5KHRydWUpXG4gICAgICBjb25zdCB7IGNoYWluVHlwZSB9ID0gZ2V0VHJhbnNpdFByb3ZpZGVyQXR0cmlidXRlcyh3YWxsZXRUeXBlKVxuICAgICAgLy8gRU9TIC0gdXNlIGVvc0pTIHRvIHNpZ24gKGVvc0FwaS50cmFuc2FjdClcbiAgICAgIGlmIChjaGFpblR5cGUgPT09IENoYWluUGxhdGZvcm1UeXBlLmVvcykge1xuICAgICAgICBzaWduZWRUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuc2lnblRyYW5zYWN0aW9uV2l0aFRyYW5zaXRBbmRFb3NTREsodHJhbnNhY3Rpb25EYXRhLCB0cmFuc2l0V2FsbGV0KVxuICAgICAgfSBlbHNlIGlmIChjaGFpblR5cGUgPT09IENoYWluUGxhdGZvcm1UeXBlLmFsZ29yYW5kKSB7XG4gICAgICAgIC8vIE90aGVyIGNoYWlucyAtIHVzZSBzaWduIGZ1bmN0aW9uIG9uIHdhbGxldFByb3ZpZGVyXG4gICAgICAgIHNpZ25lZFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb25XaXRoVHJhbnNpdEFuZEFsZ29yYW5kU0RLKHRyYW5zYWN0aW9uRGF0YSwgdHJhbnNpdFdhbGxldClcbiAgICAgIH0gZWxzZSBpZiAoY2hhaW5UeXBlID09PSBDaGFpblBsYXRmb3JtVHlwZS5ldGhlcmV1bSkge1xuICAgICAgICAvLyBFdGhlcmV1bSAtIHVzZSBzaWduIGZ1bmN0aW9uIG9uIGV0aGVyZXVtIHdhbGxldFByb3ZpZGVyXG4gICAgICAgIHNpZ25lZFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb25XaXRoVHJhbnNpdEFuZEV0aGVyZXVtU0RLKHRyYW5zYWN0aW9uRGF0YSwgdHJhbnNpdFdhbGxldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbldpdGhUcmFuc2l0UHJvdmlkZXIgZG9lc250IHN1cHBvcnQgY2hhaW4gdHlwZTogJHtjaGFpblR5cGV9YClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX29yZUlkQ29udGV4dC5zZXRJc0J1c3koZmFsc2UpXG4gICAgfVxuICAgIC8vIENvbnZlcnQgc2VyaWFsaXplZFRyYW5zYWN0aW9uIGZyb20gVUludDhBcnJheSB0byBCdWZmZXJcbiAgICAvLyBpLmUuIHdoZW4gc3RyaW5naWZpZWQgY2hhbmdlIGZyb206ICd7XFxcIjBcXFwiOjEyOSxcXFwiMVxcXCI6MTYzJ30gdG8ge1widHlwZVwiOlwiQnVmZmVyXCIsXCJkYXRhXCI6WzEyOSwxNjNdfVxuICAgIGlmIChzaWduZWRUcmFuc2FjdGlvbi5zZXJpYWxpemVkVHJhbnNhY3Rpb24pIHtcbiAgICAgIHNpZ25lZFRyYW5zYWN0aW9uLnNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IEJ1ZmZlci5mcm9tKHNpZ25lZFRyYW5zYWN0aW9uLnNlcmlhbGl6ZWRUcmFuc2FjdGlvbilcbiAgICB9XG4gICAgcmV0dXJuIHsgc2lnbmVkVHJhbnNhY3Rpb24gfVxuICB9XG5cbiAgYXN5bmMgc2lnblN0cmluZ1dpdGhUcmFuc2l0UHJvdmlkZXIoeyB3YWxsZXRUeXBlLCBjaGFpbk5ldHdvcmssIHN0cmluZywgbWVzc2FnZSwgbWV0YWRhdGEgfTogU2lnblN0cmluZ1BhcmFtcykge1xuICAgIHRoaXMuYXNzZXJ0SGFzUHJvdmlkZXJJbnN0YWxsZWQod2FsbGV0VHlwZSwgRXh0ZXJuYWxXYWxsZXRJbnRlcmZhY2UuVHJhbnNpdClcbiAgICB0aGlzLmFzc2VydFByb3ZpZGVyVmFsaWRGb3JDaGFpbk5ldHdvcmsod2FsbGV0VHlwZSwgY2hhaW5OZXR3b3JrKVxuICAgIGNvbnN0IHsgdHJhbnNpdFdhbGxldCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0VG9UcmFuc2l0UHJvdmlkZXIoeyB3YWxsZXRUeXBlLCBjaGFpbk5ldHdvcmsgfSlcbiAgICB0cnkge1xuICAgICAgdGhpcy5fb3JlSWRDb250ZXh0LnNldElzQnVzeSh0cnVlKVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0cmFuc2l0V2FsbGV0LnNpZ25BcmJpdHJhcnkoc3RyaW5nLCBtZXNzYWdlLCBtZXRhZGF0YSlcbiAgICAgIHJldHVybiB7IHNpZ25lZFN0cmluZzogcmVzcG9uc2UgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fb3JlSWRDb250ZXh0LnNldElzQnVzeShmYWxzZSlcbiAgICB9XG4gIH1cblxuICAvKiogc2lnbiB0cmFuc2FjdGlvbiB1c2luZyBFT1MgU0RLIC50cmFuc2FjdCBmdW5jdGlvbiAqL1xuICBwcml2YXRlIGFzeW5jIHNpZ25UcmFuc2FjdGlvbldpdGhUcmFuc2l0QW5kRW9zU0RLKFxuICAgIHRyYW5zYWN0aW9uRGF0YTogVHJhbnNhY3Rpb25EYXRhLFxuICAgIHRyYW5zaXRXYWxsZXQ6IFdhbGxldCxcbiAgKTogUHJvbWlzZTxTaWduYXR1cmVQcm92aWRlclNpZ25SZXN1bHQ+IHtcbiAgICBjb25zdCB7IGV4cGlyZVNlY29uZHMsIHRyYW5zYWN0aW9uIH0gPSB0cmFuc2FjdGlvbkRhdGFcbiAgICBjb25zdCB7IGJyb2FkY2FzdCB9ID0gdHJhbnNhY3Rpb25EYXRhPy5zaWduT3B0aW9ucyB8fCB7fVxuICAgIGNvbnN0IHsgc2lnbmF0dXJlcywgc2VyaWFsaXplZFRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0cmFuc2l0V2FsbGV0LmVvc0FwaS50cmFuc2FjdChcbiAgICAgIHtcbiAgICAgICAgYWN0aW9uczogW3RyYW5zYWN0aW9uXSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJyb2FkY2FzdCxcbiAgICAgICAgYmxvY2tzQmVoaW5kOiAzLFxuICAgICAgICBleHBpcmVTZWNvbmRzOiBleHBpcmVTZWNvbmRzIHx8IDYwLFxuICAgICAgfSxcbiAgICApXG4gICAgYXdhaXQgdGhpcy5jYWxsRGlzY292ZXJBZnRlclNpZ24odHJhbnNhY3Rpb25EYXRhKVxuICAgIHJldHVybiB7IHNpZ25hdHVyZXMsIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiB9XG4gIH1cblxuICAvKiogc2lnbiB0cmFuc2FjdGlvbiB1c2luZyBBbGdvcmFuZCBTREsgKi9cbiAgcHJpdmF0ZSBhc3luYyBzaWduVHJhbnNhY3Rpb25XaXRoVHJhbnNpdEFuZEFsZ29yYW5kU0RLKFxuICAgIHRyYW5zYWN0aW9uRGF0YTogVHJhbnNhY3Rpb25EYXRhLFxuICAgIHRyYW5zaXRXYWxsZXQ6IFdhbGxldCxcbiAgKTogUHJvbWlzZTxTaWduYXR1cmVQcm92aWRlclNpZ25SZXN1bHQ+IHtcbiAgICBjb25zdCB7IGNoYWluTmV0d29yaywgdHJhbnNhY3Rpb24gfSA9IHRyYW5zYWN0aW9uRGF0YVxuICAgIC8vIE90aGVyIGNoYWlucyAtIHVzZSBzaWduIGZ1bmN0aW9uIG9uIHdhbGxldFByb3ZpZGVyXG4gICAgY29uc3QgbmV0d29ya0NvbmZpZyA9IGF3YWl0IHRoaXMuX29yZUlkQ29udGV4dC5zZXR0aW5ncy5nZXRDaGFpbk5ldHdvcmtOZXh0d29ya0NvbmZpZyhjaGFpbk5ldHdvcmspXG4gICAgY29uc3Qgc2lnblBhcmFtczogU2lnbmF0dXJlUHJvdmlkZXJBcmdzID0ge1xuICAgICAgY2hhaW5JZDogbmV0d29ya0NvbmZpZy5jaGFpbklkLCAvLyBDaGFpbiB0cmFuc2FjdGlvbiBpcyBmb3JcbiAgICAgIHJlcXVpcmVkS2V5czogbnVsbCwgLy8gbm90IHVzZWQgYnkgQWxnb3JhbmQgc2lnbmF0dXJlUHJvdmlkZXJcbiAgICAgIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbjogbXNnUGFja0VuY29kZSh0cmFuc2FjdGlvbiksIC8vIFRyYW5zYWN0aW9uIHRvIHNpZ25cbiAgICAgIGFiaXM6IG51bGwsIC8vIG5vdCB1c2VkIGJ5IEFsZ29yYW5kIHNpZ25hdHVyZVByb3ZpZGVyXG4gICAgfVxuICAgIGNvbnN0IHsgc2lnbmF0dXJlcywgc2VyaWFsaXplZFRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0cmFuc2l0V2FsbGV0LnByb3ZpZGVyLnNpZ25hdHVyZVByb3ZpZGVyLnNpZ24oc2lnblBhcmFtcylcbiAgICBhd2FpdCB0aGlzLmNhbGxEaXNjb3ZlckFmdGVyU2lnbih0cmFuc2FjdGlvbkRhdGEpXG4gICAgcmV0dXJuIHsgc2lnbmF0dXJlcywgc2VyaWFsaXplZFRyYW5zYWN0aW9uIH1cbiAgfVxuXG4gIC8qKiBzaWduIHRyYW5zYWN0aW9uIHVzaW5nIGV0aGVyZXVtIHdlYjMgU0RLICovXG4gIHByaXZhdGUgYXN5bmMgc2lnblRyYW5zYWN0aW9uV2l0aFRyYW5zaXRBbmRFdGhlcmV1bVNESyhcbiAgICB0cmFuc2FjdGlvbkRhdGE6IFRyYW5zYWN0aW9uRGF0YSxcbiAgICB0cmFuc2l0V2FsbGV0OiBXYWxsZXQsXG4gICk6IFByb21pc2U8U2lnbmF0dXJlUHJvdmlkZXJTaWduUmVzdWx0PiB7XG4gICAgY29uc3QgeyBjaGFpbk5ldHdvcmssIHRyYW5zYWN0aW9uIH0gPSB0cmFuc2FjdGlvbkRhdGFcbiAgICAvLyBPdGhlciBjaGFpbnMgLSB1c2Ugc2lnbiBmdW5jdGlvbiBvbiB3YWxsZXRQcm92aWRlclxuICAgIGNvbnN0IG5ldHdvcmtDb25maWcgPSBhd2FpdCB0aGlzLl9vcmVJZENvbnRleHQuc2V0dGluZ3MuZ2V0Q2hhaW5OZXR3b3JrTmV4dHdvcmtDb25maWcoY2hhaW5OZXR3b3JrKVxuICAgIGNvbnN0IHNpZ25QYXJhbXM6IFNpZ25hdHVyZVByb3ZpZGVyQXJncyA9IHtcbiAgICAgIGNoYWluSWQ6IG5ldHdvcmtDb25maWcuY2hhaW5JZCwgLy8gQ2hhaW4gdHJhbnNhY3Rpb24gaXMgZm9yXG4gICAgICByZXF1aXJlZEtleXM6IG51bGwsIC8vIG5vdCB1c2VkIGJ5IEV0aGVyZXVtIHNpZ25hdHVyZVByb3ZpZGVyXG4gICAgICBzZXJpYWxpemVkVHJhbnNhY3Rpb246IG1zZ1BhY2tFbmNvZGUodHJhbnNhY3Rpb24pLCAvLyBUcmFuc2FjdGlvbiB0byBzaWduXG4gICAgICBhYmlzOiBudWxsLCAvLyBub3QgdXNlZCBieSBFdGhlcmV1bSBzaWduYXR1cmVQcm92aWRlclxuICAgIH1cbiAgICBjb25zdCB7IHNpZ25hdHVyZXMsIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiB9ID0gYXdhaXQgdHJhbnNpdFdhbGxldC5wcm92aWRlci5zaWduYXR1cmVQcm92aWRlci5zaWduKHNpZ25QYXJhbXMpXG4gICAgYXdhaXQgdGhpcy5jYWxsRGlzY292ZXJBZnRlclNpZ24odHJhbnNhY3Rpb25EYXRhKVxuICAgIHJldHVybiB7IHNpZ25hdHVyZXMsIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiB9XG4gIH1cblxuICAvKiogRGV0ZXJtaW5lIHRoZSBjaGFpbk5ldHdvcmsgZnJvbSB0aGUgdHJhbnNpdFdhbGxldCBjb250ZXh0ICovXG4gIGFzeW5jIGdldENoYWluTmV0d29ya0Zyb21UcmFuc2l0V2FsbGV0KHRyYW5zaXRXYWxsZXQ6IFRyYW5zaXRXYWxsZXQpIHtcbiAgICBjb25zdCB7IGNoYWluSWQgfSA9IHRyYW5zaXRXYWxsZXQ/LmN0eD8ubmV0d29yayB8fCB7fVxuICAgIGlmICghY2hhaW5JZCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgY29uc3QgbmV0d29ya3MgPSBhd2FpdCB0aGlzLl9vcmVJZENvbnRleHQuc2V0dGluZ3MuZ2V0QWxsQ2hhaW5OZXR3b3JrU2V0dGluZ3MoKVxuICAgIHJldHVybiBuZXR3b3Jrcy5maW5kKG5ldCA9PiBuZXQuaG9zdHMuZmluZChob3N0ID0+IGhvc3QuY2hhaW5JZCA9PT0gY2hhaW5JZCkpPy5uZXR3b3JrXG4gIH1cblxuICAvKiogQWRkIHRoZSBhY2NvdW50IHNlbGVjdGVkIGluIHRoZSB0cmFuc2l0V2FsbGV0IHRvIHRoZSBPUkUgYWNjb3VudCdzIGxpc3Qgb2YgYWNjb3VudC9wZXJtaXNzaW9ucyAqL1xuICBhc3luYyB1cGRhdGVPcmVBY2NvdW50UGVybWlzc2lvbnNmcm9tVHJhbnNpdFdhbGxldEF1dGgodHJhbnNpdFdhbGxldDogVHJhbnNpdFdhbGxldCwgd2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlKSB7XG4gICAgaWYgKCF0cmFuc2l0V2FsbGV0Py5jb25uZWN0ZWQgfHwgIXRyYW5zaXRXYWxsZXQ/LmF1dGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCB7IGFjY291bnROYW1lLCBwZXJtaXNzaW9uLCBwdWJsaWNLZXkgfSA9IHRyYW5zaXRXYWxsZXQuYXV0aFxuICAgIC8vIGFib3J0IHNpbGVudGx5IGlmIGFjY291bnQgaXMgbWlzc2luZyBzb21lIGluZm8gLSBzb21lIGNoYWlucy93YWxsZXRzIChlLmcuIGV0aGVyZXVtKSBkb250IHByb3ZpZGUgdGhlIHB1YmxpYyBrZXksIHNvIHdlIGNhbid0IGFkZCB0aGUgcGVybSBoZXJlXG4gICAgaWYgKCFhY2NvdW50TmFtZSB8fCAhcGVybWlzc2lvbiB8fCAhcHVibGljS2V5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgcGVybWlzc2lvbnM6IFdhbGxldFBlcm1pc3Npb25bXSA9IFt7IG5hbWU6IHBlcm1pc3Npb24sIHB1YmxpY0tleSB9XSAvLyB0b2RvOiBhZGQgcGFyZW50IHBlcm1pc3Npb24gd2hlbiBhdmFpbGFibGVcbiAgICAvLyBHZXQgdGhlIGNoYWluTmV0d29yayBmcm9tIHRoZSB0cmFuc2l0V2FsbGV0IC0gaW4gY2FzZSB0aGUgd2FsbGV0IHByb3ZpZGVyIHN3aXRjaGVzIG5ldHdvcmtzIHNvbWVob3dcbiAgICBjb25zdCB0cmFuc2l0Q2hhaW5OZXR3b3JrID0gYXdhaXQgdGhpcy5nZXRDaGFpbk5ldHdvcmtGcm9tVHJhbnNpdFdhbGxldCh0cmFuc2l0V2FsbGV0KVxuICAgIGlmICh0cmFuc2l0Q2hhaW5OZXR3b3JrKSB7XG4gICAgICBhd2FpdCB0aGlzLl91c2VyPy51cGRhdGVQZXJtaXNzaW9uc0lmTmVjZXNzYXJ5KHtcbiAgICAgICAgY2hhaW5BY2NvdW50OiBhY2NvdW50TmFtZSxcbiAgICAgICAgY2hhaW5OZXR3b3JrOiB0cmFuc2l0Q2hhaW5OZXR3b3JrLFxuICAgICAgICBwZXJtaXNzaW9ucyxcbiAgICAgICAgd2FsbGV0VHlwZSxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaXNUcmFuc2l0UHJvdmlkZXIocHJvdmlkZXI6IEF1dGhQcm92aWRlciB8IEV4dGVybmFsV2FsbGV0VHlwZSkge1xuICAgIGNvbnN0IHdhbGxldFByb3ZpZGVyVHlwZSA9IEhlbHBlcnMubWFwQXV0aFByb3ZpZGVyVG9XYWxsZXRUeXBlKHByb3ZpZGVyKVxuICAgIGlmICghd2FsbGV0UHJvdmlkZXJUeXBlKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gc3VwcG9ydGVkVHJhbnNpdFByb3ZpZGVycy5pbmNsdWRlcyh3YWxsZXRQcm92aWRlclR5cGUpXG4gIH1cblxuICAvKiogV2hldGhlciB0aGlzIEVvcyBUcmFuc2l0IHByb3ZpZGVyIHdhcyBpbnN0YWxsZWQgdXBvbiBpbnN0YW50aWF0aW9uICovXG4gIGhhc1RyYW5zaXRQcm92aWRlcih3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fb3JlSWRDb250ZXh0LnRyYW5zaXRQcm92aWRlcnNJbnN0YWxsZWQuaW5jbHVkZXMod2FsbGV0VHlwZSlcbiAgfVxuXG4gIC8qKiBUaHJvdyBpZiB0aGUgcHJvdmlkZXIgZG9lc250IHN1cHBvcnQgdGhlIHNwZWNpZmllZCBjaGFpbk5ldHdvcmsgKi9cbiAgYXN5bmMgYXNzZXJ0UHJvdmlkZXJWYWxpZEZvckNoYWluTmV0d29yayh3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUsIGNoYWluTmV0d29yazogQ2hhaW5OZXR3b3JrKSB7XG4gICAgY29uc3QgeyBjaGFpblR5cGUgfSA9IGdldFRyYW5zaXRQcm92aWRlckF0dHJpYnV0ZXMod2FsbGV0VHlwZSlcbiAgICBjb25zdCBuZXR3b3JrcyA9IGF3YWl0IHRoaXMuX29yZUlkQ29udGV4dC5zZXR0aW5ncy5nZXRBbGxDaGFpbk5ldHdvcmtTZXR0aW5ncygpXG4gICAgY29uc3QgaXNWYWxpZCA9ICEhbmV0d29ya3MuZmluZChuID0+IG4ubmV0d29yayA9PT0gY2hhaW5OZXR3b3JrICYmIG4udHlwZSA9PT0gY2hhaW5UeXBlKVxuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBFeHRlcm5hbCBXYWxsZXQgVHlwZTogJHt3YWxsZXRUeXBlfSBkb2VzbnQgc3VwcG9ydCBjaGFpbk5ldHdvcmsgJHtjaGFpbk5ldHdvcmt9LiBIaW50OiBJdCBzdXBwb3J0cyBuZXR3b3JrcyBvZiB0eXBlICR7Y2hhaW5UeXBlfS5gLFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgd2FpdFdoaWxlV2FsbGV0SXNCdXN5KHRyYW5zaXRXYWxsZXQ6IFRyYW5zaXRXYWxsZXQsIHdhbGxldFR5cGU6IEV4dGVybmFsV2FsbGV0VHlwZSkge1xuICAgIHdoaWxlICh0cmFuc2l0V2FsbGV0LmluUHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMuX29yZUlkQ29udGV4dC5zZXRJc0J1c3kodHJ1ZSlcbiAgICAgIC8vIHRvZG86IGFkZCB0aW1lb3V0XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgYXdhaXQgSGVscGVycy5zbGVlcCgyNTApXG4gICAgICAvLyB0aGlzIGlzIGhlcmUgdG8gaGVscCBhIGRldmVsb3BlciBkZWJ1ZyAtIGRvbnQgcmVtb3ZlIHRoaXMgLSBpZiBhIHdhbGxldCBpcyBub3Qgb3BlbiB0byBjb25uZWN0IHRvLCBpdCB3aWxsIGhhbmcgaGVyZVxuICAgICAgY29uc29sZS5sb2coYGNvbm5lY3RpbmcgdG8gJHt3YWxsZXRUeXBlfSB2aWEgZW9zLXRyYW5zaXQgd2FsbGV0IGluIHByb2dyZXNzOmAsIHRyYW5zaXRXYWxsZXQuaW5Qcm9ncmVzcylcbiAgICB9XG4gICAgdGhpcy5fb3JlSWRDb250ZXh0LnNldElzQnVzeShmYWxzZSlcbiAgfVxuXG4gIC8qKiBEaXNjb3ZlcnMga2V5cyBpbiBhIHdhbGxldCBwcm92aWRlci5cbiAgICogIEFueSBuZXcga2V5cyBkaXNjb3ZlcmVkIGluIHdhbGxldCBhcmUgYWRkZWQgdG8gdXNlcidzIE9SRSBJRCByZWNvcmQuXG4gICAqICBJZiB0aGUgcHJvdmlkZXIgZG9lc250IHN1cHBvcnQgYSBkaXNjb3ZlcigpIGZ1bmN0aW9uLCBhbmQgcmVxdWlyZXNMb2dvdXRMb2dpblRvRGlzY292ZXIgPT0gdHJ1ZSwgYXR0ZW1wdHMgYSBsb2dvdXQgdGhlbiBsb2dpbiBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZGlzY292ZXIoZGlzY292ZXJPcHRpb25zOiBEaXNjb3Zlck9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNjb3ZlcldpdGhUcmFuc2l0KGRpc2NvdmVyT3B0aW9ucylcbiAgfVxuXG4gIC8qKiBDYWxsIGRpc2NvdmVyIGFmdGVyIHNpZ25pbmcgc28gd2UgY2FwdHVyZSBhbmQgc2F2ZSB0aGUgYWNjb3VudFxuICAgKiAgTm90ZTogVGhpcyBpcyBuZWVkZWQgZm9yIEV0aGVyZXVtIHNpbmNlIHdlIGRvbnQga25vdyBhIHB1YmxpYyBrZXkgdW50aWwgd2Ugc2lnbiB3aXRoIGFuIGFjY291bnRcbiAgICovXG4gIGFzeW5jIGNhbGxEaXNjb3ZlckFmdGVyU2lnbih0cmFuc2FjdGlvbkRhdGE6IFRyYW5zYWN0aW9uRGF0YSkge1xuICAgIGNvbnN0IHsgY2hhaW5OZXR3b3JrLCBhY2NvdW50IH0gPSB0cmFuc2FjdGlvbkRhdGFcbiAgICBjb25zdCB7IHByb3ZpZGVyIH0gPSB0cmFuc2FjdGlvbkRhdGE/LnNpZ25PcHRpb25zIHx8IHt9XG4gICAgY29uc3Qgd2FsbGV0UHJvdmlkZXIgPSBIZWxwZXJzLm1hcEF1dGhQcm92aWRlclRvV2FsbGV0VHlwZShwcm92aWRlcilcbiAgICBjb25zdCBkaXNjb3Zlck9wdGlvbnM6IERpc2NvdmVyT3B0aW9ucyA9IHtcbiAgICAgIHdhbGxldFR5cGU6IHdhbGxldFByb3ZpZGVyLFxuICAgICAgY2hhaW5OZXR3b3JrLFxuICAgICAgb3JlQWNjb3VudDogYWNjb3VudCxcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5kaXNjb3ZlcihkaXNjb3Zlck9wdGlvbnMpXG4gIH1cblxuICAvLyBTdXBwb3J0ZWQgZmVhdHVyZXMgYnkgcHJvdmlkZXJcblxuICAvKiogd2hldGhlciBkaXNjb3ZlcnkgaXMgc3VwcG9ydGVkIGJ5IHRoZSBwcm92aWRlciAqL1xuICBjYW5EaXNjb3Zlcih3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUpIHtcbiAgICBpZiAodGhpcy5oYXNUcmFuc2l0UHJvdmlkZXIod2FsbGV0VHlwZSkpIHtcbiAgICAgIHJldHVybiBnZXRUcmFuc2l0UHJvdmlkZXJBdHRyaWJ1dGVzKHdhbGxldFR5cGUpLnN1cHBvcnRzRGlzY292ZXJ5XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqIHdoZXRoZXIgc2lnblN0cmluZyBpcyBzdXBwb3J0ZWQgYnkgdGhlIHByb3ZpZGVyICovXG4gIGNhblNpZ25TdHJpbmcod2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlKSB7XG4gICAgaWYgKHRoaXMuaGFzVHJhbnNpdFByb3ZpZGVyKHdhbGxldFR5cGUpKSB7XG4gICAgICByZXR1cm4gZ2V0VHJhbnNpdFByb3ZpZGVyQXR0cmlidXRlcyh3YWxsZXRUeXBlKS5zdXBwb3J0c1NpZ25BcmJpdHJhcnlcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKiogd2hldGhlciBjYWxsIHRvIGRpc2NvdmVyIGlzIHJlcXVpcmVkIGJ5IHByb3ZpZGVyIGJlZm9yZSBsb2dpbiAqL1xuICByZXF1aXJlc0Rpc2NvdmVyVG9Mb2dpbih3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUpIHtcbiAgICBpZiAodGhpcy5oYXNUcmFuc2l0UHJvdmlkZXIod2FsbGV0VHlwZSkpIHtcbiAgICAgIHJldHVybiBnZXRUcmFuc2l0UHJvdmlkZXJBdHRyaWJ1dGVzKHdhbGxldFR5cGUpLnJlcXVpcmVzRGlzY292ZXJUb0xvZ2luXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqIHdoZXRoZXIgY2FsbCB0byBsb2dvdXQgdGhlbiBsb2dpbiBpcyByZXF1aXJlZCBieSBwcm92aWRlciBiZWZvcmUgZGlzY292ZXIgKi9cbiAgcmVxdWlyZXNMb2dvdXRMb2dpblRvRGlzY292ZXIod2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlKSB7XG4gICAgaWYgKHRoaXMuaGFzVHJhbnNpdFByb3ZpZGVyKHdhbGxldFR5cGUpKSB7XG4gICAgICByZXR1cm4gZ2V0VHJhbnNpdFByb3ZpZGVyQXR0cmlidXRlcyh3YWxsZXRUeXBlKS5yZXF1aXJlc0xvZ291dExvZ2luVG9EaXNjb3ZlclxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKiBkZWZhdWx0IHBhdGggaW5kZXggZm9yIHByb3ZpZGVyIChpZiBhbnkpICovXG4gIGRlZmF1bHREaXNjb3ZlcnlQYXRoSW5kZXhMaXN0KHdhbGxldFR5cGU6IEV4dGVybmFsV2FsbGV0VHlwZSk6IG51bWJlcltdIHtcbiAgICBpZiAodGhpcy5oYXNUcmFuc2l0UHJvdmlkZXIod2FsbGV0VHlwZSkpIHtcbiAgICAgIHJldHVybiBnZXRUcmFuc2l0UHJvdmlkZXJBdHRyaWJ1dGVzKHdhbGxldFR5cGUpPy5kZWZhdWx0RGlzY292ZXJ5UGF0aEluZGV4TGlzdFxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqIGhlbHAgdGV4dCBkaXNwbGF5ZWQgdG8gdXNlciBmb3IgcHJvdmlkZXIgKi9cbiAgaGVscFRleHRGb3JQcm92aWRlcih3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUpIHtcbiAgICBpZiAodGhpcy5oYXNUcmFuc2l0UHJvdmlkZXIod2FsbGV0VHlwZSkpIHtcbiAgICAgIHJldHVybiBnZXRUcmFuc2l0UHJvdmlkZXJBdHRyaWJ1dGVzKHdhbGxldFR5cGUpLmhlbHBUZXh0XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd2FsbGV0QWNjZXNzQ29udGV4dF8xID0gcmVxdWlyZShcIi4vd2FsbGV0QWNjZXNzQ29udGV4dFwiKTtcbmV4cG9ydHMuaW5pdEFjY2Vzc0NvbnRleHQgPSB3YWxsZXRBY2Nlc3NDb250ZXh0XzEuaW5pdEFjY2Vzc0NvbnRleHQ7XG52YXIgd2FsbGV0XzEgPSByZXF1aXJlKFwiLi93YWxsZXRcIik7XG52YXIgd2FsbGV0XzIgPSByZXF1aXJlKFwiLi93YWxsZXRcIik7XG5leHBvcnRzLmluaXRXYWxsZXQgPSB3YWxsZXRfMi5pbml0V2FsbGV0O1xuZnVuY3Rpb24gaW5pdERlZmF1bHRBY2Nlc3NDb250ZXh0KG9wdGlvbnMpIHtcbiAgICBleHBvcnRzLmRlZmF1bHRBY2Nlc3NDb250ZXh0ID0gd2FsbGV0QWNjZXNzQ29udGV4dF8xLmluaXRBY2Nlc3NDb250ZXh0KG9wdGlvbnMpO1xuICAgIHJldHVybiBleHBvcnRzLmRlZmF1bHRBY2Nlc3NDb250ZXh0O1xufVxuZXhwb3J0cy5pbml0RGVmYXVsdEFjY2Vzc0NvbnRleHQgPSBpbml0RGVmYXVsdEFjY2Vzc0NvbnRleHQ7XG52YXIgV0FMID0ge1xuICAgIGluaXREZWZhdWx0QWNjZXNzQ29udGV4dDogaW5pdERlZmF1bHRBY2Nlc3NDb250ZXh0LFxuICAgIGdldCBhY2Nlc3NDb250ZXh0KCkge1xuICAgICAgICBpZiAoIWV4cG9ydHMuZGVmYXVsdEFjY2Vzc0NvbnRleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgICAgTm8gZGVmYXVsdCBXYWxsZXRBY2Nlc3NDb250ZXh0IGlzIGNvbmZpZ3VyZWQuIFxcbiAgICAgICAgTWFrZSBzdXJlIHRvIGZpcnN0IHJ1biAnaW5pdERlZmF1bHRBY2Nlc3NDb250ZXh0JyB0byBzZXQgaXQgdXAuXFxuICAgICAgXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBvcnRzLmRlZmF1bHRBY2Nlc3NDb250ZXh0O1xuICAgIH0sXG4gICAgaW5pdFdhbGxldDogd2FsbGV0XzEuaW5pdFdhbGxldFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IFdBTDtcbi8vIGZvcmNlIHJlYnVpbGQgMlxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW9zanNfMSA9IHJlcXVpcmUoXCJlb3Nqc1wiKTtcbnZhciBzdGF0ZUNvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vc3RhdGVDb250YWluZXJcIik7XG52YXIgd2FsbGV0XzEgPSByZXF1aXJlKFwiLi93YWxsZXRcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBERUZBVUxUX0NPTlRFWFRfU1RBVEUgPSB7XG4gICAgd2FsbGV0czogW11cbn07XG5mdW5jdGlvbiBmaW5kUHJvdmlkZXJCeUlkKHdhbGxldFByb3ZpZGVycywgcHJvdmlkZXJJZCkge1xuICAgIGlmICghd2FsbGV0UHJvdmlkZXJzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gd2FsbGV0UHJvdmlkZXJzLmZpbmQoZnVuY3Rpb24gKHdwKSB7IHJldHVybiB3cC5pZCA9PT0gcHJvdmlkZXJJZDsgfSk7XG59XG5mdW5jdGlvbiBpbml0QWNjZXNzQ29udGV4dChvcHRpb25zKSB7XG4gICAgdmFyIGFwcE5hbWUgPSBvcHRpb25zLmFwcE5hbWUsIG5ldHdvcmsgPSBvcHRpb25zLm5ldHdvcmssIGlzTm90RW9zTmV0d29yayA9IG9wdGlvbnMuaXNOb3RFb3NOZXR3b3JrO1xuICAgIHZhciBfbWFrZVdhbGxldFByb3ZpZGVyRm5zID0gb3B0aW9ucy53YWxsZXRQcm92aWRlcnM7XG4gICAgdmFyIHdhbGxldFByb3ZpZGVycyA9IF9tYWtlV2FsbGV0UHJvdmlkZXJGbnMubWFwKGZ1bmN0aW9uIChtYWtlV2FsbGV0UHJvdmlkZXIpIHsgcmV0dXJuIG1ha2VXYWxsZXRQcm92aWRlcihuZXR3b3JrKTsgfSk7XG4gICAgdmFyIF9zdGF0ZUNvbnRhaW5lciA9IHN0YXRlQ29udGFpbmVyXzEubWFrZVN0YXRlQ29udGFpbmVyKERFRkFVTFRfQ09OVEVYVF9TVEFURSk7XG4gICAgdmFyIF9saXN0ZW5lcnMgPSBbXTtcbiAgICBmdW5jdGlvbiBfaGFuZGxlVXBkYXRlKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9saXN0ZW5lcnNfMSA9IF9saXN0ZW5lcnM7IF9pIDwgX2xpc3RlbmVyc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gX2xpc3RlbmVyc18xW19pXTtcbiAgICAgICAgICAgIGxpc3RlbmVyKGN0eCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF93YWxsZXRVbnN1YnNjcmliZUZucyA9IG5ldyBNYXAoKTtcbiAgICB2YXIgc3RhdGVVbnN1YnNjcmliZSA9IF9zdGF0ZUNvbnRhaW5lci5zdWJzY3JpYmUoX2hhbmRsZVVwZGF0ZSk7XG4gICAgdmFyIGVvc1JwYztcbiAgICBpZiAoIWlzTm90RW9zTmV0d29yaykge1xuICAgICAgICB2YXIgZW9zUnBjVXJsID0gdXRpbF8xLmdldE5ldHdvcmtVcmwobmV0d29yayk7XG4gICAgICAgIGVvc1JwYyA9IG5ldyBlb3Nqc18xLkpzb25ScGMoZW9zUnBjVXJsKTtcbiAgICB9XG4gICAgdmFyIGN0eCA9IHtcbiAgICAgICAgYXBwTmFtZTogYXBwTmFtZSxcbiAgICAgICAgZW9zUnBjOiBlb3NScGMsXG4gICAgICAgIG5ldHdvcms6IG5ldHdvcmssXG4gICAgICAgIGluaXRXYWxsZXQ6IGZ1bmN0aW9uICh3YWxsZXRQcm92aWRlcikge1xuICAgICAgICAgICAgdmFyIF93YWxsZXRQcm92aWRlciA9IHR5cGVvZiB3YWxsZXRQcm92aWRlciA9PT0gJ3N0cmluZycgPyBmaW5kUHJvdmlkZXJCeUlkKHdhbGxldFByb3ZpZGVycywgd2FsbGV0UHJvdmlkZXIpIDogd2FsbGV0UHJvdmlkZXI7XG4gICAgICAgICAgICBpZiAoIV93YWxsZXRQcm92aWRlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgICAgICBDYW5ub3QgaW5pdGlhdGUgYSBzZXNzaW9uLCBpbnZhbGlkIHdhbGxldCBwcm92aWRlclxcbiAgICAgICAgICBvciB3YWxsZXQgcHJvdmlkZXIgSUQgd2FzIHBhc3NlZFxcbiAgICAgICAgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld1dhbGxldCA9IHdhbGxldF8xLmluaXRXYWxsZXQoX3dhbGxldFByb3ZpZGVyLCBjdHgpO1xuICAgICAgICAgICAgX3N0YXRlQ29udGFpbmVyLnVwZGF0ZVN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICB3YWxsZXRzOiAoKHN0YXRlICYmIHN0YXRlLndhbGxldHMpIHx8IFtdKS5jb25jYXQoW25ld1dhbGxldF0pXG4gICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gYSBuZXcgd2FsbGV0IHVwZGF0ZXMgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIF93YWxsZXRVbnN1YnNjcmliZUZucy5zZXQobmV3V2FsbGV0Ll9pbnN0YW5jZUlkLCBuZXdXYWxsZXQuc3Vic2NyaWJlKF9oYW5kbGVVcGRhdGUpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdXYWxsZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFdhbGxldFByb3ZpZGVyOiBmdW5jdGlvbiAod2FsbGV0UHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHdhbGxldFByb3ZpZGVycy5wdXNoKHdhbGxldFByb3ZpZGVyKG5ldHdvcmspKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2FsbGV0UHJvdmlkZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2FsbGV0UHJvdmlkZXJzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRXYWxsZXRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBfc3RhdGVDb250YWluZXIuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGlmICghc3RhdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLndhbGxldHMgfHwgW107XG4gICAgICAgIH0sXG4gICAgICAgIGdldEFjdGl2ZVdhbGxldHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHguZ2V0V2FsbGV0cygpLmZpbHRlcihmdW5jdGlvbiAod2FsbGV0KSB7IHJldHVybiB3YWxsZXQuY29ubmVjdGVkICYmIHdhbGxldC5hdXRoZW50aWNhdGVkOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGV0YWNoV2FsbGV0OiBmdW5jdGlvbiAod2FsbGV0KSB7XG4gICAgICAgICAgICBfc3RhdGVDb250YWluZXIudXBkYXRlU3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgIHdhbGxldHM6ICgoc3RhdGUgJiYgc3RhdGUud2FsbGV0cykgfHwgW10pLmZpbHRlcihmdW5jdGlvbiAodykgeyByZXR1cm4gdyAhPT0gd2FsbGV0OyB9KVxuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgdmFyIF9pbnN0YW5jZUlkID0gd2FsbGV0Ll9pbnN0YW5jZUlkO1xuICAgICAgICAgICAgaWYgKF93YWxsZXRVbnN1YnNjcmliZUZucy5oYXMoX2luc3RhbmNlSWQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gX3dhbGxldFVuc3Vic2NyaWJlRm5zLmdldChfaW5zdGFuY2VJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB1bnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbG9nb3V0QWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY3R4LmdldFdhbGxldHMoKS5tYXAoZnVuY3Rpb24gKHdhbGxldCkgeyByZXR1cm4gd2FsbGV0LmxvZ291dCgpOyB9KSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzY29ubmVjdEFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGN0eC5nZXRXYWxsZXRzKCkubWFwKGZ1bmN0aW9uICh3YWxsZXQpIHsgcmV0dXJuIHdhbGxldC5kaXNjb25uZWN0KCk7IH0pKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0pO1xuICAgICAgICB9LFxuICAgICAgICB0ZXJtaW5hdGVBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChjdHguZ2V0V2FsbGV0cygpLm1hcChmdW5jdGlvbiAod2FsbGV0KSB7IHJldHVybiB3YWxsZXQudGVybWluYXRlKCk7IH0pKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4LnRlcm1pbmF0ZUFsbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0YXRlVW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBfd2FsbGV0VW5zdWJzY3JpYmVGbnMuZm9yRWFjaChmdW5jdGlvbiAodW5zdWJzY3JpYmVGbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHVuc3Vic2NyaWJlRm4gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZUZuKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX2xpc3RlbmVycyA9IFtdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBfbGlzdGVuZXJzID0gX2xpc3RlbmVycy5jb25jYXQoW2xpc3RlbmVyXSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgICAgICAgICAgX2xpc3RlbmVycyA9IF9saXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsICE9PSBsaXN0ZW5lcjsgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gY3R4O1xufVxuZXhwb3J0cy5pbml0QWNjZXNzQ29udGV4dCA9IGluaXRBY2Nlc3NDb250ZXh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2FsbGV0QWNjZXNzQ29udGV4dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlb3Nqc19hcGlfMSA9IHJlcXVpcmUoXCIuL2Vvc2pzLWFwaVwiKTtcbmV4cG9ydHMuQXBpID0gZW9zanNfYXBpXzEuQXBpO1xudmFyIEFwaUludGVyZmFjZXMgPSByZXF1aXJlKFwiLi9lb3Nqcy1hcGktaW50ZXJmYWNlc1wiKTtcbmV4cG9ydHMuQXBpSW50ZXJmYWNlcyA9IEFwaUludGVyZmFjZXM7XG52YXIgZW9zanNfanNvbnJwY18xID0gcmVxdWlyZShcIi4vZW9zanMtanNvbnJwY1wiKTtcbmV4cG9ydHMuSnNvblJwYyA9IGVvc2pzX2pzb25ycGNfMS5Kc29uUnBjO1xudmFyIE51bWVyaWMgPSByZXF1aXJlKFwiLi9lb3Nqcy1udW1lcmljXCIpO1xuZXhwb3J0cy5OdW1lcmljID0gTnVtZXJpYztcbnZhciBScGNJbnRlcmZhY2VzID0gcmVxdWlyZShcIi4vZW9zanMtcnBjLWludGVyZmFjZXNcIik7XG5leHBvcnRzLlJwY0ludGVyZmFjZXMgPSBScGNJbnRlcmZhY2VzO1xudmFyIGVvc2pzX3JwY2Vycm9yXzEgPSByZXF1aXJlKFwiLi9lb3Nqcy1ycGNlcnJvclwiKTtcbmV4cG9ydHMuUnBjRXJyb3IgPSBlb3Nqc19ycGNlcnJvcl8xLlJwY0Vycm9yO1xudmFyIFNlcmlhbGl6ZSA9IHJlcXVpcmUoXCIuL2Vvc2pzLXNlcmlhbGl6ZVwiKTtcbmV4cG9ydHMuU2VyaWFsaXplID0gU2VyaWFsaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBtb2R1bGUgQVBJXG4gKi9cbi8vIGNvcHlyaWdodCBkZWZpbmVkIGluIGVvc2pzL0xJQ0VOU0UudHh0XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxuICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZCkgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2VyID0gcmVxdWlyZShcIi4vZW9zanMtc2VyaWFsaXplXCIpO1xudmFyIGFiaUFiaSA9IHJlcXVpcmUoJy4uL3NyYy9hYmkuYWJpLmpzb24nKTtcbnZhciB0cmFuc2FjdGlvbkFiaSA9IHJlcXVpcmUoJy4uL3NyYy90cmFuc2FjdGlvbi5hYmkuanNvbicpO1xudmFyIEFwaSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqICAgICogYHJwY2A6IElzc3VlcyBSUEMgY2FsbHNcbiAgICAgKiAgICAqIGBhdXRob3JpdHlQcm92aWRlcmA6IEdldCBwdWJsaWMga2V5cyBuZWVkZWQgdG8gbWVldCBhdXRob3JpdGllcyBpbiBhIHRyYW5zYWN0aW9uXG4gICAgICogICAgKiBgYWJpUHJvdmlkZXJgOiBTdXBwbGllcyBBQklzIGluIHJhdyBmb3JtIChiaW5hcnkpXG4gICAgICogICAgKiBgc2lnbmF0dXJlUHJvdmlkZXJgOiBTaWducyB0cmFuc2FjdGlvbnNcbiAgICAgKiAgICAqIGBjaGFpbklkYDogSWRlbnRpZmllcyBjaGFpblxuICAgICAqICAgICogYHRleHRFbmNvZGVyYDogYFRleHRFbmNvZGVyYCBpbnN0YW5jZSB0byB1c2UuIFBhc3MgaW4gYG51bGxgIGlmIHJ1bm5pbmcgaW4gYSBicm93c2VyXG4gICAgICogICAgKiBgdGV4dERlY29kZXJgOiBgVGV4dERlY29kZXJgIGluc3RhbmNlIHRvIHVzZS4gUGFzcyBpbiBgbnVsbGAgaWYgcnVubmluZyBpbiBhIGJyb3dzZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBcGkoYXJncykge1xuICAgICAgICAvKiogSG9sZHMgaW5mb3JtYXRpb24gbmVlZGVkIHRvIHNlcmlhbGl6ZSBjb250cmFjdCBhY3Rpb25zICovXG4gICAgICAgIHRoaXMuY29udHJhY3RzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiogRmV0Y2hlZCBhYmlzICovXG4gICAgICAgIHRoaXMuY2FjaGVkQWJpcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5ycGMgPSBhcmdzLnJwYztcbiAgICAgICAgdGhpcy5hdXRob3JpdHlQcm92aWRlciA9IGFyZ3MuYXV0aG9yaXR5UHJvdmlkZXIgfHwgYXJncy5ycGM7XG4gICAgICAgIHRoaXMuYWJpUHJvdmlkZXIgPSBhcmdzLmFiaVByb3ZpZGVyIHx8IGFyZ3MucnBjO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZVByb3ZpZGVyID0gYXJncy5zaWduYXR1cmVQcm92aWRlcjtcbiAgICAgICAgdGhpcy5jaGFpbklkID0gYXJncy5jaGFpbklkO1xuICAgICAgICB0aGlzLnRleHRFbmNvZGVyID0gYXJncy50ZXh0RW5jb2RlcjtcbiAgICAgICAgdGhpcy50ZXh0RGVjb2RlciA9IGFyZ3MudGV4dERlY29kZXI7XG4gICAgICAgIHRoaXMuYWJpVHlwZXMgPSBzZXIuZ2V0VHlwZXNGcm9tQWJpKHNlci5jcmVhdGVJbml0aWFsVHlwZXMoKSwgYWJpQWJpKTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvblR5cGVzID0gc2VyLmdldFR5cGVzRnJvbUFiaShzZXIuY3JlYXRlSW5pdGlhbFR5cGVzKCksIHRyYW5zYWN0aW9uQWJpKTtcbiAgICB9XG4gICAgLyoqIERlY29kZXMgYW4gYWJpIGFzIFVpbnQ4QXJyYXkgaW50byBqc29uLiAqL1xuICAgIEFwaS5wcm90b3R5cGUucmF3QWJpVG9Kc29uID0gZnVuY3Rpb24gKHJhd0FiaSkge1xuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IHNlci5TZXJpYWxCdWZmZXIoe1xuICAgICAgICAgICAgdGV4dEVuY29kZXI6IHRoaXMudGV4dEVuY29kZXIsXG4gICAgICAgICAgICB0ZXh0RGVjb2RlcjogdGhpcy50ZXh0RGVjb2RlcixcbiAgICAgICAgICAgIGFycmF5OiByYXdBYmksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXNlci5zdXBwb3J0ZWRBYmlWZXJzaW9uKGJ1ZmZlci5nZXRTdHJpbmcoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYWJpIHZlcnNpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIucmVzdGFydFJlYWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWJpVHlwZXMuZ2V0KCdhYmlfZGVmJykuZGVzZXJpYWxpemUoYnVmZmVyKTtcbiAgICB9O1xuICAgIC8qKiBHZXQgYWJpIGluIGJvdGggYmluYXJ5IGFuZCBzdHJ1Y3R1cmVkIGZvcm1zLiBGZXRjaCB3aGVuIG5lZWRlZC4gKi9cbiAgICBBcGkucHJvdG90eXBlLmdldENhY2hlZEFiaSA9IGZ1bmN0aW9uIChhY2NvdW50TmFtZSwgcmVsb2FkKSB7XG4gICAgICAgIGlmIChyZWxvYWQgPT09IHZvaWQgMCkgeyByZWxvYWQgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGVkQWJpLCByYXdBYmksIGFiaSwgZV8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWxvYWQgJiYgdGhpcy5jYWNoZWRBYmlzLmdldChhY2NvdW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5jYWNoZWRBYmlzLmdldChhY2NvdW50TmFtZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5hYmlQcm92aWRlci5nZXRSYXdBYmkoYWNjb3VudE5hbWUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3QWJpID0gKF9hLnNlbnQoKSkuYWJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWJpID0gdGhpcy5yYXdBYmlUb0pzb24ocmF3QWJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZEFiaSA9IHsgcmF3QWJpOiByYXdBYmksIGFiaTogYWJpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZV8xLm1lc3NhZ2UgPSBcImZldGNoaW5nIGFiaSBmb3IgXCIgKyBhY2NvdW50TmFtZSArIFwiOiBcIiArIGVfMS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZEFiaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYWJpIGZvciBcIiArIGFjY291bnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkQWJpcy5zZXQoYWNjb3VudE5hbWUsIGNhY2hlZEFiaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2FjaGVkQWJpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogR2V0IGFiaSBpbiBzdHJ1Y3R1cmVkIGZvcm0uIEZldGNoIHdoZW4gbmVlZGVkLiAqL1xuICAgIEFwaS5wcm90b3R5cGUuZ2V0QWJpID0gZnVuY3Rpb24gKGFjY291bnROYW1lLCByZWxvYWQpIHtcbiAgICAgICAgaWYgKHJlbG9hZCA9PT0gdm9pZCAwKSB7IHJlbG9hZCA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRDYWNoZWRBYmkoYWNjb3VudE5hbWUsIHJlbG9hZCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Euc2VudCgpKS5hYmldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBHZXQgYWJpcyBuZWVkZWQgYnkgYSB0cmFuc2FjdGlvbiAqL1xuICAgIEFwaS5wcm90b3R5cGUuZ2V0VHJhbnNhY3Rpb25BYmlzID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCByZWxvYWQpIHtcbiAgICAgICAgaWYgKHJlbG9hZCA9PT0gdm9pZCAwKSB7IHJlbG9hZCA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhY2NvdW50cywgdW5pcXVlQWNjb3VudHMsIGFjdGlvblByb21pc2VzO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50cyA9IHRyYW5zYWN0aW9uLmFjdGlvbnMubWFwKGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGFjdGlvbi5hY2NvdW50OyB9KTtcbiAgICAgICAgICAgICAgICB1bmlxdWVBY2NvdW50cyA9IG5ldyBTZXQoYWNjb3VudHMpO1xuICAgICAgICAgICAgICAgIGFjdGlvblByb21pc2VzID0gX19zcHJlYWQodW5pcXVlQWNjb3VudHMpLm1hcChmdW5jdGlvbiAoYWNjb3VudCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6IGFjY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRDYWNoZWRBYmkoYWNjb3VudCwgcmVsb2FkKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLmFiaSA9IChfYi5zZW50KCkpLnJhd0FiaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgUHJvbWlzZS5hbGwoYWN0aW9uUHJvbWlzZXMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBHZXQgZGF0YSBuZWVkZWQgdG8gc2VyaWFsaXplIGFjdGlvbnMgaW4gYSBjb250cmFjdCAqL1xuICAgIEFwaS5wcm90b3R5cGUuZ2V0Q29udHJhY3QgPSBmdW5jdGlvbiAoYWNjb3VudE5hbWUsIHJlbG9hZCkge1xuICAgICAgICBpZiAocmVsb2FkID09PSB2b2lkIDApIHsgcmVsb2FkID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVfMiwgX2EsIGFiaSwgdHlwZXMsIGFjdGlvbnMsIF9iLCBfYywgX2QsIG5hbWVfMSwgdHlwZSwgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWxvYWQgJiYgdGhpcy5jb250cmFjdHMuZ2V0KGFjY291bnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmNvbnRyYWN0cy5nZXQoYWNjb3VudE5hbWUpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0QWJpKGFjY291bnROYW1lLCByZWxvYWQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJpID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMgPSBzZXIuZ2V0VHlwZXNGcm9tQWJpKHNlci5jcmVhdGVJbml0aWFsVHlwZXMoKSwgYWJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2IgPSBfX3ZhbHVlcyhhYmkuYWN0aW9ucyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBfYy52YWx1ZSwgbmFtZV8xID0gX2QubmFtZSwgdHlwZSA9IF9kLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMuc2V0KG5hbWVfMSwgc2VyLmdldFR5cGUodHlwZXMsIHR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7IHR5cGVzOiB0eXBlcywgYWN0aW9uczogYWN0aW9ucyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cmFjdHMuc2V0KGFjY291bnROYW1lLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIENvbnZlcnQgYHZhbHVlYCB0byBiaW5hcnkgZm9ybS4gYHR5cGVgIG11c3QgYmUgYSBidWlsdC1pbiBhYmkgdHlwZSBvciBpbiBgdHJhbnNhY3Rpb24uYWJpLmpzb25gLiAqL1xuICAgIEFwaS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKGJ1ZmZlciwgdHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvblR5cGVzLmdldCh0eXBlKS5zZXJpYWxpemUoYnVmZmVyLCB2YWx1ZSk7XG4gICAgfTtcbiAgICAvKiogQ29udmVydCBkYXRhIGluIGBidWZmZXJgIHRvIHN0cnVjdHVyZWQgZm9ybS4gYHR5cGVgIG11c3QgYmUgYSBidWlsdC1pbiBhYmkgdHlwZSBvciBpbiBgdHJhbnNhY3Rpb24uYWJpLmpzb25gLiAqL1xuICAgIEFwaS5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoYnVmZmVyLCB0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uVHlwZXMuZ2V0KHR5cGUpLmRlc2VyaWFsaXplKGJ1ZmZlcik7XG4gICAgfTtcbiAgICAvKiogQ29udmVydCBhIHRyYW5zYWN0aW9uIHRvIGJpbmFyeSAqL1xuICAgIEFwaS5wcm90b3R5cGUuc2VyaWFsaXplVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBzZXIuU2VyaWFsQnVmZmVyKHsgdGV4dEVuY29kZXI6IHRoaXMudGV4dEVuY29kZXIsIHRleHREZWNvZGVyOiB0aGlzLnRleHREZWNvZGVyIH0pO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZShidWZmZXIsICd0cmFuc2FjdGlvbicsIF9fYXNzaWduKHsgbWF4X25ldF91c2FnZV93b3JkczogMCwgbWF4X2NwdV91c2FnZV9tczogMCwgZGVsYXlfc2VjOiAwLCBjb250ZXh0X2ZyZWVfYWN0aW9uczogW10sIGFjdGlvbnM6IFtdLCB0cmFuc2FjdGlvbl9leHRlbnNpb25zOiBbXSB9LCB0cmFuc2FjdGlvbikpO1xuICAgICAgICByZXR1cm4gYnVmZmVyLmFzVWludDhBcnJheSgpO1xuICAgIH07XG4gICAgLyoqIENvbnZlcnQgYSB0cmFuc2FjdGlvbiBmcm9tIGJpbmFyeS4gTGVhdmVzIGFjdGlvbnMgaW4gaGV4LiAqL1xuICAgIEFwaS5wcm90b3R5cGUuZGVzZXJpYWxpemVUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IHNlci5TZXJpYWxCdWZmZXIoeyB0ZXh0RW5jb2RlcjogdGhpcy50ZXh0RW5jb2RlciwgdGV4dERlY29kZXI6IHRoaXMudGV4dERlY29kZXIgfSk7XG4gICAgICAgIGJ1ZmZlci5wdXNoQXJyYXkodHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZShidWZmZXIsICd0cmFuc2FjdGlvbicpO1xuICAgIH07XG4gICAgLyoqIENvbnZlcnQgYWN0aW9ucyB0byBoZXggKi9cbiAgICBBcGkucHJvdG90eXBlLnNlcmlhbGl6ZUFjdGlvbnMgPSBmdW5jdGlvbiAoYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChhY3Rpb25zLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWNjb3VudCA9IF9hLmFjY291bnQsIG5hbWUgPSBfYS5uYW1lLCBhdXRob3JpemF0aW9uID0gX2EuYXV0aG9yaXphdGlvbiwgZGF0YSA9IF9hLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyYWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldENvbnRyYWN0KGFjY291bnQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgc2VyLnNlcmlhbGl6ZUFjdGlvbihjb250cmFjdCwgYWNjb3VudCwgbmFtZSwgYXV0aG9yaXphdGlvbiwgZGF0YSwgdGhpcy50ZXh0RW5jb2RlciwgdGhpcy50ZXh0RGVjb2RlcildO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIENvbnZlcnQgYWN0aW9ucyBmcm9tIGhleCAqL1xuICAgIEFwaS5wcm90b3R5cGUuZGVzZXJpYWxpemVBY3Rpb25zID0gZnVuY3Rpb24gKGFjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoYWN0aW9ucy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjY291bnQgPSBfYS5hY2NvdW50LCBuYW1lID0gX2EubmFtZSwgYXV0aG9yaXphdGlvbiA9IF9hLmF1dGhvcml6YXRpb24sIGRhdGEgPSBfYS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250cmFjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRDb250cmFjdChhY2NvdW50KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHNlci5kZXNlcmlhbGl6ZUFjdGlvbihjb250cmFjdCwgYWNjb3VudCwgbmFtZSwgYXV0aG9yaXphdGlvbiwgZGF0YSwgdGhpcy50ZXh0RW5jb2RlciwgdGhpcy50ZXh0RGVjb2RlcildO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIENvbnZlcnQgYSB0cmFuc2FjdGlvbiBmcm9tIGJpbmFyeS4gQWxzbyBkZXNlcmlhbGl6ZXMgYWN0aW9ucy4gKi9cbiAgICBBcGkucHJvdG90eXBlLmRlc2VyaWFsaXplVHJhbnNhY3Rpb25XaXRoQWN0aW9ucyA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGVzZXJpYWxpemVkVHJhbnNhY3Rpb24sIGRlc2VyaWFsaXplZEFjdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gc2VyLmhleFRvVWludDhBcnJheSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IHRoaXMuZGVzZXJpYWxpemVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmRlc2VyaWFsaXplQWN0aW9ucyhkZXNlcmlhbGl6ZWRUcmFuc2FjdGlvbi5hY3Rpb25zKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplZEFjdGlvbnMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgX19hc3NpZ24oe30sIGRlc2VyaWFsaXplZFRyYW5zYWN0aW9uLCB7IGFjdGlvbnM6IGRlc2VyaWFsaXplZEFjdGlvbnMgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgb3B0aW9uYWxseSBicm9hZGNhc3QgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIE5hbWVkIFBhcmFtZXRlcnM6XG4gICAgICogICAgKiBgYnJvYWRjYXN0YDogYnJvYWRjYXN0IHRoaXMgdHJhbnNhY3Rpb24/XG4gICAgICogICAgKiBgc2lnbmA6IHNpZ24gdGhpcyB0cmFuc2FjdGlvbj9cbiAgICAgKiAgICAqIElmIGJvdGggYGJsb2Nrc0JlaGluZGAgYW5kIGBleHBpcmVTZWNvbmRzYCBhcmUgcHJlc2VudCxcbiAgICAgKiAgICAgIHRoZW4gZmV0Y2ggdGhlIGJsb2NrIHdoaWNoIGlzIGBibG9ja3NCZWhpbmRgIGJlaGluZCBoZWFkIGJsb2NrLFxuICAgICAqICAgICAgdXNlIGl0IGFzIGEgcmVmZXJlbmNlIGZvciBUQVBvUywgYW5kIGV4cGlyZSB0aGUgdHJhbnNhY3Rpb24gYGV4cGlyZVNlY29uZHNgIGFmdGVyIHRoYXQgYmxvY2sncyB0aW1lLlxuICAgICAqIEByZXR1cm5zIG5vZGUgcmVzcG9uc2UgaWYgYGJyb2FkY2FzdGAsIGB7c2lnbmF0dXJlcywgc2VyaWFsaXplZFRyYW5zYWN0aW9ufWAgaWYgYCFicm9hZGNhc3RgXG4gICAgICovXG4gICAgQXBpLnByb3RvdHlwZS50cmFuc2FjdCA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IuYnJvYWRjYXN0LCBicm9hZGNhc3QgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBfZCA9IF9iLnNpZ24sIHNpZ24gPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLCBibG9ja3NCZWhpbmQgPSBfYi5ibG9ja3NCZWhpbmQsIGV4cGlyZVNlY29uZHMgPSBfYi5leHBpcmVTZWNvbmRzO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5mbywgcmVmQmxvY2ssIGFiaXMsIF9lLCBfZiwgc2VyaWFsaXplZFRyYW5zYWN0aW9uLCBwdXNoVHJhbnNhY3Rpb25BcmdzLCBhdmFpbGFibGVLZXlzLCByZXF1aXJlZEtleXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9nKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISF0aGlzLmNoYWluSWQpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5ycGMuZ2V0X2luZm8oKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8gPSBfZy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBpbmZvLmNoYWluX2lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2cubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgYmxvY2tzQmVoaW5kID09PSAnbnVtYmVyJyAmJiBleHBpcmVTZWNvbmRzKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISFpbmZvKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucnBjLmdldF9pbmZvKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvID0gX2cuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2cubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucnBjLmdldF9ibG9jayhpbmZvLmhlYWRfYmxvY2tfbnVtIC0gYmxvY2tzQmVoaW5kKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZkJsb2NrID0gX2cuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSBfX2Fzc2lnbih7fSwgc2VyLnRyYW5zYWN0aW9uSGVhZGVyKHJlZkJsb2NrLCBleHBpcmVTZWNvbmRzKSwgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2cubGFiZWwgPSA2O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzUmVxdWlyZWRUYXBvc0ZpZWxkcyh0cmFuc2FjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIGNvbmZpZ3VyYXRpb24gb3IgVEFQT1MgZmllbGRzIGFyZSBub3QgcHJlc2VudCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRUcmFuc2FjdGlvbkFiaXModHJhbnNhY3Rpb24pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJpcyA9IF9nLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lID0gW3t9LCB0cmFuc2FjdGlvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICBfZiA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5zZXJpYWxpemVBY3Rpb25zKHRyYW5zYWN0aW9uLmFjdGlvbnMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSBfX2Fzc2lnbi5hcHBseSh2b2lkIDAsIF9lLmNvbmNhdChbKF9mLmFjdGlvbnMgPSBfZy5zZW50KCksIF9mKV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IHRoaXMuc2VyaWFsaXplVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFRyYW5zYWN0aW9uQXJncyA9IHsgc2VyaWFsaXplZFRyYW5zYWN0aW9uOiBzZXJpYWxpemVkVHJhbnNhY3Rpb24sIHNpZ25hdHVyZXM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNpZ24pIHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc2lnbmF0dXJlUHJvdmlkZXIuZ2V0QXZhaWxhYmxlS2V5cygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlS2V5cyA9IF9nLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuYXV0aG9yaXR5UHJvdmlkZXIuZ2V0UmVxdWlyZWRLZXlzKHsgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLCBhdmFpbGFibGVLZXlzOiBhdmFpbGFibGVLZXlzIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkS2V5cyA9IF9nLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc2lnbmF0dXJlUHJvdmlkZXIuc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRLZXlzOiByZXF1aXJlZEtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbjogc2VyaWFsaXplZFRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYmlzOiBhYmlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hUcmFuc2FjdGlvbkFyZ3MgPSBfZy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZy5sYWJlbCA9IDEyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJyb2FkY2FzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnB1c2hTaWduZWRUcmFuc2FjdGlvbihwdXNoVHJhbnNhY3Rpb25BcmdzKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcHVzaFRyYW5zYWN0aW9uQXJnc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIEJyb2FkY2FzdCBhIHNpZ25lZCB0cmFuc2FjdGlvbiAqL1xuICAgIEFwaS5wcm90b3R5cGUucHVzaFNpZ25lZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBzaWduYXR1cmVzID0gX2Euc2lnbmF0dXJlcywgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gX2Euc2VyaWFsaXplZFRyYW5zYWN0aW9uO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMucnBjLnB1c2hfdHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlczogc2lnbmF0dXJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbjogc2VyaWFsaXplZFRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBldmVudHVhbGx5IGJyZWFrIG91dCBpbnRvIFRyYW5zYWN0aW9uVmFsaWRhdG9yIGNsYXNzXG4gICAgQXBpLnByb3RvdHlwZS5oYXNSZXF1aXJlZFRhcG9zRmllbGRzID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBleHBpcmF0aW9uID0gX2EuZXhwaXJhdGlvbiwgcmVmX2Jsb2NrX251bSA9IF9hLnJlZl9ibG9ja19udW0sIHJlZl9ibG9ja19wcmVmaXggPSBfYS5yZWZfYmxvY2tfcHJlZml4LCB0cmFuc2FjdGlvbiA9IF9fcmVzdChfYSwgW1wiZXhwaXJhdGlvblwiLCBcInJlZl9ibG9ja19udW1cIiwgXCJyZWZfYmxvY2tfcHJlZml4XCJdKTtcbiAgICAgICAgcmV0dXJuICEhKGV4cGlyYXRpb24gJiYgcmVmX2Jsb2NrX251bSAmJiByZWZfYmxvY2tfcHJlZml4KTtcbiAgICB9O1xuICAgIHJldHVybiBBcGk7XG59KCkpOyAvLyBBcGlcbmV4cG9ydHMuQXBpID0gQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW9zanMtYXBpLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIFNlcmlhbGl6ZVxuICovXG4vLyBjb3B5cmlnaHQgZGVmaW5lZCBpbiBlb3Nqcy9MSUNFTlNFLnR4dFxudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZCA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWQpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICAgIHJldHVybiBhcjtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG51bWVyaWMgPSByZXF1aXJlKFwiLi9lb3Nqcy1udW1lcmljXCIpO1xuLyoqIFN0YXRlIGZvciBzZXJpYWxpemUoKSBhbmQgZGVzZXJpYWxpemUoKSAqL1xudmFyIFNlcmlhbGl6ZXJTdGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXJpYWxpemVyU3RhdGUob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvKiogSGF2ZSBhbnkgYmluYXJ5IGV4dGVuc2lvbnMgYmVlbiBza2lwcGVkPyAqL1xuICAgICAgICB0aGlzLnNraXBwZWRCaW5hcnlFeHRlbnNpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIFNlcmlhbGl6ZXJTdGF0ZTtcbn0oKSk7XG5leHBvcnRzLlNlcmlhbGl6ZXJTdGF0ZSA9IFNlcmlhbGl6ZXJTdGF0ZTtcbi8qKiBTZXJpYWxpemUgYW5kIGRlc2VyaWFsaXplIGRhdGEgKi9cbnZhciBTZXJpYWxCdWZmZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIF9fbmFtZWRQYXJhbWV0ZXJzXG4gICAgICogICAgKiBgYXJyYXlgOiBgbnVsbGAgaWYgc2VyaWFsaXppbmcsIG9yIGJpbmFyeSBkYXRhIHRvIGRlc2VyaWFsaXplXG4gICAgICogICAgKiBgdGV4dEVuY29kZXJgOiBgVGV4dEVuY29kZXJgIGluc3RhbmNlIHRvIHVzZS4gUGFzcyBpbiBgbnVsbGAgaWYgcnVubmluZyBpbiBhIGJyb3dzZXJcbiAgICAgKiAgICAqIGB0ZXh0RGVjb2RlcmA6IGBUZXh0RGVjaWRlcmAgaW5zdGFuY2UgdG8gdXNlLiBQYXNzIGluIGBudWxsYCBpZiBydW5uaW5nIGluIGEgYnJvd3NlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNlcmlhbEJ1ZmZlcihfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdGV4dEVuY29kZXIgPSBfYi50ZXh0RW5jb2RlciwgdGV4dERlY29kZXIgPSBfYi50ZXh0RGVjb2RlciwgYXJyYXkgPSBfYi5hcnJheTtcbiAgICAgICAgLyoqIEN1cnJlbnQgcG9zaXRpb24gd2hpbGUgcmVhZGluZyAoZGVzZXJpYWxpemluZykgKi9cbiAgICAgICAgdGhpcy5yZWFkUG9zID0gMDtcbiAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5IHx8IG5ldyBVaW50OEFycmF5KDEwMjQpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgICAgdGhpcy50ZXh0RW5jb2RlciA9IHRleHRFbmNvZGVyIHx8IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICB0aGlzLnRleHREZWNvZGVyID0gdGV4dERlY29kZXIgfHwgbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgZmF0YWw6IHRydWUgfSk7XG4gICAgfVxuICAgIC8qKiBSZXNpemUgYGFycmF5YCBpZiBuZWVkZWQgdG8gaGF2ZSBhdCBsZWFzdCBgc2l6ZWAgYnl0ZXMgZnJlZSAqL1xuICAgIFNlcmlhbEJ1ZmZlci5wcm90b3R5cGUucmVzZXJ2ZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCArIHNpemUgPD0gdGhpcy5hcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbCA9IHRoaXMuYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAodGhpcy5sZW5ndGggKyBzaXplID4gbCkge1xuICAgICAgICAgICAgbCA9IE1hdGguY2VpbChsICogMS41KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3QXJyYXkgPSBuZXcgVWludDhBcnJheShsKTtcbiAgICAgICAgbmV3QXJyYXkuc2V0KHRoaXMuYXJyYXkpO1xuICAgICAgICB0aGlzLmFycmF5ID0gbmV3QXJyYXk7XG4gICAgfTtcbiAgICAvKiogSXMgdGhlcmUgZGF0YSBhdmFpbGFibGUgdG8gcmVhZD8gKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLmhhdmVSZWFkRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFBvcyA8IHRoaXMubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqIFJlc3RhcnQgcmVhZGluZyBmcm9tIHRoZSBiZWdpbm5pbmcgKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLnJlc3RhcnRSZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlYWRQb3MgPSAwO1xuICAgIH07XG4gICAgLyoqIFJldHVybiBkYXRhIHdpdGggZXhjZXNzIHN0b3JhZ2UgdHJpbW1lZCBhd2F5ICovXG4gICAgU2VyaWFsQnVmZmVyLnByb3RvdHlwZS5hc1VpbnQ4QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5LmJ1ZmZlciwgdGhpcy5hcnJheS5ieXRlT2Zmc2V0LCB0aGlzLmxlbmd0aCk7XG4gICAgfTtcbiAgICAvKiogQXBwZW5kIGJ5dGVzICovXG4gICAgU2VyaWFsQnVmZmVyLnByb3RvdHlwZS5wdXNoQXJyYXkgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB0aGlzLnJlc2VydmUodi5sZW5ndGgpO1xuICAgICAgICB0aGlzLmFycmF5LnNldCh2LCB0aGlzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IHYubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqIEFwcGVuZCBieXRlcyAqL1xuICAgIFNlcmlhbEJ1ZmZlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHYgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hBcnJheSh2KTtcbiAgICB9O1xuICAgIC8qKiBHZXQgYSBzaW5nbGUgYnl0ZSAqL1xuICAgIFNlcmlhbEJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkUG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFycmF5W3RoaXMucmVhZFBvcysrXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJyk7XG4gICAgfTtcbiAgICAvKiogQXBwZW5kIGJ5dGVzIGluIGB2YC4gVGhyb3dzIGlmIGBsZW5gIGRvZXNuJ3QgbWF0Y2ggYHYubGVuZ3RoYCAqL1xuICAgIFNlcmlhbEJ1ZmZlci5wcm90b3R5cGUucHVzaFVpbnQ4QXJyYXlDaGVja2VkID0gZnVuY3Rpb24gKHYsIGxlbikge1xuICAgICAgICBpZiAodi5sZW5ndGggIT09IGxlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaW5hcnkgZGF0YSBoYXMgaW5jb3JyZWN0IHNpemUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hBcnJheSh2KTtcbiAgICB9O1xuICAgIC8qKiBHZXQgYGxlbmAgYnl0ZXMgKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLmdldFVpbnQ4QXJyYXkgPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWRQb3MgKyBsZW4gPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5LmJ1ZmZlciwgdGhpcy5hcnJheS5ieXRlT2Zmc2V0ICsgdGhpcy5yZWFkUG9zLCBsZW4pO1xuICAgICAgICB0aGlzLnJlYWRQb3MgKz0gbGVuO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqIEFwcGVuZCBhIGB1aW50MTZgICovXG4gICAgU2VyaWFsQnVmZmVyLnByb3RvdHlwZS5wdXNoVWludDE2ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdGhpcy5wdXNoKCh2ID4+IDApICYgMHhmZiwgKHYgPj4gOCkgJiAweGZmKTtcbiAgICB9O1xuICAgIC8qKiBHZXQgYSBgdWludDE2YCAqL1xuICAgIFNlcmlhbEJ1ZmZlci5wcm90b3R5cGUuZ2V0VWludDE2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdiA9IDA7XG4gICAgICAgIHYgfD0gdGhpcy5nZXQoKSA8PCAwO1xuICAgICAgICB2IHw9IHRoaXMuZ2V0KCkgPDwgODtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfTtcbiAgICAvKiogQXBwZW5kIGEgYHVpbnQzMmAgKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLnB1c2hVaW50MzIgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB0aGlzLnB1c2goKHYgPj4gMCkgJiAweGZmLCAodiA+PiA4KSAmIDB4ZmYsICh2ID4+IDE2KSAmIDB4ZmYsICh2ID4+IDI0KSAmIDB4ZmYpO1xuICAgIH07XG4gICAgLyoqIEdldCBhIGB1aW50MzJgICovXG4gICAgU2VyaWFsQnVmZmVyLnByb3RvdHlwZS5nZXRVaW50MzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2ID0gMDtcbiAgICAgICAgdiB8PSB0aGlzLmdldCgpIDw8IDA7XG4gICAgICAgIHYgfD0gdGhpcy5nZXQoKSA8PCA4O1xuICAgICAgICB2IHw9IHRoaXMuZ2V0KCkgPDwgMTY7XG4gICAgICAgIHYgfD0gdGhpcy5nZXQoKSA8PCAyNDtcbiAgICAgICAgcmV0dXJuIHYgPj4+IDA7XG4gICAgfTtcbiAgICAvKiogQXBwZW5kIGEgYHVpbnQ2NGAuICpDYXV0aW9uKjogYG51bWJlcmAgb25seSBoYXMgNTMgYml0cyBvZiBwcmVjaXNpb24gKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLnB1c2hOdW1iZXJBc1VpbnQ2NCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHRoaXMucHVzaFVpbnQzMih2ID4+PiAwKTtcbiAgICAgICAgdGhpcy5wdXNoVWludDMyKE1hdGguZmxvb3IodiAvIDQyOTQ5NjcyOTYpID4+PiAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBhIGB1aW50NjRgIGFzIGEgYG51bWJlcmAuICpDYXV0aW9uKjogYG51bWJlcmAgb25seSBoYXMgNTMgYml0cyBvZiBwcmVjaXNpb247IHNvbWUgdmFsdWVzIHdpbGwgY2hhbmdlLlxuICAgICAqIGBudW1lcmljLmJpbmFyeVRvRGVjaW1hbChzZXJpYWxCdWZmZXIuZ2V0VWludDhBcnJheSg4KSlgIHJlY29tbWVuZGVkIGluc3RlYWRcbiAgICAgKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLmdldFVpbnQ2NEFzTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG93ID0gdGhpcy5nZXRVaW50MzIoKTtcbiAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmdldFVpbnQzMigpO1xuICAgICAgICByZXR1cm4gKGhpZ2ggPj4+IDApICogNDI5NDk2NzI5NiArIChsb3cgPj4+IDApO1xuICAgIH07XG4gICAgLyoqIEFwcGVuZCBhIGB2YXJ1aW50MzJgICovXG4gICAgU2VyaWFsQnVmZmVyLnByb3RvdHlwZS5wdXNoVmFydWludDMyID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh2ID4+PiA3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKDB4ODAgfCAodiAmIDB4N2YpKTtcbiAgICAgICAgICAgICAgICB2ID0gdiA+Pj4gNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaCh2KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEdldCBhIGB2YXJ1aW50MzJgICovXG4gICAgU2VyaWFsQnVmZmVyLnByb3RvdHlwZS5nZXRWYXJ1aW50MzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2ID0gMDtcbiAgICAgICAgdmFyIGJpdCA9IDA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuZ2V0KCk7XG4gICAgICAgICAgICB2IHw9IChiICYgMHg3ZikgPDwgYml0O1xuICAgICAgICAgICAgYml0ICs9IDc7XG4gICAgICAgICAgICBpZiAoIShiICYgMHg4MCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdiA+Pj4gMDtcbiAgICB9O1xuICAgIC8qKiBBcHBlbmQgYSBgdmFyaW50MzJgICovXG4gICAgU2VyaWFsQnVmZmVyLnByb3RvdHlwZS5wdXNoVmFyaW50MzIgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB0aGlzLnB1c2hWYXJ1aW50MzIoKHYgPDwgMSkgXiAodiA+PiAzMSkpO1xuICAgIH07XG4gICAgLyoqIEdldCBhIGB2YXJpbnQzMmAgKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLmdldFZhcmludDMyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0VmFydWludDMyKCk7XG4gICAgICAgIGlmICh2ICYgMSkge1xuICAgICAgICAgICAgcmV0dXJuICgofnYpID4+IDEpIHwgMjE0NzQ4MzY0ODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2ID4+PiAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQXBwZW5kIGEgYGZsb2F0MzJgICovXG4gICAgU2VyaWFsQnVmZmVyLnByb3RvdHlwZS5wdXNoRmxvYXQzMiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHRoaXMucHVzaEFycmF5KG5ldyBVaW50OEFycmF5KChuZXcgRmxvYXQzMkFycmF5KFt2XSkpLmJ1ZmZlcikpO1xuICAgIH07XG4gICAgLyoqIEdldCBhIGBmbG9hdDMyYCAqL1xuICAgIFNlcmlhbEJ1ZmZlci5wcm90b3R5cGUuZ2V0RmxvYXQzMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5nZXRVaW50OEFycmF5KDQpLnNsaWNlKCkuYnVmZmVyKVswXTtcbiAgICB9O1xuICAgIC8qKiBBcHBlbmQgYSBgZmxvYXQ2NGAgKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLnB1c2hGbG9hdDY0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdGhpcy5wdXNoQXJyYXkobmV3IFVpbnQ4QXJyYXkoKG5ldyBGbG9hdDY0QXJyYXkoW3ZdKSkuYnVmZmVyKSk7XG4gICAgfTtcbiAgICAvKiogR2V0IGEgYGZsb2F0NjRgICovXG4gICAgU2VyaWFsQnVmZmVyLnByb3RvdHlwZS5nZXRGbG9hdDY0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheSh0aGlzLmdldFVpbnQ4QXJyYXkoOCkuc2xpY2UoKS5idWZmZXIpWzBdO1xuICAgIH07XG4gICAgLyoqIEFwcGVuZCBhIGBuYW1lYCAqL1xuICAgIFNlcmlhbEJ1ZmZlci5wcm90b3R5cGUucHVzaE5hbWUgPSBmdW5jdGlvbiAocykge1xuICAgICAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHN0cmluZyBjb250YWluaW5nIG5hbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGFyVG9TeW1ib2woYykge1xuICAgICAgICAgICAgaWYgKGMgPj0gJ2EnLmNoYXJDb2RlQXQoMCkgJiYgYyA8PSAneicuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYyAtICdhJy5jaGFyQ29kZUF0KDApKSArIDY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA+PSAnMScuY2hhckNvZGVBdCgwKSAmJiBjIDw9ICc1Jy5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjIC0gJzEnLmNoYXJDb2RlQXQoMCkpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgIHZhciBiaXQgPSA2MztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGNoYXJUb1N5bWJvbChzLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgaWYgKGJpdCA8IDUpIHtcbiAgICAgICAgICAgICAgICBjID0gYyA8PCAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDQ7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFbTWF0aC5mbG9vcihiaXQgLyA4KV0gfD0gKChjID4+IGopICYgMSkgPDwgKGJpdCAlIDgpO1xuICAgICAgICAgICAgICAgICAgICAtLWJpdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoQXJyYXkoYSk7XG4gICAgfTtcbiAgICAvKiogR2V0IGEgYG5hbWVgICovXG4gICAgU2VyaWFsQnVmZmVyLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuZ2V0VWludDhBcnJheSg4KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBiaXQgPSA2MzsgYml0ID49IDA7KSB7XG4gICAgICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChiaXQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjID0gKGMgPDwgMSkgfCAoKGFbTWF0aC5mbG9vcihiaXQgLyA4KV0gPj4gKGJpdCAlIDgpKSAmIDEpO1xuICAgICAgICAgICAgICAgICAgICAtLWJpdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA+PSA2KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyArICdhJy5jaGFyQ29kZUF0KDApIC0gNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID49IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjICsgJzEnLmNoYXJDb2RlQXQoMCkgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHJlc3VsdC5lbmRzV2l0aCgnLicpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc3Vic3RyKDAsIHJlc3VsdC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqIEFwcGVuZCBsZW5ndGgtcHJlZml4ZWQgYmluYXJ5IGRhdGEgKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLnB1c2hCeXRlcyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHRoaXMucHVzaFZhcnVpbnQzMih2Lmxlbmd0aCk7XG4gICAgICAgIHRoaXMucHVzaEFycmF5KHYpO1xuICAgIH07XG4gICAgLyoqIEdldCBsZW5ndGgtcHJlZml4ZWQgYmluYXJ5IGRhdGEgKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLmdldEJ5dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRVaW50OEFycmF5KHRoaXMuZ2V0VmFydWludDMyKCkpO1xuICAgIH07XG4gICAgLyoqIEFwcGVuZCBhIHN0cmluZyAqL1xuICAgIFNlcmlhbEJ1ZmZlci5wcm90b3R5cGUucHVzaFN0cmluZyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHRoaXMucHVzaEJ5dGVzKHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKHYpKTtcbiAgICB9O1xuICAgIC8qKiBHZXQgYSBzdHJpbmcgKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLmdldFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dERlY29kZXIuZGVjb2RlKHRoaXMuZ2V0Qnl0ZXMoKSk7XG4gICAgfTtcbiAgICAvKiogQXBwZW5kIGEgYHN5bWJvbF9jb2RlYC4gVW5saWtlIGBzeW1ib2xgLCBgc3ltYm9sX2NvZGVgIGRvZXNuJ3QgaW5jbHVkZSBhIHByZWNpc2lvbi4gKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLnB1c2hTeW1ib2xDb2RlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBzdHJpbmcgY29udGFpbmluZyBzeW1ib2xfY29kZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBfX3NwcmVhZCh0aGlzLnRleHRFbmNvZGVyLmVuY29kZShuYW1lKSkpO1xuICAgICAgICB3aGlsZSAoYS5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgICBhLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoQXJyYXkoYS5zbGljZSgwLCA4KSk7XG4gICAgfTtcbiAgICAvKiogR2V0IGEgYHN5bWJvbF9jb2RlYC4gVW5saWtlIGBzeW1ib2xgLCBgc3ltYm9sX2NvZGVgIGRvZXNuJ3QgaW5jbHVkZSBhIHByZWNpc2lvbi4gKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLmdldFN5bWJvbENvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5nZXRVaW50OEFycmF5KDgpO1xuICAgICAgICB2YXIgbGVuO1xuICAgICAgICBmb3IgKGxlbiA9IDA7IGxlbiA8IGEubGVuZ3RoOyArK2xlbikge1xuICAgICAgICAgICAgaWYgKCFhW2xlbl0pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHRoaXMudGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGxlbikpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIC8qKiBBcHBlbmQgYSBgc3ltYm9sYCAqL1xuICAgIFNlcmlhbEJ1ZmZlci5wcm90b3R5cGUucHVzaFN5bWJvbCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHByZWNpc2lvbiA9IF9hLnByZWNpc2lvbjtcbiAgICAgICAgdmFyIGEgPSBbcHJlY2lzaW9uICYgMHhmZl07XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBfX3NwcmVhZCh0aGlzLnRleHRFbmNvZGVyLmVuY29kZShuYW1lKSkpO1xuICAgICAgICB3aGlsZSAoYS5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgICBhLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoQXJyYXkoYS5zbGljZSgwLCA4KSk7XG4gICAgfTtcbiAgICAvKiogR2V0IGEgYHN5bWJvbGAgKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLmdldFN5bWJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIHZhciBhID0gdGhpcy5nZXRVaW50OEFycmF5KDcpO1xuICAgICAgICB2YXIgbGVuO1xuICAgICAgICBmb3IgKGxlbiA9IDA7IGxlbiA8IGEubGVuZ3RoOyArK2xlbikge1xuICAgICAgICAgICAgaWYgKCFhW2xlbl0pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHRoaXMudGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGxlbikpO1xuICAgICAgICByZXR1cm4geyBuYW1lOiBuYW1lLCBwcmVjaXNpb246IHByZWNpc2lvbiB9O1xuICAgIH07XG4gICAgLyoqIEFwcGVuZCBhbiBhc3NldCAqL1xuICAgIFNlcmlhbEJ1ZmZlci5wcm90b3R5cGUucHVzaEFzc2V0ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBzdHJpbmcgY29udGFpbmluZyBhc3NldCcpO1xuICAgICAgICB9XG4gICAgICAgIHMgPSBzLnRyaW0oKTtcbiAgICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICAgIHZhciBhbW91bnQgPSAnJztcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IDA7XG4gICAgICAgIGlmIChzW3Bvc10gPT09ICctJykge1xuICAgICAgICAgICAgYW1vdW50ICs9ICctJztcbiAgICAgICAgICAgICsrcG9zO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3VuZERpZ2l0ID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChwb3MgPCBzLmxlbmd0aCAmJiBzLmNoYXJDb2RlQXQocG9zKSA+PSAnMCcuY2hhckNvZGVBdCgwKSAmJiBzLmNoYXJDb2RlQXQocG9zKSA8PSAnOScuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgICAgZm91bmREaWdpdCA9IHRydWU7XG4gICAgICAgICAgICBhbW91bnQgKz0gc1twb3NdO1xuICAgICAgICAgICAgKytwb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb3VuZERpZ2l0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fzc2V0IG11c3QgYmVnaW4gd2l0aCBhIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzW3Bvc10gPT09ICcuJykge1xuICAgICAgICAgICAgKytwb3M7XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgcy5sZW5ndGggJiYgcy5jaGFyQ29kZUF0KHBvcykgPj0gJzAnLmNoYXJDb2RlQXQoMCkgJiYgcy5jaGFyQ29kZUF0KHBvcykgPD0gJzknLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICAgICAgICBhbW91bnQgKz0gc1twb3NdO1xuICAgICAgICAgICAgICAgICsrcHJlY2lzaW9uO1xuICAgICAgICAgICAgICAgICsrcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gcy5zdWJzdHIocG9zKS50cmltKCk7XG4gICAgICAgIHRoaXMucHVzaEFycmF5KG51bWVyaWMuc2lnbmVkRGVjaW1hbFRvQmluYXJ5KDgsIGFtb3VudCkpO1xuICAgICAgICB0aGlzLnB1c2hTeW1ib2woeyBuYW1lOiBuYW1lLCBwcmVjaXNpb246IHByZWNpc2lvbiB9KTtcbiAgICB9O1xuICAgIC8qKiBHZXQgYW4gYXNzZXQgKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLmdldEFzc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW1vdW50ID0gdGhpcy5nZXRVaW50OEFycmF5KDgpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldFN5bWJvbCgpLCBuYW1lID0gX2EubmFtZSwgcHJlY2lzaW9uID0gX2EucHJlY2lzaW9uO1xuICAgICAgICB2YXIgcyA9IG51bWVyaWMuc2lnbmVkQmluYXJ5VG9EZWNpbWFsKGFtb3VudCwgcHJlY2lzaW9uICsgMSk7XG4gICAgICAgIGlmIChwcmVjaXNpb24pIHtcbiAgICAgICAgICAgIHMgPSBzLnN1YnN0cigwLCBzLmxlbmd0aCAtIHByZWNpc2lvbikgKyAnLicgKyBzLnN1YnN0cihzLmxlbmd0aCAtIHByZWNpc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMgKyAnICcgKyBuYW1lO1xuICAgIH07XG4gICAgLyoqIEFwcGVuZCBhIHB1YmxpYyBrZXkgKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLnB1c2hQdWJsaWNLZXkgPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIga2V5ID0gbnVtZXJpYy5zdHJpbmdUb1B1YmxpY0tleShzKTtcbiAgICAgICAgdGhpcy5wdXNoKGtleS50eXBlKTtcbiAgICAgICAgdGhpcy5wdXNoQXJyYXkoa2V5LmRhdGEpO1xuICAgIH07XG4gICAgLyoqIEdldCBhIHB1YmxpYyBrZXkgKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLmdldFB1YmxpY0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmdldCgpO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0VWludDhBcnJheShudW1lcmljLnB1YmxpY0tleURhdGFTaXplKTtcbiAgICAgICAgcmV0dXJuIG51bWVyaWMucHVibGljS2V5VG9TdHJpbmcoeyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH0pO1xuICAgIH07XG4gICAgLyoqIEFwcGVuZCBhIHByaXZhdGUga2V5ICovXG4gICAgU2VyaWFsQnVmZmVyLnByb3RvdHlwZS5wdXNoUHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBrZXkgPSBudW1lcmljLnN0cmluZ1RvUHJpdmF0ZUtleShzKTtcbiAgICAgICAgdGhpcy5wdXNoKGtleS50eXBlKTtcbiAgICAgICAgdGhpcy5wdXNoQXJyYXkoa2V5LmRhdGEpO1xuICAgIH07XG4gICAgLyoqIEdldCBhIHByaXZhdGUga2V5ICovXG4gICAgU2VyaWFsQnVmZmVyLnByb3RvdHlwZS5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRVaW50OEFycmF5KG51bWVyaWMucHJpdmF0ZUtleURhdGFTaXplKTtcbiAgICAgICAgcmV0dXJuIG51bWVyaWMucHJpdmF0ZUtleVRvU3RyaW5nKHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9KTtcbiAgICB9O1xuICAgIC8qKiBBcHBlbmQgYSBzaWduYXR1cmUgKi9cbiAgICBTZXJpYWxCdWZmZXIucHJvdG90eXBlLnB1c2hTaWduYXR1cmUgPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIga2V5ID0gbnVtZXJpYy5zdHJpbmdUb1NpZ25hdHVyZShzKTtcbiAgICAgICAgdGhpcy5wdXNoKGtleS50eXBlKTtcbiAgICAgICAgdGhpcy5wdXNoQXJyYXkoa2V5LmRhdGEpO1xuICAgIH07XG4gICAgLyoqIEdldCBhIHNpZ25hdHVyZSAqL1xuICAgIFNlcmlhbEJ1ZmZlci5wcm90b3R5cGUuZ2V0U2lnbmF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRVaW50OEFycmF5KG51bWVyaWMuc2lnbmF0dXJlRGF0YVNpemUpO1xuICAgICAgICByZXR1cm4gbnVtZXJpYy5zaWduYXR1cmVUb1N0cmluZyh7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VyaWFsQnVmZmVyO1xufSgpKTsgLy8gU2VyaWFsQnVmZmVyXG5leHBvcnRzLlNlcmlhbEJ1ZmZlciA9IFNlcmlhbEJ1ZmZlcjtcbi8qKiBJcyB0aGlzIGEgc3VwcG9ydGVkIEFCSSB2ZXJzaW9uPyAqL1xuZnVuY3Rpb24gc3VwcG9ydGVkQWJpVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIHZlcnNpb24uc3RhcnRzV2l0aCgnZW9zaW86OmFiaS8xLicpO1xufVxuZXhwb3J0cy5zdXBwb3J0ZWRBYmlWZXJzaW9uID0gc3VwcG9ydGVkQWJpVmVyc2lvbjtcbmZ1bmN0aW9uIGNoZWNrRGF0ZVBhcnNlKGRhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gRGF0ZS5wYXJzZShkYXRlKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRpbWUgZm9ybWF0Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiogQ29udmVydCBkYXRlIGluIElTTyBmb3JtYXQgdG8gYHRpbWVfcG9pbnRgIChtaWxpc2Vjb25kcyBzaW5jZSBlcG9jaCkgKi9cbmZ1bmN0aW9uIGRhdGVUb1RpbWVQb2ludChkYXRlKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoY2hlY2tEYXRlUGFyc2UoZGF0ZSArICdaJykgKiAxMDAwKTtcbn1cbmV4cG9ydHMuZGF0ZVRvVGltZVBvaW50ID0gZGF0ZVRvVGltZVBvaW50O1xuLyoqIENvbnZlcnQgYHRpbWVfcG9pbnRgIChtaWxpc2Vjb25kcyBzaW5jZSBlcG9jaCkgdG8gZGF0ZSBpbiBJU08gZm9ybWF0ICovXG5mdW5jdGlvbiB0aW1lUG9pbnRUb0RhdGUodXMpIHtcbiAgICB2YXIgcyA9IChuZXcgRGF0ZSh1cyAvIDEwMDApKS50b0lTT1N0cmluZygpO1xuICAgIHJldHVybiBzLnN1YnN0cigwLCBzLmxlbmd0aCAtIDEpO1xufVxuZXhwb3J0cy50aW1lUG9pbnRUb0RhdGUgPSB0aW1lUG9pbnRUb0RhdGU7XG4vKiogQ29udmVydCBkYXRlIGluIElTTyBmb3JtYXQgdG8gYHRpbWVfcG9pbnRfc2VjYCAoc2Vjb25kcyBzaW5jZSBlcG9jaCkgKi9cbmZ1bmN0aW9uIGRhdGVUb1RpbWVQb2ludFNlYyhkYXRlKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoY2hlY2tEYXRlUGFyc2UoZGF0ZSArICdaJykgLyAxMDAwKTtcbn1cbmV4cG9ydHMuZGF0ZVRvVGltZVBvaW50U2VjID0gZGF0ZVRvVGltZVBvaW50U2VjO1xuLyoqIENvbnZlcnQgYHRpbWVfcG9pbnRfc2VjYCAoc2Vjb25kcyBzaW5jZSBlcG9jaCkgdG8gdG8gZGF0ZSBpbiBJU08gZm9ybWF0ICovXG5mdW5jdGlvbiB0aW1lUG9pbnRTZWNUb0RhdGUoc2VjKSB7XG4gICAgdmFyIHMgPSAobmV3IERhdGUoc2VjICogMTAwMCkpLnRvSVNPU3RyaW5nKCk7XG4gICAgcmV0dXJuIHMuc3Vic3RyKDAsIHMubGVuZ3RoIC0gMSk7XG59XG5leHBvcnRzLnRpbWVQb2ludFNlY1RvRGF0ZSA9IHRpbWVQb2ludFNlY1RvRGF0ZTtcbi8qKiBDb252ZXJ0IGRhdGUgaW4gSVNPIGZvcm1hdCB0byBgYmxvY2tfdGltZXN0YW1wX3R5cGVgIChoYWxmLXNlY29uZHMgc2luY2UgYSBkaWZmZXJlbnQgZXBvY2gpICovXG5mdW5jdGlvbiBkYXRlVG9CbG9ja1RpbWVzdGFtcChkYXRlKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKGNoZWNrRGF0ZVBhcnNlKGRhdGUgKyAnWicpIC0gOTQ2Njg0ODAwMDAwKSAvIDUwMCk7XG59XG5leHBvcnRzLmRhdGVUb0Jsb2NrVGltZXN0YW1wID0gZGF0ZVRvQmxvY2tUaW1lc3RhbXA7XG4vKiogQ29udmVydCBgYmxvY2tfdGltZXN0YW1wX3R5cGVgIChoYWxmLXNlY29uZHMgc2luY2UgYSBkaWZmZXJlbnQgZXBvY2gpIHRvIHRvIGRhdGUgaW4gSVNPIGZvcm1hdCAqL1xuZnVuY3Rpb24gYmxvY2tUaW1lc3RhbXBUb0RhdGUoc2xvdCkge1xuICAgIHZhciBzID0gKG5ldyBEYXRlKHNsb3QgKiA1MDAgKyA5NDY2ODQ4MDAwMDApKS50b0lTT1N0cmluZygpO1xuICAgIHJldHVybiBzLnN1YnN0cigwLCBzLmxlbmd0aCAtIDEpO1xufVxuZXhwb3J0cy5ibG9ja1RpbWVzdGFtcFRvRGF0ZSA9IGJsb2NrVGltZXN0YW1wVG9EYXRlO1xuLyoqIENvbnZlcnQgYHN0cmluZ2AgdG8gYFN5bWJvbGAuIGZvcm1hdDogYHByZWNpc2lvbixOQU1FYC4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvU3ltYm9sKHMpIHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgc3RyaW5nIGNvbnRhaW5pbmcgc3ltYm9sJyk7XG4gICAgfVxuICAgIHZhciBtID0gcy5tYXRjaCgvXihbMC05XSspLChbQS1aXSspJC8pO1xuICAgIGlmICghbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3ltYm9sJyk7XG4gICAgfVxuICAgIHJldHVybiB7IG5hbWU6IG1bMl0sIHByZWNpc2lvbjogK21bMV0gfTtcbn1cbmV4cG9ydHMuc3RyaW5nVG9TeW1ib2wgPSBzdHJpbmdUb1N5bWJvbDtcbi8qKiBDb252ZXJ0IGBTeW1ib2xgIHRvIGBzdHJpbmdgLiBmb3JtYXQ6IGBwcmVjaXNpb24sTkFNRWAuICovXG5mdW5jdGlvbiBzeW1ib2xUb1N0cmluZyhfYSkge1xuICAgIHZhciBuYW1lID0gX2EubmFtZSwgcHJlY2lzaW9uID0gX2EucHJlY2lzaW9uO1xuICAgIHJldHVybiBwcmVjaXNpb24gKyAnLCcgKyBuYW1lO1xufVxuZXhwb3J0cy5zeW1ib2xUb1N0cmluZyA9IHN5bWJvbFRvU3RyaW5nO1xuLyoqIENvbnZlcnQgYmluYXJ5IGRhdGEgdG8gaGV4ICovXG5mdW5jdGlvbiBhcnJheVRvSGV4KGRhdGEpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgZGF0YV8xID0gX192YWx1ZXMoZGF0YSksIGRhdGFfMV8xID0gZGF0YV8xLm5leHQoKTsgIWRhdGFfMV8xLmRvbmU7IGRhdGFfMV8xID0gZGF0YV8xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHggPSBkYXRhXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIHJlc3VsdCArPSAoJzAwJyArIHgudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChkYXRhXzFfMSAmJiAhZGF0YV8xXzEuZG9uZSAmJiAoX2EgPSBkYXRhXzEucmV0dXJuKSkgX2EuY2FsbChkYXRhXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC50b1VwcGVyQ2FzZSgpO1xufVxuZXhwb3J0cy5hcnJheVRvSGV4ID0gYXJyYXlUb0hleDtcbi8qKiBDb252ZXJ0IGhleCB0byBiaW5hcnkgZGF0YSAqL1xuZnVuY3Rpb24gaGV4VG9VaW50OEFycmF5KGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHN0cmluZyBjb250YWluaW5nIGhleCBkaWdpdHMnKTtcbiAgICB9XG4gICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT2RkIG51bWJlciBvZiBoZXggZGlnaXRzJyk7XG4gICAgfVxuICAgIHZhciBsID0gaGV4Lmxlbmd0aCAvIDI7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIHZhciB4ID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpICogMiwgMiksIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTih4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBoZXggc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2ldID0geDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuaGV4VG9VaW50OEFycmF5ID0gaGV4VG9VaW50OEFycmF5O1xuZnVuY3Rpb24gc2VyaWFsaXplVW5rbm93bihidWZmZXIsIGRhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RvblxcJ3Qga25vdyBob3cgdG8gc2VyaWFsaXplICcgKyB0aGlzLm5hbWUpO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVVbmtub3duKGJ1ZmZlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignRG9uXFwndCBrbm93IGhvdyB0byBkZXNlcmlhbGl6ZSAnICsgdGhpcy5uYW1lKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVN0cnVjdChidWZmZXIsIGRhdGEsIHN0YXRlLCBhbGxvd0V4dGVuc2lvbnMpIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkgeyBzdGF0ZSA9IG5ldyBTZXJpYWxpemVyU3RhdGUoKTsgfVxuICAgIGlmIChhbGxvd0V4dGVuc2lvbnMgPT09IHZvaWQgMCkgeyBhbGxvd0V4dGVuc2lvbnMgPSB0cnVlOyB9XG4gICAgdmFyIGVfMiwgX2E7XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIG9iamVjdCBjb250YWluaW5nIGRhdGE6ICcgKyBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmJhc2UpIHtcbiAgICAgICAgdGhpcy5iYXNlLnNlcmlhbGl6ZShidWZmZXIsIGRhdGEsIHN0YXRlLCBhbGxvd0V4dGVuc2lvbnMpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMuZmllbGRzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gX2MudmFsdWU7XG4gICAgICAgICAgICBpZiAoZmllbGQubmFtZSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNraXBwZWRCaW5hcnlFeHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkICcgKyB0aGlzLm5hbWUgKyAnLicgKyBmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmllbGQudHlwZS5zZXJpYWxpemUoYnVmZmVyLCBkYXRhW2ZpZWxkLm5hbWVdLCBzdGF0ZSwgYWxsb3dFeHRlbnNpb25zICYmIGZpZWxkID09PSB0aGlzLmZpZWxkc1t0aGlzLmZpZWxkcy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dFeHRlbnNpb25zICYmIGZpZWxkLnR5cGUuZXh0ZW5zaW9uT2YpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2tpcHBlZEJpbmFyeUV4dGVuc2lvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgJyArIHRoaXMubmFtZSArICcuJyArIGZpZWxkLm5hbWUgKyAnICh0eXBlPScgKyBmaWVsZC50eXBlLm5hbWUgKyAnKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICB9XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVN0cnVjdChidWZmZXIsIHN0YXRlLCBhbGxvd0V4dGVuc2lvbnMpIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkgeyBzdGF0ZSA9IG5ldyBTZXJpYWxpemVyU3RhdGUoKTsgfVxuICAgIGlmIChhbGxvd0V4dGVuc2lvbnMgPT09IHZvaWQgMCkgeyBhbGxvd0V4dGVuc2lvbnMgPSB0cnVlOyB9XG4gICAgdmFyIGVfMywgX2E7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAodGhpcy5iYXNlKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuYmFzZS5kZXNlcmlhbGl6ZShidWZmZXIsIHN0YXRlLCBhbGxvd0V4dGVuc2lvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0ge307XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5maWVsZHMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgIGlmIChhbGxvd0V4dGVuc2lvbnMgJiYgZmllbGQudHlwZS5leHRlbnNpb25PZiAmJiAhYnVmZmVyLmhhdmVSZWFkRGF0YSgpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuc2tpcHBlZEJpbmFyeUV4dGVuc2lvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbZmllbGQubmFtZV0gPSBmaWVsZC50eXBlLmRlc2VyaWFsaXplKGJ1ZmZlciwgc3RhdGUsIGFsbG93RXh0ZW5zaW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVWYXJpYW50KGJ1ZmZlciwgZGF0YSwgc3RhdGUsIGFsbG93RXh0ZW5zaW9ucykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSB8fCBkYXRhLmxlbmd0aCAhPT0gMiB8fCB0eXBlb2YgZGF0YVswXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCB2YXJpYW50OiBbXCJ0eXBlXCIsIHZhbHVlXScpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZmllbGRzLmZpbmRJbmRleChmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIGZpZWxkLm5hbWUgPT09IGRhdGFbMF07IH0pO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlIFxcXCJcIiArIGRhdGFbMF0gKyBcIlxcXCIgaXMgbm90IHZhbGlkIGZvciB2YXJpYW50XCIpO1xuICAgIH1cbiAgICBidWZmZXIucHVzaFZhcnVpbnQzMihpKTtcbiAgICB0aGlzLmZpZWxkc1tpXS50eXBlLnNlcmlhbGl6ZShidWZmZXIsIGRhdGFbMV0sIHN0YXRlLCBhbGxvd0V4dGVuc2lvbnMpO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVWYXJpYW50KGJ1ZmZlciwgc3RhdGUsIGFsbG93RXh0ZW5zaW9ucykge1xuICAgIHZhciBpID0gYnVmZmVyLmdldFZhcnVpbnQzMigpO1xuICAgIGlmIChpID49IHRoaXMuZmllbGRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlIGluZGV4IFwiICsgaSArIFwiIGlzIG5vdCB2YWxpZCBmb3IgdmFyaWFudFwiKTtcbiAgICB9XG4gICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZHNbaV07XG4gICAgcmV0dXJuIFtmaWVsZC5uYW1lLCBmaWVsZC50eXBlLmRlc2VyaWFsaXplKGJ1ZmZlciwgc3RhdGUsIGFsbG93RXh0ZW5zaW9ucyldO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQXJyYXkoYnVmZmVyLCBkYXRhLCBzdGF0ZSwgYWxsb3dFeHRlbnNpb25zKSB7XG4gICAgdmFyIGVfNCwgX2E7XG4gICAgYnVmZmVyLnB1c2hWYXJ1aW50MzIoZGF0YS5sZW5ndGgpO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGRhdGFfMiA9IF9fdmFsdWVzKGRhdGEpLCBkYXRhXzJfMSA9IGRhdGFfMi5uZXh0KCk7ICFkYXRhXzJfMS5kb25lOyBkYXRhXzJfMSA9IGRhdGFfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZGF0YV8yXzEudmFsdWU7XG4gICAgICAgICAgICB0aGlzLmFycmF5T2Yuc2VyaWFsaXplKGJ1ZmZlciwgaXRlbSwgc3RhdGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGRhdGFfMl8xICYmICFkYXRhXzJfMS5kb25lICYmIChfYSA9IGRhdGFfMi5yZXR1cm4pKSBfYS5jYWxsKGRhdGFfMik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplQXJyYXkoYnVmZmVyLCBzdGF0ZSwgYWxsb3dFeHRlbnNpb25zKSB7XG4gICAgdmFyIGxlbiA9IGJ1ZmZlci5nZXRWYXJ1aW50MzIoKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLmFycmF5T2YuZGVzZXJpYWxpemUoYnVmZmVyLCBzdGF0ZSwgZmFsc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9wdGlvbmFsKGJ1ZmZlciwgZGF0YSwgc3RhdGUsIGFsbG93RXh0ZW5zaW9ucykge1xuICAgIGlmIChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBidWZmZXIucHVzaCgwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKDEpO1xuICAgICAgICB0aGlzLm9wdGlvbmFsT2Yuc2VyaWFsaXplKGJ1ZmZlciwgZGF0YSwgc3RhdGUsIGFsbG93RXh0ZW5zaW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVPcHRpb25hbChidWZmZXIsIHN0YXRlLCBhbGxvd0V4dGVuc2lvbnMpIHtcbiAgICBpZiAoYnVmZmVyLmdldCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbmFsT2YuZGVzZXJpYWxpemUoYnVmZmVyLCBzdGF0ZSwgYWxsb3dFeHRlbnNpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUV4dGVuc2lvbihidWZmZXIsIGRhdGEsIHN0YXRlLCBhbGxvd0V4dGVuc2lvbnMpIHtcbiAgICB0aGlzLmV4dGVuc2lvbk9mLnNlcmlhbGl6ZShidWZmZXIsIGRhdGEsIHN0YXRlLCBhbGxvd0V4dGVuc2lvbnMpO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVFeHRlbnNpb24oYnVmZmVyLCBzdGF0ZSwgYWxsb3dFeHRlbnNpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uT2YuZGVzZXJpYWxpemUoYnVmZmVyLCBzdGF0ZSwgYWxsb3dFeHRlbnNpb25zKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR5cGUoYXR0cnMpIHtcbiAgICByZXR1cm4gX19hc3NpZ24oeyBuYW1lOiAnPG1pc3NpbmcgbmFtZT4nLCBhbGlhc09mTmFtZTogJycsIGFycmF5T2Y6IG51bGwsIG9wdGlvbmFsT2Y6IG51bGwsIGV4dGVuc2lvbk9mOiBudWxsLCBiYXNlTmFtZTogJycsIGJhc2U6IG51bGwsIGZpZWxkczogW10sIHNlcmlhbGl6ZTogc2VyaWFsaXplVW5rbm93biwgZGVzZXJpYWxpemU6IGRlc2VyaWFsaXplVW5rbm93biB9LCBhdHRycyk7XG59XG5mdW5jdGlvbiBjaGVja1JhbmdlKG9yaWcsIGNvbnZlcnRlZCkge1xuICAgIGlmIChOdW1iZXIuaXNOYU4oK29yaWcpIHx8IE51bWJlci5pc05hTigrY29udmVydGVkKSB8fCAodHlwZW9mIG9yaWcgIT09ICdudW1iZXInICYmIHR5cGVvZiBvcmlnICE9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKCtvcmlnICE9PSArY29udmVydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIGlzIG91dCBvZiByYW5nZScpO1xuICAgIH1cbiAgICByZXR1cm4gK29yaWc7XG59XG4vKiogQ3JlYXRlIHRoZSBzZXQgb2YgdHlwZXMgYnVpbHQtaW4gdG8gdGhlIGFiaSBmb3JtYXQgKi9cbmZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxUeXBlcygpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IE1hcChPYmplY3QuZW50cmllcyh7XG4gICAgICAgIGJvb2w6IGNyZWF0ZVR5cGUoe1xuICAgICAgICAgICAgbmFtZTogJ2Jvb2wnLFxuICAgICAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0cnVlIG9yIGZhbHNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGRhdGEgPyAxIDogMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIpIHsgcmV0dXJuICEhYnVmZmVyLmdldCgpOyB9LFxuICAgICAgICB9KSxcbiAgICAgICAgdWludDg6IGNyZWF0ZVR5cGUoe1xuICAgICAgICAgICAgbmFtZTogJ3VpbnQ4JyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlciwgZGF0YSkgeyBidWZmZXIucHVzaChjaGVja1JhbmdlKGRhdGEsIGRhdGEgJiAweGZmKSk7IH0sXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyLmdldCgpOyB9LFxuICAgICAgICB9KSxcbiAgICAgICAgaW50ODogY3JlYXRlVHlwZSh7XG4gICAgICAgICAgICBuYW1lOiAnaW50OCcsXG4gICAgICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIsIGRhdGEpIHsgYnVmZmVyLnB1c2goY2hlY2tSYW5nZShkYXRhLCBkYXRhIDw8IDI0ID4+IDI0KSk7IH0sXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyLmdldCgpIDw8IDI0ID4+IDI0OyB9LFxuICAgICAgICB9KSxcbiAgICAgICAgdWludDE2OiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICd1aW50MTYnLFxuICAgICAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyLCBkYXRhKSB7IGJ1ZmZlci5wdXNoVWludDE2KGNoZWNrUmFuZ2UoZGF0YSwgZGF0YSAmIDB4ZmZmZikpOyB9LFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlci5nZXRVaW50MTYoKTsgfSxcbiAgICAgICAgfSksXG4gICAgICAgIGludDE2OiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICdpbnQxNicsXG4gICAgICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIsIGRhdGEpIHsgYnVmZmVyLnB1c2hVaW50MTYoY2hlY2tSYW5nZShkYXRhLCBkYXRhIDw8IDE2ID4+IDE2KSk7IH0sXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyLmdldFVpbnQxNigpIDw8IDE2ID4+IDE2OyB9LFxuICAgICAgICB9KSxcbiAgICAgICAgdWludDMyOiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICd1aW50MzInLFxuICAgICAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyLCBkYXRhKSB7IGJ1ZmZlci5wdXNoVWludDMyKGNoZWNrUmFuZ2UoZGF0YSwgZGF0YSA+Pj4gMCkpOyB9LFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlci5nZXRVaW50MzIoKTsgfSxcbiAgICAgICAgfSksXG4gICAgICAgIHVpbnQ2NDogY3JlYXRlVHlwZSh7XG4gICAgICAgICAgICBuYW1lOiAndWludDY0JyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlciwgZGF0YSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoQXJyYXkobnVtZXJpYy5kZWNpbWFsVG9CaW5hcnkoOCwgJycgKyBkYXRhKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIpIHsgcmV0dXJuIG51bWVyaWMuYmluYXJ5VG9EZWNpbWFsKGJ1ZmZlci5nZXRVaW50OEFycmF5KDgpKTsgfSxcbiAgICAgICAgfSksXG4gICAgICAgIGludDY0OiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICdpbnQ2NCcsXG4gICAgICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaEFycmF5KG51bWVyaWMuc2lnbmVkRGVjaW1hbFRvQmluYXJ5KDgsICcnICsgZGF0YSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyKSB7IHJldHVybiBudW1lcmljLnNpZ25lZEJpbmFyeVRvRGVjaW1hbChidWZmZXIuZ2V0VWludDhBcnJheSg4KSk7IH0sXG4gICAgICAgIH0pLFxuICAgICAgICBpbnQzMjogY3JlYXRlVHlwZSh7XG4gICAgICAgICAgICBuYW1lOiAnaW50MzInLFxuICAgICAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyLCBkYXRhKSB7IGJ1ZmZlci5wdXNoVWludDMyKGNoZWNrUmFuZ2UoZGF0YSwgZGF0YSB8IDApKTsgfSxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyKSB7IHJldHVybiBidWZmZXIuZ2V0VWludDMyKCkgfCAwOyB9LFxuICAgICAgICB9KSxcbiAgICAgICAgdmFydWludDMyOiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICd2YXJ1aW50MzInLFxuICAgICAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyLCBkYXRhKSB7IGJ1ZmZlci5wdXNoVmFydWludDMyKGNoZWNrUmFuZ2UoZGF0YSwgZGF0YSA+Pj4gMCkpOyB9LFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlci5nZXRWYXJ1aW50MzIoKTsgfSxcbiAgICAgICAgfSksXG4gICAgICAgIHZhcmludDMyOiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICd2YXJpbnQzMicsXG4gICAgICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIsIGRhdGEpIHsgYnVmZmVyLnB1c2hWYXJpbnQzMihjaGVja1JhbmdlKGRhdGEsIGRhdGEgfCAwKSk7IH0sXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyLmdldFZhcmludDMyKCk7IH0sXG4gICAgICAgIH0pLFxuICAgICAgICB1aW50MTI4OiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICd1aW50MTI4JyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlciwgZGF0YSkgeyBidWZmZXIucHVzaEFycmF5KG51bWVyaWMuZGVjaW1hbFRvQmluYXJ5KDE2LCAnJyArIGRhdGEpKTsgfSxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyKSB7IHJldHVybiBudW1lcmljLmJpbmFyeVRvRGVjaW1hbChidWZmZXIuZ2V0VWludDhBcnJheSgxNikpOyB9LFxuICAgICAgICB9KSxcbiAgICAgICAgaW50MTI4OiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICdpbnQxMjgnLFxuICAgICAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnB1c2hBcnJheShudW1lcmljLnNpZ25lZERlY2ltYWxUb0JpbmFyeSgxNiwgJycgKyBkYXRhKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIpIHsgcmV0dXJuIG51bWVyaWMuc2lnbmVkQmluYXJ5VG9EZWNpbWFsKGJ1ZmZlci5nZXRVaW50OEFycmF5KDE2KSk7IH0sXG4gICAgICAgIH0pLFxuICAgICAgICBmbG9hdDMyOiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICdmbG9hdDMyJyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlciwgZGF0YSkgeyBidWZmZXIucHVzaEZsb2F0MzIoZGF0YSk7IH0sXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyLmdldEZsb2F0MzIoKTsgfSxcbiAgICAgICAgfSksXG4gICAgICAgIGZsb2F0NjQ6IGNyZWF0ZVR5cGUoe1xuICAgICAgICAgICAgbmFtZTogJ2Zsb2F0NjQnLFxuICAgICAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyLCBkYXRhKSB7IGJ1ZmZlci5wdXNoRmxvYXQ2NChkYXRhKTsgfSxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyKSB7IHJldHVybiBidWZmZXIuZ2V0RmxvYXQ2NCgpOyB9LFxuICAgICAgICB9KSxcbiAgICAgICAgZmxvYXQxMjg6IGNyZWF0ZVR5cGUoe1xuICAgICAgICAgICAgbmFtZTogJ2Zsb2F0MTI4JyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlciwgZGF0YSkgeyBidWZmZXIucHVzaFVpbnQ4QXJyYXlDaGVja2VkKGhleFRvVWludDhBcnJheShkYXRhKSwgMTYpOyB9LFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIpIHsgcmV0dXJuIGFycmF5VG9IZXgoYnVmZmVyLmdldFVpbnQ4QXJyYXkoMTYpKTsgfSxcbiAgICAgICAgfSksXG4gICAgICAgIGJ5dGVzOiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICdieXRlcycsXG4gICAgICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaEJ5dGVzKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnB1c2hCeXRlcyhoZXhUb1VpbnQ4QXJyYXkoZGF0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlciwgc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUub3B0aW9ucy5ieXRlc0FzVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLmdldEJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlUb0hleChidWZmZXIuZ2V0Qnl0ZXMoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgICAgIHN0cmluZzogY3JlYXRlVHlwZSh7XG4gICAgICAgICAgICBuYW1lOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlciwgZGF0YSkgeyBidWZmZXIucHVzaFN0cmluZyhkYXRhKTsgfSxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyKSB7IHJldHVybiBidWZmZXIuZ2V0U3RyaW5nKCk7IH0sXG4gICAgICAgIH0pLFxuICAgICAgICBuYW1lOiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlciwgZGF0YSkgeyBidWZmZXIucHVzaE5hbWUoZGF0YSk7IH0sXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyLmdldE5hbWUoKTsgfSxcbiAgICAgICAgfSksXG4gICAgICAgIHRpbWVfcG9pbnQ6IGNyZWF0ZVR5cGUoe1xuICAgICAgICAgICAgbmFtZTogJ3RpbWVfcG9pbnQnLFxuICAgICAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyLCBkYXRhKSB7IGJ1ZmZlci5wdXNoTnVtYmVyQXNVaW50NjQoZGF0ZVRvVGltZVBvaW50KGRhdGEpKTsgfSxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyKSB7IHJldHVybiB0aW1lUG9pbnRUb0RhdGUoYnVmZmVyLmdldFVpbnQ2NEFzTnVtYmVyKCkpOyB9LFxuICAgICAgICB9KSxcbiAgICAgICAgdGltZV9wb2ludF9zZWM6IGNyZWF0ZVR5cGUoe1xuICAgICAgICAgICAgbmFtZTogJ3RpbWVfcG9pbnRfc2VjJyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlciwgZGF0YSkgeyBidWZmZXIucHVzaFVpbnQzMihkYXRlVG9UaW1lUG9pbnRTZWMoZGF0YSkpOyB9LFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIpIHsgcmV0dXJuIHRpbWVQb2ludFNlY1RvRGF0ZShidWZmZXIuZ2V0VWludDMyKCkpOyB9LFxuICAgICAgICB9KSxcbiAgICAgICAgYmxvY2tfdGltZXN0YW1wX3R5cGU6IGNyZWF0ZVR5cGUoe1xuICAgICAgICAgICAgbmFtZTogJ2Jsb2NrX3RpbWVzdGFtcF90eXBlJyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlciwgZGF0YSkgeyBidWZmZXIucHVzaFVpbnQzMihkYXRlVG9CbG9ja1RpbWVzdGFtcChkYXRhKSk7IH0sXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlcikgeyByZXR1cm4gYmxvY2tUaW1lc3RhbXBUb0RhdGUoYnVmZmVyLmdldFVpbnQzMigpKTsgfSxcbiAgICAgICAgfSksXG4gICAgICAgIHN5bWJvbF9jb2RlOiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICdzeW1ib2xfY29kZScsXG4gICAgICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIsIGRhdGEpIHsgYnVmZmVyLnB1c2hTeW1ib2xDb2RlKGRhdGEpOyB9LFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlci5nZXRTeW1ib2xDb2RlKCk7IH0sXG4gICAgICAgIH0pLFxuICAgICAgICBzeW1ib2w6IGNyZWF0ZVR5cGUoe1xuICAgICAgICAgICAgbmFtZTogJ3N5bWJvbCcsXG4gICAgICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIsIGRhdGEpIHsgYnVmZmVyLnB1c2hTeW1ib2woc3RyaW5nVG9TeW1ib2woZGF0YSkpOyB9LFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIpIHsgcmV0dXJuIHN5bWJvbFRvU3RyaW5nKGJ1ZmZlci5nZXRTeW1ib2woKSk7IH0sXG4gICAgICAgIH0pLFxuICAgICAgICBhc3NldDogY3JlYXRlVHlwZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXNzZXQnLFxuICAgICAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyLCBkYXRhKSB7IGJ1ZmZlci5wdXNoQXNzZXQoZGF0YSk7IH0sXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyLmdldEFzc2V0KCk7IH0sXG4gICAgICAgIH0pLFxuICAgICAgICBjaGVja3N1bTE2MDogY3JlYXRlVHlwZSh7XG4gICAgICAgICAgICBuYW1lOiAnY2hlY2tzdW0xNjAnLFxuICAgICAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyLCBkYXRhKSB7IGJ1ZmZlci5wdXNoVWludDhBcnJheUNoZWNrZWQoaGV4VG9VaW50OEFycmF5KGRhdGEpLCAyMCk7IH0sXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlcikgeyByZXR1cm4gYXJyYXlUb0hleChidWZmZXIuZ2V0VWludDhBcnJheSgyMCkpOyB9LFxuICAgICAgICB9KSxcbiAgICAgICAgY2hlY2tzdW0yNTY6IGNyZWF0ZVR5cGUoe1xuICAgICAgICAgICAgbmFtZTogJ2NoZWNrc3VtMjU2JyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlciwgZGF0YSkgeyBidWZmZXIucHVzaFVpbnQ4QXJyYXlDaGVja2VkKGhleFRvVWludDhBcnJheShkYXRhKSwgMzIpOyB9LFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIpIHsgcmV0dXJuIGFycmF5VG9IZXgoYnVmZmVyLmdldFVpbnQ4QXJyYXkoMzIpKTsgfSxcbiAgICAgICAgfSksXG4gICAgICAgIGNoZWNrc3VtNTEyOiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICdjaGVja3N1bTUxMicsXG4gICAgICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIsIGRhdGEpIHsgYnVmZmVyLnB1c2hVaW50OEFycmF5Q2hlY2tlZChoZXhUb1VpbnQ4QXJyYXkoZGF0YSksIDY0KTsgfSxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyKSB7IHJldHVybiBhcnJheVRvSGV4KGJ1ZmZlci5nZXRVaW50OEFycmF5KDY0KSk7IH0sXG4gICAgICAgIH0pLFxuICAgICAgICBwdWJsaWNfa2V5OiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICdwdWJsaWNfa2V5JyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKGJ1ZmZlciwgZGF0YSkgeyBidWZmZXIucHVzaFB1YmxpY0tleShkYXRhKTsgfSxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyKSB7IHJldHVybiBidWZmZXIuZ2V0UHVibGljS2V5KCk7IH0sXG4gICAgICAgIH0pLFxuICAgICAgICBwcml2YXRlX2tleTogY3JlYXRlVHlwZSh7XG4gICAgICAgICAgICBuYW1lOiAncHJpdmF0ZV9rZXknLFxuICAgICAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyLCBkYXRhKSB7IGJ1ZmZlci5wdXNoUHJpdmF0ZUtleShkYXRhKTsgfSxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyKSB7IHJldHVybiBidWZmZXIuZ2V0UHJpdmF0ZUtleSgpOyB9LFxuICAgICAgICB9KSxcbiAgICAgICAgc2lnbmF0dXJlOiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6ICdzaWduYXR1cmUnLFxuICAgICAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoYnVmZmVyLCBkYXRhKSB7IGJ1ZmZlci5wdXNoU2lnbmF0dXJlKGRhdGEpOyB9LFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlci5nZXRTaWduYXR1cmUoKTsgfSxcbiAgICAgICAgfSksXG4gICAgfSkpO1xuICAgIHJlc3VsdC5zZXQoJ2V4dGVuZGVkX2Fzc2V0JywgY3JlYXRlVHlwZSh7XG4gICAgICAgIG5hbWU6ICdleHRlbmRlZF9hc3NldCcsXG4gICAgICAgIGJhc2VOYW1lOiAnJyxcbiAgICAgICAgZmllbGRzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICdxdWFudGl0eScsIHR5cGVOYW1lOiAnYXNzZXQnLCB0eXBlOiByZXN1bHQuZ2V0KCdhc3NldCcpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdjb250cmFjdCcsIHR5cGVOYW1lOiAnbmFtZScsIHR5cGU6IHJlc3VsdC5nZXQoJ25hbWUnKSB9LFxuICAgICAgICBdLFxuICAgICAgICBzZXJpYWxpemU6IHNlcmlhbGl6ZVN0cnVjdCxcbiAgICAgICAgZGVzZXJpYWxpemU6IGRlc2VyaWFsaXplU3RydWN0LFxuICAgIH0pKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufSAvLyBjcmVhdGVJbml0aWFsVHlwZXMoKVxuZXhwb3J0cy5jcmVhdGVJbml0aWFsVHlwZXMgPSBjcmVhdGVJbml0aWFsVHlwZXM7XG4vKiogR2V0IHR5cGUgZnJvbSBgdHlwZXNgICovXG5mdW5jdGlvbiBnZXRUeXBlKHR5cGVzLCBuYW1lKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlcy5nZXQobmFtZSk7XG4gICAgaWYgKHR5cGUgJiYgdHlwZS5hbGlhc09mTmFtZSkge1xuICAgICAgICByZXR1cm4gZ2V0VHlwZSh0eXBlcywgdHlwZS5hbGlhc09mTmFtZSk7XG4gICAgfVxuICAgIGlmICh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBpZiAobmFtZS5lbmRzV2l0aCgnW10nKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlVHlwZSh7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgYXJyYXlPZjogZ2V0VHlwZSh0eXBlcywgbmFtZS5zdWJzdHIoMCwgbmFtZS5sZW5ndGggLSAyKSksXG4gICAgICAgICAgICBzZXJpYWxpemU6IHNlcmlhbGl6ZUFycmF5LFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IGRlc2VyaWFsaXplQXJyYXksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobmFtZS5lbmRzV2l0aCgnPycpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBvcHRpb25hbE9mOiBnZXRUeXBlKHR5cGVzLCBuYW1lLnN1YnN0cigwLCBuYW1lLmxlbmd0aCAtIDEpKSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogc2VyaWFsaXplT3B0aW9uYWwsXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZTogZGVzZXJpYWxpemVPcHRpb25hbCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChuYW1lLmVuZHNXaXRoKCckJykpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVR5cGUoe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGV4dGVuc2lvbk9mOiBnZXRUeXBlKHR5cGVzLCBuYW1lLnN1YnN0cigwLCBuYW1lLmxlbmd0aCAtIDEpKSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogc2VyaWFsaXplRXh0ZW5zaW9uLFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IGRlc2VyaWFsaXplRXh0ZW5zaW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBuYW1lKTtcbn1cbmV4cG9ydHMuZ2V0VHlwZSA9IGdldFR5cGU7XG4vKipcbiAqIEdldCB0eXBlcyBmcm9tIGFiaVxuICogQHBhcmFtIGluaXRpYWxUeXBlcyBTZXQgb2YgdHlwZXMgdG8gYnVpbGQgb24uXG4gKiAgICAgSW4gbW9zdCBjYXNlcywgaXQncyBiZXN0IHRvIGZpbGwgdGhpcyBmcm9tIGEgZnJlc2ggY2FsbCB0byBgZ2V0VHlwZXNGcm9tQWJpKClgLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlc0Zyb21BYmkoaW5pdGlhbFR5cGVzLCBhYmkpIHtcbiAgICB2YXIgZV81LCBfYSwgZV82LCBfYiwgZV83LCBfYywgZV84LCBfZCwgZV85LCBfZTtcbiAgICB2YXIgdHlwZXMgPSBuZXcgTWFwKGluaXRpYWxUeXBlcyk7XG4gICAgaWYgKGFiaS50eXBlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2YgPSBfX3ZhbHVlcyhhYmkudHlwZXMpLCBfZyA9IF9mLm5leHQoKTsgIV9nLmRvbmU7IF9nID0gX2YubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9oID0gX2cudmFsdWUsIG5ld190eXBlX25hbWUgPSBfaC5uZXdfdHlwZV9uYW1lLCB0eXBlID0gX2gudHlwZTtcbiAgICAgICAgICAgICAgICB0eXBlcy5zZXQobmV3X3R5cGVfbmFtZSwgY3JlYXRlVHlwZSh7IG5hbWU6IG5ld190eXBlX25hbWUsIGFsaWFzT2ZOYW1lOiB0eXBlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV81XzEpIHsgZV81ID0geyBlcnJvcjogZV81XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9nICYmICFfZy5kb25lICYmIChfYSA9IF9mLnJldHVybikpIF9hLmNhbGwoX2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhYmkuc3RydWN0cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSBfX3ZhbHVlcyhhYmkuc3RydWN0cyksIF9rID0gX2oubmV4dCgpOyAhX2suZG9uZTsgX2sgPSBfai5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2wgPSBfay52YWx1ZSwgbmFtZV8xID0gX2wubmFtZSwgYmFzZSA9IF9sLmJhc2UsIGZpZWxkcyA9IF9sLmZpZWxkcztcbiAgICAgICAgICAgICAgICB0eXBlcy5zZXQobmFtZV8xLCBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZV8xLFxuICAgICAgICAgICAgICAgICAgICBiYXNlTmFtZTogYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzOiBmaWVsZHMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBfYS5uYW1lLCB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoeyBuYW1lOiBuLCB0eXBlTmFtZTogdHlwZSwgdHlwZTogbnVsbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZTogc2VyaWFsaXplU3RydWN0LFxuICAgICAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZTogZGVzZXJpYWxpemVTdHJ1Y3QsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzZfMSkgeyBlXzYgPSB7IGVycm9yOiBlXzZfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2sgJiYgIV9rLmRvbmUgJiYgKF9iID0gX2oucmV0dXJuKSkgX2IuY2FsbChfaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNikgdGhyb3cgZV82LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFiaS52YXJpYW50cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX20gPSBfX3ZhbHVlcyhhYmkudmFyaWFudHMpLCBfbyA9IF9tLm5leHQoKTsgIV9vLmRvbmU7IF9vID0gX20ubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9wID0gX28udmFsdWUsIG5hbWVfMiA9IF9wLm5hbWUsIHQgPSBfcC50eXBlcztcbiAgICAgICAgICAgICAgICB0eXBlcy5zZXQobmFtZV8yLCBjcmVhdGVUeXBlKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZV8yLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IHQubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiAoeyBuYW1lOiBzLCB0eXBlTmFtZTogcywgdHlwZTogbnVsbCB9KTsgfSksXG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZTogc2VyaWFsaXplVmFyaWFudCxcbiAgICAgICAgICAgICAgICAgICAgZGVzZXJpYWxpemU6IGRlc2VyaWFsaXplVmFyaWFudCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfN18xKSB7IGVfNyA9IHsgZXJyb3I6IGVfN18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfbyAmJiAhX28uZG9uZSAmJiAoX2MgPSBfbS5yZXR1cm4pKSBfYy5jYWxsKF9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV83KSB0aHJvdyBlXzcuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciB0eXBlc18xID0gX192YWx1ZXModHlwZXMpLCB0eXBlc18xXzEgPSB0eXBlc18xLm5leHQoKTsgIXR5cGVzXzFfMS5kb25lOyB0eXBlc18xXzEgPSB0eXBlc18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIF9xID0gX19yZWFkKHR5cGVzXzFfMS52YWx1ZSwgMiksIG5hbWVfMyA9IF9xWzBdLCB0eXBlID0gX3FbMV07XG4gICAgICAgICAgICBpZiAodHlwZS5iYXNlTmFtZSkge1xuICAgICAgICAgICAgICAgIHR5cGUuYmFzZSA9IGdldFR5cGUodHlwZXMsIHR5cGUuYmFzZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfciA9IF9fdmFsdWVzKHR5cGUuZmllbGRzKSwgX3MgPSBfci5uZXh0KCk7ICFfcy5kb25lOyBfcyA9IF9yLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBfcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQudHlwZSA9IGdldFR5cGUodHlwZXMsIGZpZWxkLnR5cGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV85XzEpIHsgZV85ID0geyBlcnJvcjogZV85XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zICYmICFfcy5kb25lICYmIChfZSA9IF9yLnJldHVybikpIF9lLmNhbGwoX3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfOSkgdGhyb3cgZV85LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfOF8xKSB7IGVfOCA9IHsgZXJyb3I6IGVfOF8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlc18xXzEgJiYgIXR5cGVzXzFfMS5kb25lICYmIChfZCA9IHR5cGVzXzEucmV0dXJuKSkgX2QuY2FsbCh0eXBlc18xKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfOCkgdGhyb3cgZV84LmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlcztcbn0gLy8gZ2V0VHlwZXNGcm9tQWJpXG5leHBvcnRzLmdldFR5cGVzRnJvbUFiaSA9IGdldFR5cGVzRnJvbUFiaTtcbi8qKiBUQVBvUzogUmV0dXJuIHRyYW5zYWN0aW9uIGZpZWxkcyB3aGljaCByZWZlcmVuY2UgYHJlZkJsb2NrYCBhbmQgZXhwaXJlIGBleHBpcmVTZWNvbmRzYCBhZnRlciBgcmVmQmxvY2sudGltZXN0YW1wYCAqL1xuZnVuY3Rpb24gdHJhbnNhY3Rpb25IZWFkZXIocmVmQmxvY2ssIGV4cGlyZVNlY29uZHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBleHBpcmF0aW9uOiB0aW1lUG9pbnRTZWNUb0RhdGUoZGF0ZVRvVGltZVBvaW50U2VjKHJlZkJsb2NrLnRpbWVzdGFtcCkgKyBleHBpcmVTZWNvbmRzKSxcbiAgICAgICAgcmVmX2Jsb2NrX251bTogcmVmQmxvY2suYmxvY2tfbnVtICYgMHhmZmZmLFxuICAgICAgICByZWZfYmxvY2tfcHJlZml4OiByZWZCbG9jay5yZWZfYmxvY2tfcHJlZml4LFxuICAgIH07XG59XG5leHBvcnRzLnRyYW5zYWN0aW9uSGVhZGVyID0gdHJhbnNhY3Rpb25IZWFkZXI7XG4vKiogQ29udmVydCBhY3Rpb24gZGF0YSB0byBzZXJpYWxpemVkIGZvcm0gKGhleCkgKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUFjdGlvbkRhdGEoY29udHJhY3QsIGFjY291bnQsIG5hbWUsIGRhdGEsIHRleHRFbmNvZGVyLCB0ZXh0RGVjb2Rlcikge1xuICAgIHZhciBhY3Rpb24gPSBjb250cmFjdC5hY3Rpb25zLmdldChuYW1lKTtcbiAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFjdGlvbiBcIiArIG5hbWUgKyBcIiBpbiBjb250cmFjdCBcIiArIGFjY291bnQpO1xuICAgIH1cbiAgICB2YXIgYnVmZmVyID0gbmV3IFNlcmlhbEJ1ZmZlcih7IHRleHRFbmNvZGVyOiB0ZXh0RW5jb2RlciwgdGV4dERlY29kZXI6IHRleHREZWNvZGVyIH0pO1xuICAgIGFjdGlvbi5zZXJpYWxpemUoYnVmZmVyLCBkYXRhKTtcbiAgICByZXR1cm4gYXJyYXlUb0hleChidWZmZXIuYXNVaW50OEFycmF5KCkpO1xufVxuZXhwb3J0cy5zZXJpYWxpemVBY3Rpb25EYXRhID0gc2VyaWFsaXplQWN0aW9uRGF0YTtcbi8qKiBSZXR1cm4gYWN0aW9uIGluIHNlcmlhbGl6ZWQgZm9ybSAqL1xuZnVuY3Rpb24gc2VyaWFsaXplQWN0aW9uKGNvbnRyYWN0LCBhY2NvdW50LCBuYW1lLCBhdXRob3JpemF0aW9uLCBkYXRhLCB0ZXh0RW5jb2RlciwgdGV4dERlY29kZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY2NvdW50OiBhY2NvdW50LFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBhdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uLFxuICAgICAgICBkYXRhOiBzZXJpYWxpemVBY3Rpb25EYXRhKGNvbnRyYWN0LCBhY2NvdW50LCBuYW1lLCBkYXRhLCB0ZXh0RW5jb2RlciwgdGV4dERlY29kZXIpLFxuICAgIH07XG59XG5leHBvcnRzLnNlcmlhbGl6ZUFjdGlvbiA9IHNlcmlhbGl6ZUFjdGlvbjtcbi8qKiBEZXNlcmlhbGl6ZSBhY3Rpb24gZGF0YS4gSWYgYGRhdGFgIGlzIGEgYHN0cmluZ2AsIHRoZW4gaXQncyBhc3N1bWVkIHRvIGJlIGluIGhleC4gKi9cbmZ1bmN0aW9uIGRlc2VyaWFsaXplQWN0aW9uRGF0YShjb250cmFjdCwgYWNjb3VudCwgbmFtZSwgZGF0YSwgdGV4dEVuY29kZXIsIHRleHREZWNvZGVyKSB7XG4gICAgdmFyIGFjdGlvbiA9IGNvbnRyYWN0LmFjdGlvbnMuZ2V0KG5hbWUpO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IGhleFRvVWludDhBcnJheShkYXRhKTtcbiAgICB9XG4gICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBhY3Rpb24gXCIgKyBuYW1lICsgXCIgaW4gY29udHJhY3QgXCIgKyBhY2NvdW50KTtcbiAgICB9XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBTZXJpYWxCdWZmZXIoeyB0ZXh0RGVjb2RlcjogdGV4dERlY29kZXIsIHRleHRFbmNvZGVyOiB0ZXh0RW5jb2RlciB9KTtcbiAgICBidWZmZXIucHVzaEFycmF5KGRhdGEpO1xuICAgIHJldHVybiBhY3Rpb24uZGVzZXJpYWxpemUoYnVmZmVyKTtcbn1cbmV4cG9ydHMuZGVzZXJpYWxpemVBY3Rpb25EYXRhID0gZGVzZXJpYWxpemVBY3Rpb25EYXRhO1xuLyoqIERlc2VyaWFsaXplIGFjdGlvbi4gSWYgYGRhdGFgIGlzIGEgYHN0cmluZ2AsIHRoZW4gaXQncyBhc3N1bWVkIHRvIGJlIGluIGhleC4gKi9cbmZ1bmN0aW9uIGRlc2VyaWFsaXplQWN0aW9uKGNvbnRyYWN0LCBhY2NvdW50LCBuYW1lLCBhdXRob3JpemF0aW9uLCBkYXRhLCB0ZXh0RW5jb2RlciwgdGV4dERlY29kZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY2NvdW50OiBhY2NvdW50LFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBhdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uLFxuICAgICAgICBkYXRhOiBkZXNlcmlhbGl6ZUFjdGlvbkRhdGEoY29udHJhY3QsIGFjY291bnQsIG5hbWUsIGRhdGEsIHRleHRFbmNvZGVyLCB0ZXh0RGVjb2RlciksXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVzZXJpYWxpemVBY3Rpb24gPSBkZXNlcmlhbGl6ZUFjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVvc2pzLXNlcmlhbGl6ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBOdW1lcmljXG4gKi9cbi8vIGNvcHlyaWdodCBkZWZpbmVkIGluIGVvc2pzL0xJQ0VOU0UudHh0XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWQgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciByaXBlbWQxNjAgPSByZXF1aXJlKCcuL3JpcGVtZCcpLlJJUEVNRDE2MC5oYXNoO1xudmFyIGJhc2U1OENoYXJzID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonO1xudmFyIGJhc2U2NENoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuZnVuY3Rpb24gY3JlYXRlX2Jhc2U1OF9tYXAoKSB7XG4gICAgdmFyIGJhc2U1OE0gPSBBcnJheSgyNTYpLmZpbGwoLTEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZTU4Q2hhcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYmFzZTU4TVtiYXNlNThDaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlNThNO1xufVxudmFyIGJhc2U1OE1hcCA9IGNyZWF0ZV9iYXNlNThfbWFwKCk7XG5mdW5jdGlvbiBjcmVhdGVfYmFzZTY0X21hcCgpIHtcbiAgICB2YXIgYmFzZTY0TSA9IEFycmF5KDI1NikuZmlsbCgtMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlNjRDaGFycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBiYXNlNjRNW2Jhc2U2NENoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgICB9XG4gICAgYmFzZTY0TVsnPScuY2hhckNvZGVBdCgwKV0gPSAwO1xuICAgIHJldHVybiBiYXNlNjRNO1xufVxudmFyIGJhc2U2NE1hcCA9IGNyZWF0ZV9iYXNlNjRfbWFwKCk7XG4vKiogSXMgYGJpZ251bWAgYSBuZWdhdGl2ZSBudW1iZXI/ICovXG5mdW5jdGlvbiBpc05lZ2F0aXZlKGJpZ251bSkge1xuICAgIHJldHVybiAoYmlnbnVtW2JpZ251bS5sZW5ndGggLSAxXSAmIDB4ODApICE9PSAwO1xufVxuZXhwb3J0cy5pc05lZ2F0aXZlID0gaXNOZWdhdGl2ZTtcbi8qKiBOZWdhdGUgYGJpZ251bWAgKi9cbmZ1bmN0aW9uIG5lZ2F0ZShiaWdudW0pIHtcbiAgICB2YXIgY2FycnkgPSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmlnbnVtLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB4ID0gKH5iaWdudW1baV0gJiAweGZmKSArIGNhcnJ5O1xuICAgICAgICBiaWdudW1baV0gPSB4O1xuICAgICAgICBjYXJyeSA9IHggPj4gODtcbiAgICB9XG59XG5leHBvcnRzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbi8qKlxuICogQ29udmVydCBhbiB1bnNpZ25lZCBkZWNpbWFsIG51bWJlciBpbiBgc2AgdG8gYSBiaWdudW1cbiAqIEBwYXJhbSBzaXplIGJpZ251bSBzaXplIChieXRlcylcbiAqL1xuZnVuY3Rpb24gZGVjaW1hbFRvQmluYXJ5KHNpemUsIHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzcmNEaWdpdCA9IHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKHNyY0RpZ2l0IDwgJzAnLmNoYXJDb2RlQXQoMCkgfHwgc3JjRGlnaXQgPiAnOScuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYXJyeSA9IHNyY0RpZ2l0IC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2l6ZTsgKytqKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHJlc3VsdFtqXSAqIDEwICsgY2Fycnk7XG4gICAgICAgICAgICByZXN1bHRbal0gPSB4O1xuICAgICAgICAgICAgY2FycnkgPSB4ID4+IDg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhcnJ5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5kZWNpbWFsVG9CaW5hcnkgPSBkZWNpbWFsVG9CaW5hcnk7XG4vKipcbiAqIENvbnZlcnQgYSBzaWduZWQgZGVjaW1hbCBudW1iZXIgaW4gYHNgIHRvIGEgYmlnbnVtXG4gKiBAcGFyYW0gc2l6ZSBiaWdudW0gc2l6ZSAoYnl0ZXMpXG4gKi9cbmZ1bmN0aW9uIHNpZ25lZERlY2ltYWxUb0JpbmFyeShzaXplLCBzKSB7XG4gICAgdmFyIG5lZ2F0aXZlID0gc1swXSA9PT0gJy0nO1xuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBzID0gcy5zdWJzdHIoMSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBkZWNpbWFsVG9CaW5hcnkoc2l6ZSwgcyk7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIG5lZ2F0ZShyZXN1bHQpO1xuICAgICAgICBpZiAoIWlzTmVnYXRpdmUocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgaXMgb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOZWdhdGl2ZShyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIGlzIG91dCBvZiByYW5nZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5zaWduZWREZWNpbWFsVG9CaW5hcnkgPSBzaWduZWREZWNpbWFsVG9CaW5hcnk7XG4vKipcbiAqIENvbnZlcnQgYGJpZ251bWAgdG8gYW4gdW5zaWduZWQgZGVjaW1hbCBudW1iZXJcbiAqIEBwYXJhbSBtaW5EaWdpdHMgMC1wYWQgcmVzdWx0IHRvIHRoaXMgbWFueSBkaWdpdHNcbiAqL1xuZnVuY3Rpb24gYmluYXJ5VG9EZWNpbWFsKGJpZ251bSwgbWluRGlnaXRzKSB7XG4gICAgaWYgKG1pbkRpZ2l0cyA9PT0gdm9pZCAwKSB7IG1pbkRpZ2l0cyA9IDE7IH1cbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkobWluRGlnaXRzKS5maWxsKCcwJy5jaGFyQ29kZUF0KDApKTtcbiAgICBmb3IgKHZhciBpID0gYmlnbnVtLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBjYXJyeSA9IGJpZ251bVtpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXN1bHQubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciB4ID0gKChyZXN1bHRbal0gLSAnMCcuY2hhckNvZGVBdCgwKSkgPDwgOCkgKyBjYXJyeTtcbiAgICAgICAgICAgIHJlc3VsdFtqXSA9ICcwJy5jaGFyQ29kZUF0KDApICsgeCAlIDEwO1xuICAgICAgICAgICAgY2FycnkgPSAoeCAvIDEwKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNhcnJ5KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnMCcuY2hhckNvZGVBdCgwKSArIGNhcnJ5ICUgMTApO1xuICAgICAgICAgICAgY2FycnkgPSAoY2FycnkgLyAxMCkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBfX3NwcmVhZChyZXN1bHQpKTtcbn1cbmV4cG9ydHMuYmluYXJ5VG9EZWNpbWFsID0gYmluYXJ5VG9EZWNpbWFsO1xuLyoqXG4gKiBDb252ZXJ0IGBiaWdudW1gIHRvIGEgc2lnbmVkIGRlY2ltYWwgbnVtYmVyXG4gKiBAcGFyYW0gbWluRGlnaXRzIDAtcGFkIHJlc3VsdCB0byB0aGlzIG1hbnkgZGlnaXRzXG4gKi9cbmZ1bmN0aW9uIHNpZ25lZEJpbmFyeVRvRGVjaW1hbChiaWdudW0sIG1pbkRpZ2l0cykge1xuICAgIGlmIChtaW5EaWdpdHMgPT09IHZvaWQgMCkgeyBtaW5EaWdpdHMgPSAxOyB9XG4gICAgaWYgKGlzTmVnYXRpdmUoYmlnbnVtKSkge1xuICAgICAgICB2YXIgeCA9IGJpZ251bS5zbGljZSgpO1xuICAgICAgICBuZWdhdGUoeCk7XG4gICAgICAgIHJldHVybiAnLScgKyBiaW5hcnlUb0RlY2ltYWwoeCwgbWluRGlnaXRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpbmFyeVRvRGVjaW1hbChiaWdudW0sIG1pbkRpZ2l0cyk7XG59XG5leHBvcnRzLnNpZ25lZEJpbmFyeVRvRGVjaW1hbCA9IHNpZ25lZEJpbmFyeVRvRGVjaW1hbDtcbi8qKlxuICogQ29udmVydCBhbiB1bnNpZ25lZCBiYXNlLTU4IG51bWJlciBpbiBgc2AgdG8gYSBiaWdudW1cbiAqIEBwYXJhbSBzaXplIGJpZ251bSBzaXplIChieXRlcylcbiAqL1xuZnVuY3Rpb24gYmFzZTU4VG9CaW5hcnkoc2l6ZSwgcykge1xuICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNhcnJ5ID0gYmFzZTU4TWFwW3MuY2hhckNvZGVBdChpKV07XG4gICAgICAgIGlmIChjYXJyeSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiYXNlLTU4IHZhbHVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaXplOyArK2opIHtcbiAgICAgICAgICAgIHZhciB4ID0gcmVzdWx0W2pdICogNTggKyBjYXJyeTtcbiAgICAgICAgICAgIHJlc3VsdFtqXSA9IHg7XG4gICAgICAgICAgICBjYXJyeSA9IHggPj4gODtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FycnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFzZS01OCB2YWx1ZSBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQucmV2ZXJzZSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmJhc2U1OFRvQmluYXJ5ID0gYmFzZTU4VG9CaW5hcnk7XG4vKipcbiAqIENvbnZlcnQgYGJpZ251bWAgdG8gYSBiYXNlLTU4IG51bWJlclxuICogQHBhcmFtIG1pbkRpZ2l0cyAwLXBhZCByZXN1bHQgdG8gdGhpcyBtYW55IGRpZ2l0c1xuICovXG5mdW5jdGlvbiBiaW5hcnlUb0Jhc2U1OChiaWdudW0sIG1pbkRpZ2l0cykge1xuICAgIGlmIChtaW5EaWdpdHMgPT09IHZvaWQgMCkgeyBtaW5EaWdpdHMgPSAxOyB9XG4gICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGJpZ251bV8xID0gX192YWx1ZXMoYmlnbnVtKSwgYmlnbnVtXzFfMSA9IGJpZ251bV8xLm5leHQoKTsgIWJpZ251bV8xXzEuZG9uZTsgYmlnbnVtXzFfMSA9IGJpZ251bV8xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGJ5dGUgPSBiaWdudW1fMV8xLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGNhcnJ5ID0gYnl0ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVzdWx0Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSAoYmFzZTU4TWFwW3Jlc3VsdFtqXV0gPDwgOCkgKyBjYXJyeTtcbiAgICAgICAgICAgICAgICByZXN1bHRbal0gPSBiYXNlNThDaGFycy5jaGFyQ29kZUF0KHggJSA1OCk7XG4gICAgICAgICAgICAgICAgY2FycnkgPSAoeCAvIDU4KSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2FycnkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiYXNlNThDaGFycy5jaGFyQ29kZUF0KGNhcnJ5ICUgNTgpKTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IChjYXJyeSAvIDU4KSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChiaWdudW1fMV8xICYmICFiaWdudW1fMV8xLmRvbmUgJiYgKF9hID0gYmlnbnVtXzEucmV0dXJuKSkgX2EuY2FsbChiaWdudW1fMSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBiaWdudW1fMiA9IF9fdmFsdWVzKGJpZ251bSksIGJpZ251bV8yXzEgPSBiaWdudW1fMi5uZXh0KCk7ICFiaWdudW1fMl8xLmRvbmU7IGJpZ251bV8yXzEgPSBiaWdudW1fMi5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBieXRlID0gYmlnbnVtXzJfMS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChieXRlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnMScuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChiaWdudW1fMl8xICYmICFiaWdudW1fMl8xLmRvbmUgJiYgKF9iID0gYmlnbnVtXzIucmV0dXJuKSkgX2IuY2FsbChiaWdudW1fMik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgIH1cbiAgICByZXN1bHQucmV2ZXJzZSgpO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgX19zcHJlYWQocmVzdWx0KSk7XG59XG5leHBvcnRzLmJpbmFyeVRvQmFzZTU4ID0gYmluYXJ5VG9CYXNlNTg7XG4vKiogQ29udmVydCBhbiB1bnNpZ25lZCBiYXNlLTY0IG51bWJlciBpbiBgc2AgdG8gYSBiaWdudW0gKi9cbmZ1bmN0aW9uIGJhc2U2NFRvQmluYXJ5KHMpIHtcbiAgICB2YXIgbGVuID0gcy5sZW5ndGg7XG4gICAgaWYgKChsZW4gJiAzKSA9PT0gMSAmJiBzW2xlbiAtIDFdID09PSAnPScpIHtcbiAgICAgICAgbGVuIC09IDE7XG4gICAgfSAvLyBmYyBhcHBlbmRzIGFuIGV4dHJhICc9J1xuICAgIGlmICgobGVuICYgMykgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYXNlLTY0IHZhbHVlIGlzIG5vdCBwYWRkZWQgY29ycmVjdGx5Jyk7XG4gICAgfVxuICAgIHZhciBncm91cHMgPSBsZW4gPj4gMjtcbiAgICB2YXIgYnl0ZXMgPSBncm91cHMgKiAzO1xuICAgIGlmIChsZW4gPiAwICYmIHNbbGVuIC0gMV0gPT09ICc9Jykge1xuICAgICAgICBpZiAoc1tsZW4gLSAyXSA9PT0gJz0nKSB7XG4gICAgICAgICAgICBieXRlcyAtPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnl0ZXMgLT0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgIGZvciAodmFyIGdyb3VwID0gMDsgZ3JvdXAgPCBncm91cHM7ICsrZ3JvdXApIHtcbiAgICAgICAgdmFyIGRpZ2l0MCA9IGJhc2U2NE1hcFtzLmNoYXJDb2RlQXQoZ3JvdXAgKiA0ICsgMCldO1xuICAgICAgICB2YXIgZGlnaXQxID0gYmFzZTY0TWFwW3MuY2hhckNvZGVBdChncm91cCAqIDQgKyAxKV07XG4gICAgICAgIHZhciBkaWdpdDIgPSBiYXNlNjRNYXBbcy5jaGFyQ29kZUF0KGdyb3VwICogNCArIDIpXTtcbiAgICAgICAgdmFyIGRpZ2l0MyA9IGJhc2U2NE1hcFtzLmNoYXJDb2RlQXQoZ3JvdXAgKiA0ICsgMyldO1xuICAgICAgICByZXN1bHRbZ3JvdXAgKiAzICsgMF0gPSAoZGlnaXQwIDw8IDIpIHwgKGRpZ2l0MSA+PiA0KTtcbiAgICAgICAgaWYgKGdyb3VwICogMyArIDEgPCBieXRlcykge1xuICAgICAgICAgICAgcmVzdWx0W2dyb3VwICogMyArIDFdID0gKChkaWdpdDEgJiAxNSkgPDwgNCkgfCAoZGlnaXQyID4+IDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cCAqIDMgKyAyIDwgYnl0ZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdFtncm91cCAqIDMgKyAyXSA9ICgoZGlnaXQyICYgMykgPDwgNikgfCBkaWdpdDM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuYmFzZTY0VG9CaW5hcnkgPSBiYXNlNjRUb0JpbmFyeTtcbi8qKiBLZXkgdHlwZXMgdGhpcyBsaWJyYXJ5IHN1cHBvcnRzICovXG52YXIgS2V5VHlwZTtcbihmdW5jdGlvbiAoS2V5VHlwZSkge1xuICAgIEtleVR5cGVbS2V5VHlwZVtcImsxXCJdID0gMF0gPSBcImsxXCI7XG4gICAgS2V5VHlwZVtLZXlUeXBlW1wicjFcIl0gPSAxXSA9IFwicjFcIjtcbn0pKEtleVR5cGUgPSBleHBvcnRzLktleVR5cGUgfHwgKGV4cG9ydHMuS2V5VHlwZSA9IHt9KSk7XG4vKiogUHVibGljIGtleSBkYXRhIHNpemUsIGV4Y2x1ZGluZyB0eXBlIGZpZWxkICovXG5leHBvcnRzLnB1YmxpY0tleURhdGFTaXplID0gMzM7XG4vKiogUHJpdmF0ZSBrZXkgZGF0YSBzaXplLCBleGNsdWRpbmcgdHlwZSBmaWVsZCAqL1xuZXhwb3J0cy5wcml2YXRlS2V5RGF0YVNpemUgPSAzMjtcbi8qKiBTaWduYXR1cmUgZGF0YSBzaXplLCBleGNsdWRpbmcgdHlwZSBmaWVsZCAqL1xuZXhwb3J0cy5zaWduYXR1cmVEYXRhU2l6ZSA9IDY1O1xuZnVuY3Rpb24gZGlnZXN0U3VmZml4UmlwZW1kMTYwKGRhdGEsIHN1ZmZpeCkge1xuICAgIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBzdWZmaXgubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZFtpXSA9IGRhdGFbaV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VmZml4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGRbZGF0YS5sZW5ndGggKyBpXSA9IHN1ZmZpeC5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmlwZW1kMTYwKGQpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9LZXkocywgdHlwZSwgc2l6ZSwgc3VmZml4KSB7XG4gICAgdmFyIHdob2xlID0gYmFzZTU4VG9CaW5hcnkoc2l6ZSArIDQsIHMpO1xuICAgIHZhciByZXN1bHQgPSB7IHR5cGU6IHR5cGUsIGRhdGE6IG5ldyBVaW50OEFycmF5KHdob2xlLmJ1ZmZlciwgMCwgc2l6ZSkgfTtcbiAgICB2YXIgZGlnZXN0ID0gbmV3IFVpbnQ4QXJyYXkoZGlnZXN0U3VmZml4UmlwZW1kMTYwKHJlc3VsdC5kYXRhLCBzdWZmaXgpKTtcbiAgICBpZiAoZGlnZXN0WzBdICE9PSB3aG9sZVtzaXplICsgMF0gfHwgZGlnZXN0WzFdICE9PSB3aG9sZVtzaXplICsgMV1cbiAgICAgICAgfHwgZGlnZXN0WzJdICE9PSB3aG9sZVtzaXplICsgMl0gfHwgZGlnZXN0WzNdICE9PSB3aG9sZVtzaXplICsgM10pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bSBkb2VzblxcJ3QgbWF0Y2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGtleVRvU3RyaW5nKGtleSwgc3VmZml4LCBwcmVmaXgpIHtcbiAgICB2YXIgZGlnZXN0ID0gbmV3IFVpbnQ4QXJyYXkoZGlnZXN0U3VmZml4UmlwZW1kMTYwKGtleS5kYXRhLCBzdWZmaXgpKTtcbiAgICB2YXIgd2hvbGUgPSBuZXcgVWludDhBcnJheShrZXkuZGF0YS5sZW5ndGggKyA0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHdob2xlW2ldID0ga2V5LmRhdGFbaV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgIHdob2xlW2kgKyBrZXkuZGF0YS5sZW5ndGhdID0gZGlnZXN0W2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJlZml4ICsgYmluYXJ5VG9CYXNlNTgod2hvbGUpO1xufVxuLyoqIENvbnZlcnQga2V5IGluIGBzYCB0byBiaW5hcnkgZm9ybSAqL1xuZnVuY3Rpb24gc3RyaW5nVG9QdWJsaWNLZXkocykge1xuICAgIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgY29udGFpbmluZyBwdWJsaWMga2V5Jyk7XG4gICAgfVxuICAgIGlmIChzLnN1YnN0cigwLCAzKSA9PT0gJ0VPUycpIHtcbiAgICAgICAgdmFyIHdob2xlID0gYmFzZTU4VG9CaW5hcnkoZXhwb3J0cy5wdWJsaWNLZXlEYXRhU2l6ZSArIDQsIHMuc3Vic3RyKDMpKTtcbiAgICAgICAgdmFyIGtleSA9IHsgdHlwZTogS2V5VHlwZS5rMSwgZGF0YTogbmV3IFVpbnQ4QXJyYXkoZXhwb3J0cy5wdWJsaWNLZXlEYXRhU2l6ZSkgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBvcnRzLnB1YmxpY0tleURhdGFTaXplOyArK2kpIHtcbiAgICAgICAgICAgIGtleS5kYXRhW2ldID0gd2hvbGVbaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpZ2VzdCA9IG5ldyBVaW50OEFycmF5KHJpcGVtZDE2MChrZXkuZGF0YSkpO1xuICAgICAgICBpZiAoZGlnZXN0WzBdICE9PSB3aG9sZVtleHBvcnRzLnB1YmxpY0tleURhdGFTaXplXSB8fCBkaWdlc3RbMV0gIT09IHdob2xlWzM0XVxuICAgICAgICAgICAgfHwgZGlnZXN0WzJdICE9PSB3aG9sZVszNV0gfHwgZGlnZXN0WzNdICE9PSB3aG9sZVszNl0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0gZG9lc25cXCd0IG1hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgZWxzZSBpZiAocy5zdWJzdHIoMCwgNykgPT09ICdQVUJfSzFfJykge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9LZXkocy5zdWJzdHIoNyksIEtleVR5cGUuazEsIGV4cG9ydHMucHVibGljS2V5RGF0YVNpemUsICdLMScpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzLnN1YnN0cigwLCA3KSA9PT0gJ1BVQl9SMV8nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0tleShzLnN1YnN0cig3KSwgS2V5VHlwZS5yMSwgZXhwb3J0cy5wdWJsaWNLZXlEYXRhU2l6ZSwgJ1IxJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBwdWJsaWMga2V5IGZvcm1hdCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuc3RyaW5nVG9QdWJsaWNLZXkgPSBzdHJpbmdUb1B1YmxpY0tleTtcbi8qKiBDb252ZXJ0IGBrZXlgIHRvIHN0cmluZyAoYmFzZS01OCkgZm9ybSAqL1xuZnVuY3Rpb24gcHVibGljS2V5VG9TdHJpbmcoa2V5KSB7XG4gICAgaWYgKGtleS50eXBlID09PSBLZXlUeXBlLmsxICYmIGtleS5kYXRhLmxlbmd0aCA9PT0gZXhwb3J0cy5wdWJsaWNLZXlEYXRhU2l6ZSkge1xuICAgICAgICByZXR1cm4ga2V5VG9TdHJpbmcoa2V5LCAnSzEnLCAnUFVCX0sxXycpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXkudHlwZSA9PT0gS2V5VHlwZS5yMSAmJiBrZXkuZGF0YS5sZW5ndGggPT09IGV4cG9ydHMucHVibGljS2V5RGF0YVNpemUpIHtcbiAgICAgICAgcmV0dXJuIGtleVRvU3RyaW5nKGtleSwgJ1IxJywgJ1BVQl9SMV8nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHB1YmxpYyBrZXkgZm9ybWF0Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5wdWJsaWNLZXlUb1N0cmluZyA9IHB1YmxpY0tleVRvU3RyaW5nO1xuLyoqIElmIGEga2V5IGlzIGluIHRoZSBsZWdhY3kgZm9ybWF0IChgRU9TYCBwcmVmaXgpLCB0aGVuIGNvbnZlcnQgaXQgdG8gdGhlIG5ldyBmb3JtYXQgKGBQVUJfSzFfYCkuXG4gKiBMZWF2ZXMgb3RoZXIgZm9ybWF0cyB1bnRvdWNoZWRcbiAqL1xuZnVuY3Rpb24gY29udmVydExlZ2FjeVB1YmxpY0tleShzKSB7XG4gICAgaWYgKHMuc3Vic3RyKDAsIDMpID09PSAnRU9TJykge1xuICAgICAgICByZXR1cm4gcHVibGljS2V5VG9TdHJpbmcoc3RyaW5nVG9QdWJsaWNLZXkocykpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmV4cG9ydHMuY29udmVydExlZ2FjeVB1YmxpY0tleSA9IGNvbnZlcnRMZWdhY3lQdWJsaWNLZXk7XG4vKiogSWYgYSBrZXkgaXMgaW4gdGhlIGxlZ2FjeSBmb3JtYXQgKGBFT1NgIHByZWZpeCksIHRoZW4gY29udmVydCBpdCB0byB0aGUgbmV3IGZvcm1hdCAoYFBVQl9LMV9gKS5cbiAqIExlYXZlcyBvdGhlciBmb3JtYXRzIHVudG91Y2hlZFxuICovXG5mdW5jdGlvbiBjb252ZXJ0TGVnYWN5UHVibGljS2V5cyhrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMubWFwKGNvbnZlcnRMZWdhY3lQdWJsaWNLZXkpO1xufVxuZXhwb3J0cy5jb252ZXJ0TGVnYWN5UHVibGljS2V5cyA9IGNvbnZlcnRMZWdhY3lQdWJsaWNLZXlzO1xuLyoqIENvbnZlcnQga2V5IGluIGBzYCB0byBiaW5hcnkgZm9ybSAqL1xuZnVuY3Rpb24gc3RyaW5nVG9Qcml2YXRlS2V5KHMpIHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgc3RyaW5nIGNvbnRhaW5pbmcgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgaWYgKHMuc3Vic3RyKDAsIDcpID09PSAnUFZUX1IxXycpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvS2V5KHMuc3Vic3RyKDcpLCBLZXlUeXBlLnIxLCBleHBvcnRzLnByaXZhdGVLZXlEYXRhU2l6ZSwgJ1IxJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBwcml2YXRlIGtleSBmb3JtYXQnKTtcbiAgICB9XG59XG5leHBvcnRzLnN0cmluZ1RvUHJpdmF0ZUtleSA9IHN0cmluZ1RvUHJpdmF0ZUtleTtcbi8qKiBDb252ZXJ0IGBrZXlgIHRvIHN0cmluZyAoYmFzZS01OCkgZm9ybSAqL1xuZnVuY3Rpb24gcHJpdmF0ZUtleVRvU3RyaW5nKGtleSkge1xuICAgIGlmIChrZXkudHlwZSA9PT0gS2V5VHlwZS5yMSkge1xuICAgICAgICByZXR1cm4ga2V5VG9TdHJpbmcoa2V5LCAnUjEnLCAnUFZUX1IxXycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgcHJpdmF0ZSBrZXkgZm9ybWF0Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5wcml2YXRlS2V5VG9TdHJpbmcgPSBwcml2YXRlS2V5VG9TdHJpbmc7XG4vKiogQ29udmVydCBrZXkgaW4gYHNgIHRvIGJpbmFyeSBmb3JtICovXG5mdW5jdGlvbiBzdHJpbmdUb1NpZ25hdHVyZShzKSB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBjb250YWluaW5nIHNpZ25hdHVyZScpO1xuICAgIH1cbiAgICBpZiAocy5zdWJzdHIoMCwgNykgPT09ICdTSUdfSzFfJykge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9LZXkocy5zdWJzdHIoNyksIEtleVR5cGUuazEsIGV4cG9ydHMuc2lnbmF0dXJlRGF0YVNpemUsICdLMScpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzLnN1YnN0cigwLCA3KSA9PT0gJ1NJR19SMV8nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0tleShzLnN1YnN0cig3KSwgS2V5VHlwZS5yMSwgZXhwb3J0cy5zaWduYXR1cmVEYXRhU2l6ZSwgJ1IxJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBzaWduYXR1cmUgZm9ybWF0Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5zdHJpbmdUb1NpZ25hdHVyZSA9IHN0cmluZ1RvU2lnbmF0dXJlO1xuLyoqIENvbnZlcnQgYHNpZ25hdHVyZWAgdG8gc3RyaW5nIChiYXNlLTU4KSBmb3JtICovXG5mdW5jdGlvbiBzaWduYXR1cmVUb1N0cmluZyhzaWduYXR1cmUpIHtcbiAgICBpZiAoc2lnbmF0dXJlLnR5cGUgPT09IEtleVR5cGUuazEpIHtcbiAgICAgICAgcmV0dXJuIGtleVRvU3RyaW5nKHNpZ25hdHVyZSwgJ0sxJywgJ1NJR19LMV8nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2lnbmF0dXJlLnR5cGUgPT09IEtleVR5cGUucjEpIHtcbiAgICAgICAgcmV0dXJuIGtleVRvU3RyaW5nKHNpZ25hdHVyZSwgJ1IxJywgJ1NJR19SMV8nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHNpZ25hdHVyZSBmb3JtYXQnKTtcbiAgICB9XG59XG5leHBvcnRzLnNpZ25hdHVyZVRvU3RyaW5nID0gc2lnbmF0dXJlVG9TdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lb3Nqcy1udW1lcmljLmpzLm1hcCIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWJ1c2VyY29udGVudC5jb20vd2x6bGEwMDAvYmFjODNkZjZkM2M1MTkxNmM0ZGQwYmM5NDdlNDY5NDcvcmF3LzdlZTM0NjJiMDk1YWIyMjU4MGRkYWYxOTFmNDRhNTkwZGE2ZmUzM2IvUklQRU1ELTE2MC5qc1xuXG4vKlxuXHRSSVBFTUQtMTYwLmpzXG5cblx0XHRkZXZlbG9wZWRcblx0XHRcdGJ5IEsuIChodHRwczovL2dpdGh1Yi5jb20vd2x6bGEwMDApXG5cdFx0XHRvbiBEZWNlbWJlciAyNy0yOSwgMjAxNyxcblxuXHRcdGxpY2Vuc2VkIHVuZGVyXG5cblxuXHRcdHRoZSBNSVQgbGljZW5zZVxuXG5cdFx0Q29weXJpZ2h0IChjKSAyMDE3IEsuXG5cblx0XHQgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cblx0XHRvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuXHRcdGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuXHRcdHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuXHRcdGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuXHRcdHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG5cdFx0U29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcblx0XHRjb25kaXRpb25zOlxuXG5cdFx0IFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5cdFx0aW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblx0XHQgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcblx0XHRFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcblx0XHRPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuXHRcdE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG5cdFx0SE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG5cdFx0V0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG5cdFx0RlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuXHRcdE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBSSVBFTUQxNjAgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIFJJUEVNRDE2MCgpIHtcblx0XHQvLyBodHRwczovL3dlYmNhY2hlLmdvb2dsZXVzZXJjb250ZW50LmNvbS9zZWFyY2g/cT1jYWNoZTpDbkxPZ29sVEhZRUo6aHR0cHM6Ly93d3cuY29zaWMuZXNhdC5rdWxldXZlbi5iZS9wdWJsaWNhdGlvbnMvYXJ0aWNsZS0zMTcucGRmXG5cdFx0Ly8gaHR0cDovL3Nob2RoZ2FuZ2EuaW5mbGlibmV0LmFjLmluL2JpdHN0cmVhbS8xMDYwMy8yMjk3OC8xMy8xM19hcHBlbmRpeC5wZGZcblxuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSSVBFTUQxNjApO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKFJJUEVNRDE2MCwgbnVsbCwgW3tcblx0XHRrZXk6IFwiZ2V0X25fcGFkX2J5dGVzXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldF9uX3BhZF9ieXRlcyhtZXNzYWdlX3NpemUgLyogaW4gYnl0ZXMsIDEgYnl0ZSBpcyA4IGJpdHMuICovKSB7XG5cdFx0XHQvLyAgT2J0YWluIHRoZSBudW1iZXIgb2YgYnl0ZXMgbmVlZGVkIHRvIHBhZCB0aGUgbWVzc2FnZS5cblx0XHRcdC8vIEl0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNpemUgb2YgdGhlIG1lc3NhZ2Ugc2l6ZSBpbmZvcm1hdGlvbi5cblx0XHRcdC8qXG4gICBcdGh0dHBzOi8vd2ViY2FjaGUuZ29vZ2xldXNlcmNvbnRlbnQuY29tL3NlYXJjaD9xPWNhY2hlOkNuTE9nb2xUSFlFSjpodHRwczovL3d3dy5jb3NpYy5lc2F0Lmt1bGV1dmVuLmJlL3B1YmxpY2F0aW9ucy9hcnRpY2xlLTMxNy5wZGZcbiAgIFx0XHRUaGUgQ3J5cHRvZ3JhcGhpYyBIYXNoIEZ1bmN0aW9uIFJJUEVNRC0xNjBcbiAgIFx0XHR3cml0dGVuIGJ5XG4gICBcdFx0QmFydCBQcmVuZWVsLFxuICAgXHRcdEhhbnMgRG9iYmVydGluLFxuICAgXHRcdEFudG9vbiBCb3NzZWxhZXJzXG4gICBcdGluXG4gICBcdFx0MTk5Ny5cbiAgIFx0XHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgXHRcdMKnNSAgICAgRGVzY3JpcHRpb24gb2YgUklQRU1ELTE2MFxuICAgXHRcdC4uLi4uLlxuICAgXHRcdCBJbiBvcmRlciB0byBndWFyYW50ZWUgdGhhdCB0aGUgdG90YWwgaW5wdXQgc2l6ZSBpcyBhXG4gICBcdG11bHRpcGxlIG9mIDUxMiBiaXRzLCB0aGUgaW5wdXQgaXMgcGFkZGVkIGluIHRoZSBzYW1lXG4gICBcdHdheSBhcyBmb3IgYWxsIHRoZSBtZW1iZXJzIG9mIHRoZSBNRDQtZmFtaWx5OiBvbmVcbiAgIFx0YXBwZW5kcyBhIHNpbmdsZSAxIGZvbGxvd2VkIGJ5IGEgc3RyaW5nIG9mIDBzICh0aGVcbiAgIFx0bnVtYmVyIG9mIDBzIGxpZXMgYmV0d2VlbiAwIGFuZCA1MTEpOyB0aGUgbGFzdCA2NCBiaXRzXG4gICBcdG9mIHRoZSBleHRlbmRlZCBpbnB1dCBjb250YWluIHRoZSBiaW5hcnkgcmVwcmVzZW50YXRpb25cbiAgIFx0b2YgdGhlIGlucHV0IHNpemUgaW4gYml0cywgbGVhc3Qgc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdC5cbiAgICovXG5cdFx0XHQvKlxuICAgXHRodHRwczovL3Rvb2xzLmlldGYub3JnL3JmYy9yZmMxMTg2LnR4dFxuICAgXHRcdFJGQyAxMTg2OiBNRDQgTWVzc2FnZSBEaWdlc3QgQWxnb3JpdGhtLlxuICAgXHRcdHdyaXR0ZW4gYnlcbiAgIFx0XHRSb25hbGQgTGlubiBSaXZlc3RcbiAgIFx0aW5cbiAgIFx0XHRPY3RvYmVyIDE5OTAuXG4gICBcdFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgIFx0XHTCpzMgICAgIE1ENCBBbGdvcml0aG0gRGVzY3JpcHRpb25cbiAgIFx0XHQuLi4uLi5cbiAgIFx0XHRTdGVwIDEuIEFwcGVuZCBwYWRkaW5nIGJpdHNcbiAgIFx0XHQgVGhlIG1lc3NhZ2UgaXMgXCJwYWRkZWRcIiAoZXh0ZW5kZWQpIHNvIHRoYXQgaXRzIGxlbmd0aFxuICAgXHQoaW4gYml0cykgaXMgY29uZ3J1ZW50IHRvIDQ0OCwgbW9kdWxvIDUxMi4gVGhhdCBpcywgdGhlXG4gICBcdG1lc3NhZ2UgaXMgZXh0ZW5kZWQgc28gdGhhdCBpdCBpcyBqdXN0IDY0IGJpdHMgc2h5IG9mXG4gICBcdGJlaW5nIGEgbXVsdGlwbGUgb2YgNTEyIGJpdHMgbG9uZy4gUGFkZGluZyBpcyBhbHdheXNcbiAgIFx0cGVyZm9ybWVkLCBldmVuIGlmIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2UgaXMgYWxyZWFkeVxuICAgXHRjb25ncnVlbnQgdG8gNDQ4LCBtb2R1bG8gNTEyIChpbiB3aGljaCBjYXNlIDUxMiBiaXRzIG9mXG4gICBcdHBhZGRpbmcgYXJlIGFkZGVkKS5cbiAgIFx0XHQgUGFkZGluZyBpcyBwZXJmb3JtZWQgYXMgZm9sbG93czogYSBzaW5nbGUgXCIxXCIgYml0IGlzXG4gICBcdGFwcGVuZGVkIHRvIHRoZSBtZXNzYWdlLCBhbmQgdGhlbiBlbm91Z2ggemVybyBiaXRzIGFyZVxuICAgXHRhcHBlbmRlZCBzbyB0aGF0IHRoZSBsZW5ndGggaW4gYml0cyBvZiB0aGUgcGFkZGVkXG4gICBcdG1lc3NhZ2UgYmVjb21lcyBjb25ncnVlbnQgdG8gNDQ4LCBtb2R1bG8gNTEyLlxuICAgXHRcdFN0ZXAgMi4gQXBwZW5kIGxlbmd0aFxuICAgXHRcdCBBIDY0LWJpdCByZXByZXNlbnRhdGlvbiBvZiBiICh0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlXG4gICBcdGJlZm9yZSB0aGUgcGFkZGluZyBiaXRzIHdlcmUgYWRkZWQpIGlzIGFwcGVuZGVkIHRvIHRoZVxuICAgXHRyZXN1bHQgb2YgdGhlIHByZXZpb3VzIHN0ZXAuIEluIHRoZSB1bmxpa2VseSBldmVudCB0aGF0XG4gICBcdGIgaXMgZ3JlYXRlciB0aGFuIDJeNjQsIHRoZW4gb25seSB0aGUgbG93LW9yZGVyIDY0IGJpdHNcbiAgIFx0b2YgYiBhcmUgdXNlZC4gKFRoZXNlIGJpdHMgYXJlIGFwcGVuZGVkIGFzIHR3byAzMi1iaXRcbiAgIFx0d29yZHMgYW5kIGFwcGVuZGVkIGxvdy1vcmRlciB3b3JkIGZpcnN0IGluIGFjY29yZGFuY2VcbiAgIFx0d2l0aCB0aGUgcHJldmlvdXMgY29udmVudGlvbnMuKVxuICAgXHRcdCBBdCB0aGlzIHBvaW50IHRoZSByZXN1bHRpbmcgbWVzc2FnZSAoYWZ0ZXIgcGFkZGluZyB3aXRoXG4gICBcdGJpdHMgYW5kIHdpdGggYikgaGFzIGEgbGVuZ3RoIHRoYXQgaXMgYW4gZXhhY3QgbXVsdGlwbGVcbiAgIFx0b2YgNTEyIGJpdHMuIEVxdWl2YWxlbnRseSwgdGhpcyBtZXNzYWdlIGhhcyBhIGxlbmd0aFxuICAgXHR0aGF0IGlzIGFuIGV4YWN0IG11bHRpcGxlIG9mIDE2ICgzMi1iaXQpIHdvcmRzLiBMZXRcbiAgIFx0TVswIC4uLiBOLTFdIGRlbm90ZSB0aGUgd29yZHMgb2YgdGhlIHJlc3VsdGluZyBtZXNzYWdlLFxuICAgXHR3aGVyZSBOIGlzIGEgbXVsdGlwbGUgb2YgMTYuXG4gICAqL1xuXHRcdFx0Ly8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS8zMjQwNy81NDU2OFxuXHRcdFx0LypcbiAgIFx0RXhhbXBsZSBjYXNlICAjIDFcbiAgIFx0XHRbMCBiaXQ6IG1lc3NhZ2UuXVxuICAgXHRcdFsxIGJpdDogMS5dXG4gICBcdFx0WzQ0NyBiaXRzOiAwLl1cbiAgIFx0XHRbNjQgYml0czogbWVzc2FnZSBzaXplIGluZm9ybWF0aW9uLl1cbiAgIFx0XHRFeGFtcGxlIGNhc2UgICMgMlxuICAgXHRcdFs1MTItYml0czogbWVzc2FnZV1cbiAgIFx0XHRbMSBiaXQ6IDEuXVxuICAgXHRcdFs0NDcgYml0czogMC5dXG4gICBcdFx0WzY0IGJpdHM6IG1lc3NhZ2Ugc2l6ZSBpbmZvcm1hdGlvbi5dXG4gICBcdFx0RXhhbXBsZSBjYXNlICAjIDNcbiAgIFx0XHRbKDUxMiAtIDY0ID0gNDQ4KSBiaXRzOiBtZXNzYWdlLl1cbiAgIFx0XHRbMSBiaXQ6IDEuXVxuICAgXHRcdFs1MTEgYml0czogMC5dXG4gICBcdFx0WzY0IGJpdHM6IG1lc3NhZ2Ugc2l6ZSBpbmZvcm1hdGlvbi5dXG4gICBcdFx0RXhhbXBsZSBjYXNlICAjIDRcbiAgIFx0XHRbKDUxMiAtIDY1ID0gNDQ3KSBiaXRzOiBtZXNzYWdlLl1cbiAgIFx0XHRbMSBiaXQ6IDEuXVxuICAgXHRcdFswIGJpdDogMC5dXG4gICBcdFx0WzY0IGJpdHM6IG1lc3NhZ2Ugc2l6ZSBpbmZvcm1hdGlvbi5dXG4gICAqL1xuXHRcdFx0Ly8gVGhlIG51bWJlciBvZiBwYWRkaW5nIHplcm8gYml0czpcblx0XHRcdC8vICAgICAgNTExIC0gW3sobWVzc2FnZSBzaXplIGluIGJpdHMpICsgNjR9IChtb2QgNTEyKV1cblx0XHRcdHJldHVybiA2NCAtIChtZXNzYWdlX3NpemUgKyA4ICYgNjMgLyogNjMgKi8pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogXCJwYWRcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gcGFkKG1lc3NhZ2UgLyogQW4gQXJyYXlCdWZmZXIuICovKSB7XG5cdFx0XHR2YXIgbWVzc2FnZV9zaXplID0gbWVzc2FnZS5ieXRlTGVuZ3RoO1xuXHRcdFx0dmFyIG5fcGFkID0gUklQRU1EMTYwLmdldF9uX3BhZF9ieXRlcyhtZXNzYWdlX3NpemUpO1xuXG5cdFx0XHQvLyAgYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYCBpcyAoKDIgKiogNTMpIC0gMSkgYW5kXG5cdFx0XHQvLyBiaXR3aXNlIG9wZXJhdGlvbiBpbiBKYXZhc2NyaXB0IGlzIGRvbmUgb24gMzItYml0cyBvcGVyYW5kcy5cblx0XHRcdHZhciBkaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QoZGl2aWRlbmQsIGRpdmlzb3IpIHtcblx0XHRcdFx0cmV0dXJuIFtNYXRoLmZsb29yKGRpdmlkZW5kIC8gZGl2aXNvciksIGRpdmlkZW5kICUgZGl2aXNvcl07XG5cdFx0XHR9O1xuXHRcdFx0LypcbiAgIFRvIHNoaWZ0XG4gICAgIDAwMDAwMDAwIDAwMD8/Pz8/ID8/Pz8/Pz8/ID8/Pz8/Pz8/ID8/Pz8/Pz8/ID8/Pz8/Pz8/ID8/Pz8/Pz8/ID8/Pz8/Pz8/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgb1xuICAgIDAwMDAwMDAwID8/Pz8/Pz8/ID8/Pz8/Pz8/ID8/Pz8/Pz8/ID8/Pz8/Pz8/ID8/Pz8/Pz8/ID8/Pz8/Pz8/ID8/Pz8/MDAwXG4gICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgTWV0aG9kICMxXG4gICAgICAwMDAwMDAwMCAwMDA/Pz8/PyA/Pz8/Pz8/PyA/Pz8/Pz8/PyAgPz8/Pz8/Pz8gPz8/Pz8/Pz8gPz8/Pz8/Pz8gPz8/Pz8/Pz9cbiAgICBbMDAwMDAwMDAgMDAwQUFBQUEgQUFBQUFBQUEgQUFBQUFBQUFdICg8QT4gY2FwdHVyZWQpXG4gICAgWzAwMDAwMDAwIEFBQUFBQUFBIEFBQUFBQUFBIEFBQUFBMDAwXSAoPEE+IHNoaWZ0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICg8Qj4gY2FwdHVyZWQpIFtCQkJCQkJCQiBCQkJCQkJCQiBCQkJCQkJCQiBCQkJCQkJCQl1cbiAgICAgICAgICAgICAgICAgICAgICAoPEI+IHNoaWZ0ZWQpIFtCQkJdW0JCQkJCQkJCIEJCQkJCQkJCIEJCQkJCQkJCIEJCQkJCMDAwXVxuICAgIFswMDAwMDAwMCBBQUFBQUFBQSBBQUFBQUFBQSBBQUFBQUJCQl0gKDxBPiAmIDxCXzI+IG1lcmdlZClcbiAgICBbMDAwMDAwMDAgQUFBQUFBQUEgQUFBQUFBQUEgQUFBQUFCQkJdW0JCQkJCQkJCIEJCQkJCQkJCIEJCQkJCQkJCIEJCQkJCMDAwXVxuICAgICAwMDAwMDAwMCA/Pz8/Pz8/PyA/Pz8/Pz8/PyA/Pz8/Pz8/PyAgPz8/Pz8/Pz8gPz8/Pz8/Pz8gPz8/Pz8/Pz8gPz8/Pz8wMDBcbiAgIFx0Y29uc3QgdWludDMyX21heF9wbHVzXzEgPSAweDEwMDAwMDAwMDsgLy8gKDIgKiogMzIpXG4gICBjb25zdCBbXG4gICBcdG1zZ19ieXRlX3NpemVfbW9zdCwgLy8gVmFsdWUgcmFuZ2UgWzAsICgyICoqIDIxKSAtIDFdLlxuICAgXHRtc2dfYnl0ZV9zaXplX2xlYXN0IC8vIFZhbHVlIHJhbmdlIFswLCAoMiAqKiAzMikgLSAxXS5cbiAgIF0gPSBkaXZtb2QobWVzc2FnZV9zaXplLCB1aW50MzJfbWF4X3BsdXNfMSk7XG4gICBjb25zdCBbXG4gICBcdGNhcnJ5LCAvLyBWYWx1ZSByYW5nZSBbMCwgN10uXG4gICBcdG1zZ19iaXRfc2l6ZV9sZWFzdCAvLyBWYWx1ZSByYW5nZSBbMCwgKDIgKiogMzIpIC0gOF0uXG4gICBdID0gZGl2bW9kKG1lc3NhZ2VfYnl0ZV9zaXplX2xlYXN0ICogOCwgdWludDMyX21heF9wbHVzXzEpO1xuICAgY29uc3QgbWVzc2FnZV9iaXRfc2l6ZV9tb3N0ID0gbWVzc2FnZV9ieXRlX3NpemVfbW9zdCAqIDhcbiAgIFx0KyBjYXJyeTsgLy8gVmFsdWUgcmFuZ2UgWzAsICgyICoqIDI0KSAtIDFdLlxuICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgIE1ldGhvZCAjMlxuICAgICAwMDAwMDAwMCAwMDA/Pz8/PyA/Pz8/Pz8/PyA/Pz8/Pz8/PyAgPz8/Pz8/Pz8gPz8/Pz8/Pz8gPz8/Pz8/Pz8gPz8/Pz8/Pz9cbiAgICAgICBbMDAwMDAgMDAwQUFBQUEgQUFBQUFBQUEgQUFBQUFBQUEgIEFBQV0gKDxBPiBjYXB0dXJlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKDxCPiBjYXB0dXJlZCkgWzAwMEJCQkJCIEJCQkJCQkJCIEJCQkJCQkJCIEJCQkJCQkJCXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKDxCPiBzaGlmdGVkKSBbQkJCQkJCQkIgQkJCQkJCQkIgQkJCQkJCQkIgQkJCQkIwMDBdXG4gICAgWzAwMDAwMDAwIEFBQUFBQUFBIEFBQUFBQUFBIEFBQUFBQUFBXVtCQkJCQkJCQiBCQkJCQkJCQiBCQkJCQkJCQiBCQkJCQjAwMF1cbiAgICAgMDAwMDAwMDAgPz8/Pz8/Pz8gPz8/Pz8/Pz8gPz8/Pz8/Pz8gID8/Pz8/Pz8/ID8/Pz8/Pz8/ID8/Pz8/Pz8/ID8/Pz8/MDAwXG4gICBcdCovXG5cblx0XHRcdHZhciBfZGl2bW9kJG1hcCA9IGRpdm1vZChtZXNzYWdlX3NpemUsIDUzNjg3MDkxMiAvKiAoMiAqKiAyOSkgKi8pLm1hcChmdW5jdGlvbiAoeCwgaW5kZXgpIHtcblx0XHRcdFx0cmV0dXJuIGluZGV4ID8geCAqIDggOiB4O1xuXHRcdFx0fSksXG5cdFx0XHQgICAgX2Rpdm1vZCRtYXAyID0gX3NsaWNlZFRvQXJyYXkoX2Rpdm1vZCRtYXAsIDIpLFxuXHRcdFx0ICAgIG1zZ19iaXRfc2l6ZV9tb3N0ID0gX2Rpdm1vZCRtYXAyWzBdLFxuXHRcdFx0ICAgIG1zZ19iaXRfc2l6ZV9sZWFzdCA9IF9kaXZtb2QkbWFwMlsxXTtcblxuXHRcdFx0Ly8gYEFycmF5QnVmZmVyLnRyYW5zZmVyKClgIGlzIG5vdCBzdXBwb3J0ZWQuXG5cblxuXHRcdFx0dmFyIHBhZGRlZCA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2Vfc2l6ZSArIG5fcGFkICsgOCk7XG5cdFx0XHRwYWRkZWQuc2V0KG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpLCAwKTtcblx0XHRcdHZhciBkYXRhX3ZpZXcgPSBuZXcgRGF0YVZpZXcocGFkZGVkLmJ1ZmZlcik7XG5cdFx0XHRkYXRhX3ZpZXcuc2V0VWludDgobWVzc2FnZV9zaXplLCAxMjgpO1xuXHRcdFx0ZGF0YV92aWV3LnNldFVpbnQzMihtZXNzYWdlX3NpemUgKyBuX3BhZCwgbXNnX2JpdF9zaXplX2xlYXN0LCB0cnVlIC8vIExpdHRsZS1lbmRpYW5cblx0XHRcdCk7XG5cdFx0XHRkYXRhX3ZpZXcuc2V0VWludDMyKG1lc3NhZ2Vfc2l6ZSArIG5fcGFkICsgNCwgbXNnX2JpdF9zaXplX21vc3QsIHRydWUgLy8gTGl0dGxlLWVuZGlhblxuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuIHBhZGRlZC5idWZmZXI7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiBcImZcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZihqLCB4LCB5LCB6KSB7XG5cdFx0XHRpZiAoMCA8PSBqICYmIGogPD0gMTUpIHtcblx0XHRcdFx0Ly8gRXhjbHVzaXZlLU9SXG5cdFx0XHRcdHJldHVybiB4IF4geSBeIHo7XG5cdFx0XHR9XG5cdFx0XHRpZiAoMTYgPD0gaiAmJiBqIDw9IDMxKSB7XG5cdFx0XHRcdC8vIE11bHRpcGxleGluZyAobXV4aW5nKVxuXHRcdFx0XHRyZXR1cm4geCAmIHkgfCB+eCAmIHo7XG5cdFx0XHR9XG5cdFx0XHRpZiAoMzIgPD0gaiAmJiBqIDw9IDQ3KSB7XG5cdFx0XHRcdHJldHVybiAoeCB8IH55KSBeIHo7XG5cdFx0XHR9XG5cdFx0XHRpZiAoNDggPD0gaiAmJiBqIDw9IDYzKSB7XG5cdFx0XHRcdC8vIE11bHRpcGxleGluZyAobXV4aW5nKVxuXHRcdFx0XHRyZXR1cm4geCAmIHogfCB5ICYgfno7XG5cdFx0XHR9XG5cdFx0XHRpZiAoNjQgPD0gaiAmJiBqIDw9IDc5KSB7XG5cdFx0XHRcdHJldHVybiB4IF4gKHkgfCB+eik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiBcIktcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gSyhqKSB7XG5cdFx0XHRpZiAoMCA8PSBqICYmIGogPD0gMTUpIHtcblx0XHRcdFx0cmV0dXJuIDB4MDAwMDAwMDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoMTYgPD0gaiAmJiBqIDw9IDMxKSB7XG5cdFx0XHRcdC8vIE1hdGguZmxvb3IoKDIgKiogMzApICogTWF0aC5TUVJUMilcblx0XHRcdFx0cmV0dXJuIDB4NUE4Mjc5OTk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoMzIgPD0gaiAmJiBqIDw9IDQ3KSB7XG5cdFx0XHRcdC8vIE1hdGguZmxvb3IoKDIgKiogMzApICogTWF0aC5zcXJ0KDMpKVxuXHRcdFx0XHRyZXR1cm4gMHg2RUQ5RUJBMTtcblx0XHRcdH1cblx0XHRcdGlmICg0OCA8PSBqICYmIGogPD0gNjMpIHtcblx0XHRcdFx0Ly8gTWF0aC5mbG9vcigoMiAqKiAzMCkgKiBNYXRoLnNxcnQoNSkpXG5cdFx0XHRcdHJldHVybiAweDhGMUJCQ0RDO1xuXHRcdFx0fVxuXHRcdFx0aWYgKDY0IDw9IGogJiYgaiA8PSA3OSkge1xuXHRcdFx0XHQvLyBNYXRoLmZsb29yKCgyICoqIDMwKSAqIE1hdGguc3FydCg3KSlcblx0XHRcdFx0cmV0dXJuIDB4QTk1M0ZENEU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiBcIktQXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIEtQKGopIC8vIEsnXG5cdFx0e1xuXHRcdFx0aWYgKDAgPD0gaiAmJiBqIDw9IDE1KSB7XG5cdFx0XHRcdC8vIE1hdGguZmxvb3IoKDIgKiogMzApICogTWF0aC5jYnJ0KDIpKVxuXHRcdFx0XHRyZXR1cm4gMHg1MEEyOEJFNjtcblx0XHRcdH1cblx0XHRcdGlmICgxNiA8PSBqICYmIGogPD0gMzEpIHtcblx0XHRcdFx0Ly8gTWF0aC5mbG9vcigoMiAqKiAzMCkgKiBNYXRoLmNicnQoMykpXG5cdFx0XHRcdHJldHVybiAweDVDNEREMTI0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKDMyIDw9IGogJiYgaiA8PSA0Nykge1xuXHRcdFx0XHQvLyBNYXRoLmZsb29yKCgyICoqIDMwKSAqIE1hdGguY2JydCg1KSlcblx0XHRcdFx0cmV0dXJuIDB4NkQ3MDNFRjM7XG5cdFx0XHR9XG5cdFx0XHRpZiAoNDggPD0gaiAmJiBqIDw9IDYzKSB7XG5cdFx0XHRcdC8vIE1hdGguZmxvb3IoKDIgKiogMzApICogTWF0aC5jYnJ0KDcpKVxuXHRcdFx0XHRyZXR1cm4gMHg3QTZENzZFOTtcblx0XHRcdH1cblx0XHRcdGlmICg2NCA8PSBqICYmIGogPD0gNzkpIHtcblx0XHRcdFx0cmV0dXJuIDB4MDAwMDAwMDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiBcImFkZF9tb2R1bG8zMlwiLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRfbW9kdWxvMzIoKSAvKiAuLi4uLi4gKi97XG5cdFx0XHQvLyAxLiAgTW9kdWxvIGFkZGl0aW9uIChhZGRpdGlvbiBtb2R1bG8pIGlzIGFzc29jaWF0aXZlLlxuXHRcdFx0Ly8gICAgaHR0cHM6Ly9wcm9vZndpa2kub3JnL3dpa2kvTW9kdWxvX0FkZGl0aW9uX2lzX0Fzc29jaWF0aXZlXG5cdFx0XHQvLyAyLiAgQml0d2lzZSBvcGVyYXRpb24gaW4gSmF2YXNjcmlwdFxuXHRcdFx0Ly8gICAgaXMgZG9uZSBvbiAzMi1iaXRzIG9wZXJhbmRzXG5cdFx0XHQvLyAgICBhbmQgcmVzdWx0cyBpbiBhIDMyLWJpdHMgdmFsdWUuXG5cdFx0XHRyZXR1cm4gQXJyYXkuZnJvbShhcmd1bWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYSArIGI7XG5cdFx0XHR9LCAwKSB8IDA7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiBcInJvbDMyXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJvbDMyKHZhbHVlLCBjb3VudCkge1xuXHRcdFx0Ly8gQ3ljbGljIGxlZnQgc2hpZnQgKHJvdGF0ZSkgb24gMzItYml0cyB2YWx1ZS5cblx0XHRcdHJldHVybiB2YWx1ZSA8PCBjb3VudCB8IHZhbHVlID4+PiAzMiAtIGNvdW50O1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogXCJoYXNoXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhc2gobWVzc2FnZSAvKiBBbiBBcnJheUJ1ZmZlci4gKi8pIHtcblx0XHRcdC8vLy8vLy8vLy8gICAgICAgUGFkZGluZyAgICAgICAvLy8vLy8vLy8vXG5cblx0XHRcdC8vIFRoZSBwYWRkZWQgbWVzc2FnZS5cblx0XHRcdHZhciBwYWRkZWQgPSBSSVBFTUQxNjAucGFkKG1lc3NhZ2UpO1xuXG5cdFx0XHQvLy8vLy8vLy8vICAgICBDb21wcmVzc2lvbiAgICAgLy8vLy8vLy8vL1xuXG5cdFx0XHQvLyBNZXNzYWdlIHdvcmQgc2VsZWN0b3JzLlxuXHRcdFx0dmFyIHIgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCwgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMiwgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMiwgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM107XG5cdFx0XHR2YXIgclAgPSBbLy8gcidcblx0XHRcdDUsIDE0LCA3LCAwLCA5LCAyLCAxMSwgNCwgMTMsIDYsIDE1LCA4LCAxLCAxMCwgMywgMTIsIDYsIDExLCAzLCA3LCAwLCAxMywgNSwgMTAsIDE0LCAxNSwgOCwgMTIsIDQsIDksIDEsIDIsIDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTMsIDgsIDYsIDQsIDEsIDMsIDExLCAxNSwgMCwgNSwgMTIsIDIsIDEzLCA5LCA3LCAxMCwgMTQsIDEyLCAxNSwgMTAsIDQsIDEsIDUsIDgsIDcsIDYsIDIsIDEzLCAxNCwgMCwgMywgOSwgMTFdO1xuXG5cdFx0XHQvLyBBbW91bnRzIGZvciAncm90YXRlIGxlZnQnIG9wZXJhdGlvbi5cblx0XHRcdHZhciBzID0gWzExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOCwgNywgNiwgOCwgMTMsIDExLCA5LCA3LCAxNSwgNywgMTIsIDE1LCA5LCAxMSwgNywgMTMsIDEyLCAxMSwgMTMsIDYsIDcsIDE0LCA5LCAxMywgMTUsIDE0LCA4LCAxMywgNiwgNSwgMTIsIDcsIDUsIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsIDksIDgsIDksIDE0LCA1LCA2LCA4LCA2LCA1LCAxMiwgOSwgMTUsIDUsIDExLCA2LCA4LCAxMywgMTIsIDUsIDEyLCAxMywgMTQsIDExLCA4LCA1LCA2XTtcblx0XHRcdHZhciBzUCA9IFsvLyBzJ1xuXHRcdFx0OCwgOSwgOSwgMTEsIDEzLCAxNSwgMTUsIDUsIDcsIDcsIDgsIDExLCAxNCwgMTQsIDEyLCA2LCA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTEsIDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNSwgMTUsIDUsIDgsIDExLCAxNCwgMTQsIDYsIDE0LCA2LCA5LCAxMiwgOSwgMTIsIDUsIDE1LCA4LCA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFdO1xuXG5cdFx0XHQvLyBUaGUgc2l6ZSwgaW4gYnl0ZXMsIG9mIGEgd29yZC5cblx0XHRcdHZhciB3b3JkX3NpemUgPSA0O1xuXG5cdFx0XHQvLyBUaGUgc2l6ZSwgaW4gYnl0ZXMsIG9mIGEgMTYtd29yZHMgYmxvY2suXG5cdFx0XHR2YXIgYmxvY2tfc2l6ZSA9IDY0O1xuXG5cdFx0XHQvLyBUaGUgbnVtYmVyIG9mIHRoZSAxNi13b3JkcyBibG9ja3MuXG5cdFx0XHR2YXIgdCA9IHBhZGRlZC5ieXRlTGVuZ3RoIC8gYmxvY2tfc2l6ZTtcblxuXHRcdFx0Ly8gIFRoZSBtZXNzYWdlIGFmdGVyIHBhZGRpbmcgY29uc2lzdHMgb2YgdCAxNi13b3JkIGJsb2NrcyB0aGF0XG5cdFx0XHQvLyBhcmUgZGVub3RlZCB3aXRoIFhfaVtqXSwgd2l0aCAw4omkaeKJpCh0IOKIkiAxKSBhbmQgMOKJpGriiaQxNS5cblx0XHRcdHZhciBYID0gbmV3IEFycmF5KHQpLmZpbGwodW5kZWZpbmVkKS5tYXAoZnVuY3Rpb24gKF8sIGkpIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChqKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBEYXRhVmlldyhwYWRkZWQsIGkgKiBibG9ja19zaXplLCBibG9ja19zaXplKS5nZXRVaW50MzIoaiAqIHdvcmRfc2l6ZSwgdHJ1ZSAvLyBMaXR0bGUtZW5kaWFuXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyAgVGhlIHJlc3VsdCBvZiBSSVBFTUQtMTYwIGlzIGNvbnRhaW5lZCBpbiBmaXZlIDMyLWJpdCB3b3Jkcyxcblx0XHRcdC8vIHdoaWNoIGZvcm0gdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBhbGdvcml0aG0uIFRoZSBmaW5hbFxuXHRcdFx0Ly8gY29udGVudCBvZiB0aGVzZSBmaXZlIDMyLWJpdCB3b3JkcyBpcyBjb252ZXJ0ZWQgdG8gYSAxNjAtYml0XG5cdFx0XHQvLyBzdHJpbmcsIGFnYWluIHVzaW5nIHRoZSBsaXR0bGUtZW5kaWFuIGNvbnZlbnRpb24uXG5cdFx0XHR2YXIgaCA9IFsweDY3NDUyMzAxLCAvLyBoXzBcblx0XHRcdDB4RUZDREFCODksIC8vIGhfMVxuXHRcdFx0MHg5OEJBRENGRSwgLy8gaF8yXG5cdFx0XHQweDEwMzI1NDc2LCAvLyBoXzNcblx0XHRcdDB4QzNEMkUxRjAgLy8gaF80XG5cdFx0XHRdO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHQ7ICsraSkge1xuXHRcdFx0XHR2YXIgQSA9IGhbMF0sXG5cdFx0XHRcdCAgICBCID0gaFsxXSxcblx0XHRcdFx0ICAgIEMgPSBoWzJdLFxuXHRcdFx0XHQgICAgRCA9IGhbM10sXG5cdFx0XHRcdCAgICBFID0gaFs0XTtcblx0XHRcdFx0dmFyIEFQID0gQSxcblx0XHRcdFx0ICAgIEJQID0gQixcblx0XHRcdFx0ICAgIENQID0gQyxcblx0XHRcdFx0ICAgIERQID0gRCxcblx0XHRcdFx0ICAgIEVQID0gRTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG5cdFx0XHRcdFx0Ly8gTGVmdCByb3VuZHNcblx0XHRcdFx0XHR2YXIgX1QgPSBSSVBFTUQxNjAuYWRkX21vZHVsbzMyKFJJUEVNRDE2MC5yb2wzMihSSVBFTUQxNjAuYWRkX21vZHVsbzMyKEEsIFJJUEVNRDE2MC5mKGosIEIsIEMsIEQpLCBYW2ldKHJbal0pLCBSSVBFTUQxNjAuSyhqKSksIHNbal0pLCBFKTtcblx0XHRcdFx0XHRBID0gRTtcblx0XHRcdFx0XHRFID0gRDtcblx0XHRcdFx0XHREID0gUklQRU1EMTYwLnJvbDMyKEMsIDEwKTtcblx0XHRcdFx0XHRDID0gQjtcblx0XHRcdFx0XHRCID0gX1Q7XG5cblx0XHRcdFx0XHQvLyBSaWdodCByb3VuZHNcblx0XHRcdFx0XHRfVCA9IFJJUEVNRDE2MC5hZGRfbW9kdWxvMzIoUklQRU1EMTYwLnJvbDMyKFJJUEVNRDE2MC5hZGRfbW9kdWxvMzIoQVAsIFJJUEVNRDE2MC5mKDc5IC0gaiwgQlAsIENQLCBEUCksIFhbaV0oclBbal0pLCBSSVBFTUQxNjAuS1AoaikpLCBzUFtqXSksIEVQKTtcblx0XHRcdFx0XHRBUCA9IEVQO1xuXHRcdFx0XHRcdEVQID0gRFA7XG5cdFx0XHRcdFx0RFAgPSBSSVBFTUQxNjAucm9sMzIoQ1AsIDEwKTtcblx0XHRcdFx0XHRDUCA9IEJQO1xuXHRcdFx0XHRcdEJQID0gX1Q7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIFQgPSBSSVBFTUQxNjAuYWRkX21vZHVsbzMyKGhbMV0sIEMsIERQKTtcblx0XHRcdFx0aFsxXSA9IFJJUEVNRDE2MC5hZGRfbW9kdWxvMzIoaFsyXSwgRCwgRVApO1xuXHRcdFx0XHRoWzJdID0gUklQRU1EMTYwLmFkZF9tb2R1bG8zMihoWzNdLCBFLCBBUCk7XG5cdFx0XHRcdGhbM10gPSBSSVBFTUQxNjAuYWRkX21vZHVsbzMyKGhbNF0sIEEsIEJQKTtcblx0XHRcdFx0aFs0XSA9IFJJUEVNRDE2MC5hZGRfbW9kdWxvMzIoaFswXSwgQiwgQ1ApO1xuXHRcdFx0XHRoWzBdID0gVDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gIFRoZSBmaW5hbCBvdXRwdXQgc3RyaW5nIHRoZW4gY29uc2lzdHMgb2YgdGhlIGNvbmNhdGVuYXRhdGlvblxuXHRcdFx0Ly8gb2YgaF8wLCBoXzEsIGhfMiwgaF8zLCBhbmQgaF80IGFmdGVyIGNvbnZlcnRpbmcgZWFjaCBoX2kgdG8gYVxuXHRcdFx0Ly8gNC1ieXRlIHN0cmluZyB1c2luZyB0aGUgbGl0dGxlLWVuZGlhbiBjb252ZW50aW9uLlxuXHRcdFx0dmFyIHJlc3VsdCA9IG5ldyBBcnJheUJ1ZmZlcigyMCk7XG5cdFx0XHR2YXIgZGF0YV92aWV3ID0gbmV3IERhdGFWaWV3KHJlc3VsdCk7XG5cdFx0XHRoLmZvckVhY2goZnVuY3Rpb24gKGhfaSwgaSkge1xuXHRcdFx0XHRyZXR1cm4gZGF0YV92aWV3LnNldFVpbnQzMihpICogNCwgaF9pLCB0cnVlKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gUklQRU1EMTYwO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0UklQRU1EMTYwOiBSSVBFTUQxNjBcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIGNvcHlyaWdodCBkZWZpbmVkIGluIGVvc2pzL0xJQ0VOU0UudHh0XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lb3Nqcy1hcGktaW50ZXJmYWNlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBKU09OLVJQQ1xuICovXG4vLyBjb3B5cmlnaHQgZGVmaW5lZCBpbiBlb3Nqcy9MSUNFTlNFLnR4dFxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW9zanNfbnVtZXJpY18xID0gcmVxdWlyZShcIi4vZW9zanMtbnVtZXJpY1wiKTtcbnZhciBlb3Nqc19ycGNlcnJvcl8xID0gcmVxdWlyZShcIi4vZW9zanMtcnBjZXJyb3JcIik7XG5mdW5jdGlvbiBhcnJheVRvSGV4KGRhdGEpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgZGF0YV8xID0gX192YWx1ZXMoZGF0YSksIGRhdGFfMV8xID0gZGF0YV8xLm5leHQoKTsgIWRhdGFfMV8xLmRvbmU7IGRhdGFfMV8xID0gZGF0YV8xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHggPSBkYXRhXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIHJlc3VsdCArPSAoJzAwJyArIHgudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChkYXRhXzFfMSAmJiAhZGF0YV8xXzEuZG9uZSAmJiAoX2EgPSBkYXRhXzEucmV0dXJuKSkgX2EuY2FsbChkYXRhXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBNYWtlIFJQQyBjYWxscyAqL1xudmFyIEpzb25ScGMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKiAgICAqIGBmZXRjaGA6XG4gICAgICogICAgKiBicm93c2VyczogbGVhdmUgYG51bGxgIG9yIGB1bmRlZmluZWRgXG4gICAgICogICAgKiBub2RlOiBwcm92aWRlIGFuIGltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gSnNvblJwYyhlbmRwb2ludCwgYXJncykge1xuICAgICAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7IGFyZ3MgPSB7fTsgfVxuICAgICAgICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG4gICAgICAgIGlmIChhcmdzLmZldGNoKSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoQnVpbHRpbiA9IGFyZ3MuZmV0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoQnVpbHRpbiA9IGdsb2JhbC5mZXRjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUG9zdCBgYm9keWAgdG8gYGVuZHBvaW50ICsgcGF0aGAuIFRocm93cyBkZXRhaWxlZCBlcnJvciBpbmZvcm1hdGlvbiBpbiBgUnBjRXJyb3JgIHdoZW4gYXZhaWxhYmxlLiAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKHBhdGgsIGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlLCBqc29uLCBmLCBlXzI7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IHRoaXMuZmV0Y2hCdWlsdGluO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZih0aGlzLmVuZHBvaW50ICsgcGF0aCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3BvbnNlLmpzb24oKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5wcm9jZXNzZWQgJiYganNvbi5wcm9jZXNzZWQuZXhjZXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVvc2pzX3JwY2Vycm9yXzEuUnBjRXJyb3IoanNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8yID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZV8yLmlzRmV0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlXzI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZW9zanNfcnBjZXJyb3JfMS5ScGNFcnJvcihqc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBqc29uXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogUmF3IGNhbGwgdG8gYC92MS9jaGFpbi9nZXRfYWJpYCAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9hYmkgPSBmdW5jdGlvbiAoYWNjb3VudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKCcvdjEvY2hhaW4vZ2V0X2FiaScsIHsgYWNjb3VudF9uYW1lOiBhY2NvdW50TmFtZSB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIFJhdyBjYWxsIHRvIGAvdjEvY2hhaW4vZ2V0X2FjY291bnRgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2FjY291bnQgPSBmdW5jdGlvbiAoYWNjb3VudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKCcvdjEvY2hhaW4vZ2V0X2FjY291bnQnLCB7IGFjY291bnRfbmFtZTogYWNjb3VudE5hbWUgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBSYXcgY2FsbCB0byBgL3YxL2NoYWluL2dldF9ibG9ja19oZWFkZXJfc3RhdGVgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2Jsb2NrX2hlYWRlcl9zdGF0ZSA9IGZ1bmN0aW9uIChibG9ja051bU9ySWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKCcvdjEvY2hhaW4vZ2V0X2Jsb2NrX2hlYWRlcl9zdGF0ZScsIHsgYmxvY2tfbnVtX29yX2lkOiBibG9ja051bU9ySWQgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBSYXcgY2FsbCB0byBgL3YxL2NoYWluL2dldF9ibG9ja2AgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfYmxvY2sgPSBmdW5jdGlvbiAoYmxvY2tOdW1PcklkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5mZXRjaCgnL3YxL2NoYWluL2dldF9ibG9jaycsIHsgYmxvY2tfbnVtX29yX2lkOiBibG9ja051bU9ySWQgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBSYXcgY2FsbCB0byBgL3YxL2NoYWluL2dldF9jb2RlYCAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF9jb2RlID0gZnVuY3Rpb24gKGFjY291bnROYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5mZXRjaCgnL3YxL2NoYWluL2dldF9jb2RlJywgeyBhY2NvdW50X25hbWU6IGFjY291bnROYW1lIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogUmF3IGNhbGwgdG8gYC92MS9jaGFpbi9nZXRfY3VycmVuY3lfYmFsYW5jZWAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfY3VycmVuY3lfYmFsYW5jZSA9IGZ1bmN0aW9uIChjb2RlLCBhY2NvdW50LCBzeW1ib2wpIHtcbiAgICAgICAgaWYgKHN5bWJvbCA9PT0gdm9pZCAwKSB7IHN5bWJvbCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKCcvdjEvY2hhaW4vZ2V0X2N1cnJlbmN5X2JhbGFuY2UnLCB7IGNvZGU6IGNvZGUsIGFjY291bnQ6IGFjY291bnQsIHN5bWJvbDogc3ltYm9sIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogUmF3IGNhbGwgdG8gYC92MS9jaGFpbi9nZXRfY3VycmVuY3lfc3RhdHNgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0X2N1cnJlbmN5X3N0YXRzID0gZnVuY3Rpb24gKGNvZGUsIHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZmV0Y2goJy92MS9jaGFpbi9nZXRfY3VycmVuY3lfc3RhdHMnLCB7IGNvZGU6IGNvZGUsIHN5bWJvbDogc3ltYm9sIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogUmF3IGNhbGwgdG8gYC92MS9jaGFpbi9nZXRfaW5mb2AgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfaW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKCcvdjEvY2hhaW4vZ2V0X2luZm8nLCB7fSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBSYXcgY2FsbCB0byBgL3YxL2NoYWluL2dldF9wcm9kdWNlcl9zY2hlZHVsZWAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfcHJvZHVjZXJfc2NoZWR1bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5mZXRjaCgnL3YxL2NoYWluL2dldF9wcm9kdWNlcl9zY2hlZHVsZScsIHt9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIFJhdyBjYWxsIHRvIGAvdjEvY2hhaW4vZ2V0X3Byb2R1Y2Vyc2AgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfcHJvZHVjZXJzID0gZnVuY3Rpb24gKGpzb24sIGxvd2VyQm91bmQsIGxpbWl0KSB7XG4gICAgICAgIGlmIChqc29uID09PSB2b2lkIDApIHsganNvbiA9IHRydWU7IH1cbiAgICAgICAgaWYgKGxvd2VyQm91bmQgPT09IHZvaWQgMCkgeyBsb3dlckJvdW5kID0gJyc7IH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSA1MDsgfVxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZmV0Y2goJy92MS9jaGFpbi9nZXRfcHJvZHVjZXJzJywgeyBqc29uOiBqc29uLCBsb3dlcl9ib3VuZDogbG93ZXJCb3VuZCwgbGltaXQ6IGxpbWl0IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogUmF3IGNhbGwgdG8gYC92MS9jaGFpbi9nZXRfcmF3X2NvZGVfYW5kX2FiaWAgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5nZXRfcmF3X2NvZGVfYW5kX2FiaSA9IGZ1bmN0aW9uIChhY2NvdW50TmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZmV0Y2goJy92MS9jaGFpbi9nZXRfcmF3X2NvZGVfYW5kX2FiaScsIHsgYWNjb3VudF9uYW1lOiBhY2NvdW50TmFtZSB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIGNhbGxzIGAvdjEvY2hhaW4vZ2V0X3Jhd19jb2RlX2FuZF9hYmlgIGFuZCBwdWxscyBvdXQgdW5uZWVkZWQgcmF3IHdhc20gY29kZSAqL1xuICAgIC8vIFRPRE86IHVzZSBgL3YxL2NoYWluL2dldF9yYXdfYWJpYCBkaXJlY3RseSB3aGVuIGl0IGJlY29tZXMgYXZhaWxhYmxlXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0UmF3QWJpID0gZnVuY3Rpb24gKGFjY291bnROYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByYXdDb2RlQW5kQWJpLCBhYmk7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0X3Jhd19jb2RlX2FuZF9hYmkoYWNjb3VudE5hbWUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3Q29kZUFuZEFiaSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFiaSA9IGVvc2pzX251bWVyaWNfMS5iYXNlNjRUb0JpbmFyeShyYXdDb2RlQW5kQWJpLmFiaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgeyBhY2NvdW50TmFtZTogcmF3Q29kZUFuZEFiaS5hY2NvdW50X25hbWUsIGFiaTogYWJpIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBSYXcgY2FsbCB0byBgL3YxL2NoYWluL2dldF90YWJsZV9yb3dzYCAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF90YWJsZV9yb3dzID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hLmpzb24sIGpzb24gPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBjb2RlID0gX2EuY29kZSwgc2NvcGUgPSBfYS5zY29wZSwgdGFibGUgPSBfYS50YWJsZSwgX2MgPSBfYS50YWJsZV9rZXksIHRhYmxlX2tleSA9IF9jID09PSB2b2lkIDAgPyAnJyA6IF9jLCBfZCA9IF9hLmxvd2VyX2JvdW5kLCBsb3dlcl9ib3VuZCA9IF9kID09PSB2b2lkIDAgPyAnJyA6IF9kLCBfZSA9IF9hLnVwcGVyX2JvdW5kLCB1cHBlcl9ib3VuZCA9IF9lID09PSB2b2lkIDAgPyAnJyA6IF9lLCBfZiA9IF9hLmluZGV4X3Bvc2l0aW9uLCBpbmRleF9wb3NpdGlvbiA9IF9mID09PSB2b2lkIDAgPyAxIDogX2YsIF9nID0gX2Eua2V5X3R5cGUsIGtleV90eXBlID0gX2cgPT09IHZvaWQgMCA/ICcnIDogX2csIF9oID0gX2EubGltaXQsIGxpbWl0ID0gX2ggPT09IHZvaWQgMCA/IDEwIDogX2gsIF9qID0gX2EucmV2ZXJzZSwgcmV2ZXJzZSA9IF9qID09PSB2b2lkIDAgPyBmYWxzZSA6IF9qLCBfayA9IF9hLnNob3dfcGF5ZXIsIHNob3dfcGF5ZXIgPSBfayA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaztcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfbCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2wubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKCcvdjEvY2hhaW4vZ2V0X3RhYmxlX3Jvd3MnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbjoganNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiBzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVfa2V5OiB0YWJsZV9rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJfYm91bmQ6IGxvd2VyX2JvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyX2JvdW5kOiB1cHBlcl9ib3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleF9wb3NpdGlvbjogaW5kZXhfcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5X3R5cGU6IGtleV90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiByZXZlcnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dfcGF5ZXI6IHNob3dfcGF5ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9sLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIFJhdyBjYWxsIHRvIGAvdjEvY2hhaW4vZ2V0X3RhYmxlX2J5X3Njb3BlYCAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmdldF90YWJsZV9ieV9zY29wZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY29kZSA9IF9hLmNvZGUsIHRhYmxlID0gX2EudGFibGUsIF9iID0gX2EubG93ZXJfYm91bmQsIGxvd2VyX2JvdW5kID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2IsIF9jID0gX2EudXBwZXJfYm91bmQsIHVwcGVyX2JvdW5kID0gX2MgPT09IHZvaWQgMCA/ICcnIDogX2MsIF9kID0gX2EubGltaXQsIGxpbWl0ID0gX2QgPT09IHZvaWQgMCA/IDEwIDogX2Q7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5mZXRjaCgnL3YxL2NoYWluL2dldF90YWJsZV9ieV9zY29wZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlcl9ib3VuZDogbG93ZXJfYm91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJfYm91bmQ6IHVwcGVyX2JvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Uuc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogR2V0IHN1YnNldCBvZiBgYXZhaWxhYmxlS2V5c2AgbmVlZGVkIHRvIG1lZXQgYXV0aG9yaXRpZXMgaW4gYHRyYW5zYWN0aW9uYC4gSW1wbGVtZW50cyBgQXV0aG9yaXR5UHJvdmlkZXJgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZ2V0UmVxdWlyZWRLZXlzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBlb3Nqc19udW1lcmljXzEuY29udmVydExlZ2FjeVB1YmxpY0tleXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKCcvdjEvY2hhaW4vZ2V0X3JlcXVpcmVkX2tleXMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBhcmdzLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVfa2V5czogYXJncy5hdmFpbGFibGVLZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2EuYXBwbHkodm9pZCAwLCBbKF9iLnNlbnQoKSkucmVxdWlyZWRfa2V5c10pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogUHVzaCBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5wdXNoX3RyYW5zYWN0aW9uID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBzaWduYXR1cmVzID0gX2Euc2lnbmF0dXJlcywgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gX2Euc2VyaWFsaXplZFRyYW5zYWN0aW9uO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZmV0Y2goJy92MS9jaGFpbi9wdXNoX3RyYW5zYWN0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZXM6IHNpZ25hdHVyZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Npb246IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2VkX2NvbnRleHRfZnJlZV9kYXRhOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZWRfdHJ4OiBhcnJheVRvSGV4KHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIFJhdyBjYWxsIHRvIGAvdjEvZGJfc2l6ZS9nZXRgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuZGJfc2l6ZV9nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5mZXRjaCgnL3YxL2RiX3NpemUvZ2V0Jywge30pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICAvKiogUmF3IGNhbGwgdG8gYC92MS9oaXN0b3J5L2dldF9hY3Rpb25zYCAqL1xuICAgIEpzb25ScGMucHJvdG90eXBlLmhpc3RvcnlfZ2V0X2FjdGlvbnMgPSBmdW5jdGlvbiAoYWNjb3VudE5hbWUsIHBvcywgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChwb3MgPT09IHZvaWQgMCkgeyBwb3MgPSBudWxsOyB9XG4gICAgICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5mZXRjaCgnL3YxL2hpc3RvcnkvZ2V0X2FjdGlvbnMnLCB7IGFjY291bnRfbmFtZTogYWNjb3VudE5hbWUsIHBvczogcG9zLCBvZmZzZXQ6IG9mZnNldCB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIFJhdyBjYWxsIHRvIGAvdjEvaGlzdG9yeS9nZXRfdHJhbnNhY3Rpb25gICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuaGlzdG9yeV9nZXRfdHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoaWQsIGJsb2NrTnVtSGludCkge1xuICAgICAgICBpZiAoYmxvY2tOdW1IaW50ID09PSB2b2lkIDApIHsgYmxvY2tOdW1IaW50ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZmV0Y2goJy92MS9oaXN0b3J5L2dldF90cmFuc2FjdGlvbicsIHsgaWQ6IGlkLCBibG9ja19udW1faGludDogYmxvY2tOdW1IaW50IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogUmF3IGNhbGwgdG8gYC92MS9oaXN0b3J5L2dldF9rZXlfYWNjb3VudHNgICovXG4gICAgSnNvblJwYy5wcm90b3R5cGUuaGlzdG9yeV9nZXRfa2V5X2FjY291bnRzID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZmV0Y2goJy92MS9oaXN0b3J5L2dldF9rZXlfYWNjb3VudHMnLCB7IHB1YmxpY19rZXk6IHB1YmxpY0tleSB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIFJhdyBjYWxsIHRvIGAvdjEvaGlzdG9yeS9nZXRfY29udHJvbGxlZF9hY2NvdW50c2AgKi9cbiAgICBKc29uUnBjLnByb3RvdHlwZS5oaXN0b3J5X2dldF9jb250cm9sbGVkX2FjY291bnRzID0gZnVuY3Rpb24gKGNvbnRyb2xsaW5nQWNjb3VudCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZmV0Y2goJy92MS9oaXN0b3J5L2dldF9jb250cm9sbGVkX2FjY291bnRzJywgeyBjb250cm9sbGluZ19hY2NvdW50OiBjb250cm9sbGluZ0FjY291bnQgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBKc29uUnBjO1xufSgpKTsgLy8gSnNvblJwY1xuZXhwb3J0cy5Kc29uUnBjID0gSnNvblJwYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVvc2pzLWpzb25ycGMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBtb2R1bGUgUlBDLUVycm9yXG4gKi9cbi8vIGNvcHlyaWdodCBkZWZpbmVkIGluIGVvc2pzL0xJQ0VOU0UudHh0XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBIb2xkcyBkZXRhaWxlZCBlcnJvciBpbmZvcm1hdGlvbiAqL1xudmFyIFJwY0Vycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhScGNFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBScGNFcnJvcihqc29uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChqc29uLmVycm9yICYmIGpzb24uZXJyb3IuZGV0YWlscyAmJiBqc29uLmVycm9yLmRldGFpbHMubGVuZ3RoICYmIGpzb24uZXJyb3IuZGV0YWlsc1swXS5tZXNzYWdlKSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGpzb24uZXJyb3IuZGV0YWlsc1swXS5tZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24ucHJvY2Vzc2VkICYmIGpzb24ucHJvY2Vzc2VkLmV4Y2VwdCAmJiBqc29uLnByb2Nlc3NlZC5leGNlcHQubWVzc2FnZSkge1xuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBqc29uLnByb2Nlc3NlZC5leGNlcHQubWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywganNvbi5tZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUnBjRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgX3RoaXMuanNvbiA9IGpzb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJwY0Vycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5ScGNFcnJvciA9IFJwY0Vycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW9zanMtcnBjZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBjb3B5cmlnaHQgZGVmaW5lZCBpbiBlb3Nqcy9MSUNFTlNFLnR4dFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW9zanMtcnBjLWludGVyZmFjZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBtYWtlU3RhdGVDb250YWluZXIoaW5pdGlhbFN0YXRlKSB7XG4gICAgdmFyIHN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVTdGF0ZTogZnVuY3Rpb24gKHVwZGF0ZXIpIHtcbiAgICAgICAgICAgIHN0YXRlID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgdXBkYXRlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICA/IHVwZGF0ZXIoc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIDogdXBkYXRlcjtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbGlzdGVuZXJzXzEgPSBsaXN0ZW5lcnM7IF9pIDwgbGlzdGVuZXJzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzXzFbX2ldO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobGlzdGVuZXJGbikge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXJGbik7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAobCkgeyByZXR1cm4gbCAhPT0gbGlzdGVuZXJGbjsgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMubWFrZVN0YXRlQ29udGFpbmVyID0gbWFrZVN0YXRlQ29udGFpbmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVDb250YWluZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlb3Nqc18xID0gcmVxdWlyZShcImVvc2pzXCIpO1xudmFyIHY0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInV1aWQvdjRcIikpO1xudmFyIHN0YXRlQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9zdGF0ZUNvbnRhaW5lclwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIERFRkFVTFRfU1RBVEUgPSB7XG4gICAgY29ubmVjdGluZzogZmFsc2UsXG4gICAgY29ubmVjdGVkOiBmYWxzZSxcbiAgICBjb25uZWN0aW9uRXJyb3I6IGZhbHNlLFxuICAgIGNvbm5lY3Rpb25FcnJvck1lc3NhZ2U6IHZvaWQgMCxcbiAgICBhdXRoOiB2b2lkIDAsXG4gICAgYXV0aGVudGljYXRpbmc6IGZhbHNlLFxuICAgIGF1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICAgIGF1dGhlbnRpY2F0aW9uQ29uZmlybWVkOiBmYWxzZSxcbiAgICBhdXRoZW50aWNhdGlvbkVycm9yOiBmYWxzZSxcbiAgICBhdXRoZW50aWNhdGlvbkVycm9yTWVzc2FnZTogdm9pZCAwLFxuICAgIGFjY291bnRJbmZvOiB2b2lkIDAsXG4gICAgYWNjb3VudEZldGNoaW5nOiBmYWxzZSxcbiAgICBhY2NvdW50RmV0Y2hFcnJvcjogZmFsc2UsXG4gICAgYWNjb3VudEZldGNoRXJyb3JNZXNzYWdlOiB2b2lkIDBcbn07XG5mdW5jdGlvbiBpbml0V2FsbGV0KHdhbGxldFByb3ZpZGVyLCBjdHgpIHtcbiAgICB2YXIgX2luc3RhbmNlSWQgPSB2NF8xLmRlZmF1bHQoKTtcbiAgICB2YXIgX3N0YXRlQ29udGFpbmVyID0gc3RhdGVDb250YWluZXJfMS5tYWtlU3RhdGVDb250YWluZXIoX19hc3NpZ24oe30sIERFRkFVTFRfU1RBVEUpKTtcbiAgICAvL2xldCBkaXNjb3ZlckRhdGE6IERpc2NvdmVyeURhdGEgPSB7IGtleVRvQWNjb3VudE1hcDogW10sIGtleXM6IFtdIH07XG4gICAgdmFyIGRpc2NvdmVyRGF0YSA9IHsga2V5VG9BY2NvdW50TWFwOiBbXSB9O1xuICAgIHZhciBjb3VudGVyID0gMDtcbiAgICB2YXIgZ2V0U3RhdGUgPSBfc3RhdGVDb250YWluZXIuZ2V0U3RhdGU7XG4gICAgdmFyIGVvc0FwaSA9IG5ldyBlb3Nqc18xLkFwaSh7XG4gICAgICAgIC8vIEFwaSgpIGNvbnN0cnVjdG9yIHJlcXVpcmVzIGEgSnNvblJwYyAtIGV2ZW4gaWYgd2UgZG9udCB3YW50IG9uZSBmb3Igbm9uLWVvcywgc28gY3JlYXRlIGVtcHR5IEpzb25ScGMgaGVyZVxuICAgICAgICBycGM6IGN0eC5lb3NScGMgPyBjdHguZW9zUnBjIDogbmV3IGVvc2pzXzEuSnNvblJwYygnJyksXG4gICAgICAgIGNoYWluSWQ6IGN0eC5uZXR3b3JrLmNoYWluSWQsXG4gICAgICAgIHNpZ25hdHVyZVByb3ZpZGVyOiB3YWxsZXRQcm92aWRlci5zaWduYXR1cmVQcm92aWRlclxuICAgIH0pO1xuICAgIC8vIEFjY291bnQgaGVscGVyc1xuICAgIGZ1bmN0aW9uIGZldGNoQWNjb3VudEluZm8oYWNjb3VudE5hbWUpIHtcbiAgICAgICAgaWYgKCFhY2NvdW50TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdObyBgYWNjb3VudE5hbWVgIHdhcyBwYXNzZWQgaW4gb3JkZXIgdG8gZmV0Y2ggdGhlIGFjY291bnQgaW5mbycpO1xuICAgICAgICB9XG4gICAgICAgIF9zdGF0ZUNvbnRhaW5lci51cGRhdGVTdGF0ZShmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIChfX2Fzc2lnbih7fSwgc3RhdGUsIHsgYWNjb3VudEZldGNoaW5nOiB0cnVlLCBhY2NvdW50RmV0Y2hFcnJvcjogZmFsc2UsIGFjY291bnRGZXRjaEVycm9yTWVzc2FnZTogdm9pZCAwIH0pKTsgfSk7XG4gICAgICAgIC8vIE5vbkVPUyBTdXBwb3J0OiBpZiBjdHguZW9zUnBjIGlzIHVuZGVmaW5lZCxcbiAgICAgICAgLy8gcmV0dXJuIEFjY291bnRJbmZvIHdpdGgganVzdCBhY2NvdW50TmFtZVxuICAgICAgICBpZiAoIWN0eC5lb3NScGMpIHtcbiAgICAgICAgICAgIHZhciBhY2NvdW50SW5mb18xID0geyBuYW1lOiBhY2NvdW50TmFtZSB9O1xuICAgICAgICAgICAgX3N0YXRlQ29udGFpbmVyLnVwZGF0ZVN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gKF9fYXNzaWduKHt9LCBzdGF0ZSwgeyBhY2NvdW50RmV0Y2hpbmc6IGZhbHNlLCBhY2NvdW50SW5mbzogYWNjb3VudEluZm9fMSB9KSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhY2NvdW50SW5mb18xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LmVvc1JwY1xuICAgICAgICAgICAgLmdldF9hY2NvdW50KGFjY291bnROYW1lKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGFjY291bnREYXRhKSB7XG4gICAgICAgICAgICB2YXIgYWNjb3VudEluZm8gPSBfX2Fzc2lnbih7fSwgYWNjb3VudERhdGEpO1xuICAgICAgICAgICAgX3N0YXRlQ29udGFpbmVyLnVwZGF0ZVN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gKF9fYXNzaWduKHt9LCBzdGF0ZSwgeyBhY2NvdW50RmV0Y2hpbmc6IGZhbHNlLCBhY2NvdW50SW5mbzogYWNjb3VudEluZm8gfSkpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50SW5mbztcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF9zdGF0ZUNvbnRhaW5lci51cGRhdGVTdGF0ZShmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIChfX2Fzc2lnbih7fSwgc3RhdGUsIHsgYWNjb3VudEZldGNoaW5nOiBmYWxzZSwgYWNjb3VudEluZm86IHZvaWQgMCwgYWNjb3VudEZldGNoRXJyb3I6IHRydWUsIGFjY291bnRGZXRjaEVycm9yTWVzc2FnZTogdXRpbF8xLmdldEVycm9yTWVzc2FnZShlcnJvcikgfSkpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDb25uZWN0aW9uXG4gICAgZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgICAgX3N0YXRlQ29udGFpbmVyLnVwZGF0ZVN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gKF9fYXNzaWduKHt9LCBzdGF0ZSwgeyBjb25uZWN0ZWQ6IGZhbHNlLCBjb25uZWN0aW5nOiB0cnVlLCBjb25uZWN0aW9uRXJyb3I6IGZhbHNlLCBjb25uZWN0aW9uRXJyb3JNZXNzYWdlOiB2b2lkIDAgfSkpOyB9KTtcbiAgICAgICAgcmV0dXJuIHdhbGxldFByb3ZpZGVyXG4gICAgICAgICAgICAuY29ubmVjdChjdHguYXBwTmFtZSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9zdGF0ZUNvbnRhaW5lci51cGRhdGVTdGF0ZShmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIChfX2Fzc2lnbih7fSwgc3RhdGUsIHsgY29ubmVjdGluZzogZmFsc2UsIGNvbm5lY3RlZDogdHJ1ZSB9KSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfc3RhdGVDb250YWluZXIudXBkYXRlU3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAoX19hc3NpZ24oe30sIHN0YXRlLCB7IGNvbm5lY3Rpbmc6IGZhbHNlLCBjb25uZWN0aW9uRXJyb3I6IHRydWUsIGNvbm5lY3Rpb25FcnJvck1lc3NhZ2U6IHV0aWxfMS5nZXRFcnJvck1lc3NhZ2UoZXJyb3IpIH0pKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzY292ZXIoZGlzY292ZXJ5T3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYWNjb3VudHNEYXRhT2JqVG9NZXJnZSwgZGlzY292ZXJSZXN1bHQ7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudHNEYXRhT2JqVG9NZXJnZSA9IHsga2V5VG9BY2NvdW50TWFwOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd2FsbGV0UHJvdmlkZXIuZGlzY292ZXIoZGlzY292ZXJ5T3B0aW9ucykudGhlbihmdW5jdGlvbiAod2FsbGV0RGlzY292ZXJ5RGF0YSkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZWREYXRhLCBwcm9taXNlcywgX2xvb3BfMSwgX2ksIF9hLCBrZXlEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnd2FsbGV0RGlzY292ZXJ5RGF0YScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh3YWxsZXREaXNjb3ZlcnlEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9NZXJnZSBhbnkgcHJvcGVydGllcyB0aGF0IHdlcmUgcmV0dXJuZWQgZnJvbSB0aGUgd2FsbGV0cyBzcGVjaWZpYyBkaXNjb3ZlcnkgcHJvY2Vzcy4gVGhpcyBhbGxvd3MgdGhlIHdhbGxldCB0byBhZGQgY3VzdG9tIHByb3BlcnRpZXMgdG8gdGhlIHJlc3BvbnNlIGlmIG5lZWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudHNEYXRhT2JqVG9NZXJnZSA9IF9fYXNzaWduKHt9LCBhY2NvdW50c0RhdGFPYmpUb01lcmdlLCB3YWxsZXREaXNjb3ZlcnlEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFjY291bnRzRGF0YU9ialRvTWVyZ2Uua2V5cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IGtleXM6IHN0cmluZ1tdID0gW107IC8vIElmIHRoZSBkaXNjb3ZlciBmdWN0aW9uIGluIHRoZSB3YWxsZXQgZG9lc24ndCByZXR1cm4gYW55IGtleXMgd2Uga25vdyB0aGUgbG9naW4gZnVuY3Rpb24gaXMgZ29pbmcgdG8gaGF2ZSB0byBwcm9tcHQgdGhlIHVzZXIgdG8gc2VsZWN0IG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHdhbGxldERpc2NvdmVyeURhdGEua2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcdGtleXMgPSB3YWxsZXREaXNjb3ZlcnlEYXRhLmtleXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBjYWxsYmFjayBvZiB0aGlzIGtpbmQgY2FuIGJlIHN1cHBsaWVkIHRvIHRoZSBkaXNjb3ZlciBmdW5jdGlvbiwgd2hpY2ggd2lsbCBhbGxvdyB0aGUgY2FsbGVyIHRvIG1vZGlmeSB0aGUgbGlzdCBvZiBrZXlzIGJlZm9yZSB0aGUgYWNjb3VudCBsb29rdXAgcHJvY2VzcyBoYXBwZW5zLiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZlYXR1cmUgd2FzIGFkZGVkIHNvIHRoYXQga2V5IHJldHVybmVkIGZyb20gdGhlIExlZGdlciBkZXZpY2UgY2FuIGJlIG1vZGlmaWVkIHRvIGhhdmUgYSBFTlUgcHJlZml4IHdoZW4gaW4gdXNlIHdpdGggdGhlIHRoZSBlbnVtaXZvIGNoYWluIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzY292ZXJ5T3B0aW9ucy5rZXlNb2RpZmllckZ1bmMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWREYXRhID0gZGlzY292ZXJ5T3B0aW9ucy5rZXlNb2RpZmllckZ1bmMod2FsbGV0RGlzY292ZXJ5RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXREaXNjb3ZlcnlEYXRhID0gbW9kaWZpZWREYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGRpc2NvdmVyeU9wdGlvbnMua2V5TG9va3VwRnVuYyAhPT0gdW5kZWZpbmVkKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc2NvdmVyeU9wdGlvbnMua2V5TG9va3VwRnVuYyh3YWxsZXREaXNjb3ZlcnlEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzY292ZXJ5T3B0aW9ucy5rZXlMb29rdXBGdW5jKHdhbGxldERpc2NvdmVyeURhdGEsIGZ1bmN0aW9uIChkaXNjb3ZlcmVkQWNjb3VudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRzRGF0YU9ialRvTWVyZ2Uua2V5VG9BY2NvdW50TWFwID0gZGlzY292ZXJlZEFjY291bnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2FjY291bnRzRGF0YU9ialRvTWVyZ2Uoa2V5TG9va3VwRnVuYyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHsgYWNjb3VudHNEYXRhT2JqVG9NZXJnZTogYWNjb3VudHNEYXRhT2JqVG9NZXJnZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBhY2NvdW50c0RhdGFPYmpUb01lcmdlOiBhY2NvdW50c0RhdGFPYmpUb01lcmdlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8xID0gZnVuY3Rpb24gKGtleURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlEYXRhLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlJbmRleCA9IGtleURhdGEuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzY292ZXJEYXRhLmtleVRvQWNjb3VudE1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZEluQ2FjaGUgPSBkaXNjb3ZlckRhdGEua2V5VG9BY2NvdW50TWFwLmZpbmRJbmRleChmdW5jdGlvbiAoeSkgeyByZXR1cm4geS5pbmRleCA9PSBrZXlJbmRleDsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kSW5DYWNoZSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAmJiAhY2FjaGVkICYmIGN0eC5lb3NScGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGN0eC5lb3NScGMuaGlzdG9yeV9nZXRfa2V5X2FjY291bnRzKGtleSkudGhlbihmdW5jdGlvbiAoYWNjb3VudERhdGEpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjY291bnRFbnRyeSwgX2xvb3BfMiwgX2ksIF9hLCBhY2NvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50RW50cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDoga2V5SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhY2NvdW50RGF0YS5hY2NvdW50X25hbWVzLmxlbmd0aCA+IDApKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMiA9IGZ1bmN0aW9uIChhY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGN0eC5lb3NScGMuZ2V0X2FjY291bnQoYWNjb3VudCkudGhlbihmdW5jdGlvbiAoYWNjb3VudEluZm8pIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2ksIF9hLCBwZXJtaXNzaW9uLCBfYiwgX2MsIHBlcm1pc3Npb25LZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgX2EgPSBhY2NvdW50SW5mby5wZXJtaXNzaW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb24gPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9iID0gMCwgX2MgPSBwZXJtaXNzaW9uLnJlcXVpcmVkX2F1dGgua2V5czsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uS2V5ID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZXJtaXNzaW9uS2V5LmtleSA9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudEVudHJ5LmFjY291bnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogYWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb246IHBlcm1pc3Npb24ucGVybV9uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgX2EgPSBhY2NvdW50RGF0YS5hY2NvdW50X25hbWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IF9hLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzUgLyp5aWVsZCoqLywgX2xvb3BfMihhY2NvdW50KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGFjY291bnRFbnRyeV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgX2EgPSB3YWxsZXREaXNjb3ZlcnlEYXRhLmtleXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlEYXRhID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMShrZXlEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRzRGF0YU9ialRvTWVyZ2Uua2V5VG9BY2NvdW50TWFwID0gcmVzdWx0cyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnYWNjb3VudHNEYXRhT2JqVG9NZXJnZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHsgYWNjb3VudHNEYXRhT2JqVG9NZXJnZTogYWNjb3VudHNEYXRhT2JqVG9NZXJnZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgYWNjb3VudHNEYXRhT2JqVG9NZXJnZTogYWNjb3VudHNEYXRhT2JqVG9NZXJnZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNjb3ZlclJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXNjb3ZlckRhdGEua2V5VG9BY2NvdW50TWFwLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzY292ZXJEYXRhID0gX19hc3NpZ24oe30sIGRpc2NvdmVyRGF0YSwgYWNjb3VudHNEYXRhT2JqVG9NZXJnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50c0RhdGFPYmpUb01lcmdlLmtleVRvQWNjb3VudE1hcC5mb3JFYWNoKGZ1bmN0aW9uIChuZXdLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzY292ZXJEYXRhLmtleVRvQWNjb3VudE1hcC5wdXNoKG5ld0tleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc2NvdmVyRGF0YS5rZXlzID0gYWNjb3VudHNEYXRhT2JqVG9NZXJnZS5rZXlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZGlzY292ZXJEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLnJlc29sdmUoZGlzY292ZXJEYXRhKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gd2FsbGV0UHJvdmlkZXIuZGlzY29ubmVjdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3N0YXRlQ29udGFpbmVyLnVwZGF0ZVN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gKF9fYXNzaWduKHt9LCBzdGF0ZSwgeyBjb25uZWN0aW5nOiBmYWxzZSwgY29ubmVjdGVkOiBmYWxzZSwgY29ubmVjdGlvbkVycm9yOiBmYWxzZSwgY29ubmVjdGlvbkVycm9yTWVzc2FnZTogdm9pZCAwIH0pKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEF1dGhlbnRpY2F0aW9uXG4gICAgZnVuY3Rpb24gbG9naW4oYWNjb3VudE5hbWUsIGF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgX3N0YXRlQ29udGFpbmVyLnVwZGF0ZVN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gKF9fYXNzaWduKHt9LCBzdGF0ZSwgeyBhY2NvdW50SW5mbzogdm9pZCAwLCBhdXRoZW50aWNhdGVkOiBmYWxzZSwgYXV0aGVudGljYXRpb25Db25maXJtZWQ6IGZhbHNlLCBhdXRoZW50aWNhdGluZzogdHJ1ZSwgYXV0aGVudGljYXRpb25FcnJvcjogZmFsc2UsIGF1dGhlbnRpY2F0aW9uRXJyb3JNZXNzYWdlOiB2b2lkIDAgfSkpOyB9KTtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBrZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vSWYgd2UndmUgZG9uZSBkaXNjb3ZlcnkgdGhlbiB3ZSBzaG91bGQgYmUgYWJsZSB0byBmaW5kIHRoZSBhY2NvdW50IHRyeWluZyB0byBsb2dpbiBpbiB0aGUgZGlzY292ZXJEYXRhXG4gICAgICAgIGlmIChkaXNjb3ZlckRhdGEua2V5VG9BY2NvdW50TWFwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdzZWUgaWYgd2UgY2FuIGZpbmQgJyArIGFjY291bnROYW1lICsgJyAnICsgYXV0aG9yaXphdGlvbik7XG4gICAgICAgICAgICBpZiAoYWNjb3VudE5hbWUgJiYgYXV0aG9yaXphdGlvbikge1xuICAgICAgICAgICAgICAgIGRpc2NvdmVyRGF0YS5rZXlUb0FjY291bnRNYXAuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXhPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gaW5kZXhPYmouYWNjb3VudHMuZmluZChmdW5jdGlvbiAoYWNjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY291bnQuYWNjb3VudCA9PSBhY2NvdW50TmFtZSAmJiBhY2NvdW50LmF1dGhvcml6YXRpb24gPT0gYXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleE9iai5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGluZGV4T2JqLmtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnTG9naW5nIHdhcyBub3QgYWJsZSB0byBkZXRlcm1pbmUgdGhlIEtleSBhbmQgSW5kZXggZm9yICcgKyBhdXRob3JpemF0aW9uICsgJ0AnICsgYWNjb3VudE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhbGxldFByb3ZpZGVyXG4gICAgICAgICAgICAubG9naW4oYWNjb3VudE5hbWUsIGF1dGhvcml6YXRpb24sIGluZGV4LCBrZXkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAod2FsbGV0QXV0aCkge1xuICAgICAgICAgICAgX3N0YXRlQ29udGFpbmVyLnVwZGF0ZVN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gKF9fYXNzaWduKHt9LCBzdGF0ZSwgeyBhdXRoOiB3YWxsZXRBdXRoLCBhdXRoZW50aWNhdGVkOiB0cnVlLCBhdXRoZW50aWNhdGluZzogZmFsc2UgfSkpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaEFjY291bnRJbmZvKHdhbGxldEF1dGguYWNjb3VudE5hbWUpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGFjY291bnRJbmZvKSB7XG4gICAgICAgICAgICBfc3RhdGVDb250YWluZXIudXBkYXRlU3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAoX19hc3NpZ24oe30sIHN0YXRlLCB7IGFjY291bnRJbmZvOiBhY2NvdW50SW5mbyB9KSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnRJbmZvO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3N0YXRlQ29udGFpbmVyLnVwZGF0ZVN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gKF9fYXNzaWduKHt9LCBzdGF0ZSwgeyBhdXRoZW50aWNhdGluZzogZmFsc2UsIGF1dGhlbnRpY2F0aW9uRXJyb3I6IHRydWUsIGF1dGhlbnRpY2F0aW9uRXJyb3JNZXNzYWdlOiB1dGlsXzEuZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB9KSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ291dCgpIHtcbiAgICAgICAgcmV0dXJuIHdhbGxldFByb3ZpZGVyLmxvZ291dCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3N0YXRlQ29udGFpbmVyLnVwZGF0ZVN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gKF9fYXNzaWduKHt9LCBzdGF0ZSwgeyBhY2NvdW50SW5mbzogdm9pZCAwLCBhdXRoZW50aWNhdGluZzogZmFsc2UsIGF1dGhlbnRpY2F0ZWQ6IGZhbHNlLCBhdXRoZW50aWNhdGlvbkVycm9yOiBmYWxzZSwgYXV0aGVudGljYXRpb25FcnJvck1lc3NhZ2U6IHZvaWQgMCB9KSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaWduQXJiaXRyYXJ5KGRhdGEsIHVzZXJNZXNzYWdlLCBtZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gd2FsbGV0UHJvdmlkZXIuc2lnbkFyYml0cmFyeShkYXRhLCB1c2VyTWVzc2FnZSwgbWV0YWRhdGEpO1xuICAgIH1cbiAgICB2YXIgd2FsbGV0ID0ge1xuICAgICAgICBfaW5zdGFuY2VJZDogX2luc3RhbmNlSWQsXG4gICAgICAgIGN0eDogY3R4LFxuICAgICAgICBwcm92aWRlcjogd2FsbGV0UHJvdmlkZXIsXG4gICAgICAgIGVvc0FwaTogZW9zQXBpLFxuICAgICAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RhdGUoKSB8fCBfX2Fzc2lnbih7fSwgREVGQVVMVF9TVEFURSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNob3J0Y3V0IHN0YXRlIGFjY2Vzc29yc1xuICAgICAgICBnZXQgYXV0aCgpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gKHN0YXRlICYmIHN0YXRlLmF1dGgpIHx8IHZvaWQgMDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGFjY291bnRJbmZvKCkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiAoc3RhdGUgJiYgc3RhdGUuYWNjb3VudEluZm8pIHx8IHZvaWQgMDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gKHN0YXRlICYmIHN0YXRlLmNvbm5lY3RlZCkgfHwgZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBhdXRoZW50aWNhdGVkKCkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiAoc3RhdGUgJiYgc3RhdGUuYXV0aGVudGljYXRlZCkgfHwgZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpblByb2dyZXNzKCkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGlmICghc3RhdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNvbm5lY3RpbmcgPSBzdGF0ZS5jb25uZWN0aW5nLCBhdXRoZW50aWNhdGluZyA9IHN0YXRlLmF1dGhlbnRpY2F0aW5nLCBhY2NvdW50RmV0Y2hpbmcgPSBzdGF0ZS5hY2NvdW50RmV0Y2hpbmc7XG4gICAgICAgICAgICByZXR1cm4gISEoY29ubmVjdGluZyB8fCBhdXRoZW50aWNhdGluZyB8fCBhY2NvdW50RmV0Y2hpbmcpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGlmICghc3RhdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNvbm5lY3RlZCA9IHN0YXRlLmNvbm5lY3RlZCwgYXV0aGVudGljYXRlZCA9IHN0YXRlLmF1dGhlbnRpY2F0ZWQsIGFjY291bnRJbmZvID0gc3RhdGUuYWNjb3VudEluZm87XG4gICAgICAgICAgICByZXR1cm4gISEoY29ubmVjdGVkICYmIGF1dGhlbnRpY2F0ZWQgJiYgYWNjb3VudEluZm8pO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaGFzRXJyb3IoKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbkVycm9yID0gc3RhdGUuY29ubmVjdGlvbkVycm9yLCBhdXRoZW50aWNhdGlvbkVycm9yID0gc3RhdGUuYXV0aGVudGljYXRpb25FcnJvciwgYWNjb3VudEZldGNoRXJyb3IgPSBzdGF0ZS5hY2NvdW50RmV0Y2hFcnJvcjtcbiAgICAgICAgICAgIHJldHVybiAhIShjb25uZWN0aW9uRXJyb3IgfHwgYXV0aGVudGljYXRpb25FcnJvciB8fCBhY2NvdW50RmV0Y2hFcnJvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBlcnJvck1lc3NhZ2UoKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKCF3YWxsZXQuaGFzRXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBjb25uZWN0aW9uRXJyb3JNZXNzYWdlID0gc3RhdGUuY29ubmVjdGlvbkVycm9yTWVzc2FnZSwgYXV0aGVudGljYXRpb25FcnJvck1lc3NhZ2UgPSBzdGF0ZS5hdXRoZW50aWNhdGlvbkVycm9yTWVzc2FnZSwgYWNjb3VudEZldGNoRXJyb3JNZXNzYWdlID0gc3RhdGUuYWNjb3VudEZldGNoRXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIChjb25uZWN0aW9uRXJyb3JNZXNzYWdlIHx8XG4gICAgICAgICAgICAgICAgYXV0aGVudGljYXRpb25FcnJvck1lc3NhZ2UgfHxcbiAgICAgICAgICAgICAgICBhY2NvdW50RmV0Y2hFcnJvck1lc3NhZ2UgfHxcbiAgICAgICAgICAgICAgICAnV2FsbGV0IGNvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdDogY29ubmVjdCxcbiAgICAgICAgZGlzY292ZXI6IGRpc2NvdmVyLFxuICAgICAgICBkaXNjb25uZWN0OiBkaXNjb25uZWN0LFxuICAgICAgICBsb2dpbjogbG9naW4sXG4gICAgICAgIGxvZ291dDogbG9nb3V0LFxuICAgICAgICBmZXRjaEFjY291bnRJbmZvOiBmZXRjaEFjY291bnRJbmZvLFxuICAgICAgICB0ZXJtaW5hdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dvdXQoKS50aGVuKGRpc2Nvbm5lY3QpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGN0eC5kZXRhY2hXYWxsZXQod2FsbGV0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIF9zdGF0ZUNvbnRhaW5lci5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICAgICAgICB9LFxuICAgICAgICBzaWduQXJiaXRyYXJ5OiBzaWduQXJiaXRyYXJ5XG4gICAgfTtcbiAgICByZXR1cm4gd2FsbGV0O1xufVxuZXhwb3J0cy5pbml0V2FsbGV0ID0gaW5pdFdhbGxldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhbGxldC5qcy5tYXAiLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIHRoZVxuLy8gYnJvd3NlciB0aGlzIGlzIGEgbGl0dGxlIGNvbXBsaWNhdGVkIGR1ZSB0byB1bmtub3duIHF1YWxpdHkgb2YgTWF0aC5yYW5kb20oKVxuLy8gYW5kIGluY29uc2lzdGVudCBzdXBwb3J0IGZvciB0aGUgYGNyeXB0b2AgQVBJLiAgV2UgZG8gdGhlIGJlc3Qgd2UgY2FuIHZpYVxuLy8gZmVhdHVyZS1kZXRlY3Rpb25cblxuLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvXG4vLyBpbXBsZW1lbnRhdGlvbi4gQWxzbywgZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIG9uIElFMTEuXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gKHR5cGVvZihjcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZihtc0NyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0bykpO1xuXG5pZiAoZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIC8vIFdIQVRXRyBjcnlwdG8gUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICB2YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xuICAgIHJldHVybiBybmRzODtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIHJuZHMgPSBuZXcgQXJyYXkoMTYpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWF0aFJORygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm5kcztcbiAgfTtcbn1cbiIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuICByZXR1cm4gKFtcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXVxuICBdKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZ2V0TmV0d29ya1VybChfYSkge1xuICAgIHZhciBwcm90b2NvbCA9IF9hLnByb3RvY29sLCBob3N0ID0gX2EuaG9zdCwgcG9ydCA9IF9hLnBvcnQ7XG4gICAgcmV0dXJuIChwcm90b2NvbCA/IHByb3RvY29sIDogJ2h0dHAnKSArIFwiOi8vXCIgKyBob3N0ICsgKHBvcnQgPyBcIjpcIiArIHBvcnQgOiAnJyk7XG59XG5leHBvcnRzLmdldE5ldHdvcmtVcmwgPSBnZXROZXR3b3JrVXJsO1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yLCBmYWxsYmFja01lc3NhZ2UpIHtcbiAgICBpZiAoZmFsbGJhY2tNZXNzYWdlID09PSB2b2lkIDApIHsgZmFsbGJhY2tNZXNzYWdlID0gJ0Vycm9yJzsgfVxuICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnc3RyaW5nJyA/IGVycm9yIDogZXJyb3IubWVzc2FnZSB8fCBmYWxsYmFja01lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFja01lc3NhZ2U7XG59XG5leHBvcnRzLmdldEVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItY29uc3QgKi9cblxuaW1wb3J0IHsgZW5jb2RlIH0gZnJvbSAnQG1zZ3BhY2svbXNncGFjaydcblxuLy8gVGhpcyBmdW5jaXRvbiBjb3BpZWQgZnJvbSBhbGdvU2RrIC0gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kL2pzLWFsZ29yYW5kLXNkay9ibG9iL2RjZWMzOGNjNzkyNmRlN2Y1NDMyOGNlMjhlNzYyOTBmZmVhOWZlNDEvc3JjL2VuY29kaW5nL2VuY29kaW5nLmpzI0wyNFxuLyoqXG4gKiBjb250YWluc0VtcHR5IHJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlIG9iamVjdCdzIHZhbHVlcyBhcmUgZW1wdHksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEVtcHR5IGFycmF5cyBjb25zaWRlcmVkIGVtcHR5XG4gKiBAcGFyYW0gb2JqXG4gKiBAcmV0dXJucyB7e2ZpcnN0RW1wdHlLZXk6IHN0cmluZywgY29udGFpbnNFbXB0eTogYm9vbGVhbn19IHt0cnVlLCBlbXB0eSBrZXl9IGlmIGNvbnRhaW5zIGVtcHR5LCB7ZmFsc2UsIHVuZGVmaW5lZH0gb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zRW1wdHkob2JqOiBhbnkpOiB7IGZpcnN0RW1wdHlLZXk6IHN0cmluZzsgY29udGFpbnNFbXB0eTogYm9vbGVhbiB9IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGlmICghb2JqW2tleV0gfHwgb2JqW2tleV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IGNvbnRhaW5zRW1wdHk6IHRydWUsIGZpcnN0RW1wdHlLZXk6IGtleSB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGNvbnRhaW5zRW1wdHk6IGZhbHNlLCBmaXJzdEVtcHR5S2V5OiB1bmRlZmluZWQgfVxufVxuXG4vLyBUaGlzIGZ1bmNpdG9uIGNvcGllZCBmcm9tIGFsZ29TZGsgLSBodHRwczovL2dpdGh1Yi5jb20vYWxnb3JhbmQvanMtYWxnb3JhbmQtc2RrL2Jsb2IvZGNlYzM4Y2M3OTI2ZGU3ZjU0MzI4Y2UyOGU3NjI5MGZmZWE5ZmU0MS9zcmMvZW5jb2RpbmcvZW5jb2RpbmcuanMjTDQxXG4vKipcbiAqIGVuY29kZSBlbmNvZGVzIG9iamVjdHMgdXNpbmcgbXNncGFja1xuICogQHBhcmFtIG9iaiBhIGRpY3Rpb25hcnkgdG8gYmUgZW5jb2RlZC4gTXVzdCBub3QgY29udGFpbiBlbXB0eSBvciAwIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBtc2dwYWNrIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcbiAqIEB0aHJvd3MgRXJyb3IgY29udGFpbmluZyBFUlJPUl9DT05UQUlOU19FTVBUWV9TVFJJTkcgaWYgdGhlIG9iamVjdCBjb250YWlucyBlbXB0eSBvciB6ZXJvIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbXNnUGFja0VuY29kZShvYmo6IGFueSkge1xuICBjb25zdCBFUlJPUl9DT05UQUlOU19FTVBUWV9TVFJJTkcgPVxuICAgICdUaGUgb2JqZWN0IGNvbnRhaW5zIGVtcHR5IG9yIDAgdmFsdWVzLiBGaXJzdCBlbXB0eSBvciAwIHZhbHVlIGVuY291bnRlcmVkIGR1cmluZyBlbmNvZGluZzogJ1xuICAvLyBDaGVjayBmb3IgZW1wdHkgdmFsdWVzXG4gIGNvbnN0IGVtcHR5Q2hlY2sgPSBjb250YWluc0VtcHR5KG9iailcbiAgaWYgKGVtcHR5Q2hlY2suY29udGFpbnNFbXB0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9DT05UQUlOU19FTVBUWV9TVFJJTkcgKyBlbXB0eUNoZWNrLmZpcnN0RW1wdHlLZXkpXG4gIH1cblxuICAvLyBlbmFibGUgdGhlIGNhbm9uaWNhbCBvcHRpb25cbiAgY29uc3Qgb3B0aW9ucyA9IHsgc29ydEtleXM6IHRydWUgfVxuICByZXR1cm4gZW5jb2RlKG9iaiwgb3B0aW9ucylcbn1cbiIsImltcG9ydCB7IEVuY29kZXIgfSBmcm9tIFwiLi9FbmNvZGVyLm1qc1wiO1xudmFyIGRlZmF1bHRFbmNvZGVPcHRpb25zID0ge307XG4vKipcbiAqIEl0IGVuY29kZXMgYHZhbHVlYCBpbiB0aGUgTWVzc2FnZVBhY2sgZm9ybWF0IGFuZFxuICogcmV0dXJucyBhIGJ5dGUgYnVmZmVyLlxuICpcbiAqIFRoZSByZXR1cm5lZCBidWZmZXIgaXMgYSBzbGljZSBvZiBhIGxhcmdlciBgQXJyYXlCdWZmZXJgLCBzbyB5b3UgaGF2ZSB0byB1c2UgaXRzIGAjYnl0ZU9mZnNldGAgYW5kIGAjYnl0ZUxlbmd0aGAgaW4gb3JkZXIgdG8gY29udmVydCBpdCB0byBhbm90aGVyIHR5cGVkIGFycmF5cyBpbmNsdWRpbmcgTm9kZUpTIGBCdWZmZXJgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gZGVmYXVsdEVuY29kZU9wdGlvbnM7IH1cbiAgICB2YXIgZW5jb2RlciA9IG5ldyBFbmNvZGVyKG9wdGlvbnMuZXh0ZW5zaW9uQ29kZWMsIG9wdGlvbnMuY29udGV4dCwgb3B0aW9ucy5tYXhEZXB0aCwgb3B0aW9ucy5pbml0aWFsQnVmZmVyU2l6ZSwgb3B0aW9ucy5zb3J0S2V5cywgb3B0aW9ucy5mb3JjZUZsb2F0MzIsIG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkLCBvcHRpb25zLmZvcmNlSW50ZWdlclRvRmxvYXQpO1xuICAgIHJldHVybiBlbmNvZGVyLmVuY29kZVNoYXJlZFJlZih2YWx1ZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmNvZGUubWpzLm1hcCIsImltcG9ydCB7IHV0ZjhFbmNvZGVKcywgdXRmOENvdW50LCBURVhUX0VOQ09ERVJfVEhSRVNIT0xELCB1dGY4RW5jb2RlVEUgfSBmcm9tIFwiLi91dGlscy91dGY4Lm1qc1wiO1xuaW1wb3J0IHsgRXh0ZW5zaW9uQ29kZWMgfSBmcm9tIFwiLi9FeHRlbnNpb25Db2RlYy5tanNcIjtcbmltcG9ydCB7IHNldEludDY0LCBzZXRVaW50NjQgfSBmcm9tIFwiLi91dGlscy9pbnQubWpzXCI7XG5pbXBvcnQgeyBlbnN1cmVVaW50OEFycmF5IH0gZnJvbSBcIi4vdXRpbHMvdHlwZWRBcnJheXMubWpzXCI7XG5leHBvcnQgdmFyIERFRkFVTFRfTUFYX0RFUFRIID0gMTAwO1xuZXhwb3J0IHZhciBERUZBVUxUX0lOSVRJQUxfQlVGRkVSX1NJWkUgPSAyMDQ4O1xudmFyIEVuY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW5jb2RlcihleHRlbnNpb25Db2RlYywgY29udGV4dCwgbWF4RGVwdGgsIGluaXRpYWxCdWZmZXJTaXplLCBzb3J0S2V5cywgZm9yY2VGbG9hdDMyLCBpZ25vcmVVbmRlZmluZWQsIGZvcmNlSW50ZWdlclRvRmxvYXQpIHtcbiAgICAgICAgaWYgKGV4dGVuc2lvbkNvZGVjID09PSB2b2lkIDApIHsgZXh0ZW5zaW9uQ29kZWMgPSBFeHRlbnNpb25Db2RlYy5kZWZhdWx0Q29kZWM7IH1cbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gdW5kZWZpbmVkOyB9XG4gICAgICAgIGlmIChtYXhEZXB0aCA9PT0gdm9pZCAwKSB7IG1heERlcHRoID0gREVGQVVMVF9NQVhfREVQVEg7IH1cbiAgICAgICAgaWYgKGluaXRpYWxCdWZmZXJTaXplID09PSB2b2lkIDApIHsgaW5pdGlhbEJ1ZmZlclNpemUgPSBERUZBVUxUX0lOSVRJQUxfQlVGRkVSX1NJWkU7IH1cbiAgICAgICAgaWYgKHNvcnRLZXlzID09PSB2b2lkIDApIHsgc29ydEtleXMgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoZm9yY2VGbG9hdDMyID09PSB2b2lkIDApIHsgZm9yY2VGbG9hdDMyID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGlnbm9yZVVuZGVmaW5lZCA9PT0gdm9pZCAwKSB7IGlnbm9yZVVuZGVmaW5lZCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChmb3JjZUludGVnZXJUb0Zsb2F0ID09PSB2b2lkIDApIHsgZm9yY2VJbnRlZ2VyVG9GbG9hdCA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uQ29kZWMgPSBleHRlbnNpb25Db2RlYztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5tYXhEZXB0aCA9IG1heERlcHRoO1xuICAgICAgICB0aGlzLmluaXRpYWxCdWZmZXJTaXplID0gaW5pdGlhbEJ1ZmZlclNpemU7XG4gICAgICAgIHRoaXMuc29ydEtleXMgPSBzb3J0S2V5cztcbiAgICAgICAgdGhpcy5mb3JjZUZsb2F0MzIgPSBmb3JjZUZsb2F0MzI7XG4gICAgICAgIHRoaXMuaWdub3JlVW5kZWZpbmVkID0gaWdub3JlVW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmZvcmNlSW50ZWdlclRvRmxvYXQgPSBmb3JjZUludGVnZXJUb0Zsb2F0O1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIodGhpcy5pbml0aWFsQnVmZmVyU2l6ZSkpO1xuICAgICAgICB0aGlzLmJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGhpcy52aWV3LmJ1ZmZlcik7XG4gICAgfVxuICAgIEVuY29kZXIucHJvdG90eXBlLnJlaW5pdGlhbGl6ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGFsbW9zdCBlcXVpdmFsZW50IHRvIHtAbGluayBFbmNvZGVyI2VuY29kZX0sIGJ1dCBpdCByZXR1cm5zIGFuIHJlZmVyZW5jZSBvZiB0aGUgZW5jb2RlcidzIGludGVybmFsIGJ1ZmZlciBhbmQgdGh1cyBtdWNoIGZhc3RlciB0aGFuIHtAbGluayBFbmNvZGVyI2VuY29kZX0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBFbmNvZGVzIHRoZSBvYmplY3QgYW5kIHJldHVybnMgYSBzaGFyZWQgcmVmZXJlbmNlIHRoZSBlbmNvZGVyJ3MgaW50ZXJuYWwgYnVmZmVyLlxuICAgICAqL1xuICAgIEVuY29kZXIucHJvdG90eXBlLmVuY29kZVNoYXJlZFJlZiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgdGhpcy5yZWluaXRpYWxpemVTdGF0ZSgpO1xuICAgICAgICB0aGlzLmRvRW5jb2RlKG9iamVjdCwgMSk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLnN1YmFycmF5KDAsIHRoaXMucG9zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEVuY29kZXMgdGhlIG9iamVjdCBhbmQgcmV0dXJucyBhIGNvcHkgb2YgdGhlIGVuY29kZXIncyBpbnRlcm5hbCBidWZmZXIuXG4gICAgICovXG4gICAgRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICB0aGlzLnJlaW5pdGlhbGl6ZVN0YXRlKCk7XG4gICAgICAgIHRoaXMuZG9FbmNvZGUob2JqZWN0LCAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMuc2xpY2UoMCwgdGhpcy5wb3MpO1xuICAgIH07XG4gICAgRW5jb2Rlci5wcm90b3R5cGUuZG9FbmNvZGUgPSBmdW5jdGlvbiAob2JqZWN0LCBkZXB0aCkge1xuICAgICAgICBpZiAoZGVwdGggPiB0aGlzLm1heERlcHRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gZGVlcCBvYmplY3RzIGluIGRlcHRoIFwiLmNvbmNhdChkZXB0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVOaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVCb29sZWFuKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVOdW1iZXIob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLmVuY29kZVN0cmluZyhvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVPYmplY3Qob2JqZWN0LCBkZXB0aCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVuY29kZXIucHJvdG90eXBlLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlID0gZnVuY3Rpb24gKHNpemVUb1dyaXRlKSB7XG4gICAgICAgIHZhciByZXF1aXJlZFNpemUgPSB0aGlzLnBvcyArIHNpemVUb1dyaXRlO1xuICAgICAgICBpZiAodGhpcy52aWV3LmJ5dGVMZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplQnVmZmVyKHJlcXVpcmVkU2l6ZSAqIDIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbmNvZGVyLnByb3RvdHlwZS5yZXNpemVCdWZmZXIgPSBmdW5jdGlvbiAobmV3U2l6ZSkge1xuICAgICAgICB2YXIgbmV3QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKG5ld1NpemUpO1xuICAgICAgICB2YXIgbmV3Qnl0ZXMgPSBuZXcgVWludDhBcnJheShuZXdCdWZmZXIpO1xuICAgICAgICB2YXIgbmV3VmlldyA9IG5ldyBEYXRhVmlldyhuZXdCdWZmZXIpO1xuICAgICAgICBuZXdCeXRlcy5zZXQodGhpcy5ieXRlcyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ld1ZpZXc7XG4gICAgICAgIHRoaXMuYnl0ZXMgPSBuZXdCeXRlcztcbiAgICB9O1xuICAgIEVuY29kZXIucHJvdG90eXBlLmVuY29kZU5pbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy53cml0ZVU4KDB4YzApO1xuICAgIH07XG4gICAgRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlQm9vbGVhbiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVVOCgweGMyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVVOCgweGMzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlTnVtYmVyID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIob2JqZWN0KSAmJiAhdGhpcy5mb3JjZUludGVnZXJUb0Zsb2F0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0IDwgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwb3NpdGl2ZSBmaXhpbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZVU4KG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdCA8IDB4MTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVpbnQgOFxuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlVTgoMHhjYyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVVOChvYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3QgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVpbnQgMTZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZVU4KDB4Y2QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlVTE2KG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdCA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVpbnQgMzJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZVU4KDB4Y2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlVTMyKG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB1aW50IDY0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVVOCgweGNmKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZVU2NChvYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QgPj0gLTB4MjApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVnYXRpdmUgZml4aW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVVOCgweGUwIHwgKG9iamVjdCArIDB4MjApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0ID49IC0weDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGludCA4XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVVOCgweGQwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZUk4KG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdCA+PSAtMHg4MDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGludCAxNlxuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlVTgoMHhkMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVJMTYob2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0ID49IC0weDgwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGludCAzMlxuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlVTgoMHhkMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVJMzIob2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGludCA2NFxuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlVTgoMHhkMyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVJNjQob2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBub24taW50ZWdlciBudW1iZXJzXG4gICAgICAgICAgICBpZiAodGhpcy5mb3JjZUZsb2F0MzIpIHtcbiAgICAgICAgICAgICAgICAvLyBmbG9hdCAzMlxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVVOCgweGNhKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlRjMyKG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmbG9hdCA2NFxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVVOCgweGNiKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlRjY0KG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVuY29kZXIucHJvdG90eXBlLndyaXRlU3RyaW5nSGVhZGVyID0gZnVuY3Rpb24gKGJ5dGVMZW5ndGgpIHtcbiAgICAgICAgaWYgKGJ5dGVMZW5ndGggPCAzMikge1xuICAgICAgICAgICAgLy8gZml4c3RyXG4gICAgICAgICAgICB0aGlzLndyaXRlVTgoMHhhMCArIGJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGVMZW5ndGggPCAweDEwMCkge1xuICAgICAgICAgICAgLy8gc3RyIDhcbiAgICAgICAgICAgIHRoaXMud3JpdGVVOCgweGQ5KTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVVOChieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlTGVuZ3RoIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgLy8gc3RyIDE2XG4gICAgICAgICAgICB0aGlzLndyaXRlVTgoMHhkYSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlVTE2KGJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGVMZW5ndGggPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgLy8gc3RyIDMyXG4gICAgICAgICAgICB0aGlzLndyaXRlVTgoMHhkYik7XG4gICAgICAgICAgICB0aGlzLndyaXRlVTMyKGJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vIGxvbmcgc3RyaW5nOiBcIi5jb25jYXQoYnl0ZUxlbmd0aCwgXCIgYnl0ZXMgaW4gVVRGLThcIikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGVTdHJpbmcgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIHZhciBtYXhIZWFkZXJTaXplID0gMSArIDQ7XG4gICAgICAgIHZhciBzdHJMZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuICAgICAgICBpZiAoc3RyTGVuZ3RoID4gVEVYVF9FTkNPREVSX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSB1dGY4Q291bnQob2JqZWN0KTtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUobWF4SGVhZGVyU2l6ZSArIGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy53cml0ZVN0cmluZ0hlYWRlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIHV0ZjhFbmNvZGVURShvYmplY3QsIHRoaXMuYnl0ZXMsIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IGJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYnl0ZUxlbmd0aCA9IHV0ZjhDb3VudChvYmplY3QpO1xuICAgICAgICAgICAgdGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZShtYXhIZWFkZXJTaXplICsgYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLndyaXRlU3RyaW5nSGVhZGVyKGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgdXRmOEVuY29kZUpzKG9iamVjdCwgdGhpcy5ieXRlcywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCwgZGVwdGgpIHtcbiAgICAgICAgLy8gdHJ5IHRvIGVuY29kZSBvYmplY3RzIHdpdGggY3VzdG9tIGNvZGVjIGZpcnN0IG9mIG5vbi1wcmltaXRpdmVzXG4gICAgICAgIHZhciBleHQgPSB0aGlzLmV4dGVuc2lvbkNvZGVjLnRyeVRvRW5jb2RlKG9iamVjdCwgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgaWYgKGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUV4dGVuc2lvbihleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVBcnJheShvYmplY3QsIGRlcHRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcob2JqZWN0KSkge1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVCaW5hcnkob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLmVuY29kZU1hcChvYmplY3QsIGRlcHRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN5bWJvbCwgZnVuY3Rpb24gYW5kIG90aGVyIHNwZWNpYWwgb2JqZWN0IGNvbWUgaGVyZSB1bmxlc3MgZXh0ZW5zaW9uQ29kZWMgaGFuZGxlcyB0aGVtLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG9iamVjdDogXCIuY29uY2F0KE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkob2JqZWN0KSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGVCaW5hcnkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIHZhciBzaXplID0gb2JqZWN0LmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChzaXplIDwgMHgxMDApIHtcbiAgICAgICAgICAgIC8vIGJpbiA4XG4gICAgICAgICAgICB0aGlzLndyaXRlVTgoMHhjNCk7XG4gICAgICAgICAgICB0aGlzLndyaXRlVTgoc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIC8vIGJpbiAxNlxuICAgICAgICAgICAgdGhpcy53cml0ZVU4KDB4YzUpO1xuICAgICAgICAgICAgdGhpcy53cml0ZVUxNihzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgIC8vIGJpbiAzMlxuICAgICAgICAgICAgdGhpcy53cml0ZVU4KDB4YzYpO1xuICAgICAgICAgICAgdGhpcy53cml0ZVUzMihzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvbyBsYXJnZSBiaW5hcnk6IFwiLmNvbmNhdChzaXplKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzID0gZW5zdXJlVWludDhBcnJheShvYmplY3QpO1xuICAgICAgICB0aGlzLndyaXRlVThhKGJ5dGVzKTtcbiAgICB9O1xuICAgIEVuY29kZXIucHJvdG90eXBlLmVuY29kZUFycmF5ID0gZnVuY3Rpb24gKG9iamVjdCwgZGVwdGgpIHtcbiAgICAgICAgdmFyIHNpemUgPSBvYmplY3QubGVuZ3RoO1xuICAgICAgICBpZiAoc2l6ZSA8IDE2KSB7XG4gICAgICAgICAgICAvLyBmaXhhcnJheVxuICAgICAgICAgICAgdGhpcy53cml0ZVU4KDB4OTAgKyBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgLy8gYXJyYXkgMTZcbiAgICAgICAgICAgIHRoaXMud3JpdGVVOCgweGRjKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVVMTYoc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgICAgICAvLyBhcnJheSAzMlxuICAgICAgICAgICAgdGhpcy53cml0ZVU4KDB4ZGQpO1xuICAgICAgICAgICAgdGhpcy53cml0ZVUzMihzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvbyBsYXJnZSBhcnJheTogXCIuY29uY2F0KHNpemUpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG9iamVjdF8xID0gb2JqZWN0OyBfaSA8IG9iamVjdF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBvYmplY3RfMVtfaV07XG4gICAgICAgICAgICB0aGlzLmRvRW5jb2RlKGl0ZW0sIGRlcHRoICsgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVuY29kZXIucHJvdG90eXBlLmNvdW50V2l0aG91dFVuZGVmaW5lZCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleXMpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBrZXlzXzEgPSBrZXlzOyBfaSA8IGtleXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKG9iamVjdFtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9O1xuICAgIEVuY29kZXIucHJvdG90eXBlLmVuY29kZU1hcCA9IGZ1bmN0aW9uIChvYmplY3QsIGRlcHRoKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICAgICAgaWYgKHRoaXMuc29ydEtleXMpIHtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaXplID0gdGhpcy5pZ25vcmVVbmRlZmluZWQgPyB0aGlzLmNvdW50V2l0aG91dFVuZGVmaW5lZChvYmplY3QsIGtleXMpIDoga2V5cy5sZW5ndGg7XG4gICAgICAgIGlmIChzaXplIDwgMTYpIHtcbiAgICAgICAgICAgIC8vIGZpeG1hcFxuICAgICAgICAgICAgdGhpcy53cml0ZVU4KDB4ODAgKyBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgLy8gbWFwIDE2XG4gICAgICAgICAgICB0aGlzLndyaXRlVTgoMHhkZSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlVTE2KHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgLy8gbWFwIDMyXG4gICAgICAgICAgICB0aGlzLndyaXRlVTgoMHhkZik7XG4gICAgICAgICAgICB0aGlzLndyaXRlVTMyKHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vIGxhcmdlIG1hcCBvYmplY3Q6IFwiLmNvbmNhdChzaXplKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBrZXlzXzIgPSBrZXlzOyBfaSA8IGtleXNfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzXzJbX2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBpZiAoISh0aGlzLmlnbm9yZVVuZGVmaW5lZCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5jb2RlU3RyaW5nKGtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0VuY29kZSh2YWx1ZSwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlRXh0ZW5zaW9uID0gZnVuY3Rpb24gKGV4dCkge1xuICAgICAgICB2YXIgc2l6ZSA9IGV4dC5kYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKHNpemUgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIGZpeGV4dCAxXG4gICAgICAgICAgICB0aGlzLndyaXRlVTgoMHhkNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PT0gMikge1xuICAgICAgICAgICAgLy8gZml4ZXh0IDJcbiAgICAgICAgICAgIHRoaXMud3JpdGVVOCgweGQ1KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplID09PSA0KSB7XG4gICAgICAgICAgICAvLyBmaXhleHQgNFxuICAgICAgICAgICAgdGhpcy53cml0ZVU4KDB4ZDYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT09IDgpIHtcbiAgICAgICAgICAgIC8vIGZpeGV4dCA4XG4gICAgICAgICAgICB0aGlzLndyaXRlVTgoMHhkNyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PT0gMTYpIHtcbiAgICAgICAgICAgIC8vIGZpeGV4dCAxNlxuICAgICAgICAgICAgdGhpcy53cml0ZVU4KDB4ZDgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPCAweDEwMCkge1xuICAgICAgICAgICAgLy8gZXh0IDhcbiAgICAgICAgICAgIHRoaXMud3JpdGVVOCgweGM3KTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVVOChzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgLy8gZXh0IDE2XG4gICAgICAgICAgICB0aGlzLndyaXRlVTgoMHhjOCk7XG4gICAgICAgICAgICB0aGlzLndyaXRlVTE2KHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgLy8gZXh0IDMyXG4gICAgICAgICAgICB0aGlzLndyaXRlVTgoMHhjOSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlVTMyKHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vIGxhcmdlIGV4dGVuc2lvbiBvYmplY3Q6IFwiLmNvbmNhdChzaXplKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZUk4KGV4dC50eXBlKTtcbiAgICAgICAgdGhpcy53cml0ZVU4YShleHQuZGF0YSk7XG4gICAgfTtcbiAgICBFbmNvZGVyLnByb3RvdHlwZS53cml0ZVU4ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoMSk7XG4gICAgICAgIHRoaXMudmlldy5zZXRVaW50OCh0aGlzLnBvcywgdmFsdWUpO1xuICAgICAgICB0aGlzLnBvcysrO1xuICAgIH07XG4gICAgRW5jb2Rlci5wcm90b3R5cGUud3JpdGVVOGEgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBzaXplID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZShzaXplKTtcbiAgICAgICAgdGhpcy5ieXRlcy5zZXQodmFsdWVzLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IHNpemU7XG4gICAgfTtcbiAgICBFbmNvZGVyLnByb3RvdHlwZS53cml0ZUk4ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoMSk7XG4gICAgICAgIHRoaXMudmlldy5zZXRJbnQ4KHRoaXMucG9zLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMucG9zKys7XG4gICAgfTtcbiAgICBFbmNvZGVyLnByb3RvdHlwZS53cml0ZVUxNiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDIpO1xuICAgICAgICB0aGlzLnZpZXcuc2V0VWludDE2KHRoaXMucG9zLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgfTtcbiAgICBFbmNvZGVyLnByb3RvdHlwZS53cml0ZUkxNiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDIpO1xuICAgICAgICB0aGlzLnZpZXcuc2V0SW50MTYodGhpcy5wb3MsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICB9O1xuICAgIEVuY29kZXIucHJvdG90eXBlLndyaXRlVTMyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoNCk7XG4gICAgICAgIHRoaXMudmlldy5zZXRVaW50MzIodGhpcy5wb3MsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICB9O1xuICAgIEVuY29kZXIucHJvdG90eXBlLndyaXRlSTMyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoNCk7XG4gICAgICAgIHRoaXMudmlldy5zZXRJbnQzMih0aGlzLnBvcywgdmFsdWUpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH07XG4gICAgRW5jb2Rlci5wcm90b3R5cGUud3JpdGVGMzIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSg0KTtcbiAgICAgICAgdGhpcy52aWV3LnNldEZsb2F0MzIodGhpcy5wb3MsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICB9O1xuICAgIEVuY29kZXIucHJvdG90eXBlLndyaXRlRjY0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoOCk7XG4gICAgICAgIHRoaXMudmlldy5zZXRGbG9hdDY0KHRoaXMucG9zLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfTtcbiAgICBFbmNvZGVyLnByb3RvdHlwZS53cml0ZVU2NCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDgpO1xuICAgICAgICBzZXRVaW50NjQodGhpcy52aWV3LCB0aGlzLnBvcywgdmFsdWUpO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgIH07XG4gICAgRW5jb2Rlci5wcm90b3R5cGUud3JpdGVJNjQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSg4KTtcbiAgICAgICAgc2V0SW50NjQodGhpcy52aWV3LCB0aGlzLnBvcywgdmFsdWUpO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgIH07XG4gICAgcmV0dXJuIEVuY29kZXI7XG59KCkpO1xuZXhwb3J0IHsgRW5jb2RlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW5jb2Rlci5tanMubWFwIiwiLy8gRXh0ZW5zaW9uQ29kZWMgdG8gaGFuZGxlIE1lc3NhZ2VQYWNrIGV4dGVuc2lvbnNcbmltcG9ydCB7IEV4dERhdGEgfSBmcm9tIFwiLi9FeHREYXRhLm1qc1wiO1xuaW1wb3J0IHsgdGltZXN0YW1wRXh0ZW5zaW9uIH0gZnJvbSBcIi4vdGltZXN0YW1wLm1qc1wiO1xudmFyIEV4dGVuc2lvbkNvZGVjID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkNvZGVjKCkge1xuICAgICAgICAvLyBidWlsdC1pbiBleHRlbnNpb25zXG4gICAgICAgIHRoaXMuYnVpbHRJbkVuY29kZXJzID0gW107XG4gICAgICAgIHRoaXMuYnVpbHRJbkRlY29kZXJzID0gW107XG4gICAgICAgIC8vIGN1c3RvbSBleHRlbnNpb25zXG4gICAgICAgIHRoaXMuZW5jb2RlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWNvZGVycyA9IFtdO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRpbWVzdGFtcEV4dGVuc2lvbik7XG4gICAgfVxuICAgIEV4dGVuc2lvbkNvZGVjLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGUsIGVuY29kZSA9IF9hLmVuY29kZSwgZGVjb2RlID0gX2EuZGVjb2RlO1xuICAgICAgICBpZiAodHlwZSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBjdXN0b20gZXh0ZW5zaW9uc1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVyc1t0eXBlXSA9IGVuY29kZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlcnNbdHlwZV0gPSBkZWNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBidWlsdC1pbiBleHRlbnNpb25zXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAxICsgdHlwZTtcbiAgICAgICAgICAgIHRoaXMuYnVpbHRJbkVuY29kZXJzW2luZGV4XSA9IGVuY29kZTtcbiAgICAgICAgICAgIHRoaXMuYnVpbHRJbkRlY29kZXJzW2luZGV4XSA9IGRlY29kZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXh0ZW5zaW9uQ29kZWMucHJvdG90eXBlLnRyeVRvRW5jb2RlID0gZnVuY3Rpb24gKG9iamVjdCwgY29udGV4dCkge1xuICAgICAgICAvLyBidWlsdC1pbiBleHRlbnNpb25zXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5idWlsdEluRW5jb2RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlbmNvZGVFeHQgPSB0aGlzLmJ1aWx0SW5FbmNvZGVyc1tpXTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVFeHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZW5jb2RlRXh0KG9iamVjdCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IC0xIC0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHREYXRhKHR5cGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjdXN0b20gZXh0ZW5zaW9uc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW5jb2RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlbmNvZGVFeHQgPSB0aGlzLmVuY29kZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGVuY29kZUV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBlbmNvZGVFeHQob2JqZWN0LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHREYXRhKHR5cGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRXh0RGF0YSkge1xuICAgICAgICAgICAgLy8gdG8ga2VlcCBFeHREYXRhIGFzIGlzXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uQ29kZWMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChkYXRhLCB0eXBlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBkZWNvZGVFeHQgPSB0eXBlIDwgMCA/IHRoaXMuYnVpbHRJbkRlY29kZXJzWy0xIC0gdHlwZV0gOiB0aGlzLmRlY29kZXJzW3R5cGVdO1xuICAgICAgICBpZiAoZGVjb2RlRXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlRXh0KGRhdGEsIHR5cGUsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVjb2RlKCkgZG9lcyBub3QgZmFpbCwgcmV0dXJucyBFeHREYXRhIGluc3RlYWQuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4dERhdGEodHlwZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV4dGVuc2lvbkNvZGVjLmRlZmF1bHRDb2RlYyA9IG5ldyBFeHRlbnNpb25Db2RlYygpO1xuICAgIHJldHVybiBFeHRlbnNpb25Db2RlYztcbn0oKSk7XG5leHBvcnQgeyBFeHRlbnNpb25Db2RlYyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXh0ZW5zaW9uQ29kZWMubWpzLm1hcCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tc2dwYWNrL21zZ3BhY2svYmxvYi9tYXN0ZXIvc3BlYy5tZCN0aW1lc3RhbXAtZXh0ZW5zaW9uLXR5cGVcbmltcG9ydCB7IERlY29kZUVycm9yIH0gZnJvbSBcIi4vRGVjb2RlRXJyb3IubWpzXCI7XG5pbXBvcnQgeyBnZXRJbnQ2NCwgc2V0SW50NjQgfSBmcm9tIFwiLi91dGlscy9pbnQubWpzXCI7XG5leHBvcnQgdmFyIEVYVF9USU1FU1RBTVAgPSAtMTtcbnZhciBUSU1FU1RBTVAzMl9NQVhfU0VDID0gMHgxMDAwMDAwMDAgLSAxOyAvLyAzMi1iaXQgdW5zaWduZWQgaW50XG52YXIgVElNRVNUQU1QNjRfTUFYX1NFQyA9IDB4NDAwMDAwMDAwIC0gMTsgLy8gMzQtYml0IHVuc2lnbmVkIGludFxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVRpbWVTcGVjVG9UaW1lc3RhbXAoX2EpIHtcbiAgICB2YXIgc2VjID0gX2Euc2VjLCBuc2VjID0gX2EubnNlYztcbiAgICBpZiAoc2VjID49IDAgJiYgbnNlYyA+PSAwICYmIHNlYyA8PSBUSU1FU1RBTVA2NF9NQVhfU0VDKSB7XG4gICAgICAgIC8vIEhlcmUgc2VjID49IDAgJiYgbnNlYyA+PSAwXG4gICAgICAgIGlmIChuc2VjID09PSAwICYmIHNlYyA8PSBUSU1FU1RBTVAzMl9NQVhfU0VDKSB7XG4gICAgICAgICAgICAvLyB0aW1lc3RhbXAgMzIgPSB7IHNlYzMyICh1bnNpZ25lZCkgfVxuICAgICAgICAgICAgdmFyIHJ2ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhydi5idWZmZXIpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgc2VjKTtcbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRpbWVzdGFtcCA2NCA9IHsgbnNlYzMwICh1bnNpZ25lZCksIHNlYzM0ICh1bnNpZ25lZCkgfVxuICAgICAgICAgICAgdmFyIHNlY0hpZ2ggPSBzZWMgLyAweDEwMDAwMDAwMDtcbiAgICAgICAgICAgIHZhciBzZWNMb3cgPSBzZWMgJiAweGZmZmZmZmZmO1xuICAgICAgICAgICAgdmFyIHJ2ID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhydi5idWZmZXIpO1xuICAgICAgICAgICAgLy8gbnNlYzMwIHwgc2VjSGlnaDJcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKDAsIChuc2VjIDw8IDIpIHwgKHNlY0hpZ2ggJiAweDMpKTtcbiAgICAgICAgICAgIC8vIHNlY0xvdzMyXG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMig0LCBzZWNMb3cpO1xuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyB0aW1lc3RhbXAgOTYgPSB7IG5zZWMzMiAodW5zaWduZWQpLCBzZWM2NCAoc2lnbmVkKSB9XG4gICAgICAgIHZhciBydiA9IG5ldyBVaW50OEFycmF5KDEyKTtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcocnYuYnVmZmVyKTtcbiAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgbnNlYyk7XG4gICAgICAgIHNldEludDY0KHZpZXcsIDQsIHNlYyk7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlRGF0ZVRvVGltZVNwZWMoZGF0ZSkge1xuICAgIHZhciBtc2VjID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgdmFyIHNlYyA9IE1hdGguZmxvb3IobXNlYyAvIDFlMyk7XG4gICAgdmFyIG5zZWMgPSAobXNlYyAtIHNlYyAqIDFlMykgKiAxZTY7XG4gICAgLy8gTm9ybWFsaXplcyB7IHNlYywgbnNlYyB9IHRvIGVuc3VyZSBuc2VjIGlzIHVuc2lnbmVkLlxuICAgIHZhciBuc2VjSW5TZWMgPSBNYXRoLmZsb29yKG5zZWMgLyAxZTkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlYzogc2VjICsgbnNlY0luU2VjLFxuICAgICAgICBuc2VjOiBuc2VjIC0gbnNlY0luU2VjICogMWU5LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlVGltZXN0YW1wRXh0ZW5zaW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHZhciB0aW1lU3BlYyA9IGVuY29kZURhdGVUb1RpbWVTcGVjKG9iamVjdCk7XG4gICAgICAgIHJldHVybiBlbmNvZGVUaW1lU3BlY1RvVGltZXN0YW1wKHRpbWVTcGVjKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUaW1lc3RhbXBUb1RpbWVTcGVjKGRhdGEpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgIC8vIGRhdGEgbWF5IGJlIDMyLCA2NCwgb3IgOTYgYml0c1xuICAgIHN3aXRjaCAoZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgLy8gdGltZXN0YW1wIDMyID0geyBzZWMzMiB9XG4gICAgICAgICAgICB2YXIgc2VjID0gdmlldy5nZXRVaW50MzIoMCk7XG4gICAgICAgICAgICB2YXIgbnNlYyA9IDA7XG4gICAgICAgICAgICByZXR1cm4geyBzZWM6IHNlYywgbnNlYzogbnNlYyB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgODoge1xuICAgICAgICAgICAgLy8gdGltZXN0YW1wIDY0ID0geyBuc2VjMzAsIHNlYzM0IH1cbiAgICAgICAgICAgIHZhciBuc2VjMzBBbmRTZWNIaWdoMiA9IHZpZXcuZ2V0VWludDMyKDApO1xuICAgICAgICAgICAgdmFyIHNlY0xvdzMyID0gdmlldy5nZXRVaW50MzIoNCk7XG4gICAgICAgICAgICB2YXIgc2VjID0gKG5zZWMzMEFuZFNlY0hpZ2gyICYgMHgzKSAqIDB4MTAwMDAwMDAwICsgc2VjTG93MzI7XG4gICAgICAgICAgICB2YXIgbnNlYyA9IG5zZWMzMEFuZFNlY0hpZ2gyID4+PiAyO1xuICAgICAgICAgICAgcmV0dXJuIHsgc2VjOiBzZWMsIG5zZWM6IG5zZWMgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDEyOiB7XG4gICAgICAgICAgICAvLyB0aW1lc3RhbXAgOTYgPSB7IG5zZWMzMiAodW5zaWduZWQpLCBzZWM2NCAoc2lnbmVkKSB9XG4gICAgICAgICAgICB2YXIgc2VjID0gZ2V0SW50NjQodmlldywgNCk7XG4gICAgICAgICAgICB2YXIgbnNlYyA9IHZpZXcuZ2V0VWludDMyKDApO1xuICAgICAgICAgICAgcmV0dXJuIHsgc2VjOiBzZWMsIG5zZWM6IG5zZWMgfTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IERlY29kZUVycm9yKFwiVW5yZWNvZ25pemVkIGRhdGEgc2l6ZSBmb3IgdGltZXN0YW1wIChleHBlY3RlZCA0LCA4LCBvciAxMik6IFwiLmNvbmNhdChkYXRhLmxlbmd0aCkpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUaW1lc3RhbXBFeHRlbnNpb24oZGF0YSkge1xuICAgIHZhciB0aW1lU3BlYyA9IGRlY29kZVRpbWVzdGFtcFRvVGltZVNwZWMoZGF0YSk7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRpbWVTcGVjLnNlYyAqIDFlMyArIHRpbWVTcGVjLm5zZWMgLyAxZTYpO1xufVxuZXhwb3J0IHZhciB0aW1lc3RhbXBFeHRlbnNpb24gPSB7XG4gICAgdHlwZTogRVhUX1RJTUVTVEFNUCxcbiAgICBlbmNvZGU6IGVuY29kZVRpbWVzdGFtcEV4dGVuc2lvbixcbiAgICBkZWNvZGU6IGRlY29kZVRpbWVzdGFtcEV4dGVuc2lvbixcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lc3RhbXAubWpzLm1hcCIsIi8vIEludGVnZXIgVXRpbGl0eVxuZXhwb3J0IHZhciBVSU5UMzJfTUFYID0gNDI5NDk2NzI5NTtcbi8vIERhdGFWaWV3IGV4dGVuc2lvbiB0byBoYW5kbGUgaW50NjQgLyB1aW50NjQsXG4vLyB3aGVyZSB0aGUgYWN0dWFsIHJhbmdlIGlzIDUzLWJpdHMgaW50ZWdlciAoYS5rLmEuIHNhZmUgaW50ZWdlcilcbmV4cG9ydCBmdW5jdGlvbiBzZXRVaW50NjQodmlldywgb2Zmc2V0LCB2YWx1ZSkge1xuICAgIHZhciBoaWdoID0gdmFsdWUgLyA0Mjk0OTY3Mjk2O1xuICAgIHZhciBsb3cgPSB2YWx1ZTsgLy8gaGlnaCBiaXRzIGFyZSB0cnVuY2F0ZWQgYnkgRGF0YVZpZXdcbiAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIGhpZ2gpO1xuICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDQsIGxvdyk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0SW50NjQodmlldywgb2Zmc2V0LCB2YWx1ZSkge1xuICAgIHZhciBoaWdoID0gTWF0aC5mbG9vcih2YWx1ZSAvIDQyOTQ5NjcyOTYpO1xuICAgIHZhciBsb3cgPSB2YWx1ZTsgLy8gaGlnaCBiaXRzIGFyZSB0cnVuY2F0ZWQgYnkgRGF0YVZpZXdcbiAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIGhpZ2gpO1xuICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDQsIGxvdyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50NjQodmlldywgb2Zmc2V0KSB7XG4gICAgdmFyIGhpZ2ggPSB2aWV3LmdldEludDMyKG9mZnNldCk7XG4gICAgdmFyIGxvdyA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQpO1xuICAgIHJldHVybiBoaWdoICogNDI5NDk2NzI5NiArIGxvdztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaW50NjQodmlldywgb2Zmc2V0KSB7XG4gICAgdmFyIGhpZ2ggPSB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIHZhciBsb3cgPSB2aWV3LmdldFVpbnQzMihvZmZzZXQgKyA0KTtcbiAgICByZXR1cm4gaGlnaCAqIDQyOTQ5NjcyOTYgKyBsb3c7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnQubWpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgRGVjb2RlRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlY29kZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlY29kZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgLy8gZml4IHRoZSBwcm90b3R5cGUgY2hhaW4gaW4gYSBjcm9zcy1wbGF0Zm9ybSB3YXlcbiAgICAgICAgdmFyIHByb3RvID0gT2JqZWN0LmNyZWF0ZShEZWNvZGVFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIHByb3RvKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogRGVjb2RlRXJyb3IubmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIERlY29kZUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0IHsgRGVjb2RlRXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlY29kZUVycm9yLm1qcy5tYXAiLCIvKipcbiAqIEV4dERhdGEgaXMgdXNlZCB0byBoYW5kbGUgRXh0ZW5zaW9uIFR5cGVzIHRoYXQgYXJlIG5vdCByZWdpc3RlcmVkIHRvIEV4dGVuc2lvbkNvZGVjLlxuICovXG52YXIgRXh0RGF0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFeHREYXRhKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIEV4dERhdGE7XG59KCkpO1xuZXhwb3J0IHsgRXh0RGF0YSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXh0RGF0YS5tanMubWFwIiwidmFyIF9hLCBfYiwgX2M7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uICovXG5pbXBvcnQgeyBVSU5UMzJfTUFYIH0gZnJvbSBcIi4vaW50Lm1qc1wiO1xudmFyIFRFWFRfRU5DT0RJTkdfQVZBSUxBQkxFID0gKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiIHx8ICgoX2EgPSBwcm9jZXNzID09PSBudWxsIHx8IHByb2Nlc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2Nlc3MuZW52KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbXCJURVhUX0VOQ09ESU5HXCJdKSAhPT0gXCJuZXZlclwiKSAmJlxuICAgIHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gXCJ1bmRlZmluZWRcIjtcbmV4cG9ydCBmdW5jdGlvbiB1dGY4Q291bnQoc3RyKSB7XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSAwO1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHdoaWxlIChwb3MgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKyspO1xuICAgICAgICBpZiAoKHZhbHVlICYgMHhmZmZmZmY4MCkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIDEtYnl0ZVxuICAgICAgICAgICAgYnl0ZUxlbmd0aCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHZhbHVlICYgMHhmZmZmZjgwMCkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIDItYnl0ZXNcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYpIHtcbiAgICAgICAgICAgICAgICAvLyBoaWdoIHN1cnJvZ2F0ZVxuICAgICAgICAgICAgICAgIGlmIChwb3MgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4dHJhID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChleHRyYSAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICgodmFsdWUgJiAweDNmZikgPDwgMTApICsgKGV4dHJhICYgMHgzZmYpICsgMHgxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodmFsdWUgJiAweGZmZmYwMDAwKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIDMtYnl0ZVxuICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGggKz0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDQtYnl0ZVxuICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGggKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnl0ZUxlbmd0aDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1dGY4RW5jb2RlSnMoc3RyLCBvdXRwdXQsIG91dHB1dE9mZnNldCkge1xuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciBvZmZzZXQgPSBvdXRwdXRPZmZzZXQ7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgd2hpbGUgKHBvcyA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICAgIGlmICgodmFsdWUgJiAweGZmZmZmZjgwKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gMS1ieXRlXG4gICAgICAgICAgICBvdXRwdXRbb2Zmc2V0KytdID0gdmFsdWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodmFsdWUgJiAweGZmZmZmODAwKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gMi1ieXRlc1xuICAgICAgICAgICAgb3V0cHV0W29mZnNldCsrXSA9ICgodmFsdWUgPj4gNikgJiAweDFmKSB8IDB4YzA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmKSB7XG4gICAgICAgICAgICAgICAgLy8gaGlnaCBzdXJyb2dhdGVcbiAgICAgICAgICAgICAgICBpZiAocG9zIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRyYSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoZXh0cmEgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoKHZhbHVlICYgMHgzZmYpIDw8IDEwKSArIChleHRyYSAmIDB4M2ZmKSArIDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHZhbHVlICYgMHhmZmZmMDAwMCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyAzLWJ5dGVcbiAgICAgICAgICAgICAgICBvdXRwdXRbb2Zmc2V0KytdID0gKCh2YWx1ZSA+PiAxMikgJiAweDBmKSB8IDB4ZTA7XG4gICAgICAgICAgICAgICAgb3V0cHV0W29mZnNldCsrXSA9ICgodmFsdWUgPj4gNikgJiAweDNmKSB8IDB4ODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyA0LWJ5dGVcbiAgICAgICAgICAgICAgICBvdXRwdXRbb2Zmc2V0KytdID0gKCh2YWx1ZSA+PiAxOCkgJiAweDA3KSB8IDB4ZjA7XG4gICAgICAgICAgICAgICAgb3V0cHV0W29mZnNldCsrXSA9ICgodmFsdWUgPj4gMTIpICYgMHgzZikgfCAweDgwO1xuICAgICAgICAgICAgICAgIG91dHB1dFtvZmZzZXQrK10gPSAoKHZhbHVlID4+IDYpICYgMHgzZikgfCAweDgwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dFtvZmZzZXQrK10gPSAodmFsdWUgJiAweDNmKSB8IDB4ODA7XG4gICAgfVxufVxudmFyIHNoYXJlZFRleHRFbmNvZGVyID0gVEVYVF9FTkNPRElOR19BVkFJTEFCTEUgPyBuZXcgVGV4dEVuY29kZXIoKSA6IHVuZGVmaW5lZDtcbmV4cG9ydCB2YXIgVEVYVF9FTkNPREVSX1RIUkVTSE9MRCA9ICFURVhUX0VOQ09ESU5HX0FWQUlMQUJMRVxuICAgID8gVUlOVDMyX01BWFxuICAgIDogdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgKChfYiA9IHByb2Nlc3MgPT09IG51bGwgfHwgcHJvY2VzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvY2Vzcy5lbnYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltcIlRFWFRfRU5DT0RJTkdcIl0pICE9PSBcImZvcmNlXCJcbiAgICAgICAgPyAyMDBcbiAgICAgICAgOiAwO1xuZnVuY3Rpb24gdXRmOEVuY29kZVRFZW5jb2RlKHN0ciwgb3V0cHV0LCBvdXRwdXRPZmZzZXQpIHtcbiAgICBvdXRwdXQuc2V0KHNoYXJlZFRleHRFbmNvZGVyLmVuY29kZShzdHIpLCBvdXRwdXRPZmZzZXQpO1xufVxuZnVuY3Rpb24gdXRmOEVuY29kZVRFZW5jb2RlSW50byhzdHIsIG91dHB1dCwgb3V0cHV0T2Zmc2V0KSB7XG4gICAgc2hhcmVkVGV4dEVuY29kZXIuZW5jb2RlSW50byhzdHIsIG91dHB1dC5zdWJhcnJheShvdXRwdXRPZmZzZXQpKTtcbn1cbmV4cG9ydCB2YXIgdXRmOEVuY29kZVRFID0gKHNoYXJlZFRleHRFbmNvZGVyID09PSBudWxsIHx8IHNoYXJlZFRleHRFbmNvZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaGFyZWRUZXh0RW5jb2Rlci5lbmNvZGVJbnRvKSA/IHV0ZjhFbmNvZGVURWVuY29kZUludG8gOiB1dGY4RW5jb2RlVEVlbmNvZGU7XG52YXIgQ0hVTktfU0laRSA9IDQwOTY7XG5leHBvcnQgZnVuY3Rpb24gdXRmOERlY29kZUpzKGJ5dGVzLCBpbnB1dE9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIHZhciBvZmZzZXQgPSBpbnB1dE9mZnNldDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbiAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICB3aGlsZSAob2Zmc2V0IDwgZW5kKSB7XG4gICAgICAgIHZhciBieXRlMSA9IGJ5dGVzW29mZnNldCsrXTtcbiAgICAgICAgaWYgKChieXRlMSAmIDB4ODApID09PSAwKSB7XG4gICAgICAgICAgICAvLyAxIGJ5dGVcbiAgICAgICAgICAgIHVuaXRzLnB1c2goYnl0ZTEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChieXRlMSAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAgICAgICAvLyAyIGJ5dGVzXG4gICAgICAgICAgICB2YXIgYnl0ZTIgPSBieXRlc1tvZmZzZXQrK10gJiAweDNmO1xuICAgICAgICAgICAgdW5pdHMucHVzaCgoKGJ5dGUxICYgMHgxZikgPDwgNikgfCBieXRlMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGJ5dGUxICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgIC8vIDMgYnl0ZXNcbiAgICAgICAgICAgIHZhciBieXRlMiA9IGJ5dGVzW29mZnNldCsrXSAmIDB4M2Y7XG4gICAgICAgICAgICB2YXIgYnl0ZTMgPSBieXRlc1tvZmZzZXQrK10gJiAweDNmO1xuICAgICAgICAgICAgdW5pdHMucHVzaCgoKGJ5dGUxICYgMHgxZikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChieXRlMSAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICAvLyA0IGJ5dGVzXG4gICAgICAgICAgICB2YXIgYnl0ZTIgPSBieXRlc1tvZmZzZXQrK10gJiAweDNmO1xuICAgICAgICAgICAgdmFyIGJ5dGUzID0gYnl0ZXNbb2Zmc2V0KytdICYgMHgzZjtcbiAgICAgICAgICAgIHZhciBieXRlNCA9IGJ5dGVzW29mZnNldCsrXSAmIDB4M2Y7XG4gICAgICAgICAgICB2YXIgdW5pdCA9ICgoYnl0ZTEgJiAweDA3KSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBjKSB8IChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuICAgICAgICAgICAgaWYgKHVuaXQgPiAweGZmZmYpIHtcbiAgICAgICAgICAgICAgICB1bml0IC09IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgdW5pdHMucHVzaCgoKHVuaXQgPj4+IDEwKSAmIDB4M2ZmKSB8IDB4ZDgwMCk7XG4gICAgICAgICAgICAgICAgdW5pdCA9IDB4ZGMwMCB8ICh1bml0ICYgMHgzZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzLnB1c2goYnl0ZTEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0cy5sZW5ndGggPj0gQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCB1bml0cyk7XG4gICAgICAgICAgICB1bml0cy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh1bml0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgdW5pdHMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxudmFyIHNoYXJlZFRleHREZWNvZGVyID0gVEVYVF9FTkNPRElOR19BVkFJTEFCTEUgPyBuZXcgVGV4dERlY29kZXIoKSA6IG51bGw7XG5leHBvcnQgdmFyIFRFWFRfREVDT0RFUl9USFJFU0hPTEQgPSAhVEVYVF9FTkNPRElOR19BVkFJTEFCTEVcbiAgICA/IFVJTlQzMl9NQVhcbiAgICA6IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmICgoX2MgPSBwcm9jZXNzID09PSBudWxsIHx8IHByb2Nlc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2Nlc3MuZW52KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbXCJURVhUX0RFQ09ERVJcIl0pICE9PSBcImZvcmNlXCJcbiAgICAgICAgPyAyMDBcbiAgICAgICAgOiAwO1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhEZWNvZGVURChieXRlcywgaW5wdXRPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICB2YXIgc3RyaW5nQnl0ZXMgPSBieXRlcy5zdWJhcnJheShpbnB1dE9mZnNldCwgaW5wdXRPZmZzZXQgKyBieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gc2hhcmVkVGV4dERlY29kZXIuZGVjb2RlKHN0cmluZ0J5dGVzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjgubWpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBlbnN1cmVVaW50OEFycmF5KGJ1ZmZlcikge1xuICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIuYnVmZmVyLCBidWZmZXIuYnl0ZU9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEFycmF5TGlrZTxudW1iZXI+XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYnVmZmVyKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGF0YVZpZXcoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICB9XG4gICAgdmFyIGJ1ZmZlclZpZXcgPSBlbnN1cmVVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhidWZmZXJWaWV3LmJ1ZmZlciwgYnVmZmVyVmlldy5ieXRlT2Zmc2V0LCBidWZmZXJWaWV3LmJ5dGVMZW5ndGgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWRBcnJheXMubWpzLm1hcCIsImltcG9ydCB7IEV4dGVybmFsV2FsbGV0VHlwZSwgQ2hhaW5QbGF0Zm9ybVR5cGUgfSBmcm9tICcuLi9jb21tb24vbW9kZWxzJ1xuaW1wb3J0IHtcbiAgVHJhbnNpdERpc2NvdmVyeURhdGEsXG4gIFRyYW5zaXREaXNjb3ZlcktleUxvb2t1cENhbGxiYWNrLFxuICBUcmFuc2l0RGlzY292ZXJ5QWNjb3VudCxcbiAgVHJhbnNpdERpc2NvdmVyQ29udGludWVDYWxsYmFjayxcbiAgVHJhbnNpdFByb3ZpZGVyQXR0cmlidXRlcyxcbn0gZnJvbSAnLi9tb2RlbHMnXG5cbi8qKiBGdW5jdGlvbiB1c2VkIHdpdGhpbiB0cmFuc2l0IHByb3ZpZGVyIHRvIHRyYW5zZm9ybSBhIHdhbGxldCdzIHB1YmxpYyBrZXkgdG8gYSBmdWxsIGFjY291bnQgc3RydWN1dHJlICovXG5jb25zdCBBbGdvcmFuZERpc2NvdmVyeUtleUxvb2t1cEZ1bmM6IFRyYW5zaXREaXNjb3ZlcktleUxvb2t1cENhbGxiYWNrID0gKFxuICBkaXNjb3ZlcnlEYXRhOiBUcmFuc2l0RGlzY292ZXJ5RGF0YSxcbiAgY2FsbGJhY2s6IFRyYW5zaXREaXNjb3ZlckNvbnRpbnVlQ2FsbGJhY2ssXG4pID0+IHtcbiAgY29uc3QgYWNjb3VudEluZm9BcnJheTogVHJhbnNpdERpc2NvdmVyeUFjY291bnRbXSA9IGRpc2NvdmVyeURhdGEua2V5cy5tYXAoa2V5ID0+IHtcbiAgICAvLyBub3RlIGhvbGRzIGEgc3RyaW5naWZpZWQgSlNPTiBvYmplY3QgLSBjb21wb3NlZCBieSBBbGdvc2lnbmVyIFRyYW5zaXQgcGx1Z2luXG4gICAgY29uc3QgYWNjb3VudCA9IEpTT04ucGFyc2Uoa2V5Lm5vdGUpXG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4OiBrZXkuaW5kZXgsXG4gICAgICBrZXk6IGtleS5rZXksXG4gICAgICBhY2NvdW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgYWNjb3VudDogYWNjb3VudD8uYWNjb3VudE5hbWUsXG4gICAgICAgICAgYXV0aG9yaXphdGlvbjogYWNjb3VudD8ucGVybWlzc2lvbixcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfVxuICB9KVxuICBjYWxsYmFjayhhY2NvdW50SW5mb0FycmF5KVxufVxuXG4vKiogUGFzcy10aHJvdWdoIGZ1bmN0aW9uIHVzZWQgd2l0aGluIGVvcy10cmFuc2l0IGhvc3QgLSBpZiBub3QgcHJvdmlkZWQsIHdhbGxldCB3aWxsIHRyeSB0byB1c2UgRU9TIHRvIHRyYW5zZm9ybSBrZXlzICovXG5jb25zdCBOb25Fb3NEaXNjb3ZlcnlLZXlMb29rdXBGdW5jOiBUcmFuc2l0RGlzY292ZXJLZXlMb29rdXBDYWxsYmFjayA9IChcbiAgZGlzY292ZXJ5RGF0YTogVHJhbnNpdERpc2NvdmVyeURhdGEsXG4gIGNhbGxiYWNrOiBUcmFuc2l0RGlzY292ZXJDb250aW51ZUNhbGxiYWNrLFxuKSA9PiB7XG4gIGNhbGxiYWNrKGRpc2NvdmVyeURhdGEua2V5VG9BY2NvdW50TWFwKVxufVxuXG5leHBvcnQgY29uc3QgdHJhbnNpdFByb3ZpZGVyQXR0cmlidXRlc0RhdGE6IFRyYW5zaXRQcm92aWRlckF0dHJpYnV0ZXNbXSA9IFtcbiAge1xuICAgIHByb3ZpZGVyTmFtZTogRXh0ZXJuYWxXYWxsZXRUeXBlLkFsZ29TaWduZXIsXG4gICAgY2hhaW5UeXBlOiBDaGFpblBsYXRmb3JtVHlwZS5hbGdvcmFuZCxcbiAgICBwcm92aWRlcklkOiAnYWxnb3NpZ25lcicsXG4gICAgcmVxdWlyZXNMb2dpbjogZmFsc2UsXG4gICAgc3VwcG9ydHNEaXNjb3Zlcnk6IHRydWUsXG4gICAgc3VwcG9ydHNTaWduQXJiaXRyYXJ5OiBmYWxzZSxcbiAgICByZXF1aXJlc0xvZ291dExvZ2luVG9EaXNjb3ZlcjogZmFsc2UsXG4gICAgcmVxdWlyZXNEaXNjb3ZlclRvTG9naW46IGZhbHNlLFxuICAgIGhlbHBUZXh0OiB7XG4gICAgICBsb2dpbjogJ1RoaXMgd2FsbGV0IGRvZXNu4oCZdCByZXF1aXJlIHlvdSB0byBsb2dpbi4nLFxuICAgICAgc2lnbjogJycsXG4gICAgICBkaXNjb3ZlcjogJycsXG4gICAgICB2ZXJzaW9uc1JlcXVpcmVkOiAnJyxcbiAgICB9LFxuICAgIGRpc2NvdmVyeUtleUxvb2t1cEZ1bmM6IEFsZ29yYW5kRGlzY292ZXJ5S2V5TG9va3VwRnVuYyxcbiAgICBsb2dvVXJsOiAnaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL29yZWlkLWZpbGVzL3BhcnRuZXJzL3dhbGxldC1hbGdvc2lnbmVyLWxvZ28ucG5nJyxcbiAgfSxcbiAge1xuICAgIHByb3ZpZGVyTmFtZTogRXh0ZXJuYWxXYWxsZXRUeXBlLktleWNhdCxcbiAgICBjaGFpblR5cGU6IENoYWluUGxhdGZvcm1UeXBlLmVvcyxcbiAgICBwcm92aWRlcklkOiAnS2V5Y2F0JyxcbiAgICByZXF1aXJlc0xvZ2luOiB0cnVlLFxuICAgIHN1cHBvcnRzRGlzY292ZXJ5OiBmYWxzZSxcbiAgICBzdXBwb3J0c1NpZ25BcmJpdHJhcnk6IHRydWUsXG4gICAgcmVxdWlyZXNMb2dvdXRMb2dpblRvRGlzY292ZXI6IHRydWUsXG4gICAgcmVxdWlyZXNEaXNjb3ZlclRvTG9naW46IGZhbHNlLFxuICAgIGhlbHBUZXh0OiB7XG4gICAgICBsb2dpbjogJ0tleWNhdCByZXF1aXJlcyBsb2dnaW5nIGluIHRocm91Z2ggdGhlIEtleWNhdCBhcHAuJyxcbiAgICAgIHNpZ246ICcnLFxuICAgICAgZGlzY292ZXI6ICcnLFxuICAgICAgdmVyc2lvbnNSZXF1aXJlZDogJycsXG4gICAgfSxcbiAgICBsb2dvVXJsOiAnaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL29yZWlkLWZpbGVzL3BhcnRuZXJzL3dhbGxldC1rZXljYXQtbG9nby5wbmcnLFxuICB9LFxuICB7XG4gICAgcHJvdmlkZXJOYW1lOiBFeHRlcm5hbFdhbGxldFR5cGUuTGVkZ2VyLFxuICAgIGNoYWluVHlwZTogQ2hhaW5QbGF0Zm9ybVR5cGUuZW9zLFxuICAgIHByb3ZpZGVySWQ6ICdsZWRnZXInLFxuICAgIHJlcXVpcmVzTG9naW46IHRydWUsXG4gICAgc3VwcG9ydHNEaXNjb3Zlcnk6IHRydWUsXG4gICAgc3VwcG9ydHNTaWduQXJiaXRyYXJ5OiBmYWxzZSxcbiAgICByZXF1aXJlc0xvZ291dExvZ2luVG9EaXNjb3ZlcjogZmFsc2UsXG4gICAgcmVxdWlyZXNEaXNjb3ZlclRvTG9naW46IHRydWUsXG4gICAgZGVmYXVsdERpc2NvdmVyeVBhdGhJbmRleExpc3Q6IFswLCAxLCAyXSxcbiAgICBoZWxwVGV4dDoge1xuICAgICAgbG9naW46ICdUaGlzIHdhbGxldCBkb2VzbuKAmXQgcmVxdWlyZSB5b3UgdG8gbG9naW4nLFxuICAgICAgc2lnbjogJ0Nvbm5lY3QgYW5kIHVubG9jayB5b3VyIExlZGdlciB3aXRoIHlvdXIgUElOIGNvZGUuIExhdW5jaCB0aGUgRU9TIGFwcCBvbiB0aGUgZGV2aWNlLicsXG4gICAgICBkaXNjb3ZlcjogJ0Nvbm5lY3QgYW5kIHVubG9jayB5b3VyIExlZGdlciB3aXRoIHlvdXIgUElOIGNvZGUuIExhdW5jaCB0aGUgRU9TIGFwcCBvbiB0aGUgZGV2aWNlLicsXG4gICAgICB2ZXJzaW9uc1JlcXVpcmVkOlxuICAgICAgICAnWW91IG5lZWQgdG8gaGF2ZSByZWNlbnQgdmVyc2lvbnMgb2YgeW91ciBicm93c2VyLCBMZWRnZXIgZmlybXdhcmUsIGFuZCB0aGUgTGVkZ2VyIEVPUyBhcHAuIENsaWNrIGhlcmUgZm9yIG1vcmUgZGV0YWlscy4nLFxuICAgIH0sXG4gICAgbG9nb1VybDogJ2h0dHBzOi8vc3RvcmFnZS5nb29nbGVhcGlzLmNvbS9vcmVpZC1maWxlcy9wYXJ0bmVycy93YWxsZXQtbGVkZ2VyLWxvZ28ucG5nJyxcbiAgfSxcbiAge1xuICAgIHByb3ZpZGVyTmFtZTogRXh0ZXJuYWxXYWxsZXRUeXBlLkx5bngsXG4gICAgY2hhaW5UeXBlOiBDaGFpblBsYXRmb3JtVHlwZS5lb3MsXG4gICAgcHJvdmlkZXJJZDogJ0VPUyBMeW54JyxcbiAgICByZXF1aXJlc0xvZ2luOiB0cnVlLFxuICAgIHN1cHBvcnRzRGlzY292ZXJ5OiBmYWxzZSxcbiAgICBzdXBwb3J0c1NpZ25BcmJpdHJhcnk6IHRydWUsXG4gICAgcmVxdWlyZXNMb2dvdXRMb2dpblRvRGlzY292ZXI6IHRydWUsXG4gICAgcmVxdWlyZXNEaXNjb3ZlclRvTG9naW46IGZhbHNlLFxuICAgIGhlbHBUZXh0OiB7XG4gICAgICBsb2dpbjogJ0VPUyBMeW54IHJlcXVpcmVzIGxvZ2dpbmcgaW4gdGhyb3VnaCB0aGUgRU9TIEx5bnggYXBwLicsXG4gICAgICBzaWduOiAnJyxcbiAgICAgIGRpc2NvdmVyOiAnJyxcbiAgICAgIHZlcnNpb25zUmVxdWlyZWQ6ICcnLFxuICAgIH0sXG4gICAgbG9nb1VybDogJ2h0dHBzOi8vc3RvcmFnZS5nb29nbGVhcGlzLmNvbS9vcmVpZC1maWxlcy9wYXJ0bmVycy93YWxsZXQtbHlueC1sb2dvLnBuZycsXG4gIH0sXG4gIHtcbiAgICBwcm92aWRlck5hbWU6IEV4dGVybmFsV2FsbGV0VHlwZS5NZWV0b25lLFxuICAgIGNoYWluVHlwZTogQ2hhaW5QbGF0Zm9ybVR5cGUuZW9zLFxuICAgIHByb3ZpZGVySWQ6ICdtZWV0b25lX3Byb3ZpZGVyJyxcbiAgICByZXF1aXJlc0xvZ2luOiBmYWxzZSxcbiAgICBzdXBwb3J0c0Rpc2NvdmVyeTogZmFsc2UsXG4gICAgc3VwcG9ydHNTaWduQXJiaXRyYXJ5OiB0cnVlLFxuICAgIHJlcXVpcmVzTG9nb3V0TG9naW5Ub0Rpc2NvdmVyOiB0cnVlLFxuICAgIHJlcXVpcmVzRGlzY292ZXJUb0xvZ2luOiBmYWxzZSxcbiAgICBoZWxwVGV4dDoge1xuICAgICAgbG9naW46ICdUaGlzIHdhbGxldCBkb2VzbuKAmXQgcmVxdWlyZSB5b3UgdG8gbG9naW4nLFxuICAgICAgc2lnbjogJycsXG4gICAgICBkaXNjb3ZlcjogJycsXG4gICAgICB2ZXJzaW9uc1JlcXVpcmVkOiAnJyxcbiAgICB9LFxuICAgIGxvZ29Vcmw6ICdodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vb3JlaWQtZmlsZXMvcGFydG5lcnMvd2FsbGV0LW1lZXRvbmUtbG9nby5wbmcnLFxuICB9LFxuICB7XG4gICAgcHJvdmlkZXJOYW1lOiBFeHRlcm5hbFdhbGxldFR5cGUuTWV0cm8sXG4gICAgY2hhaW5UeXBlOiBDaGFpblBsYXRmb3JtVHlwZS5lb3MsXG4gICAgcHJvdmlkZXJJZDogJ21ldHJvJyxcbiAgICByZXF1aXJlc0xvZ2luOiBmYWxzZSxcbiAgICBzdXBwb3J0c0Rpc2NvdmVyeTogZmFsc2UsXG4gICAgc3VwcG9ydHNTaWduQXJiaXRyYXJ5OiBmYWxzZSxcbiAgICByZXF1aXJlc0xvZ291dExvZ2luVG9EaXNjb3ZlcjogZmFsc2UsXG4gICAgcmVxdWlyZXNEaXNjb3ZlclRvTG9naW46IGZhbHNlLFxuICAgIGhlbHBUZXh0OiB7XG4gICAgICBsb2dpbjogJ1RoaXMgd2FsbGV0IGRvZXNu4oCZdCByZXF1aXJlIHlvdSB0byBsb2dpbicsXG4gICAgICBzaWduOiAnJyxcbiAgICAgIGRpc2NvdmVyOiAnJyxcbiAgICAgIHZlcnNpb25zUmVxdWlyZWQ6ICcnLFxuICAgIH0sXG4gICAgbG9nb1VybDogJ2h0dHBzOi8vc3RvcmFnZS5nb29nbGVhcGlzLmNvbS9vcmVpZC1maWxlcy9wYXJ0bmVycy93YWxsZXQtZ2VuZXJpYy1sb2dvLnBuZycsXG4gIH0sXG4gIHtcbiAgICBwcm92aWRlck5hbWU6IEV4dGVybmFsV2FsbGV0VHlwZS5Qb3J0aXMsXG4gICAgY2hhaW5UeXBlOiBDaGFpblBsYXRmb3JtVHlwZS5lb3MsXG4gICAgcHJvdmlkZXJJZDogJ1BvcnRpc1Byb3ZpZGVyJyxcbiAgICByZXF1aXJlc0xvZ2luOiB0cnVlLFxuICAgIHN1cHBvcnRzRGlzY292ZXJ5OiBmYWxzZSxcbiAgICBzdXBwb3J0c1NpZ25BcmJpdHJhcnk6IGZhbHNlLFxuICAgIHJlcXVpcmVzTG9nb3V0TG9naW5Ub0Rpc2NvdmVyOiB0cnVlLFxuICAgIHJlcXVpcmVzRGlzY292ZXJUb0xvZ2luOiBmYWxzZSxcbiAgICBoZWxwVGV4dDoge1xuICAgICAgbG9naW46ICdQb3J0aXMgcmVxdWlyZXMgbG9nZ2luZyBpbiB0aHJvdWdoIHRoZSBQb3J0aXMgYXBwLicsXG4gICAgICBzaWduOiAnJyxcbiAgICAgIGRpc2NvdmVyOiAnJyxcbiAgICAgIHZlcnNpb25zUmVxdWlyZWQ6ICcnLFxuICAgIH0sXG4gICAgbG9nb1VybDogJ2h0dHBzOi8vc3RvcmFnZS5nb29nbGVhcGlzLmNvbS9vcmVpZC1maWxlcy9wYXJ0bmVycy93YWxsZXQtcG9ydGlzLWxvZ28ucG5nJyxcbiAgfSxcbiAge1xuICAgIHByb3ZpZGVyTmFtZTogRXh0ZXJuYWxXYWxsZXRUeXBlLlNjYXR0ZXIsXG4gICAgY2hhaW5UeXBlOiBDaGFpblBsYXRmb3JtVHlwZS5lb3MsXG4gICAgcHJvdmlkZXJJZDogJ3NjYXR0ZXInLFxuICAgIHJlcXVpcmVzTG9naW46IHRydWUsXG4gICAgc3VwcG9ydHNEaXNjb3Zlcnk6IGZhbHNlLFxuICAgIHN1cHBvcnRzU2lnbkFyYml0cmFyeTogdHJ1ZSxcbiAgICByZXF1aXJlc0xvZ291dExvZ2luVG9EaXNjb3ZlcjogdHJ1ZSxcbiAgICByZXF1aXJlc0Rpc2NvdmVyVG9Mb2dpbjogZmFsc2UsXG4gICAgaGVscFRleHQ6IHtcbiAgICAgIGxvZ2luOiAnU2NhdHRlciByZXF1aXJlcyBsb2dnaW5nIGluIHRocm91Z2ggdGhlIFNjYXR0ZXIgYXBwLicsXG4gICAgICBzaWduOiAnJyxcbiAgICAgIGRpc2NvdmVyOiAnJyxcbiAgICAgIHZlcnNpb25zUmVxdWlyZWQ6ICcnLFxuICAgIH0sXG4gICAgbG9nb1VybDogJ2h0dHBzOi8vc3RvcmFnZS5nb29nbGVhcGlzLmNvbS9vcmVpZC1maWxlcy9wYXJ0bmVycy93YWxsZXQtc2NhdHRlci1sb2dvLnBuZycsXG4gIH0sXG4gIHtcbiAgICBwcm92aWRlck5hbWU6IEV4dGVybmFsV2FsbGV0VHlwZS5TaW1wbGVFb3MsXG4gICAgY2hhaW5UeXBlOiBDaGFpblBsYXRmb3JtVHlwZS5lb3MsXG4gICAgcHJvdmlkZXJJZDogJ3NpbXBsZW9zJyxcbiAgICByZXF1aXJlc0xvZ2luOiB0cnVlLFxuICAgIHN1cHBvcnRzRGlzY292ZXJ5OiBmYWxzZSxcbiAgICBzdXBwb3J0c1NpZ25BcmJpdHJhcnk6IGZhbHNlLFxuICAgIHJlcXVpcmVzTG9nb3V0TG9naW5Ub0Rpc2NvdmVyOiB0cnVlLFxuICAgIHJlcXVpcmVzRGlzY292ZXJUb0xvZ2luOiBmYWxzZSxcbiAgICBoZWxwVGV4dDoge1xuICAgICAgbG9naW46ICdTaW1wbGVvcyByZXF1aXJlcyBsb2dnaW5nIGluIHRocm91Z2ggdGhlIFNpbXBsZW9zIGFwcC4nLFxuICAgICAgc2lnbjogJycsXG4gICAgICBkaXNjb3ZlcjogJycsXG4gICAgICB2ZXJzaW9uc1JlcXVpcmVkOiAnJyxcbiAgICB9LFxuICAgIGxvZ29Vcmw6ICdodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vb3JlaWQtZmlsZXMvcGFydG5lcnMvd2FsbGV0LXNpbXBsZW9zLWxvZ28ucG5nJyxcbiAgfSxcbiAge1xuICAgIHByb3ZpZGVyTmFtZTogRXh0ZXJuYWxXYWxsZXRUeXBlLlRva2VuUG9ja2V0LFxuICAgIGNoYWluVHlwZTogQ2hhaW5QbGF0Zm9ybVR5cGUuZW9zLFxuICAgIHByb3ZpZGVySWQ6ICdUb2tlblBvY2tldCcsXG4gICAgcmVxdWlyZXNMb2dpbjogdHJ1ZSxcbiAgICBzdXBwb3J0c0Rpc2NvdmVyeTogZmFsc2UsXG4gICAgc3VwcG9ydHNTaWduQXJiaXRyYXJ5OiB0cnVlLFxuICAgIHJlcXVpcmVzTG9nb3V0TG9naW5Ub0Rpc2NvdmVyOiB0cnVlLFxuICAgIHJlcXVpcmVzRGlzY292ZXJUb0xvZ2luOiBmYWxzZSxcbiAgICBoZWxwVGV4dDoge1xuICAgICAgbG9naW46ICdUaGlzIHdhbGxldCBkb2VzbuKAmXQgcmVxdWlyZSB5b3UgdG8gbG9naW4nLFxuICAgICAgc2lnbjogJycsXG4gICAgICBkaXNjb3ZlcjogJycsXG4gICAgICB2ZXJzaW9uc1JlcXVpcmVkOiAnJyxcbiAgICB9LFxuICAgIGxvZ29Vcmw6ICdodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vb3JlaWQtZmlsZXMvcGFydG5lcnMvd2FsbGV0LWdlbmVyaWMtbG9nby5wbmcnLFxuICB9LFxuICB7XG4gICAgcHJvdmlkZXJOYW1lOiBFeHRlcm5hbFdhbGxldFR5cGUuV2FsbGV0Q29ubmVjdCxcbiAgICBjaGFpblR5cGU6IENoYWluUGxhdGZvcm1UeXBlLmV0aGVyZXVtLFxuICAgIHByb3ZpZGVySWQ6ICd3YWxsZXRjb25uZWN0JyxcbiAgICByZXF1aXJlc0xvZ2luOiBmYWxzZSxcbiAgICBzdXBwb3J0c0Rpc2NvdmVyeTogdHJ1ZSxcbiAgICBzdXBwb3J0c1NpZ25BcmJpdHJhcnk6IHRydWUsXG4gICAgcmVxdWlyZXNMb2dvdXRMb2dpblRvRGlzY292ZXI6IGZhbHNlLFxuICAgIHJlcXVpcmVzRGlzY292ZXJUb0xvZ2luOiBmYWxzZSxcbiAgICBoZWxwVGV4dDoge1xuICAgICAgbG9naW46ICdUaGlzIHdhbGxldCBkb2VzbuKAmXQgcmVxdWlyZSB5b3UgdG8gbG9naW4uJyxcbiAgICAgIHNpZ246ICcnLFxuICAgICAgZGlzY292ZXI6ICcnLFxuICAgICAgdmVyc2lvbnNSZXF1aXJlZDogJycsXG4gICAgfSxcbiAgICBkaXNjb3ZlcnlLZXlMb29rdXBGdW5jOiBOb25Fb3NEaXNjb3ZlcnlLZXlMb29rdXBGdW5jLFxuICAgIGxvZ29Vcmw6ICdodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vb3JlaWQtZmlsZXMvcGFydG5lcnMvd2FsbGV0LXdhbGxldGNvbm5lY3QtbG9nby5wbmcnLFxuICB9LFxuICB7XG4gICAgcHJvdmlkZXJOYW1lOiBFeHRlcm5hbFdhbGxldFR5cGUuV2ViMyxcbiAgICBjaGFpblR5cGU6IENoYWluUGxhdGZvcm1UeXBlLmV0aGVyZXVtLFxuICAgIHByb3ZpZGVySWQ6ICd3ZWIzJyxcbiAgICByZXF1aXJlc0xvZ2luOiBmYWxzZSxcbiAgICBzdXBwb3J0c0Rpc2NvdmVyeTogdHJ1ZSxcbiAgICBzdXBwb3J0c1NpZ25BcmJpdHJhcnk6IHRydWUsXG4gICAgcmVxdWlyZXNMb2dvdXRMb2dpblRvRGlzY292ZXI6IGZhbHNlLFxuICAgIHJlcXVpcmVzRGlzY292ZXJUb0xvZ2luOiBmYWxzZSxcbiAgICBoZWxwVGV4dDoge1xuICAgICAgbG9naW46ICdUaGlzIHdhbGxldCBkb2VzbuKAmXQgcmVxdWlyZSB5b3UgdG8gbG9naW4uJyxcbiAgICAgIHNpZ246ICcnLFxuICAgICAgZGlzY292ZXI6ICcnLFxuICAgICAgdmVyc2lvbnNSZXF1aXJlZDogJycsXG4gICAgfSxcbiAgICBkaXNjb3ZlcnlLZXlMb29rdXBGdW5jOiBOb25Fb3NEaXNjb3ZlcnlLZXlMb29rdXBGdW5jLFxuICAgIGxvZ29Vcmw6ICdodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vb3JlaWQtZmlsZXMvcGFydG5lcnMvd2FsbGV0LXdlYjMtbG9nby5wbmcnLFxuICB9LFxuICB7XG4gICAgcHJvdmlkZXJOYW1lOiBFeHRlcm5hbFdhbGxldFR5cGUuV2hhbGVWYXVsdCxcbiAgICBjaGFpblR5cGU6IENoYWluUGxhdGZvcm1UeXBlLmVvcyxcbiAgICBwcm92aWRlcklkOiAnd2hhbGV2YXVsdCcsXG4gICAgcmVxdWlyZXNMb2dpbjogdHJ1ZSxcbiAgICBzdXBwb3J0c0Rpc2NvdmVyeTogZmFsc2UsXG4gICAgc3VwcG9ydHNTaWduQXJiaXRyYXJ5OiB0cnVlLFxuICAgIHJlcXVpcmVzTG9nb3V0TG9naW5Ub0Rpc2NvdmVyOiB0cnVlLFxuICAgIHJlcXVpcmVzRGlzY292ZXJUb0xvZ2luOiBmYWxzZSxcbiAgICBoZWxwVGV4dDoge1xuICAgICAgbG9naW46ICdXaGFsZXZhdWx0IHJlcXVpcmVzIGxvZ2dpbmcgaW4gdGhyb3VnaCB0aGUgV2hhbGV2YXVsdCBhcHAuJyxcbiAgICAgIHNpZ246ICcnLFxuICAgICAgZGlzY292ZXI6ICcnLFxuICAgICAgdmVyc2lvbnNSZXF1aXJlZDogJycsXG4gICAgfSxcbiAgICBsb2dvVXJsOiAnaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL29yZWlkLWZpbGVzL3BhcnRuZXJzL3dhbGxldC13aGFsZXZhdWx0LWxvZ28ucG5nJyxcbiAgfSxcbl1cblxuLyoqIEdldCBwcm92aWRlci1zcGVjaWZpYyBzZXR0aW5ncyBhbmQgbWV0YWRhdGEgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2l0UHJvdmlkZXJBdHRyaWJ1dGVzKHdhbGxldFR5cGU6IEV4dGVybmFsV2FsbGV0VHlwZSk6IFRyYW5zaXRQcm92aWRlckF0dHJpYnV0ZXMge1xuICByZXR1cm4gdHJhbnNpdFByb3ZpZGVyQXR0cmlidXRlc0RhdGEuZmluZCh0cCA9PiB0cC5wcm92aWRlck5hbWUgPT09IHdhbGxldFR5cGUudG9TdHJpbmcoKSlcbn1cblxuLyoqIEdldCBwcm92aWRlci1zcGVjaWZpYyBzZXR0aW5ncyBhbmQgbWV0YWRhdGEgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2l0UHJvdmlkZXJBdHRyaWJ1dGVzQnlQcm92aWRlcklkKHByb3ZpZGVySWQ6IHN0cmluZyk6IFRyYW5zaXRQcm92aWRlckF0dHJpYnV0ZXMge1xuICByZXR1cm4gdHJhbnNpdFByb3ZpZGVyQXR0cmlidXRlc0RhdGEuZmluZCh0cCA9PiB0cC5wcm92aWRlcklkID09PSBwcm92aWRlcklkKVxufVxuXG4vKiogR2V0IHRoZSBsaXN0IG9mIHByb3ZpZGVyIGF0dHJpYnV0ZXMgZm9yIGEgZ2l2ZW4gY2hhaW4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2l0UHJvdmlkZXJBdHRyaWJ1dGVzQnlDaGFpbihjaGFpbjogQ2hhaW5QbGF0Zm9ybVR5cGUpOiBUcmFuc2l0UHJvdmlkZXJBdHRyaWJ1dGVzW10ge1xuICByZXR1cm4gdHJhbnNpdFByb3ZpZGVyQXR0cmlidXRlc0RhdGEuZmlsdGVyKHAgPT4gcC5jaGFpblR5cGUgPT09IGNoYWluKVxufVxuXG5leHBvcnQgY29uc3Qgc3VwcG9ydGVkVHJhbnNpdFByb3ZpZGVyczogRXh0ZXJuYWxXYWxsZXRUeXBlW10gPSB0cmFuc2l0UHJvdmlkZXJBdHRyaWJ1dGVzRGF0YS5tYXAodHAgPT4gdHAucHJvdmlkZXJOYW1lKVxuIiwiaW1wb3J0IHsgZ2V0VWFsUHJvdmlkZXJBdHRyaWJ1dGVzLCBnZXRVYWxQcm92aWRlckF0dHJpYnV0ZXNCeVVhbE5hbWUsIHN1cHBvcnRlZFVBTFByb3ZpZGVycyB9IGZyb20gJy4vdWFsUHJvdmlkZXJzJ1xuaW1wb3J0IE9yZUlkQ29udGV4dCBmcm9tICcuLi9jb3JlL0lPcmVpZENvbnRleHQnXG5pbXBvcnQgSGVscGVycyBmcm9tICcuLi91dGlscy9oZWxwZXJzJ1xuaW1wb3J0IHtcbiAgQ2hhaW5BY2NvdW50LFxuICBDaGFpbk5ldHdvcmssXG4gIEV4dGVybmFsV2FsbGV0SW50ZXJmYWNlLFxuICBFeHRlcm5hbFdhbGxldFR5cGUsXG4gIExvZ2luV2l0aFdhbGxldE9wdGlvbnMsXG4gIFNpZ25hdHVyZVByb3ZpZGVyU2lnblJlc3VsdCxcbiAgU2lnblN0cmluZ1BhcmFtcyxcbiAgVHJhbnNhY3Rpb25EYXRhLFxufSBmcm9tICcuLi9tb2RlbHMnXG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi4vdXNlci91c2VyJ1xuaW1wb3J0IHtcbiAgQ29ubmVjdFRvVWFsUHJvdmlkZXJQYXJhbXMsXG4gIENvbm5lY3RUb1VhbFByb3ZpZGVyUmVzdWx0LFxuICBVYWxBdXRoZW50aWNhdG9yLFxuICBVYWxBdXRoZW50aWNhdG9yRmFjdG9yeSxcbiAgVWFsVXNlcixcbiAgVXNlckFjY291bnRQZXJtaXNzaW9ucyxcbn0gZnJvbSAnLi9tb2RlbHMnXG5pbXBvcnQgeyBBdXRoZW50aWNhdG9yLCBTaWduVHJhbnNhY3Rpb25SZXNwb25zZSB9IGZyb20gJ3VuaXZlcnNhbC1hdXRoZW50aWNhdG9yLWxpYnJhcnknXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVhbEhlbHBlciB7XG4gIGNvbnN0cnVjdG9yKGFyZ3M6IHsgb3JlSWRDb250ZXh0OiBPcmVJZENvbnRleHQ7IHVzZXI6IFVzZXIgfSkge1xuICAgIHRoaXMuX29yZUlkQ29udGV4dCA9IGFyZ3Mub3JlSWRDb250ZXh0XG4gICAgdGhpcy5fdXNlciA9IGFyZ3MudXNlclxuICB9XG5cbiAgX29yZUlkQ29udGV4dDogT3JlSWRDb250ZXh0XG5cbiAgX3VzZXI6IFVzZXJcblxuICAvKiogVmVyaWZpZXMgdGhhdCBhbGwgcGx1Z2lucyBoYXZlIGEgdmFsaWQgbmFtZVxuICAgKiAgU3RvcmVzIGEgbGlzdCBvZiB0aGUgaW5zdGFsbGVkIHByb3ZpZGVyTmFtZXMgZm9yIGFsbCB3b3JraW5nIHBsdWdpbnMgaW4gdWFsUHJvdmlkZXJzSW5zdGFsbGVkXG4gICAqL1xuICBhc3luYyBpbnN0YWxsVWFsUHJvdmlkZXJzKHVhbFdhbGxldFByb3ZpZGVyczogVWFsQXV0aGVudGljYXRvckZhY3RvcnlbXSkge1xuICAgIC8vIE1hcHMgaW5zdGFsbGVkIFVBTFByb3ZpZGVycyB0byBhcnJheSBvZiBFeHRlcm5hTFdhbGxldFR5cGUgbmFtZXNcbiAgICB0aGlzLl9vcmVJZENvbnRleHQudWFsUHJvdmlkZXJzSW5zdGFsbGVkID0gKHVhbFdhbGxldFByb3ZpZGVycyB8fCBbXSkubWFwKFxuICAgICAgdWFsUHJvdmlkZXJGYWN0b3J5ID0+IGdldFVhbFByb3ZpZGVyQXR0cmlidXRlc0J5VWFsTmFtZSh1YWxQcm92aWRlckZhY3Rvcnk/Lm5hbWUpPy5wcm92aWRlck5hbWUsXG4gICAgKVxuICB9XG5cbiAgLyoqIFJldHJpZXZlIHRoZSB1c2VyIGFuZCB0aGVpciBhY2NvdW50L3Blcm1pc3Npb24gZGV0YWlscyBmb3IgdGhlIG1hdGNoaW5nIGNoYWluTmV0d29ya1xuICAgKiAgUmV0dXJucyBudWxsIGlmIG5vdGhpbmcgaW4gd2FsbGV0IGZvciBjaGFpbk5ldHdvcmtcbiAgICovXG4gIGFzeW5jIGxvZ2luVG9VYWxQcm92aWRlcihcbiAgICB3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUsXG4gICAgYXV0aGVudGljYXRvcjogQXV0aGVudGljYXRvcixcbiAgICBjaGFpbk5ldHdvcms6IENoYWluTmV0d29yayxcbiAgICBjaGFpbkFjY291bnQ6IENoYWluQWNjb3VudCxcbiAgKTogUHJvbWlzZTx7IHVzZXI6IFVhbFVzZXI7IHVzZXJQZXJtaXNzaW9uczogVXNlckFjY291bnRQZXJtaXNzaW9ucyB9PiB7XG4gICAgdGhpcy5hc3NlcnRIYXNQcm92aWRlckluc3RhbGxlZCh3YWxsZXRUeXBlLCBFeHRlcm5hbFdhbGxldEludGVyZmFjZS5VYWwpXG4gICAgdGhpcy5hc3NlcnRQcm92aWRlclZhbGlkRm9yQ2hhaW5OZXR3b3JrKHdhbGxldFR5cGUsIGNoYWluTmV0d29yaylcbiAgICB0cnkge1xuICAgICAgLy8gd2UgZ2V0IGFuIGFycmF5IG9mIHVzZXJzIC0gb25lIGZvciBlYWNoIGNoYWluIGJlaW5nIHVzZWQgaW4gdGhlIHdhbGxldFxuICAgICAgY29uc3QgdXNlcnM6IFVhbFVzZXJbXSA9IGF3YWl0IGF1dGhlbnRpY2F0b3IubG9naW4oY2hhaW5BY2NvdW50KVxuICAgICAgaWYgKEhlbHBlcnMuaXNOdWxsT3JFbXB0eSh1c2VycykpIHJldHVybiBudWxsXG5cbiAgICAgIC8vIGZvciBldmVyeSBzdXBwb3J0ZWQgY2hhaW4sIHBvcHVsYXRlIGEgcmVzdWx0IHdpdGggdGhlIHVzZXIgYW5kIHVzZXIncyBhY2NvdW50L3Blcm1pc3Npb24gaW5mb1xuICAgICAgY29uc3QgdXNlcnNXaXRoQWNjb3VudHNEZXRhaWxzOiB7IHVzZXI6IFVhbFVzZXI7IHVzZXJQZXJtaXNzaW9uczogVXNlckFjY291bnRQZXJtaXNzaW9ucyB9W10gPSBbXVxuICAgICAgYXdhaXQgSGVscGVycy5hc3luY0ZvckVhY2godXNlcnMsIGFzeW5jIHVzZXIgPT4ge1xuICAgICAgICBjb25zdCB1c2VyUGVybWlzc2lvbnMgPSBhd2FpdCB0aGlzLmdldEFjY291bnRBbmRQZXJtaXNzaW9uc0Zyb21VYWxVc2VyKHVzZXIpXG4gICAgICAgIHVzZXJzV2l0aEFjY291bnRzRGV0YWlscy5wdXNoKHsgdXNlciwgdXNlclBlcm1pc3Npb25zIH0pXG4gICAgICB9KVxuXG4gICAgICAvLyBnZXQgb25seSB0aGUgdXNlciBtYXRjaGluZyB0aGUgZGVzaXJlZCBjaGFpbk5ldHdvcmtcbiAgICAgIGNvbnN0IHVzZXJGb3JDaGFpbiA9IHVzZXJzV2l0aEFjY291bnRzRGV0YWlscy5maW5kKHV3YSA9PiB1d2EudXNlclBlcm1pc3Npb25zLmNoYWluTmV0d29yayA9PT0gY2hhaW5OZXR3b3JrKVxuICAgICAgcmV0dXJuIHVzZXJGb3JDaGFpblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2UgPSAnJyB9ID0gZXJyb3JcbiAgICAgIGlmIChtZXNzYWdlLmluY2x1ZGVzKCd1bmtub3duIGtleSAoYm9vc3Q6OnR1cGxlczo6dHVwbGUnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBhY2NvdW50IHNlbGVjdGVkIGJ5IHRoZSB3YWxsZXQgZm9yIGxvZ2luIGlzbid0IG9uIHRoZSAke2NoYWluTmV0d29ya30gY2hhaW5gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBXZSBzaG91bGQgY2FjaGUgdGhlIHdhbGxldC91c2VyIG9iamVjdCB0byBhdm9pZCBjYWxsaW5nIGxvZ2luIGV2ZXJ5dGltZSB3ZSBuZWVkIHRvIHNpZ25cbiAgYXN5bmMgY29ubmVjdFRvVWFsUHJvdmlkZXIoe1xuICAgIHdhbGxldFR5cGUsXG4gICAgY2hhaW5OZXR3b3JrLFxuICAgIGNoYWluQWNjb3VudCA9IG51bGwsXG4gIH06IENvbm5lY3RUb1VhbFByb3ZpZGVyUGFyYW1zKTogUHJvbWlzZTxDb25uZWN0VG9VYWxQcm92aWRlclJlc3VsdD4ge1xuICAgIHRoaXMuYXNzZXJ0SGFzUHJvdmlkZXJJbnN0YWxsZWQod2FsbGV0VHlwZSwgRXh0ZXJuYWxXYWxsZXRJbnRlcmZhY2UuVWFsKVxuICAgIHRoaXMuYXNzZXJ0UHJvdmlkZXJWYWxpZEZvckNoYWluTmV0d29yayh3YWxsZXRUeXBlLCBjaGFpbk5ldHdvcmspXG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLl9vcmVJZENvbnRleHRcblxuICAgIGNvbnN0IFNlbGVjdGVkQXV0aGVudGljYXRvciA9IG9wdGlvbnMudWFsQXV0aGVudGljYXRvcnMuZmluZChcbiAgICAgIHVhbEF1dGhlbnRpY2F0b3IgPT4gdWFsQXV0aGVudGljYXRvci5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IHdhbGxldFR5cGUsXG4gICAgKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5ldHdvcmtDb25maWcgPSBhd2FpdCB0aGlzLl9vcmVJZENvbnRleHQuc2V0dGluZ3MuZ2V0Q2hhaW5OZXR3b3JrTmV4dHdvcmtDb25maWcoY2hhaW5OZXR3b3JrKVxuICAgICAgY29uc3QgdWFsTmV0d29ya0NvbmZpZyA9IHtcbiAgICAgICAgY2hhaW5JZDogbmV0d29ya0NvbmZpZy5jaGFpbklkLFxuICAgICAgICBycGNFbmRwb2ludHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5uZXR3b3JrQ29uZmlnLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9XG4gICAgICAvLyBjb25zdHJ1Y3QgYXV0aGVudGljYXRvclxuICAgICAgY29uc3QgYXV0aGVudGljYXRvciA9IG5ldyBTZWxlY3RlZEF1dGhlbnRpY2F0b3IoW3VhbE5ldHdvcmtDb25maWddLCB7XG4gICAgICAgIGFwcE5hbWU6IG9wdGlvbnMuYXBwTmFtZSxcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuX29yZUlkQ29udGV4dC5zZXRJc0J1c3kodHJ1ZSkgLy8gYnVzeSBpcyBjbGVhcmVkIGJ5IHdhaXRXaGlsZVdhbGxldElzQnVzeSB3aGVuIGRvbmVcbiAgICAgIGF3YWl0IGF1dGhlbnRpY2F0b3IuaW5pdCgpXG4gICAgICBhd2FpdCB0aGlzLndhaXRXaGlsZVdhbGxldElzQnVzeShhdXRoZW50aWNhdG9yLCB3YWxsZXRUeXBlKVxuXG4gICAgICAvLyBUT0RPOiBjb25zaWRlciBpZiB3ZSBzaG91bGQgd2FpdCB3aGlsZSAuaXNMb2FkaW5nKClcblxuICAgICAgaWYgKGF1dGhlbnRpY2F0b3IuaXNFcnJvcmVkKCkpIHtcbiAgICAgICAgY29uc3QgdWFsRXJyb3IgPSBhdXRoZW50aWNhdG9yLmdldEVycm9yKClcbiAgICAgICAgY29uc29sZS5sb2coYEVycm9yIGNvbm5lY3RpbmcgdG8gVUFMIHdhbGxldCB0eXBlOiAke3VhbEVycm9yLm5hbWV9YCwgdWFsRXJyb3IuY2F1c2UpXG4gICAgICAgIHRocm93IHVhbEVycm9yLmNhdXNlIC8vIHJlLXRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIC8vIC8vIFRPRE86IGNvbnNpZGVyIGlmIHRoaXMgY29kZSBpcyByZWxldmFudFxuICAgICAgLy8gaWYgKGF1dGhlbnRpY2F0b3Iuc2hvdWxkQXV0b0xvZ2luKCkgIT09IHRydWUpIHJldHVybiBudWxsXG5cbiAgICAgIGNvbnN0IHVzZXJGb3JDaGFpbiA9IGF3YWl0IHRoaXMubG9naW5Ub1VhbFByb3ZpZGVyKHdhbGxldFR5cGUsIGF1dGhlbnRpY2F0b3IsIGNoYWluTmV0d29yaywgY2hhaW5BY2NvdW50KVxuXG4gICAgICAvLyBObyB1c2VyIGluIHRoZSB3YWxsZXQgZm9yIHRoZSBnaXZlbiBjaGFpbk5ldHdvcmtcbiAgICAgIGlmICghdXNlckZvckNoYWluKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBVc2VyIGRvZXNuJ3QgaGF2ZSBhbiBhY2NvdW50IGZvciB0aGUgY2hhaW5OZXR3b3JrOiAke2NoYWluTmV0d29ya30gaW4gd2FsbGV0IHR5cGU6ICR7d2FsbGV0VHlwZX1gKVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgcGVybWlzc2lvbnMgaW4gb3JlSWQgLSBUT0RPOiBjb25zaWRlciBpZiB3ZSBzaG91bGQgdXBkYXRlIGFsbCB0aGUgcGVybWlzc2lvbnMgaW4gYWxsIHRoZSBmb3VuZCBjaGFpbnMgKGluIHVzZXJzV2l0aEFjY291bnRzRGV0YWlscylcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMudXBkYXRlT3JlQWNjb3VudFBlcm1pc3Npb25zZnJvbVVhbFVzZXIodXNlckZvckNoYWluLnVzZXIsIHdhbGxldFR5cGUpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgRmFpbGVkIHRvIGFkZCBuZXdseSBkaXNjb3ZlcmVkIGNoYWluIGFjY291bnRzIGluIGNvbm5lY3RUb1VhbFByb3ZpZGVyIGZvciBjaGFpbk5ldHdvcms6ICR7Y2hhaW5OZXR3b3JrfSBpbiB3YWxsZXQgdHlwZTogJHt3YWxsZXRUeXBlfWAsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gY29uc3Qge1xuICAgICAgLy8gICBhY2NvdW50LFxuICAgICAgLy8gICBjaGFpbk5ldHdvcms6IGNoYWluTmV0d29ya0Zyb21BdXRoZW50aWNhdG9yLCAvLyBnZXQgdGhlIGNoYWluTmV0d29yayBmcm9tIHRoZSBVQUxQcm92aWRlciBzaW5jZSB3ZSBjYW50IHRlbGwgaXQgd2hhdCBuZXR3b3JrIHRvIHVzZVxuICAgICAgLy8gICBwZXJtaXNzaW9ucyxcbiAgICAgIC8vIH0gPSBhd2FpdCB0aGlzLmdldEFjY291bnRBbmRQZXJtaXNzaW9uc0Zyb21VYWxVc2VyKHVzZXIpXG4gICAgICAvLyBjb25zdCBwdWJsaWNLZXlzID0gYXdhaXQgdXNlci5nZXRLZXlzKClcbiAgICAgIC8vIGNvbnN0IGFjY291bnQgPSBhd2FpdCB1c2VyLmdldEFjY291bnROYW1lKClcbiAgICAgIC8vIGNvbnN0IHBlcm1pc3Npb25zID0gW3sgbmFtZTogJ2FjdGl2ZScsIHB1YmxpY0tleTogcHVibGljS2V5c1swXSB9XVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgaXNMb2dnZWRJbjogdHJ1ZSxcbiAgICAgICAgY2hhaW5BY2NvdW50OiB1c2VyRm9yQ2hhaW4udXNlclBlcm1pc3Npb25zLmNoYWluQWNjb3VudCxcbiAgICAgICAgY2hhaW5OZXR3b3JrOiB1c2VyRm9yQ2hhaW4udXNlclBlcm1pc3Npb25zLmNoYWluTmV0d29yayxcbiAgICAgICAgcGVybWlzc2lvbnM6IHVzZXJGb3JDaGFpbi51c2VyUGVybWlzc2lvbnMucGVybWlzc2lvbnMsXG4gICAgICAgIHdhbGxldFR5cGUsXG4gICAgICAgIGF1dGhlbnRpY2F0b3IsXG4gICAgICAgIHVhbFVzZXI6IHVzZXJGb3JDaGFpbi51c2VyLFxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBGYWlsZWQgdG8gY29ubmVjdCB0byAke3dhbGxldFR5cGV9IHdhbGxldDpgLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqIEV4dHJhY3QgdXNlciBhY2NvdW50L3Blcm1pc3Npb24gZm9yIGFsbCBwdWJsaWNLZXlzIGluIHRoZSBVc2VyJ3Mgd2FsbGV0ICovXG4gIGFzeW5jIGdldEFjY291bnRBbmRQZXJtaXNzaW9uc0Zyb21VYWxVc2VyKHVhbFVzZXI6IFVhbFVzZXIpOiBQcm9taXNlPFVzZXJBY2NvdW50UGVybWlzc2lvbnM+IHtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdWFsVXNlci5nZXRDaGFpbklkKClcbiAgICBjb25zdCBjaGFpbk5ldHdvcmsgPSBhd2FpdCB0aGlzLl9vcmVJZENvbnRleHQuc2V0dGluZ3MuZ2V0Q2hhaW5OZXR3b3JrQnlDaGFpbklkKGNoYWluSWQpXG4gICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IHVhbFVzZXIuZ2V0QWNjb3VudE5hbWUoKVxuICAgIGNvbnN0IHB1YmxpY0tleXMgPSBhd2FpdCB0aGlzLmdldEtleXModWFsVXNlcilcbiAgICAvLyBmb3IgZWFjaCBwdWJsaWNLZXkgaW4gdGhlIHVzZXIncyB3YWxsZXQsIHJldHVybiBhIFdhbGxldFBlcm1pc3Npb24gb2JqZWN0XG4gICAgY29uc3QgcGVybWlzc2lvbnMgPSBwdWJsaWNLZXlzLm1hcChwdWJsaWNLZXkgPT4gKHtcbiAgICAgIGFjY291bnQsXG4gICAgICBwdWJsaWNLZXksXG4gICAgICBuYW1lOiAnYWN0aXZlJywgLy8gVUFMIGRvZXNuJ3QgcmV0dXJuIHRoZSBwZXJtaXNzaW9uIHNvIHdlIGRlZmF1bHQgdG8gYWN0aXZlXG4gICAgICAvLyB0b2RvOiBhZGQgcGFyZW50IHBlcm1pc3Npb24gd2hlbiBhdmFpbGFibGVcbiAgICB9KSlcbiAgICByZXR1cm4geyBjaGFpbkFjY291bnQ6IGFjY291bnQsIGNoYWluTmV0d29yaywgcGVybWlzc2lvbnMgfVxuICB9XG5cbiAgLyoqIExvZ2luIHVzaW5nIHRoZSB3YWxsZXQgcHJvdmlkZXIgKi9cbiAgYXN5bmMgbG9naW5XaXRoVWFsUHJvdmlkZXIobG9naW5PcHRpb25zOiBMb2dpbldpdGhXYWxsZXRPcHRpb25zKSB7XG4gICAgY29uc3QgeyB3YWxsZXRUeXBlLCBjaGFpbkFjY291bnQsIGNoYWluTmV0d29yayB9ID0gbG9naW5PcHRpb25zXG4gICAgLy8gQ29ubmVjdCB0byBQcm92aWRlclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb25uZWN0VG9VYWxQcm92aWRlcih7IHdhbGxldFR5cGUsIGNoYWluQWNjb3VudCwgY2hhaW5OZXR3b3JrIH0pXG4gICAgY29uc3QgeyBhdXRoZW50aWNhdG9yLCBpc0xvZ2dlZEluIH0gPSByZXNwb25zZVxuICAgIC8vIExvZ2luIGlmIG5lZWRlZCAtIGlmIG5vdCBsb2dnZWQtaW4gYnkgY29ubmVjdFRvVWFsUHJvdmlkZXIsIHRoZW4gY2FsbCBsb2dpbiBleHBsaWNpdGx5XG4gICAgaWYgKCFpc0xvZ2dlZEluKSB7XG4gICAgICBjb25zdCB1c2VyRm9yQ2hhaW4gPSBhd2FpdCB0aGlzLmxvZ2luVG9VYWxQcm92aWRlcih3YWxsZXRUeXBlLCBhdXRoZW50aWNhdG9yLCBjaGFpbk5ldHdvcmssIGNoYWluQWNjb3VudClcbiAgICAgIGlmICh1c2VyRm9yQ2hhaW4pIHtcbiAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVPcmVBY2NvdW50UGVybWlzc2lvbnNmcm9tVWFsVXNlcih1c2VyRm9yQ2hhaW4udXNlciwgd2FsbGV0VHlwZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKiogVGhyb3cgaWYgdGhlIHJlcXVpcmVkIHBsdWctaW4gaXMgbm90IGluc3RhbGxlZCAqL1xuICBhc3NlcnRIYXNQcm92aWRlckluc3RhbGxlZChwcm92aWRlcjogRXh0ZXJuYWxXYWxsZXRUeXBlLCBwcm92aWRlclR5cGU6IEV4dGVybmFsV2FsbGV0SW50ZXJmYWNlKSB7XG4gICAgaWYgKHByb3ZpZGVyVHlwZSA9PT0gRXh0ZXJuYWxXYWxsZXRJbnRlcmZhY2UuVWFsKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzVWFsUHJvdmlkZXIocHJvdmlkZXIpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBVQUwgYXV0aGVudGljYXRvcjpcIiR7cHJvdmlkZXJ9XCIgbm90IGluc3RhbGxlZC4gUGxlYXNlIHBhc3MgaXQgaW4gdmlhIHVhbEF1dGhlbnRpY2F0b3JzLmApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIHNpZ24gd2l0aCBhIFVBTCB3YWxsZXQgKi9cbiAgYXN5bmMgc2lnbldpdGhVYWxQcm92aWRlcihcbiAgICB0cmFuc2FjdGlvbkRhdGE6IFRyYW5zYWN0aW9uRGF0YSxcbiAgICB3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUsXG4gICk6IFByb21pc2U8eyBzaWduZWRUcmFuc2FjdGlvbjogU2lnbmF0dXJlUHJvdmlkZXJTaWduUmVzdWx0IH0+IHtcbiAgICBjb25zdCB7IGNoYWluTmV0d29yaywgdHJhbnNhY3Rpb24sIGNoYWluQWNjb3VudCwgc2lnbk9wdGlvbnMgfSA9IHRyYW5zYWN0aW9uRGF0YVxuICAgIGNvbnN0IHsgcHJvdmlkZXIsIGJyb2FkY2FzdCB9ID0gc2lnbk9wdGlvbnNcbiAgICB0aGlzLmFzc2VydEhhc1Byb3ZpZGVySW5zdGFsbGVkKHdhbGxldFR5cGUsIEV4dGVybmFsV2FsbGV0SW50ZXJmYWNlLlVhbClcbiAgICB0aGlzLmFzc2VydFByb3ZpZGVyVmFsaWRGb3JDaGFpbk5ldHdvcmsod2FsbGV0VHlwZSwgY2hhaW5OZXR3b3JrKVxuICAgIGNvbnN0IHsgdWFsVXNlciB9ID0gYXdhaXQgdGhpcy5jb25uZWN0VG9VYWxQcm92aWRlcih7IHdhbGxldFR5cGUsIGNoYWluTmV0d29yaywgY2hhaW5BY2NvdW50IH0pXG4gICAgbGV0IHNpZ25lZFRyYW5zYWN0aW9uUmVzcG9uc2U6IFNpZ25UcmFuc2FjdGlvblJlc3BvbnNlXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX29yZUlkQ29udGV4dC5zZXRJc0J1c3kodHJ1ZSlcbiAgICAgIHNpZ25lZFRyYW5zYWN0aW9uUmVzcG9uc2UgPSBhd2FpdCB1YWxVc2VyLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgeyBicm9hZGNhc3QgfSlcblxuICAgICAgLy8gQ29udmVydCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gZnJvbSBVSW50OEFycmF5IHRvIEJ1ZmZlclxuICAgICAgLy8gaS5lLiB3aGVuIHN0cmluZ2lmaWVkIGNoYW5nZSBmcm9tOiAne1xcXCIwXFxcIjoxMjksXFxcIjFcXFwiOjE2Myd9IHRvIHtcInR5cGVcIjpcIkJ1ZmZlclwiLFwiZGF0YVwiOlsxMjksMTYzXX1cbiAgICAgIGNvbnN0IHsgc2VyaWFsaXplZFRyYW5zYWN0aW9uIH0gPSBzaWduZWRUcmFuc2FjdGlvblJlc3BvbnNlLnRyYW5zYWN0aW9uXG4gICAgICBpZiAoc2VyaWFsaXplZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHNpZ25lZFRyYW5zYWN0aW9uUmVzcG9uc2UudHJhbnNhY3Rpb24uc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gQnVmZmVyLmZyb20oc2VyaWFsaXplZFRyYW5zYWN0aW9uKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc2lnbmVkVHJhbnNhY3Rpb246IHNpZ25lZFRyYW5zYWN0aW9uUmVzcG9uc2UudHJhbnNhY3Rpb24gfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fb3JlSWRDb250ZXh0LnNldElzQnVzeShmYWxzZSlcbiAgICB9XG4gIH1cblxuICAvKiogU2lnbnMgYW4gYXJiaXRyYXJ5IHN0cmluZyB1c2luZyBhIHNwZWNpZmljIHByb3ZpZGVyICovXG4gIGFzeW5jIHNpZ25TdHJpbmdXaXRoVWFsUHJvdmlkZXIoeyB3YWxsZXRUeXBlLCBjaGFpbk5ldHdvcmssIHN0cmluZywgY2hhaW5BY2NvdW50LCBtZXNzYWdlIH06IFNpZ25TdHJpbmdQYXJhbXMpIHtcbiAgICB0aGlzLmFzc2VydEhhc1Byb3ZpZGVySW5zdGFsbGVkKHdhbGxldFR5cGUsIEV4dGVybmFsV2FsbGV0SW50ZXJmYWNlLlVhbClcbiAgICB0aGlzLmFzc2VydFByb3ZpZGVyVmFsaWRGb3JDaGFpbk5ldHdvcmsod2FsbGV0VHlwZSwgY2hhaW5OZXR3b3JrKVxuICAgIGNvbnN0IHsgdWFsVXNlciB9ID0gYXdhaXQgdGhpcy5jb25uZWN0VG9VYWxQcm92aWRlcih7IHdhbGxldFR5cGUsIGNoYWluTmV0d29yaywgY2hhaW5BY2NvdW50IH0pXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX29yZUlkQ29udGV4dC5zZXRJc0J1c3kodHJ1ZSlcbiAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCB0aGlzLmdldEtleXModWFsVXNlcilcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdWFsVXNlci5zaWduQXJiaXRyYXJ5KGtleXNbMF0sIHN0cmluZywgbWVzc2FnZSlcbiAgICAgIHJldHVybiB7IHNpZ25lZFN0cmluZzogcmVzcG9uc2UgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fb3JlSWRDb250ZXh0LnNldElzQnVzeShmYWxzZSlcbiAgICB9XG4gIH1cblxuICAvKiogQWRkIHRoZSBhY2NvdW50IHNlbGVjdGVkIGluIHRoZSBVQUwgVXNlciB0byB0aGUgT1JFIGFjY291bnQncyBsaXN0IG9mIGFjY291bnQvcGVybWlzc2lvbnMgKi9cbiAgYXN5bmMgdXBkYXRlT3JlQWNjb3VudFBlcm1pc3Npb25zZnJvbVVhbFVzZXIodXNlcjogVWFsVXNlciwgd2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIGNvbnN0IHsgY2hhaW5BY2NvdW50LCBjaGFpbk5ldHdvcmssIHBlcm1pc3Npb25zIH0gPSBhd2FpdCB0aGlzLmdldEFjY291bnRBbmRQZXJtaXNzaW9uc0Zyb21VYWxVc2VyKHVzZXIpXG4gICAgLy8gYWJvcnQgc2lsZW50bHkgaWYgYWNjb3VudCBpcyBtaXNzaW5nIHNvbWUgaW5mbyAtIHNvbWUgY2hhaW5zL3dhbGxldHMgKGUuZy4gZXRoZXJldW0pIGRvbnQgcHJvdmlkZSB0aGUgcHVibGljIGtleSwgc28gd2UgY2FuJ3QgYWRkIHRoZSBwZXJtIGhlcmVcbiAgICBpZiAoIWNoYWluQWNjb3VudCB8fCAhcGVybWlzc2lvbnMgfHwgIWNoYWluTmV0d29yaykgcmV0dXJuXG5cbiAgICAvLyBzYXZlIHBlcm1pc3Npb25zIHRvIG9yZWlkIHNlcnZpY2VcbiAgICBhd2FpdCB0aGlzLl91c2VyPy51cGRhdGVQZXJtaXNzaW9uc0lmTmVjZXNzYXJ5KHtcbiAgICAgIGNoYWluQWNjb3VudCxcbiAgICAgIGNoYWluTmV0d29yayxcbiAgICAgIHBlcm1pc3Npb25zLFxuICAgICAgd2FsbGV0VHlwZSxcbiAgICB9KVxuICAgIHJldHVyblxuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhpcyBVQUwgcHJvdmlkZXIgd2FzIGluc3RhbGxlZCB1cG9uIGluc3RhbnRpYXRpb24gKi9cbiAgaXNVYWxQcm92aWRlcih3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUpIHtcbiAgICBjb25zdCB3YWxsZXRQcm92aWRlclR5cGUgPSBIZWxwZXJzLm1hcEF1dGhQcm92aWRlclRvV2FsbGV0VHlwZSh3YWxsZXRUeXBlKVxuICAgIGlmICghd2FsbGV0UHJvdmlkZXJUeXBlKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gc3VwcG9ydGVkVUFMUHJvdmlkZXJzLmluY2x1ZGVzKHdhbGxldFByb3ZpZGVyVHlwZSlcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoaXMgVUFMIHByb3ZpZGVyIHdhcyBpbnN0YWxsZWQgdXBvbiBpbnN0YW50aWF0aW9uICovXG4gIGhhc1VhbFByb3ZpZGVyKHdhbGxldFR5cGU6IEV4dGVybmFsV2FsbGV0VHlwZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9vcmVJZENvbnRleHQudWFsUHJvdmlkZXJzSW5zdGFsbGVkLmluY2x1ZGVzKHdhbGxldFR5cGUpXG4gIH1cblxuICAvKipcbiAgICogZ2V0IHVzZXIgYWNjb3VudCBrZXlzXG4gICAqIHNvbWUgd2FsbGV0cyBkb24ndCBzdXBwb3J0IGdldEtleXNcbiAgICovXG4gIGFzeW5jIGdldEtleXModWFsVXNlcjogVWFsVXNlcik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBsZXQga2V5czogc3RyaW5nW11cblxuICAgIHRyeSB7XG4gICAgICBrZXlzID0gYXdhaXQgdWFsVXNlci5nZXRLZXlzKClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gVE9ETzogYWRkIGxvZ2ljIHRvIGdldCBwZXJtaXNzaW9ucyBmcm9tIGVvcyBjaGFpbiBmb3IgdGhpcyBhY2NvdW50XG4gICAgICAvLyBjb25zdCBhY2NvdW50ID0gYXdhaXQgdWFsVXNlci5nZXRBY2NvdW50TmFtZSgpXG4gICAgICAvLyBjb25zdCB1YWxVc2VyQWNjb3VudCA9ICh1YWxVc2VyIGFzIGFueSkuY2xpZW50ICYmIChhd2FpdCAodWFsVXNlciBhcyBhbnkpLmNsaWVudC52MS5jaGFpbi5nZXRfYWNjb3VudChhY2NvdW50KSlcbiAgICAgIC8vIGNvbnN0IGtleXMgPSBhd2FpdCAodWFsVXNlciBhcyBhbnkpLmV4dHJhY3RBY2NvdW50S2V5cyh1YWxVc2VyQWNjb3VudClcbiAgICAgIGtleXMgPSBbXVxuICAgIH1cblxuICAgIHJldHVybiBrZXlzXG4gIH1cblxuICAvKiogVGhyb3cgaWYgdGhlIHByb3ZpZGVyIGRvZXNudCBzdXBwb3J0IHRoZSBzcGVjaWZpZWQgY2hhaW5OZXR3b3JrICovXG4gIGFzeW5jIGFzc2VydFByb3ZpZGVyVmFsaWRGb3JDaGFpbk5ldHdvcmsod2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlLCBjaGFpbk5ldHdvcms6IENoYWluTmV0d29yaykge1xuICAgIGNvbnN0IHsgY2hhaW5UeXBlIH0gPSBnZXRVYWxQcm92aWRlckF0dHJpYnV0ZXMod2FsbGV0VHlwZSlcbiAgICBjb25zdCBuZXR3b3JrcyA9IGF3YWl0IHRoaXMuX29yZUlkQ29udGV4dC5zZXR0aW5ncy5nZXRBbGxDaGFpbk5ldHdvcmtTZXR0aW5ncygpXG4gICAgY29uc3QgaXNWYWxpZCA9ICEhbmV0d29ya3MuZmluZChuID0+IG4ubmV0d29yayA9PT0gY2hhaW5OZXR3b3JrICYmIG4udHlwZSA9PT0gY2hhaW5UeXBlKVxuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBFeHRlcm5hbCBXYWxsZXQgVHlwZTogJHt3YWxsZXRUeXBlfSBkb2VzbnQgc3VwcG9ydCBjaGFpbk5ldHdvcmsgJHtjaGFpbk5ldHdvcmt9LiBIaW50OiBJdCBzdXBwb3J0cyBuZXR3b3JrcyBvZiB0eXBlICR7Y2hhaW5UeXBlfS5gLFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8qKiBzZXQgaXNCdXN5IG9uIG9yZUlkQ29udGV4dCB3aGlsZSB3YWxsZXQgYXV0aGVudGljYXRvciBpc0xvYWRpbmcgKi9cbiAgcHJpdmF0ZSBhc3luYyB3YWl0V2hpbGVXYWxsZXRJc0J1c3kodWFsQXV0aGVudGljYXRvcjogVWFsQXV0aGVudGljYXRvciwgd2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlKSB7XG4gICAgd2hpbGUgKHVhbEF1dGhlbnRpY2F0b3IuaXNMb2FkaW5nKCkpIHtcbiAgICAgIHRoaXMuX29yZUlkQ29udGV4dC5zZXRJc0J1c3kodHJ1ZSlcbiAgICAgIC8vIHRvZG86IGFkZCB0aW1lb3V0XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgYXdhaXQgSGVscGVycy5zbGVlcCgyNTApXG4gICAgICAvLyB0aGlzIGlzIGhlcmUgdG8gaGVscCBhIGRldmVsb3BlciBkZWJ1ZyAtIGRvbnQgcmVtb3ZlIHRoaXMgLSBpZiBhIHdhbGxldCBpcyBub3Qgb3BlbiB0byBjb25uZWN0IHRvLCBpdCB3aWxsIGhhbmcgaGVyZVxuICAgICAgY29uc29sZS5sb2coYGNvbm5lY3RpbmcgdG8gJHt3YWxsZXRUeXBlfSB2aWEgVUFMIHdhbGxldCBpbiBwcm9ncmVzczpgLCB1YWxBdXRoZW50aWNhdG9yLmlzTG9hZGluZygpKVxuICAgIH1cbiAgICB0aGlzLl9vcmVJZENvbnRleHQuc2V0SXNCdXN5KGZhbHNlKVxuICB9XG5cbiAgLy8gU3VwcG9ydGVkIGZlYXR1cmVzIGJ5IHByb3ZpZGVyXG5cbiAgLyoqIHdoZXRoZXIgZGlzY292ZXJ5IGlzIHN1cHBvcnRlZCBieSB0aGUgcHJvdmlkZXIgKi9cbiAgY2FuRGlzY292ZXIod2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlKSB7XG4gICAgaWYgKHRoaXMuaGFzVWFsUHJvdmlkZXIod2FsbGV0VHlwZSkpIHtcbiAgICAgIHJldHVybiBnZXRVYWxQcm92aWRlckF0dHJpYnV0ZXMod2FsbGV0VHlwZSkuc3VwcG9ydHNEaXNjb3ZlcnlcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKiogd2hldGhlciBzaWduU3RyaW5nIGlzIHN1cHBvcnRlZCBieSB0aGUgcHJvdmlkZXIgKi9cbiAgY2FuU2lnblN0cmluZyh3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUpIHtcbiAgICBpZiAodGhpcy5oYXNVYWxQcm92aWRlcih3YWxsZXRUeXBlKSkge1xuICAgICAgcmV0dXJuIGdldFVhbFByb3ZpZGVyQXR0cmlidXRlcyh3YWxsZXRUeXBlKS5zdXBwb3J0c1NpZ25BcmJpdHJhcnlcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKiogd2hldGhlciBjYWxsIHRvIGRpc2NvdmVyIGlzIHJlcXVpcmVkIGJ5IHByb3ZpZGVyIGJlZm9yZSBsb2dpbiAqL1xuICByZXF1aXJlc0Rpc2NvdmVyVG9Mb2dpbih3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUpIHtcbiAgICBpZiAodGhpcy5oYXNVYWxQcm92aWRlcih3YWxsZXRUeXBlKSkge1xuICAgICAgcmV0dXJuIGdldFVhbFByb3ZpZGVyQXR0cmlidXRlcyh3YWxsZXRUeXBlKS5yZXF1aXJlc0Rpc2NvdmVyVG9Mb2dpblxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKiB3aGV0aGVyIGNhbGwgdG8gbG9nb3V0IHRoZW4gbG9naW4gaXMgcmVxdWlyZWQgYnkgcHJvdmlkZXIgYmVmb3JlIGRpc2NvdmVyICovXG4gIHJlcXVpcmVzTG9nb3V0TG9naW5Ub0Rpc2NvdmVyKHdhbGxldFR5cGU6IEV4dGVybmFsV2FsbGV0VHlwZSkge1xuICAgIGlmICh0aGlzLmhhc1VhbFByb3ZpZGVyKHdhbGxldFR5cGUpKSB7XG4gICAgICByZXR1cm4gZ2V0VWFsUHJvdmlkZXJBdHRyaWJ1dGVzKHdhbGxldFR5cGUpLnJlcXVpcmVzTG9nb3V0TG9naW5Ub0Rpc2NvdmVyXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqIGRlZmF1bHQgcGF0aCBpbmRleCBmb3IgcHJvdmlkZXIgKGlmIGFueSkgKi9cbiAgZGVmYXVsdERpc2NvdmVyeVBhdGhJbmRleExpc3Qod2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlKTogbnVtYmVyW10ge1xuICAgIGlmICh0aGlzLmhhc1VhbFByb3ZpZGVyKHdhbGxldFR5cGUpKSB7XG4gICAgICByZXR1cm4gZ2V0VWFsUHJvdmlkZXJBdHRyaWJ1dGVzKHdhbGxldFR5cGUpPy5kZWZhdWx0RGlzY292ZXJ5UGF0aEluZGV4TGlzdFxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqIGhlbHAgdGV4dCBkaXNwbGF5ZWQgdG8gdXNlciBmb3IgcHJvdmlkZXIgKi9cbiAgaGVscFRleHRGb3JQcm92aWRlcih3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUpIHtcbiAgICBpZiAodGhpcy5oYXNVYWxQcm92aWRlcih3YWxsZXRUeXBlKSkge1xuICAgICAgcmV0dXJuIGdldFVhbFByb3ZpZGVyQXR0cmlidXRlcyh3YWxsZXRUeXBlKS5oZWxwVGV4dFxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbiIsImltcG9ydCB7IEV4dGVybmFsV2FsbGV0VHlwZSwgQ2hhaW5QbGF0Zm9ybVR5cGUgfSBmcm9tICcuLi9jb21tb24vbW9kZWxzJ1xuaW1wb3J0IHsgVWFsUHJvdmlkZXJBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vdWFsL21vZGVscydcblxuZXhwb3J0IGNvbnN0IHVhbFByb3ZpZGVyQXR0cmlidXRlc0RhdGE6IFVhbFByb3ZpZGVyQXR0cmlidXRlc1tdID0gW1xuICB7XG4gICAgcHJvdmlkZXJOYW1lOiBFeHRlcm5hbFdhbGxldFR5cGUuQW5jaG9yLFxuICAgIHByb3ZpZGVySWQ6ICdBbmNob3InLFxuICAgIGNoYWluVHlwZTogQ2hhaW5QbGF0Zm9ybVR5cGUuZW9zLFxuICAgIHJlcXVpcmVzTG9naW46IHRydWUsXG4gICAgc3VwcG9ydHNTaWduQXJiaXRyYXJ5OiBmYWxzZSxcbiAgICByZXF1aXJlc0xvZ291dExvZ2luVG9EaXNjb3ZlcjogZmFsc2UsXG4gICAgcmVxdWlyZXNEaXNjb3ZlclRvTG9naW46IGZhbHNlLFxuICAgIHN1cHBvcnRzRGlzY292ZXJ5OiBmYWxzZSxcbiAgICBoZWxwVGV4dDoge1xuICAgICAgbG9naW46ICdUaGlzIHdhbGxldCBkb2VzbuKAmXQgcmVxdWlyZSB5b3UgdG8gbG9naW4nLFxuICAgICAgc2lnbjogJycsXG4gICAgICBkaXNjb3ZlcjogJycsXG4gICAgICB2ZXJzaW9uc1JlcXVpcmVkOiAnJyxcbiAgICB9LFxuICAgIGxvZ29Vcmw6ICdodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vb3JlaWQtZmlsZXMvcGFydG5lcnMvd2FsbGV0LWdlbmVyaWMtbG9nby5wbmcnLCAvLyBUT0RPOiBBZGQgYWN0dWFsIGxvZ29cbiAgfSxcbiAge1xuICAgIHByb3ZpZGVyTmFtZTogRXh0ZXJuYWxXYWxsZXRUeXBlLkxlZGdlcixcbiAgICBwcm92aWRlcklkOiAnTGVkZ2VyJyxcbiAgICBjaGFpblR5cGU6IENoYWluUGxhdGZvcm1UeXBlLmVvcyxcbiAgICByZXF1aXJlc0xvZ2luOiB0cnVlLFxuICAgIHN1cHBvcnRzU2lnbkFyYml0cmFyeTogZmFsc2UsXG4gICAgcmVxdWlyZXNMb2dvdXRMb2dpblRvRGlzY292ZXI6IGZhbHNlLFxuICAgIHJlcXVpcmVzRGlzY292ZXJUb0xvZ2luOiBmYWxzZSxcbiAgICBzdXBwb3J0c0Rpc2NvdmVyeTogZmFsc2UsXG4gICAgaGVscFRleHQ6IHtcbiAgICAgIGxvZ2luOiAnVGhpcyB3YWxsZXQgZG9lc27igJl0IHJlcXVpcmUgeW91IHRvIGxvZ2luJyxcbiAgICAgIHNpZ246ICdDb25uZWN0IGFuZCB1bmxvY2sgeW91ciBMZWRnZXIgd2l0aCB5b3VyIFBJTiBjb2RlLiBMYXVuY2ggdGhlIEVPUyBhcHAgb24gdGhlIGRldmljZS4nLFxuICAgICAgZGlzY292ZXI6ICdDb25uZWN0IGFuZCB1bmxvY2sgeW91ciBMZWRnZXIgd2l0aCB5b3VyIFBJTiBjb2RlLiBMYXVuY2ggdGhlIEVPUyBhcHAgb24gdGhlIGRldmljZS4nLFxuICAgICAgdmVyc2lvbnNSZXF1aXJlZDpcbiAgICAgICAgJ1lvdSBuZWVkIHRvIGhhdmUgcmVjZW50IHZlcnNpb25zIG9mIHlvdXIgYnJvd3NlciwgTGVkZ2VyIGZpcm13YXJlLCBhbmQgdGhlIExlZGdlciBFT1MgYXBwLiBDbGljayBoZXJlIGZvciBtb3JlIGRldGFpbHMuJyxcbiAgICB9LFxuICAgIGxvZ29Vcmw6ICdodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vb3JlaWQtZmlsZXMvcGFydG5lcnMvd2FsbGV0LWxlZGdlci1sb2dvLnBuZycsXG4gIH0sXG4gIHtcbiAgICBwcm92aWRlck5hbWU6IEV4dGVybmFsV2FsbGV0VHlwZS5MeW54LFxuICAgIHByb3ZpZGVySWQ6ICdMeW54JyxcbiAgICBjaGFpblR5cGU6IENoYWluUGxhdGZvcm1UeXBlLmVvcyxcbiAgICByZXF1aXJlc0xvZ2luOiBmYWxzZSxcbiAgICBzdXBwb3J0c1NpZ25BcmJpdHJhcnk6IHRydWUsXG4gICAgcmVxdWlyZXNMb2dvdXRMb2dpblRvRGlzY292ZXI6IGZhbHNlLFxuICAgIHJlcXVpcmVzRGlzY292ZXJUb0xvZ2luOiBmYWxzZSxcbiAgICBzdXBwb3J0c0Rpc2NvdmVyeTogZmFsc2UsXG4gICAgaGVscFRleHQ6IHtcbiAgICAgIGxvZ2luOiAnVGhpcyB3YWxsZXQgZG9lc27igJl0IHJlcXVpcmUgeW91IHRvIGxvZ2luJyxcbiAgICAgIHNpZ246ICcnLFxuICAgICAgZGlzY292ZXI6ICcnLFxuICAgICAgdmVyc2lvbnNSZXF1aXJlZDogJycsXG4gICAgfSxcbiAgICBsb2dvVXJsOiAnaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL29yZWlkLWZpbGVzL3BhcnRuZXJzL3dhbGxldC1seW54LWxvZ28ucG5nJyxcbiAgfSxcbiAge1xuICAgIHByb3ZpZGVyTmFtZTogRXh0ZXJuYWxXYWxsZXRUeXBlLlNjYXR0ZXIsXG4gICAgcHJvdmlkZXJJZDogJ1NjYXR0ZXInLFxuICAgIGNoYWluVHlwZTogQ2hhaW5QbGF0Zm9ybVR5cGUuZW9zLFxuICAgIHJlcXVpcmVzTG9naW46IHRydWUsXG4gICAgc3VwcG9ydHNTaWduQXJiaXRyYXJ5OiB0cnVlLFxuICAgIHJlcXVpcmVzTG9nb3V0TG9naW5Ub0Rpc2NvdmVyOiBmYWxzZSxcbiAgICByZXF1aXJlc0Rpc2NvdmVyVG9Mb2dpbjogZmFsc2UsXG4gICAgc3VwcG9ydHNEaXNjb3Zlcnk6IGZhbHNlLFxuICAgIGhlbHBUZXh0OiB7XG4gICAgICBsb2dpbjogJ1NjYXR0ZXIgcmVxdWlyZXMgbG9nZ2luZyBpbiB0aHJvdWdoIHRoZSBTY2F0dGVyIGFwcC4nLFxuICAgICAgc2lnbjogJycsXG4gICAgICBkaXNjb3ZlcjogJycsXG4gICAgICB2ZXJzaW9uc1JlcXVpcmVkOiAnJyxcbiAgICB9LFxuICAgIGxvZ29Vcmw6ICdodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vb3JlaWQtZmlsZXMvcGFydG5lcnMvd2FsbGV0LXNjYXR0ZXItbG9nby5wbmcnLFxuICB9LFxuICB7XG4gICAgcHJvdmlkZXJOYW1lOiBFeHRlcm5hbFdhbGxldFR5cGUuVG9rZW5Qb2NrZXQsXG4gICAgcHJvdmlkZXJJZDogJ1Rva2VuIFBvY2tldCcsXG4gICAgY2hhaW5UeXBlOiBDaGFpblBsYXRmb3JtVHlwZS5lb3MsXG4gICAgcmVxdWlyZXNMb2dpbjogZmFsc2UsXG4gICAgc3VwcG9ydHNTaWduQXJiaXRyYXJ5OiB0cnVlLFxuICAgIHJlcXVpcmVzTG9nb3V0TG9naW5Ub0Rpc2NvdmVyOiBmYWxzZSxcbiAgICByZXF1aXJlc0Rpc2NvdmVyVG9Mb2dpbjogZmFsc2UsXG4gICAgc3VwcG9ydHNEaXNjb3Zlcnk6IGZhbHNlLFxuICAgIGhlbHBUZXh0OiB7XG4gICAgICBsb2dpbjogJ1RoaXMgd2FsbGV0IGRvZXNu4oCZdCByZXF1aXJlIHlvdSB0byBsb2dpbicsXG4gICAgICBzaWduOiAnJyxcbiAgICAgIGRpc2NvdmVyOiAnJyxcbiAgICAgIHZlcnNpb25zUmVxdWlyZWQ6ICcnLFxuICAgIH0sXG4gICAgbG9nb1VybDogJ2h0dHBzOi8vc3RvcmFnZS5nb29nbGVhcGlzLmNvbS9vcmVpZC1maWxlcy9wYXJ0bmVycy93YWxsZXQtZ2VuZXJpYy1sb2dvLnBuZycsXG4gIH0sXG4gIHtcbiAgICBwcm92aWRlck5hbWU6IEV4dGVybmFsV2FsbGV0VHlwZS5Xb21iYXQsXG4gICAgcHJvdmlkZXJJZDogJ1dvbWJhdCcsXG4gICAgY2hhaW5UeXBlOiBDaGFpblBsYXRmb3JtVHlwZS5lb3MsXG4gICAgcmVxdWlyZXNMb2dpbjogdHJ1ZSxcbiAgICBzdXBwb3J0c1NpZ25BcmJpdHJhcnk6IHRydWUsXG4gICAgcmVxdWlyZXNMb2dvdXRMb2dpblRvRGlzY292ZXI6IGZhbHNlLFxuICAgIHJlcXVpcmVzRGlzY292ZXJUb0xvZ2luOiBmYWxzZSxcbiAgICBzdXBwb3J0c0Rpc2NvdmVyeTogZmFsc2UsXG4gICAgaGVscFRleHQ6IHtcbiAgICAgIGxvZ2luOiAnVGhpcyB3YWxsZXQgZG9lc27igJl0IHJlcXVpcmUgeW91IHRvIGxvZ2luJyxcbiAgICAgIHNpZ246ICcnLFxuICAgICAgZGlzY292ZXI6ICcnLFxuICAgICAgdmVyc2lvbnNSZXF1aXJlZDogJycsXG4gICAgfSxcbiAgICBsb2dvVXJsOiAnaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL29yZWlkLWZpbGVzL3BhcnRuZXJzL3dhbGxldC13b21iYXQtbG9nby5wbmcnLCAvLyBUT0RPOiBBZGQgYWN0dWFsIGxvZ29cbiAgfSxcbl1cblxuLyoqIEdldCBwcm92aWRlci1zcGVjaWZpYyBzZXR0aW5ncyBhbmQgbWV0YWRhdGEgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVYWxQcm92aWRlckF0dHJpYnV0ZXMod2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlKTogVWFsUHJvdmlkZXJBdHRyaWJ1dGVzIHtcbiAgcmV0dXJuIHVhbFByb3ZpZGVyQXR0cmlidXRlc0RhdGEuZmluZCh1cCA9PiB1cC5wcm92aWRlck5hbWUgPT09IHdhbGxldFR5cGUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpKVxufVxuXG4vKiogR2V0IHByb3ZpZGVyLXNwZWNpZmljIHNldHRpbmdzIGFuZCBtZXRhZGF0YSBieSB0aGUgVUFMIHByb3ZpZGVyIG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVYWxQcm92aWRlckF0dHJpYnV0ZXNCeVVhbE5hbWUod2FsbGV0VHlwZTogc3RyaW5nKTogVWFsUHJvdmlkZXJBdHRyaWJ1dGVzIHtcbiAgcmV0dXJuIHVhbFByb3ZpZGVyQXR0cmlidXRlc0RhdGEuZmluZCh1cCA9PiB1cC5wcm92aWRlck5hbWUgPT09IHdhbGxldFR5cGUudG9Mb3dlckNhc2UoKSlcbn1cblxuZXhwb3J0IGNvbnN0IHN1cHBvcnRlZFVBTFByb3ZpZGVyczogRXh0ZXJuYWxXYWxsZXRUeXBlW10gPSB1YWxQcm92aWRlckF0dHJpYnV0ZXNEYXRhLm1hcCh0cCA9PiB0cC5wcm92aWRlck5hbWUpXG4iLCJpbXBvcnQge1xuICBBcGlHZXRVc2VyUGFyYW1zLFxuICBjYWxsQXBpRGVsZXRlVGVzdFVzZXIsXG4gIGNhbGxBcGlHZXRVc2VyLFxuICBjYWxsQXBpUGFzc3dvcmRMZXNzU2VuZENvZGUsXG4gIGNhbGxBcGlQYXNzd29yZExlc3NWZXJpZnlDb2RlLFxufSBmcm9tICcuLi9hcGknXG5pbXBvcnQgeyBjYWxsQXBpQWRkUGVybWlzc2lvbiB9IGZyb20gJy4uL2FwaS9lbmRwb2ludHMvYWRkUGVybWlzc2lvbidcbmltcG9ydCBPcmVJZENvbnRleHQgZnJvbSAnLi4vY29yZS9JT3JlaWRDb250ZXh0J1xuaW1wb3J0IHsgZ2V0T3JlSWROZXdDaGFpbkFjY291bnRVcmwgfSBmcm9tICcuLi9jb3JlL3VybEdlbmVyYXRvcnMnXG5pbXBvcnQgSGVscGVycyBmcm9tICcuLi91dGlscy9oZWxwZXJzJ1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL3V0aWxzL29ic2VydmFibGUnXG5pbXBvcnQgeyBBdXRoUHJvdmlkZXIsIEFjY291bnROYW1lLCBDaGFpbkFjY291bnQsIENoYWluTmV0d29yaywgRXh0ZXJuYWxXYWxsZXRUeXBlIH0gZnJvbSAnLi4vY29tbW9uL21vZGVscydcbmltcG9ydCB7IE5ld0FjY291bnRPcHRpb25zLCBOZXdBY2NvdW50V2l0aE9yZUlkUmVzdWx0IH0gZnJvbSAnLi4vY29yZS9tb2RlbHMnXG5pbXBvcnQge1xuICBVc2VyQ2hhaW5BY2NvdW50LFxuICBVc2VyRGF0YSxcbiAgVXNlclBlcm1pc3Npb25EYXRhLFxuICBVc2VyUGVybWlzc2lvbkZvckNoYWluQWNjb3VudCxcbiAgVXNlclNvdXJjZURhdGEsXG4gIFdhbGxldFBlcm1pc3Npb24sXG59IGZyb20gJy4vbW9kZWxzJ1xuaW1wb3J0IHsgQWNjZXNzVG9rZW5IZWxwZXIgfSBmcm9tICcuLi9hdXRoL2FjY2Vzc1Rva2VuSGVscGVyJ1xuaW1wb3J0IHsgY2FsbEFwaVVwZGF0ZURlbGF5V2FsbGV0U2V0dXAgfSBmcm9tICcuLi9hcGkvZW5kcG9pbnRzL3VwZGF0ZURlbGF5V2FsbGV0U2V0dXAnXG5cbmNvbnN0IHsgaXNOdWxsT3JFbXB0eSB9ID0gSGVscGVyc1xuXG5leHBvcnQgdHlwZSBTdWJzY3JpYmVyVXNlciA9ICh2YWx1ZXM6IFVzZXIpID0+IHZvaWRcblxuZXhwb3J0IGNsYXNzIFVzZXIgZXh0ZW5kcyBPYnNlcnZhYmxlPFN1YnNjcmliZXJVc2VyPiB7XG4gIGNvbnN0cnVjdG9yKGFyZ3M6IHsgb3JlSWRDb250ZXh0OiBPcmVJZENvbnRleHQ7IGFjY2Vzc1Rva2VuSGVscGVyOiBBY2Nlc3NUb2tlbkhlbHBlcjsgYWNjb3VudE5hbWU6IEFjY291bnROYW1lIH0pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fb3JlSWRDb250ZXh0ID0gYXJncy5vcmVJZENvbnRleHRcbiAgICB0aGlzLl9hY2Nlc3NUb2tlbkhlbHBlciA9IGFyZ3MuYWNjZXNzVG9rZW5IZWxwZXIgLy8gcmVmZXJlbmNlIHRvIGN1cnJlbnQgYWNjZXNzVG9rZW4gKHZpYSBnZXR0ZXIpXG4gICAgdGhpcy5fYWNjb3VudE5hbWUgPSBhcmdzLmFjY291bnROYW1lXG4gICAgdGhpcy5fYWNjZXNzVG9rZW5IZWxwZXIuc3Vic2NyaWJlKHRoaXMub25VcGRhdGVBY2Nlc3NUb2tlbkhlbHBlcilcbiAgfVxuXG4gIC8vIHB1bGxlZCBmcm9tIHRoZSBhY2Nlc3NUb2tlblxuICBwcml2YXRlIF9hY2NvdW50TmFtZTogQWNjb3VudE5hbWVcblxuICBwcml2YXRlIF9hY2Nlc3NUb2tlbkhlbHBlcjogQWNjZXNzVG9rZW5IZWxwZXJcblxuICBwcml2YXRlIF9vcmVJZENvbnRleHQ6IE9yZUlkQ29udGV4dFxuXG4gIC8qKiBVc2VyJ3MgYmFzaWMgaW5mb3JtYXRpb24gYW5kIGJsb2NrY2hhaW4gYWNjb3VudHMgKGFrYSBwZXJtaXNzaW9ucykgKi9cbiAgcHJpdmF0ZSBfdXNlclNvdXJjZURhdGE6IFVzZXJTb3VyY2VEYXRhXG5cbiAgcHJpdmF0ZSBnZXQgYWNjZXNzVG9rZW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fYWNjZXNzVG9rZW5IZWxwZXIuYWNjZXNzVG9rZW5cbiAgfVxuXG4gIC8qKiBVc2VyJ3MgT3JlSUQgKGFjY291bnROYW1lKSAqL1xuICBnZXQgYWNjb3VudE5hbWUoKTogQWNjb3VudE5hbWUge1xuICAgIHJldHVybiB0aGlzLl9hY2NvdW50TmFtZVxuICB9XG5cbiAgLyoqIFVzZXIncyBwZXJzb25hbCBpbmZvIChlLmcuIG5hbWUsIGVtYWlsLCBwaWN0dXJlKSAqL1xuICBnZXQgZGF0YSgpOiBVc2VyRGF0YSB7XG4gICAgdGhpcy5hc3NlcnRVc2VySGFzRGF0YSgpXG4gICAgY29uc3QgeyBwZXJtaXNzaW9ucywgLi4ub3RoZXJJbmZvIH0gPSB0aGlzLl91c2VyU291cmNlRGF0YVxuICAgIHJldHVybiB7XG4gICAgICAuLi5vdGhlckluZm8sXG4gICAgICBjaGFpbkFjY291bnRzOiB0aGlzLmdldENoYWluQWNjb3VudHMoKSxcbiAgICB9XG4gIH1cblxuICAvKiogV2hldGhlciB1c2VyJ3MgZGF0YSBoYXMgYmVlbiByZXRyaWV2ZWQgd2l0aCBnZXREYXRhKCkgKi9cbiAgZ2V0IGhhc0RhdGEoKSB7XG4gICAgcmV0dXJuICFpc051bGxPckVtcHR5KHRoaXM/Ll91c2VyU291cmNlRGF0YSlcbiAgfVxuXG4gIHByaXZhdGUgc2V0VXNlclNvdXJjZURhdGEodXNlclNvdXJjZURhdGE6IFVzZXJTb3VyY2VEYXRhKSB7XG4gICAgdGhpcy5fdXNlclNvdXJjZURhdGEgPSB1c2VyU291cmNlRGF0YVxuICAgIHN1cGVyLmNhbGxTdWJzY3JpYmVycygpXG4gIH1cblxuICAvKiogUmV0dXJuIEJsb2NrY2hhaW4gYWNjb3VudHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyJ3MgT3JlSWQgYWNjb3VudCAqL1xuICBwcml2YXRlIGdldENoYWluQWNjb3VudHMoKTogVXNlckNoYWluQWNjb3VudFtdIHtcbiAgICB0aGlzLmFzc2VydFVzZXJIYXNEYXRhKClcbiAgICBjb25zdCBjaGFpbkFjY291bnRzID0gKHRoaXMuX3VzZXJTb3VyY2VEYXRhLnBlcm1pc3Npb25zIHx8IFtdKS5tYXAocGVybSA9PiB7XG4gICAgICBjb25zdCBbZGVmYXVsdFBlcm1pc3Npb25dID0gdGhpcy5nZXREZWZhdWx0UGVybWlzc2lvbkZvckNoYWluQWNjb3VudChwZXJtLmNoYWluQWNjb3VudCwgcGVybS5jaGFpbk5ldHdvcmspXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFpbkFjY291bnQ6IHBlcm0uY2hhaW5BY2NvdW50LFxuICAgICAgICBjaGFpbk5ldHdvcms6IHBlcm0uY2hhaW5OZXR3b3JrLFxuICAgICAgICBkZWZhdWx0UGVybWlzc2lvbixcbiAgICAgICAgcGVybWlzc2lvbnM6IHRoaXMuZ2V0UGVybWlzc2lvbkZvckNoYWluQWNjb3VudChwZXJtLmNoYWluQWNjb3VudCwgcGVybS5jaGFpbk5ldHdvcmspLFxuICAgICAgfVxuICAgIH0pXG4gICAgLy8gb25seSByZXR1cm4gdW5pcXVlIGNvbWJpbmF0aW9ucyBvZiBjaGFpbkFjY291bnQgYW5kIGNoYWluTmV0d29ya1xuICAgIHJldHVybiBIZWxwZXJzLmdldFVuaXF1ZVZhbHVlcyhjaGFpbkFjY291bnRzKVxuICB9XG5cbiAgLyoqIFdoZXRoZXIgd2UgaGF2ZSBhIHZhbGlkIGFjY2VzcyB0b2tlbiBmb3IgdGhlIGN1cnJlbnQgdXNlciAqL1xuICBnZXQgaXNMb2dnZWRJbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLmFjY2Vzc1Rva2VuXG4gIH1cblxuICAvKiogcnVucyB3aGVuIGFjY2Vzc1Rva2VuSGVscGVyIGNoYW5nZXMgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBwcml2YXRlIG9uVXBkYXRlQWNjZXNzVG9rZW5IZWxwZXIgPSAobmV3QWNjZXNzVG9rZW5IZWxwZXI6IEFjY2Vzc1Rva2VuSGVscGVyKSA9PiB7XG4gICAgdGhpcy5fYWNjb3VudE5hbWUgPSBuZXdBY2Nlc3NUb2tlbkhlbHBlci5hY2NvdW50TmFtZVxuICAgIHN1cGVyLmNhbGxTdWJzY3JpYmVycygpXG4gIH1cblxuICAvKiogdGhyb3cgaWYgdXNlciBkYXRhIGhhc24ndCBiZWVuIHJldHJpZXZlZCB5ZXQgKi9cbiAgcHJpdmF0ZSBhc3NlcnRVc2VySGFzRGF0YSgpIHtcbiAgICBpZiAoIXRoaXMuaGFzRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2VyIGRhdGEgaGFzbnQgYmVlbiByZXRyaWV2ZWQuIENhbGwgdXNlci5nZXREYXRhKCkgZmlyc3QuJylcbiAgICB9XG4gIH1cblxuICAvKiogdGhyb3cgaWYgdXNlciBoYXNuJ3QgaGF2ZSBhIHZhbGlkIGVtYWlsIChpLmUuIHVzZXIuZW1haWwpICovXG4gIHByaXZhdGUgYXNzZXJ0VXNlckhhc1ZhbGlkRW1haWwoKSB7XG4gICAgdGhpcy5hc3NlcnRVc2VySGFzRGF0YSgpXG4gICAgY29uc3QgeyBlbWFpbCB9ID0gdGhpcz8uZGF0YSB8fCB7fVxuICAgIGlmICghSGVscGVycy5pc1ZhbGlkRW1haWwoZW1haWwpKSB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgZG9lc250IGhhdmUgYSB2YWxpZCBlbWFpbCcpXG4gIH1cblxuICAvKiogR2V0IHRoZSB1c2VyIGluZm8gZnJvbSBPUkUgSUQgQVBJIGZvciBhIGdpdmVuIHVzZXIgYWNjb3VudCBhbmQgKHVzdWFsbHkpIHNhdmUgdGhlIHVzZXIgaW50byBsb2NhbFN0b3JhZ2UgJ2NhY2hlJ1xuICAgKiAgTXVzdCBoYXZlIGEgdmFsaWQgYWNjZXNzVG9rZW4gdG8gcmV0cmlldmUgdXNlclxuICAgKi9cbiAgYXN5bmMgZ2V0RGF0YShmb3JjZVJlZnJlc2g/OiBib29sZWFuKTogUHJvbWlzZTxVc2VyRGF0YT4ge1xuICAgIGlmICh0aGlzLmhhc0RhdGEgJiYgIWZvcmNlUmVmcmVzaCkgcmV0dXJuIHRoaXMuZGF0YVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gdGhpcy5hY2Nlc3NUb2tlblxuICAgIGlmICghYWNjZXNzVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWNjZXNzVG9rZW4gaXMgbWlzc2luZyBvciBoYXMgZXhwaXJlZCcpXG4gICAgfVxuICAgIC8vIGdldCBhY2NvdW50IHNwZWNpZmllZCBpbiBhY2Nlc3MgdG9rZW5cbiAgICBjb25zdCBhY2NvdW50ID0gdGhpcz8uX2FjY291bnROYW1lXG4gICAgY29uc3QgcGFyYW1zOiBBcGlHZXRVc2VyUGFyYW1zID0geyBhY2NvdW50IH1cbiAgICBjb25zdCB1c2VyU291cmNlRGF0YSA9IGF3YWl0IGNhbGxBcGlHZXRVc2VyKHRoaXMuX29yZUlkQ29udGV4dCwgcGFyYW1zKVxuXG4gICAgdGhpcy5fYWNjb3VudE5hbWUgPSBhY2NvdW50XG4gICAgdGhpcy5zZXRVc2VyU291cmNlRGF0YSh1c2VyU291cmNlRGF0YSlcbiAgICByZXR1cm4gdGhpcy5kYXRhXG4gIH1cblxuICAvKiogQ2xlYXJzIHVzZXIncyBhY2Nlc3NUb2tlbiBhbmQgdXNlciBwcm9maWxlIGRhdGEgKi9cbiAgbG9nb3V0KCkge1xuICAgIHRoaXMuX29yZUlkQ29udGV4dC5sb2dvdXQoKVxuICB9XG5cbiAgLyoqIFJlcXVlc3QgT1JFSUQgdG8gY3JlYXRlIGEgbmV3IGJsb2NrY2hhaW4gYWNjb3VudCBpbiBhbiBleGlzdGluZyB1c2VyJ3Mgd2FsbGV0XG4gICAqICBUaGlzIGlzIGFuIGFkdmFuY2VkIGZlYXR1cmUgLSBpdCBtb3N0IGNhc2VzLCBibG9ja2NoYWluIGFjY291bnRzIHdpbGwgYmUgY3JlYXRlZCBhdXRvbWF0aWNhbGx5IHVwb24gZmlyc3QgbG9naW5cbiAgICovXG4gIC8vIGFzeW5jIG5ld0NoYWluQWNjb3VudChuZXdBY2NvdW50T3B0aW9uczogTmV3QWNjb3VudE9wdGlvbnMpIHtcbiAgLy8gICAvLyBUT0RPIC0gY2FsbCBBUEkgdG8gY3JlYXRlIGNoYWluIGFjY291bnQgKHJlcXVpcmVzIGFwaUtleSB3aXRoIGNyZWF0ZUFjY291bnQgcmlnaHQpXG4gIC8vICAgLy8gZm9yIHdlYndpZGdldCwgaXQgc2hvdWxkIGp1c3QgcmVmcmVzaCB1c2VyIGluZm8gdXBvbiBjYWxsYmFja1xuICAvLyB9XG5cbiAgLyoqIFJldHVybnMgYSBmdWxseSBmb3JtZWQgdXJsIHRvIHJlZGlyZWN0IHRoZSB1c2VyJ3MgYnJvd3NlciB0byBjcmVhdGUgYSBuZXcgY2hhaW4gYWNjb3VudCB1c2luZyBPUkUgSURcbiAgICogIFRoaXMgZnVuY3Rpb24gY2FsbHMgdGhlIC9uZXctYWNjb3VudCB3ZWIgZW5kcG9pbnRcbiAgICogIFJldHVybnM6IENhbGxiYWNrIHJldHVybnMgbmV3IGNoYWluQWNjb3VudCBuYW1lICovXG4gIGFzeW5jIGdldE5ld0NoYWluQWNjb3VudFVybChuZXdBY2NvdW50T3B0aW9uczogTmV3QWNjb3VudE9wdGlvbnMpOiBQcm9taXNlPE5ld0FjY291bnRXaXRoT3JlSWRSZXN1bHQ+IHtcbiAgICBjb25zdCB7IGFjY291bnQsIGFjY291bnRUeXBlLCBjaGFpbk5ldHdvcmssIGFjY291bnRPcHRpb25zLCBwcm92aWRlciwgc3RhdGUgfSA9IG5ld0FjY291bnRPcHRpb25zIHx8IHt9XG4gICAgY29uc3QgeyBuZXdBY2NvdW50Q2FsbGJhY2tVcmwsIGJhY2tncm91bmRDb2xvciB9ID0gdGhpcy5fb3JlSWRDb250ZXh0Lm9wdGlvbnNcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgYWNjb3VudCxcbiAgICAgIGFjY291bnRUeXBlLFxuICAgICAgYmFja2dyb3VuZENvbG9yLFxuICAgICAgY2hhaW5OZXR3b3JrLFxuICAgICAgYWNjb3VudE9wdGlvbnMsXG4gICAgICBwcm92aWRlcixcbiAgICAgIGNhbGxiYWNrVXJsOiBuZXdBY2NvdW50Q2FsbGJhY2tVcmwsXG4gICAgICBzdGF0ZSxcbiAgICB9XG4gICAgY29uc3QgbmV3QWNjb3VudFVybCA9IGF3YWl0IGdldE9yZUlkTmV3Q2hhaW5BY2NvdW50VXJsKHRoaXMuX29yZUlkQ29udGV4dCwgYXJncylcbiAgICByZXR1cm4geyBuZXdBY2NvdW50VXJsLCBlcnJvcnM6IG51bGwgfVxuICB9XG5cbiAgLyoqIERlbGV0ZSBhIHRlc3QgdXNlclxuICAgKiBUZXN0IHVzZXJzIGFyZSBjcmVhdGVkIGJ5IHNldHRpbmcgaXNUZXN0VXNlcjp0cnVlIG9uIGZpcnN0IGF1dGhlbnRpY2F0aW9uKVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlVGVzdFVzZXIoKSB7XG4gICAgaWYgKCF0aGlzPy5hY2NvdW50TmFtZSkgdGhyb3cgbmV3IEVycm9yKCdVc2VyIG5vdCBhdXRoZW50aWNhdGVkLiBNdXN0IGJlIGxvZ2dlZC1pbiAob3IgaGF2ZSBzZXQgYW4gYWNjZXNzVG9rZW4pLicpXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsbEFwaURlbGV0ZVRlc3RVc2VyKHRoaXMuX29yZUlkQ29udGV4dCwge1xuICAgICAgYWNjb3VudDogdGhpcy5hY2NvdW50TmFtZSxcbiAgICB9KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKiBJZiB0aGUgdXNlciBoYXNuJ3QgYWxyZWFkeSBzZXR1cCB0aGVpciB3YWxsZXQsIHRoaXMgd2lsbCBwcm9tcHQgdGhlIHNldHVwIG9uIHRoZWlyIG5leHQgaW50ZXJhY3RpdmUgYXV0aGVudGljYXRpb25cbiAgICogVXNlZCB0byB0dXJuLW9mZiB0aGUgZGVsYXlXYWxsZXRTZXR1cCBmb3IgYSB1c2VyJ3MgYWNjb3VudFxuICAgKiBkZWxheVdhbGxldFNldHVwIGlzIGVuYWJsZWQgYnkgcGFzc2luZyBkZWxheVdhbGxldFNldHVwOnRydWUgZm9yIGEgdXNlcidzIGZpcnN0IGF1dGhlbnRpY2F0aW9uIChlLmcuIHBvcHVwLmF1dGgoZGVsYXlXYWxsZXRTZXR1cDp0cnVlKSlcbiAgICogRGVsYXllZCBXYWxsZXQgU2V0dXAgYWxsb3dzIGEgdXNlciB0byBsb2dpbiB3aXRob3V0IGNyZWF0aW5nIGJsb2NrY2hhaW4gYWNjb3VudHMgcmlnaHQgYXdheVxuICAgKiBDYWxsIHRoaXMgZnVuY3Rpb24gKHRvIGRpc2FibGUgZGVsYXlXYWxsZXRTZXR1cCkganVzdCBiZWZvcmUgdGhlIHVzZXIgbmVlZHMgYSBibG9ja2NoYWluIGFjY291bnQgKGUuZy4gYmVmb3JlIHNpZ25pbmcgYSB0cmFuc2FjdGlvbilcbiAgICovXG4gIGFzeW5jIGRpc2FibGVEZWxheWVkV2FsbGV0U2V0dXAoKSB7XG4gICAgaWYgKCF0aGlzPy5hY2NvdW50TmFtZSkgdGhyb3cgbmV3IEVycm9yKCdVc2VyIG5vdCBhdXRoZW50aWNhdGVkLiBNdXN0IGJlIGxvZ2dlZC1pbiAob3IgaGF2ZSBzZXQgYW4gYWNjZXNzVG9rZW4pLicpXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsbEFwaVVwZGF0ZURlbGF5V2FsbGV0U2V0dXAodGhpcy5fb3JlSWRDb250ZXh0LCB7XG4gICAgICBhY2NvdW50OiB0aGlzLmFjY291bnROYW1lLFxuICAgICAgZGVsYXlXYWxsZXRTZXR1cDogZmFsc2UsXG4gICAgfSlcbiAgICBhd2FpdCB0aGlzLmdldERhdGEodHJ1ZSlcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKiogU2VuZCBhIGNvZGUgdG8gdGhlIHVzZXIncyBwcmltYXJ5IGVtYWlsICh1c2VyLmVtYWlsKSAtIGluIG9yZGVyIHRvIHZlcmlmeSB0aGUgdXNlciBoYXMgYWNjZXNzIHRvIGl0XG4gICAqICBBZnRlciBzZW5kaW5nIHRoZSBjb2RlLCB1c2UgY2hlY2tWZXJpZmljYXRpb25Db2RlRm9yRW1haWwoKSB0byB2ZXJpZnkgdGhhdCB0aGUgdXNlciByZWNlaXZlZCB0aGUgY29kZSAqL1xuICBhc3luYyBzZW5kVmVyaWZpY2F0aW9uQ29kZVRvRW1haWwoKSB7XG4gICAgdGhpcy5hc3NlcnRVc2VySGFzVmFsaWRFbWFpbCgpXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsbEFwaVBhc3N3b3JkTGVzc1NlbmRDb2RlKHRoaXMuX29yZUlkQ29udGV4dCwge1xuICAgICAgZW1haWw6IHRoaXM/LmRhdGE/LmVtYWlsLFxuICAgICAgcHJvdmlkZXI6IEF1dGhQcm92aWRlci5FbWFpbCxcbiAgICB9KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKiBDb25maXJtIHRoYXQgdGhlIGNvZGUgbWF0Y2hlcyB0aGUgbGFzdCBvbmUganVzdCBzZW50IHRvIHRoZSBlbWFpbCBieSBzZW5kVmVyaWZpY2F0aW9uQ29kZVRvRW1haWwoKSAqL1xuICBhc3luYyBjaGVja1ZlcmlmaWNhdGlvbkNvZGVGb3JFbWFpbCh7IGNvZGUgfTogeyBjb2RlOiBzdHJpbmcgfSkge1xuICAgIHRoaXMuYXNzZXJ0VXNlckhhc1ZhbGlkRW1haWwoKVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhbGxBcGlQYXNzd29yZExlc3NWZXJpZnlDb2RlKHRoaXMuX29yZUlkQ29udGV4dCwge1xuICAgICAgY29kZSxcbiAgICAgIGVtYWlsOiB0aGlzPy5kYXRhPy5lbWFpbCxcbiAgICAgIHByb3ZpZGVyOiBBdXRoUHJvdmlkZXIuRW1haWwsXG4gICAgfSlcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBUT0RPOiByZW5hbWUgc2VuZFZlcmlmaWNhdGlvbkNvZGVUb0VtYWlsIC0gcGFzc3dvcmRsZXNzVmVyaWZpY2F0aW9uU2VuZENvZGUodHlwZSwgZW1haWwsIHBob25lKVxuICAvLyBUT0RPOiByZW5hbWUgY2hlY2tWZXJpZmljYXRpb25Db2RlRm9yRW1haWwgLSBwYXNzd29yZGxlc3NWZXJpZmljYXRpb25WZXJpZnlDb2RlKHR5cGUsIGVtYWlsLCBwaG9uZSlcblxuICAvKiogTWFwIHBlcm1pc3Npb24gZnJvbSBzZXJ2ZXIgZGF0YSB0byBsb2NhbCBVc2VyUGVybWlzc2lvbiBvYmplY3QgKi9cbiAgbWFwVXNlclBlcm1pc3Npb24ocGVybWlzc2lvbjogVXNlclBlcm1pc3Npb25EYXRhKTogVXNlclBlcm1pc3Npb25Gb3JDaGFpbkFjY291bnQge1xuICAgIGlmIChpc051bGxPckVtcHR5KHBlcm1pc3Npb24pKSByZXR1cm4gbnVsbFxuICAgIGNvbnN0IHsgY2hhaW5OZXR3b3JrLCBjaGFpbkFjY291bnQsIHBlcm1pc3Npb246IHBlcm1pc3Npb25OYW1lLCAuLi5vdGhlciB9ID0gcGVybWlzc2lvblxuICAgIHJldHVybiB7XG4gICAgICAuLi5vdGhlcixcbiAgICAgIG5hbWU6IHBlcm1pc3Npb25OYW1lLFxuICAgIH1cbiAgfVxuXG4gIC8qKiByZXR1cm5zIHRoZSBVc2VyUGVybWlzc2lucyBhIGNoYWluTmV0d29yay9jaGFpbkFjY291bnRcbiAgICogaWYgZGVmYXVsdE9ubHkgPSB0cnVlLCByZXR1cm5zIHRoZSBzaW5nbGUgZGVmYXVsdCBwZXJtaXNzaW9uIGZvciB0aGUgY2hhaW5BY2NvdW50XG4gICAqL1xuICBnZXRQZXJtaXNzaW9uRm9yQ2hhaW5BY2NvdW50KFxuICAgIGNoYWluQWNjb3VudDogQ2hhaW5BY2NvdW50LFxuICAgIGNoYWluTmV0d29yazogQ2hhaW5OZXR3b3JrLFxuICApOiBVc2VyUGVybWlzc2lvbkZvckNoYWluQWNjb3VudFtdIHtcbiAgICBjb25zdCBhY2NvdW50UGVybWlzc2lvbnMgPSB0aGlzLl91c2VyU291cmNlRGF0YS5wZXJtaXNzaW9ucy5maWx0ZXIoXG4gICAgICBwID0+IHAuY2hhaW5BY2NvdW50ID09PSBjaGFpbkFjY291bnQgJiYgcC5jaGFpbk5ldHdvcmsgPT09IGNoYWluTmV0d29yayxcbiAgICApXG4gICAgcmV0dXJuIGFjY291bnRQZXJtaXNzaW9ucy5tYXAodGhpcy5tYXBVc2VyUGVybWlzc2lvbilcbiAgfVxuXG4gIGdldERlZmF1bHRQZXJtaXNzaW9uRm9yQ2hhaW5BY2NvdW50KFxuICAgIGNoYWluQWNjb3VudDogQ2hhaW5BY2NvdW50LFxuICAgIGNoYWluTmV0d29yazogQ2hhaW5OZXR3b3JrLFxuICApOiBVc2VyUGVybWlzc2lvbkZvckNoYWluQWNjb3VudFtdIHtcbiAgICBjb25zdCBhY2NvdW50UGVybWlzc2lvbnMgPSB0aGlzLmdldFBlcm1pc3Npb25Gb3JDaGFpbkFjY291bnQoY2hhaW5BY2NvdW50LCBjaGFpbk5ldHdvcmspXG4gICAgbGV0IGRlZmF1bHRQZXJtaXNzaW9uID0gYWNjb3VudFBlcm1pc3Npb25zLmZpbHRlcihwID0+IHAuaXNEZWZhdWx0ID09PSB0cnVlKVxuICAgIC8vIGlmIG5vIGRlZmF1bHQgaXMgZGVmaW5lZCwgYW5kIHRoZXJlIGlzIG9ubHkgb25lIHBlcm1pc3Npb24sIHVzZSBpdCBhcyB0aGUgZGVmYXVsdCAtIHRoaXMgbWlnaHQgYmUgYW4gZXh0ZXJuYWwga2V5XG4gICAgaWYgKGlzTnVsbE9yRW1wdHkoZGVmYXVsdFBlcm1pc3Npb24pICYmIGFjY291bnRQZXJtaXNzaW9ucz8ubGVuZ3RoID09PSAxKSB7XG4gICAgICBkZWZhdWx0UGVybWlzc2lvbiA9IGFjY291bnRQZXJtaXNzaW9uc1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFBlcm1pc3Npb25cbiAgfVxuXG4gIC8qKiBVcGRhdGUgcGVybWlzc2lvbnMgZm9yIHVzZXIncyBPUkUgQWNjb3VudCBpZiBhbnkgKi9cbiAgYXN5bmMgdXBkYXRlUGVybWlzc2lvbnNJZk5lY2Vzc2FyeShhcmdzOiB7XG4gICAgY2hhaW5BY2NvdW50OiBDaGFpbkFjY291bnRcbiAgICBwZXJtaXNzaW9uczogV2FsbGV0UGVybWlzc2lvbltdXG4gICAgY2hhaW5OZXR3b3JrOiBDaGFpbk5ldHdvcmtcbiAgICB3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGVcbiAgfSkge1xuICAgIC8vIHVzZSBsb2dnZWQtaW4gYWNjb3VudCBpZiBtaXNzaW5nIG9yZUFjY291bnQgcGFyYW1cbiAgICBhd2FpdCB0aGlzLmFkZFdhbGxldFBlcm1pc3Npb25zVG9PcmVJZEFjY291bnQoYXJncylcbiAgfVxuXG4gIC8vIGZvciBlYWNoIHBlcm1pc3Npb24gaW4gdGhlIHdhbGxldCwgYWRkIHRvIE9SRSBJRCAoaWYgbm90IGluIHVzZXIncyByZWNvcmQpXG4gIC8qKiBmb3IgYWxsIHdhbGxldFBlcm1pc3Npb25zIG5vdCBhbHJlYWR5IGluIHRoZSB1c2VyJ3MgT3JlSUQgd2FsbGV0LCBhZGQgaXQgYnkgY2FsbGluZyB0aGUgYXBpIChhZGRQZXJtaXNzaW9uKSAqL1xuICBhc3luYyBhZGRXYWxsZXRQZXJtaXNzaW9uc1RvT3JlSWRBY2NvdW50KGFyZ3M6IHtcbiAgICBjaGFpbkFjY291bnQ6IENoYWluQWNjb3VudFxuICAgIGNoYWluTmV0d29yazogQ2hhaW5OZXR3b3JrXG4gICAgcGVybWlzc2lvbnM6IFdhbGxldFBlcm1pc3Npb25bXVxuICAgIHdhbGxldFR5cGU6IEV4dGVybmFsV2FsbGV0VHlwZVxuICB9KSB7XG4gICAgLy8gZ2V0IGxhdGVzdCB1c2VyIGluZm9cbiAgICBhd2FpdCB0aGlzLmdldERhdGEoKVxuXG4gICAgY29uc3QgeyBjaGFpbkFjY291bnQsIGNoYWluTmV0d29yaywgcGVybWlzc2lvbnMsIHdhbGxldFR5cGUgfSA9IGFyZ3NcbiAgICBpZiAoIXRoaXMuYWNjb3VudE5hbWUgfHwgaXNOdWxsT3JFbXB0eShwZXJtaXNzaW9ucykgfHwgaXNOdWxsT3JFbXB0eShjaGFpbk5ldHdvcmspKSB7XG4gICAgICByZXR1cm4gLy8gdG9kbzogY29uc2lkZXIgaWYgd2Ugc2hvdWxkIGV4aXQgc2lsZW50bHkgaGVyZSAtIHNpbmNlIHdlIGFyZSBjYWxsZWQgYWZ0ZXIgZGlzY292ZXJ5IGV2ZXJ5dGltZSwgdGhlbiBhbnN3ZXIgaXMgcHJvYmFibHkgeWVzXG4gICAgfVxuXG4gICAgLy8gZm9yIGVhY2ggcGVybWlzc2lvbiBwcm92aWRlZCwgY2hlY2sgaWYgaXQncyBhbHJlYWR5IGluIHRoZSB1c2VyJ3MgbGlzdCwgaWYgbm90LCBhZGQgaXQgYnkgY2FsbGluZyB0aGUgYXBpIChhZGRQZXJtaXNzaW9uKVxuICAgIGF3YWl0IEhlbHBlcnMuYXN5bmNGb3JFYWNoKHBlcm1pc3Npb25zLCBhc3luYyBwZXJtID0+IHtcbiAgICAgIGNvbnN0IHBlcm1pc3Npb24gPSBwZXJtLm5hbWVcbiAgICAgIGxldCBwYXJlbnRQZXJtaXNzaW9uID0gcGVybS5wYXJlbnRcbiAgICAgIGlmICghcGFyZW50UGVybWlzc2lvbikge1xuICAgICAgICAvLyBIQUNLOiBhc3N1bWUgcGFyZW50IHBlcm1pc3Npb24gLSBpdHMgbWlzc2luZyBmcm9tIHRoZSBkaXNjb3ZlcigpIHJlc3VsdHNcbiAgICAgICAgcGFyZW50UGVybWlzc2lvbiA9ICdhY3RpdmUnXG5cbiAgICAgICAgaWYgKHBlcm1pc3Npb24gPT09ICdvd25lcicpIHtcbiAgICAgICAgICBwYXJlbnRQZXJtaXNzaW9uID0gJydcbiAgICAgICAgfSBlbHNlIGlmIChwZXJtaXNzaW9uID09PSAnYWN0aXZlJykge1xuICAgICAgICAgIHBhcmVudFBlcm1pc3Npb24gPSAnb3duZXInXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGZpbHRlciBvdXQgcGVybWlzc2lvbiB0aGF0IHRoZSB1c2VyIGFscmVhZHkgaGFzIGluIGhpcyByZWNvcmRcbiAgICAgIGNvbnN0IHNraXBUaGlzUGVybWlzc2lvbiA9IHRoaXMuX3VzZXJTb3VyY2VEYXRhLnBlcm1pc3Npb25zLnNvbWUoXG4gICAgICAgIHVwID0+XG4gICAgICAgICAgKHVwLmNoYWluQWNjb3VudCA9PT0gY2hhaW5BY2NvdW50ICYmIHVwLmNoYWluTmV0d29yayA9PT0gY2hhaW5OZXR3b3JrICYmIHVwLnBlcm1pc3Npb24gPT09IHBlcm1pc3Npb24pIHx8XG4gICAgICAgICAgcGVybWlzc2lvbiA9PT0gJ293bmVyJyxcbiAgICAgIClcblxuICAgICAgLy8gZG9uJ3QgYWRkICdvd25lcicgcGVybWlzc2lvbiBhbmQgc2tpcCBvbmVzIHRoYXQgYXJlIGFscmVhZHkgc3RvcmVkIGluIHVzZXIncyBhY2NvdW50XG4gICAgICBpZiAoc2tpcFRoaXNQZXJtaXNzaW9uICE9PSB0cnVlKSB7XG4gICAgICAgIC8vIGxldCBwdWJsaWNLZXkgPSBwLnJlcXVpcmVkX2F1dGgua2V5c1swXS5rZXk7IC8vVE9ETzogSGFuZGxlIG11bHRpcGxlIGtleXMgYW5kIHdlaWdodHNcbiAgICAgICAgY29uc3QgeyBwdWJsaWNLZXkgfSA9IHBlcm1cbiAgICAgICAgLy8gaWYgY2FsbCBpcyBzdWNjZXNzZnVsLCBub3RoaW5nIGlzIHJldHVybmVkIGluIHJlc3BvbnNlIChleGNlcHQgcHJvY2Vzc0lkKVxuICAgICAgICBhd2FpdCBjYWxsQXBpQWRkUGVybWlzc2lvbih0aGlzLl9vcmVJZENvbnRleHQsIHtcbiAgICAgICAgICBhY2NvdW50OiB0aGlzLmFjY291bnROYW1lLFxuICAgICAgICAgIGNoYWluQWNjb3VudCxcbiAgICAgICAgICBjaGFpbk5ldHdvcmssXG4gICAgICAgICAgcHVibGljS2V5LFxuICAgICAgICAgIHBhcmVudFBlcm1pc3Npb24sXG4gICAgICAgICAgcGVybWlzc2lvbixcbiAgICAgICAgICBwcm92aWRlcjogd2FsbGV0VHlwZSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gcmVsb2FkIHVzZXIgdG8gZ2V0IHVwZGF0ZWQgcGVybWlzc2lvbnNcbiAgICBhd2FpdCB0aGlzLmdldERhdGEoKVxuICB9XG59XG4iLCJleHBvcnQgY2xhc3MgT2JzZXJ2YWJsZTxTdWJzY3JpYmVyIGV4dGVuZHMgRnVuY3Rpb24+IHtcbiAgcHJpdmF0ZSBfc3Vic2NyaWJlcnM6IGFueVtdXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXVxuICB9XG5cbiAgcHVibGljIHN1YnNjcmliZShzdWJzY3JpYmVyOiBTdWJzY3JpYmVyKSB7XG4gICAgY29uc3QgaGFzVGhpc1N1YnNjcmliZXIgPSB0aGlzLl9zdWJzY3JpYmVycy5maW5kKHMgPT4gcyA9PT0gc3Vic2NyaWJlcilcbiAgICBpZiAoIXN1YnNjcmliZXIgfHwgaGFzVGhpc1N1YnNjcmliZXIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdWJzY3JpYmVyKHRoaXMpXG4gICAgdGhpcy5fc3Vic2NyaWJlcnMucHVzaChzdWJzY3JpYmVyKVxuICB9XG5cbiAgcHVibGljIHVuc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXIpIHtcbiAgICB0aGlzLl9zdWJzY3JpYmVycyA9IHRoaXMuX3N1YnNjcmliZXJzLmZpbHRlcihmID0+IGYgIT09IHN1YnNjcmliZXIpXG4gIH1cblxuICBwdWJsaWMgY2FsbFN1YnNjcmliZXJzKCkge1xuICAgIHRoaXMuX3N1YnNjcmliZXJzLmZvckVhY2goZiA9PiBmKHRoaXMpKVxuICB9XG59XG4iLCJpbXBvcnQgT3JlSWRDb250ZXh0IGZyb20gJy4uLy4uL2NvcmUvSU9yZWlkQ29udGV4dCdcbmltcG9ydCB7IEFwaUVuZHBvaW50LCBQcm9jZXNzSWQsIFJlcXVlc3RUeXBlIH0gZnJvbSAnLi4vLi4vbW9kZWxzJ1xuaW1wb3J0IHsgYXNzZXJ0SGFzQXBpS2V5T3JBY2Nlc3NUb2tlbiwgYXNzZXJ0UGFyYW1zSGF2ZVJlcXVpcmVkVmFsdWVzIH0gZnJvbSAnLi4vaGVscGVycydcblxuZXhwb3J0IHR5cGUgQXBpVXBkYXRlRGVsYXlXYWxsZXRTZXR1cFBhcmFtcyA9IHtcbiAgYWNjb3VudD86IHN0cmluZ1xuICAvKiogbmV3IHZhbHVlIGZvciB3YWxsZXQuZGVsYXlXYWxsZXRTZXR1cCBwcm9wZXJ0eSAqL1xuICBkZWxheVdhbGxldFNldHVwPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBBcGlVcGRhdGVEZWxheVdhbGxldFNldHVwQm9keVBhcmFtcyA9IHtcbiAgYWNjb3VudD86IHN0cmluZ1xuICBkZWxheV93YWxsZXRfc2V0dXA/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIENhbGxBcGlVcGRhdGVEZWxheVdhbGxldFNldHVwUmVzdWx0ID0ge1xuICBzdWNjZXNzOiBib29sZWFuXG4gIHByb2Nlc3NJZDogUHJvY2Vzc0lkXG59XG5cbi8qKiBDYWxsIHRoZSBhY2NvdW50L3VwZGF0ZS1kZWxheS13YWxsZXQtc2V0dXAgYXBpXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgd2FsbGV0J3MgZGVsYXlXYWxsZXRTZXR1cCBmbGFnXG4gKiBDYW4gb25seSBiZSB1cGRhdGVkIGlmIHRoZSB3YWxsZXQgaXMgbm90IHlldCBzZXR1cCAod2FsbGV0LnJlcXVpcmVzV2FsbGV0U2V0dXAgPSBmYWxzZSlcbiAqIFJldHVybnM6IHN1Y2Nlc3M6IHRydWUgKG9yIHRocm93cyBhbiBlcnJvcilcbiAqICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbEFwaVVwZGF0ZURlbGF5V2FsbGV0U2V0dXAoXG4gIG9yZUlkQ29udGV4dDogT3JlSWRDb250ZXh0LFxuICBwYXJhbXM6IEFwaVVwZGF0ZURlbGF5V2FsbGV0U2V0dXBQYXJhbXMsXG4pOiBQcm9taXNlPENhbGxBcGlVcGRhdGVEZWxheVdhbGxldFNldHVwUmVzdWx0PiB7XG4gIGNvbnN0IGFwaU5hbWUgPSBBcGlFbmRwb2ludC5VcGRhdGVEZWxheVdhbGxldFNldHVwXG4gIGNvbnN0IHsgYWNjb3VudCwgZGVsYXlXYWxsZXRTZXR1cCB9ID0gcGFyYW1zXG5cbiAgYXNzZXJ0SGFzQXBpS2V5T3JBY2Nlc3NUb2tlbihvcmVJZENvbnRleHQsIGFwaU5hbWUpXG4gIGFzc2VydFBhcmFtc0hhdmVSZXF1aXJlZFZhbHVlcyhwYXJhbXMsIFsnYWNjb3VudCcsICdkZWxheVdhbGxldFNldHVwJ10sIGFwaU5hbWUpXG5cbiAgY29uc3QgYm9keTogQXBpVXBkYXRlRGVsYXlXYWxsZXRTZXR1cEJvZHlQYXJhbXMgPSB7XG4gICAgYWNjb3VudDogYWNjb3VudCxcbiAgICBkZWxheV93YWxsZXRfc2V0dXA6IGRlbGF5V2FsbGV0U2V0dXAsXG4gIH1cblxuICBjb25zdCByZXN1bHRzID0gYXdhaXQgb3JlSWRDb250ZXh0LmNhbGxPcmVJZEFwaShSZXF1ZXN0VHlwZS5Qb3N0LCBBcGlFbmRwb2ludC5VcGRhdGVEZWxheVdhbGxldFNldHVwLCBib2R5LCBudWxsKVxuICByZXR1cm4gcmVzdWx0cyAvLyBzdWNjZXNzOiB0cnVlXG59XG4iLCJpbXBvcnQgSGVscGVycyBmcm9tICcuLi91dGlscy9oZWxwZXJzJ1xuaW1wb3J0IHsgSldUVG9rZW4gfSBmcm9tICcuL21vZGVscydcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi91dGlscy9vYnNlcnZhYmxlJ1xuXG5leHBvcnQgdHlwZSBTdWJzY3JpYmVyQWNjZXNzVG9rZW5IZWxwZXIgPSAoYWNjZXNzVG9rZW5IZWxwZXI6IEFjY2Vzc1Rva2VuSGVscGVyKSA9PiB2b2lkXG5cbmV4cG9ydCBjbGFzcyBBY2Nlc3NUb2tlbkhlbHBlciBleHRlbmRzIE9ic2VydmFibGU8U3Vic2NyaWJlckFjY2Vzc1Rva2VuSGVscGVyPiB7XG4gIGNvbnN0cnVjdG9yKGFjY2Vzc1Rva2VuPzogc3RyaW5nLCBpZ25vcmVJc3N1ZXIgPSBmYWxzZSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9pZ25vcmVJc3N1ZXIgPSBpZ25vcmVJc3N1ZXJcbiAgICB0aGlzLnNldEFjY2Vzc1Rva2VuKGFjY2Vzc1Rva2VuKVxuICB9XG5cbiAgX2FjY2Vzc1Rva2VuOiBzdHJpbmdcblxuICBfZGVjb2RlZEFjY2Vzc1Rva2VuOiBKV1RUb2tlblxuXG4gIF9pZFRva2VuOiBzdHJpbmdcblxuICBfZGVjb2RlZElkVG9rZW46IEpXVFRva2VuXG5cbiAgX2lnbm9yZUlzc3VlcjogYm9vbGVhblxuXG4gIGdldCBhY2Nlc3NUb2tlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYWNjZXNzVG9rZW5cbiAgfVxuXG4gIGdldCBkZWNvZGVkQWNjZXNzVG9rZW4oKSB7XG4gICAgaWYgKCF0aGlzLmFjY2Vzc1Rva2VuKSByZXR1cm4gbnVsbFxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVkQWNjZXNzVG9rZW5cbiAgfVxuXG4gIGdldCBpZFRva2VuKCkge1xuICAgIHJldHVybiB0aGlzLl9pZFRva2VuXG4gIH1cblxuICBnZXQgZGVjb2RlZElkVG9rZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZWRJZFRva2VuXG4gIH1cblxuICBnZXQgYWNjb3VudE5hbWUoKSB7XG4gICAgaWYgKCF0aGlzLmFjY2Vzc1Rva2VuKSByZXR1cm4gbnVsbFxuICAgIEFjY2Vzc1Rva2VuSGVscGVyLmFzc2VydElzVG9rZW5WYWxpZCh0aGlzLmRlY29kZWRBY2Nlc3NUb2tlbilcbiAgICByZXR1cm4gSGVscGVycy5nZXRDbGFpbUZyb21Kd3RUb2tlbkJ5U2VhcmNoU3RyaW5nKHRoaXMuZGVjb2RlZEFjY2Vzc1Rva2VuLCAnaHR0cHM6Ly9vcmVpZC5haWtvbi5jb20vYWNjb3VudCcpXG4gIH1cblxuICAvKiogY2xlYXIgYWNjZXNzVG9rZW4gKi9cbiAgY2xlYXJBY2Nlc3NUb2tlbigpIHtcbiAgICB0aGlzLnNldEFjY2Vzc1Rva2VuKG51bGwpXG4gIH1cblxuICAvKiogY2xlYXIgaWRUb2tlbiAqL1xuICBjbGVhcklkVG9rZW4oKSB7XG4gICAgdGhpcy5zZXRJZFRva2VuKG51bGwpXG4gIH1cblxuICAvKiogV2hldGhlciBjdXJyZW50IGFjY2Vzc1Rva2VuIGlzIGV4cGlyZWQgKG9yIGlzIG1pc3NpbmcpXG4gICAqICAob3B0aW9uYWwpIHByb3ZpZGUgYSBEYXRlKCkgdG8gY29tcGFyZSBleHBpcmF0aW9uIGFnYWluc3QgLSBkZWZhdWx0cyB0byBjdXJyZW50IERhdGUoKVxuICAgKiAgUmV0dXJuczogKGJvb2xlYW4pIHRydWUgaWYgaGFzRXhwaXJlZFxuICAgKi9cbiAgaGFzRXhwaXJlZChub3c/OiBEYXRlKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLl9kZWNvZGVkQWNjZXNzVG9rZW4pIHJldHVybiB0cnVlXG4gICAgaWYgKCFBY2Nlc3NUb2tlbkhlbHBlci5pc1Rva2VuRGF0ZVZhbGlkTm93KHRoaXMuX2RlY29kZWRBY2Nlc3NUb2tlbiwgbm93KSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBzZXRBY2Nlc3NUb2tlbih2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgdGhpcy5fYWNjZXNzVG9rZW4gPSBudWxsIC8vIGFsbG93cyBjbGVhcmluZyBvZiB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkZWNvZGVkQWNjZXNzVG9rZW4gPSBIZWxwZXJzLmp3dERlY29kZVNhZmUodmFsdWUpIGFzIEpXVFRva2VuXG4gICAgICBpZiAoIWRlY29kZWRBY2Nlc3NUb2tlbikgdGhyb3cgRXJyb3IoYENhbid0IHNldCBhY2Nlc3NUb2tlbi4gVmFsdWUgcHJvdmlkZWQ6ICR7dmFsdWV9YClcbiAgICAgIEFjY2Vzc1Rva2VuSGVscGVyLmFzc2VydElzVG9rZW5WYWxpZChkZWNvZGVkQWNjZXNzVG9rZW4sIHRoaXMuX2lnbm9yZUlzc3VlcilcbiAgICAgIEFjY2Vzc1Rva2VuSGVscGVyLmFzc2VydElkVG9rZW5NYXRjaGVzQWNjZXNzVG9rZW4oZGVjb2RlZEFjY2Vzc1Rva2VuLCB0aGlzLmRlY29kZWRJZFRva2VuKVxuICAgICAgdGhpcy5fZGVjb2RlZEFjY2Vzc1Rva2VuID0gZGVjb2RlZEFjY2Vzc1Rva2VuXG4gICAgICB0aGlzLl9hY2Nlc3NUb2tlbiA9IHZhbHVlXG4gICAgICAvLyBTZXQgYSB0aW1lciB0byBjbGVhciB0aGUgdG9rZW4gd2hlbiBpdCBleHBpcmVzICh3aWxsIGNsZWFyIGlmIGFscmVhZHkgZXhwaXJlZClcbiAgICAgIEhlbHBlcnMucnVuQXRUaW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckFjY2Vzc1Rva2VuKClcbiAgICAgICAgY29uc29sZS5sb2coJ2FjY2Vzc1Rva2VuIGhhcyBleHBpcmVkIGFuZCBoYXMgYmVlbiBjbGVhcmVkJylcbiAgICAgIH0sIHRoaXMuX2RlY29kZWRBY2Nlc3NUb2tlbi5leHAgKiAxMDAwKVxuICAgIH1cbiAgICBzdXBlci5jYWxsU3Vic2NyaWJlcnMoKVxuICB9XG5cbiAgc2V0SWRUb2tlbih2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgdGhpcy5fZGVjb2RlZElkVG9rZW4gPSBudWxsIC8vIGFsbG93cyBjbGVhcmluZyBvZiB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkZWNvZGVkSWRUb2tlbiA9IEhlbHBlcnMuand0RGVjb2RlU2FmZSh2YWx1ZSkgYXMgSldUVG9rZW5cbiAgICAgIGlmICghZGVjb2RlZElkVG9rZW4pIHRocm93IEVycm9yKGBDYW4ndCBzZXQgSWRUb2tlbi4gVmFsdWUgcHJvdmlkZWQ6ICR7dmFsdWV9YClcbiAgICAgIEFjY2Vzc1Rva2VuSGVscGVyLmFzc2VydElzVG9rZW5WYWxpZChkZWNvZGVkSWRUb2tlbiwgdGhpcy5faWdub3JlSXNzdWVyKVxuICAgICAgQWNjZXNzVG9rZW5IZWxwZXIuYXNzZXJ0SWRUb2tlbk1hdGNoZXNBY2Nlc3NUb2tlbih0aGlzLmRlY29kZWRBY2Nlc3NUb2tlbiwgZGVjb2RlZElkVG9rZW4pXG4gICAgICB0aGlzLl9kZWNvZGVkSWRUb2tlbiA9IGRlY29kZWRJZFRva2VuXG4gICAgICB0aGlzLl9pZFRva2VuID0gdmFsdWVcbiAgICAgIC8vIFNldCBhIHRpbWVyIHRvIGNsZWFyIHRoZSB0b2tlbiB3aGVuIGl0IGV4cGlyZXMgKHdpbGwgY2xlYXIgaWYgYWxyZWFkeSBleHBpcmVkKVxuICAgICAgSGVscGVycy5ydW5BdFRpbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFySWRUb2tlbigpXG4gICAgICAgIGNvbnNvbGUubG9nKCdpZFRva2VuIGhhcyBleHBpcmVkIGFuZCBoYXMgYmVlbiBjbGVhcmVkJylcbiAgICAgIH0sIHRoaXMuX2RlY29kZWRJZFRva2VuLmV4cCAqIDEwMDApXG4gICAgfVxuICAgIHN1cGVyLmNhbGxTdWJzY3JpYmVycygpXG4gIH1cblxuICAvKiogVGhyb3dzIGlmIGFjY2Vzc1Rva2VuIGlzIE5PVCBzZXQgeWV0ICovXG4gIGFzc2VydEhhc0FjY2Vzc1Rva2VuKCkge1xuICAgIGlmICghdGhpcy5hY2Nlc3NUb2tlbikgdGhyb3cgRXJyb3IoJ0FjY2Vzc1Rva2VuIG5vdCBzZXQuIExvZ2luIGZpcnN0LicpXG4gIH1cblxuICAvKiogV2hldGhlciB0b2tlbiBpcyBhIHZhbGlkIE9SRUlEIGlzc3VlZCB0b2tlbiBhbmQgTk9UIGV4cGlyZWQgKi9cbiAgc3RhdGljIGlzVG9rZW5WYWxpZChkZWNvZGVkVG9rZW46IFBhcnRpYWw8SldUVG9rZW4+LCBpZ25vcmVJc3N1ZXIgPSBmYWxzZSk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBBY2Nlc3NUb2tlbkhlbHBlci5hc3NlcnRJc1Rva2VuVmFsaWQoZGVjb2RlZFRva2VuLCBpZ25vcmVJc3N1ZXIpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKiogVGhyb3dzIGlmIGRlY29kZWRUb2tlbiBpcyBOT1QgYSB2YWxpZCBPUkVJRCBpc3N1ZWQgdG9rZW4gKi9cbiAgc3RhdGljIGFzc2VydElzVG9rZW5WYWxpZChkZWNvZGVkVG9rZW46IFBhcnRpYWw8SldUVG9rZW4+LCBpZ25vcmVJc3N1ZXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcbiAgICBpZiAoIWRlY29kZWRUb2tlbikgdGhyb3cgRXJyb3IoJ0pXVCAoYWNjZXNzIG9yIGlkKSB0b2tlbiBpcyBpbnZhbGlkLCBvciBleHBpcmVkKScpXG4gICAgLy8gY2hlY2sgaWYgT1JFIElEIGlzc3VlZCB0aGlzIHRva2VuXG4gICAgaWYgKCFpZ25vcmVJc3N1ZXIgJiYgIWRlY29kZWRUb2tlbi5pc3MuaW5jbHVkZXMoJ29yZWlkLmlvJykpIHtcbiAgICAgIHRocm93IEVycm9yKCdBY2Nlc3MgdG9rZW4gbm90IGlzc3VlZCBieSBPUkUgSUQnKVxuICAgIH1cbiAgICBpZiAoIUFjY2Vzc1Rva2VuSGVscGVyLmlzVG9rZW5EYXRlVmFsaWROb3coZGVjb2RlZFRva2VuLCBub3cpKSB7XG4gICAgICB0aHJvdyBFcnJvcignQWNjZXNzIHRva2VuIGhhcyBleHBpcmVkJylcbiAgICB9XG4gIH1cblxuICAvKiogVGhyb3dzIGlmIGFjY2Vzc1Rva2VuIGRvZXMgbm90IG1hdGNoIHRoZSBzYW1lIHVzZXIgYW5kIGlzc3VlciBhcyB0aGUgaWRUb2tlbiAqL1xuICBzdGF0aWMgYXNzZXJ0SWRUb2tlbk1hdGNoZXNBY2Nlc3NUb2tlbihkZWNvZGVkQWNjZXNzVG9rZW46IFBhcnRpYWw8SldUVG9rZW4+LCBkZWNvZGVkSWRUb2tlbjogUGFydGlhbDxKV1RUb2tlbj4pIHtcbiAgICBpZiAoIWRlY29kZWRBY2Nlc3NUb2tlbiB8fCAhZGVjb2RlZElkVG9rZW4pIHJldHVyblxuICAgIC8vIGNoZWNrIGlmIE9SRSBJRCBpc3N1ZWQgdGhpcyB0b2tlblxuICAgIGlmIChkZWNvZGVkQWNjZXNzVG9rZW4uaXNzICE9PSBkZWNvZGVkSWRUb2tlbi5pc3MpIHtcbiAgICAgIHRocm93IEVycm9yKCdBY2Nlc3NUb2tlbiBhbmQgSWRUb2tlbiBtaXNtYXRjaCAtIG5vdCBpc3N1ZWQgYnkgdGhlIHNhbWUgaXNzdWVyJylcbiAgICB9XG4gICAgaWYgKGRlY29kZWRBY2Nlc3NUb2tlbi5zdWIgIT09IGRlY29kZWRJZFRva2VuLnN1Yikge1xuICAgICAgdGhyb3cgRXJyb3IoJ0FjY2Vzc1Rva2VuIGFuZCBJZFRva2VuIG1pc21hdGNoIC0gbm90IGZvciB0aGUgc2FtZSB1c2VyJylcbiAgICB9XG4gIH1cblxuICAvKiogV2hldGhlciBhIEpXVCB0b2tlbiBpcyB2YWxpZCBmb3IgdXNlIHJpZ2h0IG5vdyAtIG5vdCBleHBpcmVkIGFuZCBub3QgYmVpbmcgdXNlZCBiZWZvcmUgZmlyc3QgdXNhYmxlIGRhdGUgKG5iZikgKi9cbiAgc3RhdGljIGlzVG9rZW5EYXRlVmFsaWROb3coZGVjb2RlZFRva2VuOiBQYXJ0aWFsPEpXVFRva2VuPiwgbm93PzogRGF0ZSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG5vd0RhdGUgPSBub3cgfHwgbmV3IERhdGUoKVxuICAgIGNvbnN0IG5vd0luTXMgPSBub3dEYXRlLmdldFRpbWUoKSAvIDEwMDBcbiAgICBpZiAodHlwZW9mIGRlY29kZWRUb2tlbi5leHAgIT09ICd1bmRlZmluZWQnICYmIGRlY29kZWRUb2tlbj8uZXhwIDwgbm93SW5Ncykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGVjb2RlZFRva2VuPy5uYmYgIT09ICd1bmRlZmluZWQnICYmIGRlY29kZWRUb2tlbj8ubmJmID4gbm93SW5Ncykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbmltcG9ydCBheGlvcyBmcm9tICdheGlvcydcbmltcG9ydCB7XG4gIEFwaUN1c3RvZGlhbE1pZ3JhdGVBY2NvdW50UGFyYW1zLFxuICBBcGlDdXN0b2RpYWxOZXdBY2NvdW50UGFyYW1zLFxuICBBcGlDdXN0b2RpYWxTaWduU3RyaW5nUGFyYW1zLFxuICBBcGlDdXN0b2RpYWxTaWduU3RyaW5nUmVzdWx0LFxuICBBcGlHZXRBcHBUb2tlblBhcmFtcyxcbiAgY2FsbEFwaUN1c3RvZGlhbE1pZ3JhdGVBY2NvdW50LFxuICBjYWxsQXBpQ3VzdG9kaWFsTmV3QWNjb3VudCxcbiAgY2FsbEFwaUN1c3RvZGlhbFNpZ25TdHJpbmcsXG4gIGNhbGxBcGlHZXRBcHBUb2tlbixcbn0gZnJvbSAnLi4vYXBpJ1xuaW1wb3J0IHsgQXV0aCB9IGZyb20gJy4uL2F1dGgvYXV0aCdcbmltcG9ydCB7IGRlZmF1bHRPcmVJZFNlcnZpY2VVcmwsIHB1YmxpY0FwaUVuZHBvaW50cywgdmVyc2lvbiB9IGZyb20gJy4uL2NvbnN0YW50cydcbmltcG9ydCB7XG4gIEFwaUVuZHBvaW50LFxuICBBcHBBY2Nlc3NUb2tlbixcbiAgQXBwQWNjZXNzVG9rZW5NZXRhZGF0YSxcbiAgRXh0ZXJuYWxXYWxsZXRUeXBlLFxuICBOZXdBY2NvdW50UmVzdWx0LFxuICBQcm9jZXNzSWQsXG4gIFJlcXVlc3RUeXBlLFxuICBTaWduUmVzdWx0LFxuICBTaWduU3RyaW5nUGFyYW1zLFxuICBTaWduU3RyaW5nUmVzdWx0LFxuICBUcmFuc2FjdGlvbkRhdGEsXG4gIFdlYldpZGdldFByb3BzLFxufSBmcm9tICcuLi9tb2RlbHMnXG5pbXBvcnQgeyBQb3B1cFBsdWdpbiB9IGZyb20gJy4uL3BsdWdpbnMnXG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICcuLi9wbHVnaW5zL3BsdWdpbidcbmltcG9ydCBUcmFuc2FjdGlvbiBmcm9tICcuLi90cmFuc2FjdGlvbi90cmFuc2FjdGlvbidcbmltcG9ydCBUcmFuc2l0SGVscGVyIGZyb20gJy4uL3RyYW5zaXQvVHJhbnNpdEhlbHBlcidcbmltcG9ydCBVYWxIZWxwZXIgZnJvbSAnLi4vdWFsL1VhbEhlbHBlcidcbmltcG9ydCBIZWxwZXJzIGZyb20gJy4uL3V0aWxzL2hlbHBlcnMnXG5pbXBvcnQgeyBhcHBlbmRIbWFjVG9VcmwsIGdlbmVyYXRlSG1hY1dpdGhBcGlLZXlPclByb3h5U2VydmVyIH0gZnJvbSAnLi4vdXRpbHMvaG1hYydcbmltcG9ydCBMb2NhbFN0YXRlIGZyb20gJy4uL3V0aWxzL2xvY2FsU3RhdGUnXG5pbXBvcnQgU3RvcmFnZUhhbmRsZXIgZnJvbSAnLi4vdXRpbHMvc3RvcmFnZSdcbmltcG9ydCBJT3JlaWRDb250ZXh0IGZyb20gJy4vSU9yZWlkQ29udGV4dCdcbmltcG9ydCB7IE9yZUlkT3B0aW9ucyB9IGZyb20gJy4vSU9yZUlkT3B0aW9ucydcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuL1NldHRpbmdzJ1xuaW1wb3J0IFdhbGxldEhlbHBlciBmcm9tICcuLi93YWxsZXRzL1dhbGxldEhlbHBlcidcblxuY29uc3QgeyBpc051bGxPckVtcHR5IH0gPSBIZWxwZXJzXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9yZUlkIGltcGxlbWVudHMgSU9yZWlkQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IE9yZUlkT3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMgPSBudWxsXG4gICAgdGhpcy52YWxpZGF0ZUFuZFNldE9wdGlvbnMob3B0aW9ucylcbiAgICBjb25zdCBzdG9yYWdlSGFuZGxlciA9IHRoaXMub3B0aW9ucz8uc3RvcmFnZUhhbmRsZXIgfHwgbmV3IFN0b3JhZ2VIYW5kbGVyKClcbiAgICB0aGlzLl9sb2NhbFN0YXRlID0gbmV3IExvY2FsU3RhdGUodGhpcy5vcHRpb25zPy5hcHBJZCwgc3RvcmFnZUhhbmRsZXIpXG4gICAgdGhpcy5fc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoeyBvcmVJZENvbnRleHQ6IHRoaXMgfSlcbiAgICB0aGlzLl9hdXRoID0gbmV3IEF1dGgoeyBvcmVJZENvbnRleHQ6IHRoaXMgfSlcbiAgICB0aGlzLl90cmFuc2l0SGVscGVyID0gbmV3IFRyYW5zaXRIZWxwZXIoeyBvcmVJZENvbnRleHQ6IHRoaXMsIHVzZXI6IHRoaXMuX2F1dGgudXNlciB9KVxuICAgIHRoaXMuX3RyYW5zaXRIZWxwZXIuaW5zdGFsbFRyYW5zaXRQcm92aWRlcnModGhpcy5vcHRpb25zPy5lb3NUcmFuc2l0V2FsbGV0UHJvdmlkZXJzKVxuICAgIHRoaXMuX3VhbEhlbHBlciA9IG5ldyBVYWxIZWxwZXIoeyBvcmVJZENvbnRleHQ6IHRoaXMsIHVzZXI6IHRoaXMuX2F1dGgudXNlciB9KVxuICAgIHRoaXMuX3VhbEhlbHBlci5pbnN0YWxsVWFsUHJvdmlkZXJzKHRoaXMub3B0aW9ucz8udWFsQXV0aGVudGljYXRvcnMpXG4gICAgdGhpcy5fd2FsbGV0SGVscGVyID0gbmV3IFdhbGxldEhlbHBlcih7XG4gICAgICBvcmVJZENvbnRleHQ6IHRoaXMsXG4gICAgICB0cmFuc2l0SGVscGVyOiB0aGlzLl90cmFuc2l0SGVscGVyLFxuICAgICAgdWFsSGVscGVyOiB0aGlzLl91YWxIZWxwZXIsXG4gICAgfSlcbiAgICB0aGlzLl9pbml0aWFsaXplclBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnMgfHwge31cbiAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2VcbiAgfVxuXG4gIHByaXZhdGUgX2F1dGg6IEF1dGhcblxuICBwcml2YXRlIF9pbml0aWFsaXplclBsdWdpbnM6IHsgcG9wdXA/OiBQbHVnaW48UG9wdXBQbHVnaW4+IH1cblxuICBwcml2YXRlIF9pc0luaXRpYWxpemVkOiBib29sZWFuXG5cbiAgcHJpdmF0ZSBfbG9jYWxTdGF0ZTogTG9jYWxTdGF0ZVxuXG4gIHByaXZhdGUgX29wdGlvbnM6IE9yZUlkT3B0aW9uc1xuXG4gIHByaXZhdGUgX3BvcHVwPzogUG9wdXBQbHVnaW5cblxuICBwcml2YXRlIF9zZXR0aW5nczogU2V0dGluZ3NcblxuICBwcml2YXRlIF90cmFuc2l0SGVscGVyOiBUcmFuc2l0SGVscGVyXG5cbiAgcHJpdmF0ZSBfdWFsSGVscGVyOiBVYWxIZWxwZXJcblxuICBwcml2YXRlIF93YWxsZXRIZWxwZXI6IFdhbGxldEhlbHBlclxuXG4gIGlzQnVzeTogYm9vbGVhblxuXG4gIC8qKiBOYW1lcyBvZiBhbGwgVHJhbnNpdCBwcm92aWRlcnMgaW5zdGFsbGVkIChwcm92aWRlZCB0byB0aGlzIGNvbnN0cnVjdG9yKSAqL1xuICB0cmFuc2l0UHJvdmlkZXJzSW5zdGFsbGVkOiBFeHRlcm5hbFdhbGxldFR5cGVbXSA9IFtdXG5cbiAgLyoqIE5hbWVzIG9mIGFsbCBVYWwgd2FsbGV0IHByb3ZpZGVycyBpbnN0YWxsZWQgKHByb3ZpZGVkIHRvIHRoaXMgY29uc3RydWN0b3IpICovXG4gIHVhbFByb3ZpZGVyc0luc3RhbGxlZDogRXh0ZXJuYWxXYWxsZXRUeXBlW10gPSBbXVxuXG4gIC8qKiBhY2Nlc3NUb2tlbiAoc3RvcmVkIGluIGxvY2FsU3RhdGUpICovXG4gIGdldCBhY2Nlc3NUb2tlbigpIHtcbiAgICByZXR1cm4gdGhpcy5hdXRoLmFjY2Vzc1Rva2VuXG4gIH1cblxuICAvKiogYWNjZXNzVG9rZW4gaGVscGVyIGZ1bmN0aW9ucyBhbmQgY3VycmVudCBzdGF0ZSAqL1xuICBnZXQgYWNjZXNzVG9rZW5IZWxwZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXV0aC5hY2Nlc3NUb2tlbkhlbHBlclxuICB9XG5cbiAgLyoqIGF1dGhlbnRpY2F0aW9uIGZsb3dzIGFuZCBsb2dpbiBzdGF0ZSAqL1xuICBnZXQgYXV0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0aFxuICB9XG5cbiAgLyoqIHdoZXRoZXIgdGhlIGN1cnJlbnQgYXBwSWQgaXMgYSBkZW1vIGFwcCAqL1xuICBnZXQgaXNEZW1vQXBwKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnM/LmFwcElkPy50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2RlbW8nKSB8fCBmYWxzZVxuICB9XG5cbiAgLyoqIHdoZXRoZXIgaW5pdCgpIGhhcyBiZWVuIGNhbGxlZCAqL1xuICBnZXQgaXNJbml0aWFsaXplZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNJbml0aWFsaXplZFxuICB9XG5cbiAgLyoqIGhlbHBlciB0byBwZXJzaXN0IGRhdGEgKGUuZy4gYWNjZXNzVG9rZW4pICovXG4gIGdldCBsb2NhbFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbFN0YXRlXG4gIH1cblxuICAvKiogb3JlaWQgb3B0aW9ucyB1c2VkIGluIGNvbnN0cnVjdG9yICovXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zXG4gIH1cblxuICAvKiogaW5zdGFsbGVkIHBvcHVwIHBsdWdpbiAqL1xuICBnZXQgcG9wdXAoKSB7XG4gICAgdGhpcy5hc3NlcnRJc0luaXRpYWxpemVkKClcbiAgICByZXR1cm4gdGhpcy5fcG9wdXBcbiAgfVxuXG4gIC8qKiBJZiB3ZSdyZSBydW5uaW5nIGluIHRoZSBicm93c2VyLCB3ZSBtdXN0IHVzZSBhIHByb3h5IHNlcnZlciB0byB0YWxrIHRvIE9SRUlEIGFwaVxuICBVbmxlc3MsIHdlIGFyZSBydW5uaW5nIHRoZSBkZW1vIGFwcCwgaW4gd2hpY2ggY2FzZSBDT1JTIGlzIGRpc2FibGVkIGJ5IE9SRUlEIHNlcnZlciAqL1xuICBnZXQgcmVxdWlyZXNQcm94eVNlcnZlcigpIHtcbiAgICAvLyBpZiB3ZSBhcmVuJ3QgdXNpbmcgYW4gYXBpS2V5LCB3ZSBkb250IGV2ZXIgbmVlZCBhIHByb3h5IHNlcnZlclxuICAgIGlmICh0aGlzPy5vcHRpb25zPy5pc1VzaW5nUHJveHlTZXJ2ZXIpIHJldHVybiB0cnVlXG4gICAgaWYgKCF0aGlzPy5vcHRpb25zPy5hcGlLZXkpIHJldHVybiBmYWxzZVxuICAgIHJldHVybiBIZWxwZXJzLmlzSW5Ccm93c2VyICYmICF0aGlzLmlzRGVtb0FwcFxuICB9XG5cbiAgLyoqIG9yZWlkIHNldHRpbmdzIGhlbHBlciAqL1xuICBnZXQgc2V0dGluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzXG4gIH1cblxuICAvKiogRXh0ZXJuYWwgd2FsbGV0IGhlbHBlciBmdW5jdGlvbnMgYW5kIGNvbm5lY3Rpb25zICovXG4gIGdldCB3YWxsZXRIZWxwZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldEhlbHBlclxuICB9XG5cbiAgLyoqIHBlcmZvcm0gYXN5bmNocm9ub3VzIHNldHVwIHRhc2tzICovXG4gIGFzeW5jIGluaXQoKSB7XG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZXJQbHVnaW5zPy5wb3B1cCkge1xuICAgICAgdGhpcy5fcG9wdXAgPSBhd2FpdCB0aGlzLl9pbml0aWFsaXplclBsdWdpbnM/LnBvcHVwPy5pbml0KHRoaXMpXG4gICAgfVxuXG4gICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWVcbiAgfVxuXG4gIC8qKiB0aHJvdyBhbmQgZXJyb3IgaWYgb3JlSWQgaXMgbm90IGluaXRpYWxpemVkIHlldCAqL1xuICBwcml2YXRlIGFzc2VydElzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3JlSWQgaXMgbm90IGluaXRpYWxpemVkIC0gY2FsbCBpbml0KCkgZmlyc3QnKVxuICAgIH1cbiAgfVxuXG4gIC8qKiBDbGVhcnMgdXNlcidzIGFjY2Vzc1Rva2VuIGFuZCB1c2VyIHByb2ZpbGUgZGF0YSAqL1xuICBsb2dvdXQoKSB7XG4gICAgdGhpcy5hdXRoLmxvZ291dCgpXG4gIH1cblxuICAvKiogU2lnbiBhbiBhcmJpdHJhcnkgc3RyaW5nIChpbnN0ZWFkIG9mIGEgdHJhbnNhY3Rpb24pXG4gICAqIFRoaXMgb25seSBzdXBwb3J0cyBUcmFuc2l0IGFuZCBVYWwgd2FsbGV0c1xuICAgKi9cbiAgYXN5bmMgc2lnblN0cmluZ1dpdGhXYWxsZXQocGFyYW1zOiBTaWduU3RyaW5nUGFyYW1zKTogUHJvbWlzZTxTaWduU3RyaW5nUmVzdWx0PiB7XG4gICAgcmV0dXJuIHRoaXMud2FsbGV0SGVscGVyLnNpZ25TdHJpbmdXaXRoV2FsbGV0KHBhcmFtcylcbiAgfVxuXG4gIC8qKiBTaWduIGFuIGFyYml0cmFyeSBzdHJpbmcgKGluc3RlYWQgb2YgYSB0cmFuc2FjdGlvbikgdXNpbmcgT1JFIElEXG4gICAqL1xuICBhc3luYyBjdXN0b2RpYWxTaWduU3RyaW5nKHBhcmFtczogQXBpQ3VzdG9kaWFsU2lnblN0cmluZ1BhcmFtcyk6IFByb21pc2U8QXBpQ3VzdG9kaWFsU2lnblN0cmluZ1Jlc3VsdD4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FsbEFwaUN1c3RvZGlhbFNpZ25TdHJpbmcodGhpcywgcGFyYW1zKVxuICAgIGlmIChyZXNwb25zZT8uZXJyb3JDb2RlIHx8IHJlc3BvbnNlPy5lcnJvck1lc3NhZ2UpIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvck1lc3NhZ2UpXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKiogQ3JlYXRlIGEgbmV3IHVzZXIgYWNjb3VudCB0aGF0IGlzIG1hbmFnZWQgYnkgeW91ciBhcHBcbiAgICogUmVxdWlyZXMgYSB3YWxsZXQgcGFzc3dvcmQgKHVzZXJQYXNzd29yZCkgb24gYmVoYWxmIG9mIHRoZSB1c2VyXG4gICAqIFJlcXVpcmVzIGFuIGFwaUtleSB3aXRoIHRoZSBjcmVhdGVVc2VyIHJpZ2h0XG4gICAqIFJldHVybnM6IGFjY291bnROYW1lIG9mIG5ld2x5IGNyZWF0ZWQgYWNjb3VudFxuICAgKiAgICAgICBPUiBlcnJvckNvZGUsIGVycm9yTWVzc2FnZSwgYW5kIG1lc3NhZ2UgaWYgYW55IHByb2JsZW1zICovXG4gIGFzeW5jIGN1c3RvZGlhbE5ld0FjY291bnQoYWNjb3VudE9wdGlvbnM6IEFwaUN1c3RvZGlhbE5ld0FjY291bnRQYXJhbXMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhbGxBcGlDdXN0b2RpYWxOZXdBY2NvdW50KHRoaXMsIGFjY291bnRPcHRpb25zKVxuICAgIGlmIChyZXNwb25zZT8uZXJyb3JDb2RlIHx8IHJlc3BvbnNlPy5lcnJvck1lc3NhZ2UpIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvck1lc3NhZ2UpXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKiogQ2FsbCB0aGUgY3VzdG9kaWFsL21pZ3JhdGUtdXNlciBhcGlcbiAgICogQ29udmVydHMgYSB1c2VyIGFjY291bnQgdG8gYSBuZXcgYWNjb3VudCB0eXBlXG4gICAqIFVzdWFsbHkgdXNlZCB0byBjb252ZXJ0IGEgdmlydGFsIGFjY291bnQgdG8gYSBuYXRpdmUgYWNjb3VudCAob24tY2hhaW4pXG4gICAqIC4uIGFuZCBleHBlY3RzIHRoZSBhY2NvdW50IHRvIGJlIGEgbWFuYWdlZCAoY3VzdG9kaWFsKSBhY2NvdW50XG4gICAqIFJlcXVpcmVzIGEgd2FsbGV0IHBhc3N3b3JkICh1c2VyUGFzc3dvcmQpIG9uIGJlaGFsZiBvZiB0aGUgdXNlclxuICAgKiBSZXF1aXJlcyBhbiBhcGlLZXkgd2l0aCB0aGUgYWNjb3VudE1pZ3JhdGlvbiByaWdodFxuICAgKiBSZXR1cm5zOiBhY2NvdW50IG5hbWUgb2YgbWlncmF0ZWQgYWNjb3VudFxuICAgKiAgICAgICBPUiBlcnJvckNvZGUsIGVycm9yTWVzc2FnZSwgYW5kIG1lc3NhZ2UgaWYgYW55IHByb2JsZW1zICovXG4gIGFzeW5jIGN1c3RvZGlhbE1pZ3JhdGVBY2NvdW50KG1pZ3JhdGVPcHRpb25zOiBBcGlDdXN0b2RpYWxNaWdyYXRlQWNjb3VudFBhcmFtcykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FsbEFwaUN1c3RvZGlhbE1pZ3JhdGVBY2NvdW50KHRoaXMsIG1pZ3JhdGVPcHRpb25zKVxuICAgIGlmIChyZXNwb25zZT8uZXJyb3JDb2RlIHx8IHJlc3BvbnNlPy5lcnJvck1lc3NhZ2UpIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvck1lc3NhZ2UpXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKiogUmV0dXJucyBtZXRhZGF0YSBhYm91dCB0aGUgaW5zdGFsbGVkIGV4dGVybmFsIHdhbGxldCB0eXBlIChlLmcuIG5hbWUsIGxvZ28pIGFuZCB3aGljaCBmZWF0dXJlcyBpdCBzdXBwb3J0c1xuICAgKiAgUmV0dXJucyBkaWZmZXJlbnQgZGF0YSBkZXBlbmRpbmcgb24gdGhlIHdhbGxldCBpbnRlcmZhY2UgdHlwZSAoVHJhbnNpdCBvciBVYWwpXG4gICAqL1xuICBnZXRFeHRlcm5hbFdhbGxldEluZm8od2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMud2FsbGV0SGVscGVyLmdldEV4dGVybmFsV2FsbGV0SW5mbyh3YWxsZXRUeXBlKVxuICB9XG5cbiAgLyoqIENyZWF0ZSBhIG5ldyBUcmFuc2FjdGlvbiBvYmplY3QgLSB1c2VkIGZvciBjb21wb3NpbmcgYW5kIHNpZ25pbmcgdHJhbnNhY3Rpb25zICovXG4gIGFzeW5jIGNyZWF0ZVRyYW5zYWN0aW9uKGRhdGE6IFRyYW5zYWN0aW9uRGF0YSkge1xuICAgIGlmICghdGhpcy5fYXV0aC51c2VyLmhhc0RhdGEpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2F1dGgudXNlci5nZXREYXRhKClcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbih7IG9yZUlkQ29udGV4dDogdGhpcywgdXNlcjogdGhpcy5hdXRoLnVzZXIsIGRhdGEgfSlcbiAgfVxuXG4gIC8qKiBDYWxsIHRoZSBzZXRCdXN5Q2FsbGJhY2soKSBjYWxsYmFjayBwcm92aWRlZCBpbiBvcHRpb250XG4gICAqICBVc2UgdHJ1ZSBvciBmYWxzZSB0byBzZXQgdGhlIGN1cnJlbnQgYnVzeSBzdGF0ZVxuICAgKi9cbiAgc2V0SXNCdXN5KHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuaXNCdXN5ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5pc0J1c3kgPSB2YWx1ZVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZXRCdXN5Q2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNldEJ1c3lDYWxsYmFjayh2YWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUT0RPIGFkZCB2YWxpZGF0aW9uIG9mIG5ld2VyIG9wdGlvbnNcbiAgLyoqICBWYWxpZGF0ZXMgc3RhcnR1cCBvcHRpb25zICovXG4gIHZhbGlkYXRlQW5kU2V0T3B0aW9ucyhvcHRpb25zOiBPcmVJZE9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFwcElkLCBhcGlLZXksIG9yZUlkVXJsIH0gPSBvcHRpb25zIHx8IHt9XG4gICAgbGV0IGVycm9yTWVzc2FnZSA9ICcnXG4gICAgLy8gc2V0IG9wdGlvbnMgbm93IHNpbmNlIHRoaXMucmVxdWlyZXNQcm94eVNlcnZlciBuZWVkcyBpdCBzZXRcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuXG4gICAgLy8gQXBwbHkgZGVmYXVsdCBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMpIHRoaXMub3B0aW9ucy5vcmVJZFVybCA9IG9yZUlkVXJsIHx8IGRlZmF1bHRPcmVJZFNlcnZpY2VVcmxcblxuICAgIGlmICghYXBwSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSArPVxuICAgICAgICAnXFxuIC0tPiBNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAtIGFwcElkLiBZb3UgY2FuIGdldCBhbiBhcHBJZCB3aGVuIHlvdSByZWdpc3RlciB5b3VyIGFwcCB3aXRoIE9SRSBJRC4nXG4gICAgfVxuXG4gICAgLy8gYXBpLWtleSBhbmQgc2VydmljZS1rZXkgbm90IGFsbG93ZWQgaWYgdGhpcyBpcyBiZWluZyBpbnN0YW50aWF0ZWQgaW4gdGhlIGJyb3dzZXJcbiAgICBpZiAodGhpcy5yZXF1aXJlc1Byb3h5U2VydmVyICYmIGFwaUtleSkge1xuICAgICAgZXJyb3JNZXNzYWdlICs9XG4gICAgICAgICdcXG4gLS0+IFlvdSBjYW50IGluY2x1ZGUgdGhlIGFwaUtleSB3aGVuIGNyZWF0aW5nIGFuIGluc3RhbmNlIG9mIE9yZUlkIHRoYXQgcnVucyBpbiB0aGUgYnJvd3Nlci4gVGhpcyBpcyB0byBwcmV2ZW50IHlvdXIga2V5IGZyb20gYmVpbmcgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci4gSWYgdGhpcyBhcHAgcnVucyBzb2xlbHkgaW4gdGhlIGJyb3dzZXIgKGxpa2UgYSBDcmVhdGUgUmVhY3QgQXBwKSwgeW91IG5lZWQgdG8gc2V0LXVwIGEgcHJveHkgc2VydmVyIHRvIHByb3RlY3QgeW91ciBrZXlzLiBSZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vVGVhbUFpa29uL29yZS1pZC1kb2NzLiBOb3RlOiBZb3Ugd29udCBnZXQgdGhpcyBlcnJvciB3aGVuIHVzaW5nIHRoZSBhcHBJZCBhbmQgYXBpS2V5IGZvciBhIGRlbW8gYXBwIChhcHBJZCBzdGFydHMgd2l0aCBkZW1vXykuJ1xuICAgIH1cbiAgICBpZiAoZXJyb3JNZXNzYWdlICE9PSAnJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcHRpb25zIGFyZSBtaXNzaW5nIG9yIGludmFsaWQuICR7ZXJyb3JNZXNzYWdlfWApXG4gICAgfVxuICB9XG5cbiAgLyoqIEdldHMgYSBzaW5nbGUtdXNlIHRva2VuIHRvIGFjY2VzcyB0aGUgc2VydmljZSAqL1xuICBhc3luYyBnZXRBcHBBY2Nlc3NUb2tlbihwYXJhbXM/OiBBcGlHZXRBcHBUb2tlblBhcmFtcykge1xuICAgIHJldHVybiBjYWxsQXBpR2V0QXBwVG9rZW4odGhpcywgcGFyYW1zKVxuICB9XG5cbiAgLyoqIEV4dHJhY3RzIHRoZSByZXNwb25zZSBwYXJhbWV0ZXJzIG9uIHRoZSAvbmV3LWFjY291bnQgY2FsbGJhY2sgVVJMIHN0cmluZyAqL1xuICBoYW5kbGVOZXdBY2NvdW50UmVzcG9uc2UoY2FsbGJhY2tVcmxTdHJpbmc6IHN0cmluZyk6IE5ld0FjY291bnRSZXN1bHQge1xuICAgIGNvbnN0IHtcbiAgICAgIGNoYWluX2FjY291bnQ6IGNoYWluQWNjb3VudCxcbiAgICAgIHByb2Nlc3NfaWQ6IHByb2Nlc3NJZCxcbiAgICAgIHN0YXRlLFxuICAgICAgZXJyb3JzLFxuICAgIH0gPSBIZWxwZXJzLmV4dHJhY3REYXRhRnJvbUNhbGxiYWNrVXJsKGNhbGxiYWNrVXJsU3RyaW5nKVxuICAgIHRoaXMuc2V0SXNCdXN5KGZhbHNlKVxuICAgIHJldHVybiB7IGNoYWluQWNjb3VudCwgcHJvY2Vzc0lkLCBzdGF0ZSwgZXJyb3JzIH1cbiAgfVxuXG4gIC8qKiBFeHRyYWN0cyBhbmQgcmV0dXJucyB0aGUgcmVzcG9uc2UgcGFyYW1ldGVycyBmcm9tIHRoZSAvc2lnbiBjYWxsYmFjayBVUkwgc3RyaW5nICovXG4gIGhhbmRsZVNpZ25DYWxsYmFjayhjYWxsYmFja1VybFN0cmluZzogc3RyaW5nKTogU2lnblJlc3VsdCB7XG4gICAgbGV0IHNpZ25lZFRyYW5zYWN0aW9uXG4gICAgY29uc3Qge1xuICAgICAgc2lnbmVkX3RyYW5zYWN0aW9uOiBlbmNvZGVkVHJhbnNhY3Rpb24sXG4gICAgICBwcm9jZXNzX2lkOiBwcm9jZXNzSWQsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRyYW5zYWN0aW9uX2lkOiB0cmFuc2FjdGlvbklkLFxuICAgICAgZXJyb3JzLFxuICAgIH0gPSBIZWxwZXJzLmV4dHJhY3REYXRhRnJvbUNhbGxiYWNrVXJsKGNhbGxiYWNrVXJsU3RyaW5nKVxuXG4gICAgaWYgKCFlcnJvcnMpIHtcbiAgICAgIC8vIERlY29kZSBiYXNlNjQgcGFyYW1ldGVyc1xuICAgICAgc2lnbmVkVHJhbnNhY3Rpb24gPSBIZWxwZXJzLmJhc2U2NERlY29kZVNhZmUoZW5jb2RlZFRyYW5zYWN0aW9uKVxuICAgIH1cbiAgICB0aGlzLnNldElzQnVzeShmYWxzZSlcbiAgICByZXR1cm4geyBzaWduZWRUcmFuc2FjdGlvbiwgcHJvY2Vzc0lkLCBzdGF0ZSwgdHJhbnNhY3Rpb25JZCwgZXJyb3JzIH1cbiAgfVxuXG4gIC8qKiBVcGRhdGVzIGFuZCByZXR1cm5zIGEgV2ViV2lkZ2V0UHJvcHMgb2JqZWN0IHRvIGluY2x1ZGUgdHdvIG5ldyBmaWVsZHM6IHRpbWVzdGFtcCwgc2lnbmF0dXJlXG4gICAqICB0aW1lc3RhbXA6IGN1cnJlbnQgc2VydmVyIHRpbWVcbiAgICogIHNpZ25hdHVyZTogSE1BQyBzaWduYXR1cmUgb2YgdGhlIG9iamVjdCBpbmNsdWRpbmcgdGhlIHRpbWVzdGFtcCAtIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIGFwaUtleVxuICAgKiAgSUYgaW5jb21pbmcgcHJvcHMgYWxyZWFkeSBoYXMgYSB2YWx1ZSBmb3IgdGltZXN0YW1wIC0gaXQgaXMga2VwdFxuICAgKiAgSWYgYm90aCBpbmNvbWluZyBhbmQgdGltZXN0YW1wIGFuZCBzaWduYXR1cmUgYXJlIGFscmVhZHkgcHJlc2VudCwgdGhpcyByZXR1cm5zIGluY29taW5nIGRhdGEgdW5tb2RpZmllZFxuICAgKiAgSWYgYW4gYXBpS2V5IGlzIG5vdCBwcm92aWRlZCBpbiBvcHRpb25zLCB0aGlzIGZ1bmN0aW9uIGV4cGVjdHMgYSBwcm94eSBzZXJ2ZXIgZW5kcG9pbnQgYXQgL29yZWlkL2htYWMgdG8gZ2VuZXJhdGUgdGhlIHNpZ2FudHVyZSB3aXRoIHRoZSBzZWN1cmVkIGFwaUtleVxuICAgKiAgUmV0dXJucyB0aGUgdXBkYXRlZCBvYmplY3QgdGhhdCBpbmNsdWRlcyB0aGUgdGltZXN0YW1wIGFuZCB0aGUgc2lnbmF0dXJlIGZpZWxkc1xuICAgKi9cbiAgYXN5bmMgYXBwZW5kVGltZXN0YW1wQW5kU2lnbmF0dXJlVG9XaWRnZXRQcm9wcyhkYXRhOiBXZWJXaWRnZXRQcm9wcykge1xuICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSB0aW1lc3RhbXAgYW5kIHNpZ25hdHVyZSwganVzdCByZXR1cm4gZGF0YSBhcyBpc1xuICAgIGlmIChkYXRhPy50aW1lc3RhbXAgJiYgZGF0YT8uc2lnbmF0dXJlKSByZXR1cm4gZGF0YVxuICAgIGNvbnN0IHNpZ25lZFByb3BzOiBQYXJ0aWFsPFdlYldpZGdldFByb3BzPiA9IHsgLi4uZGF0YSB9XG4gICAgLy8ga2VlcCBleGlzdGluZyB0aW1lc3RhbXAgaWYgdGhlcmUgaXMgb25lXG4gICAgY29uc3Qgbm93VGltZXN0YW1wID0gZGF0YT8udGltZXN0YW1wIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgc2lnbmVkUHJvcHMub3JpZ2luID0gZGF0YT8ub3JpZ2luIHx8IHdpbmRvdz8ubG9jYXRpb24ub3JpZ2luXG4gICAgc2lnbmVkUHJvcHMudGltZXN0YW1wID0gbm93VGltZXN0YW1wXG4gICAgLy8gaWYgd2UgaGF2ZSBhbiBhcGlLZXksIGFkZCBhIHNpZ25hdHVyZVxuICAgIHRyeSB7XG4gICAgICBzaWduZWRQcm9wcy5zaWduYXR1cmUgPSBhd2FpdCBnZW5lcmF0ZUhtYWNXaXRoQXBpS2V5T3JQcm94eVNlcnZlcihcbiAgICAgICAgdGhpcy5yZXF1aXJlc1Byb3h5U2VydmVyLFxuICAgICAgICB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgICBKU09OLnN0cmluZ2lmeShIZWxwZXJzLnNvcnRKc29uKGRhdGEpKSwgLy8gcHJvcHMgaW5jbHVkaW5nIHRpbWVzdGFtcCAtIHNvcnRKc29uIGVuc3VyZXMganNvbiBtZW1iZXJzIGFyZSBhbHdheXMgaW4gdGhlIHNhbWUgb3JkZXJcbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gZG8gbm90aGluZywgd2UganVzdCBjYW4ndCBhZGQgYSBzaWduYXR1cmUgc2luY2UgYXBpS2V5IGFuZCBwcm94eVNlcnZlciBhcmUgbWlzc2luZ1xuICAgIH1cbiAgICByZXR1cm4gc2lnbmVkUHJvcHMgYXMgV2ViV2lkZ2V0UHJvcHNcbiAgfVxuXG4gIC8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsbCBhcGkgZW5kcG9pbnQgYW5kIGluamVjdCBhcGkta2V5XG4gICAgaGVyZSBwYXJhbXMgY2FuIGJlIHF1ZXJ5IHBhcmFtcyBpbiBjYXNlIG9mIGEgR0VUIHJlcXVlc3Qgb3IgYm9keSBwYXJhbXMgaW4gY2FzZSBvZiBQT1NUIHJlcXVlc3RcbiAgICBwcm9jZXNzSWQgKG9wdGlvbmFsKSAtIGNhbiBiZSB1c2VkIHRvIGFzc29jaWF0ZSBtdWx0aXBsZSBjYWxscyB0b2dldGhlciBpbnRvIGEgc2luZ2xlIHByb2Nlc3MgZmxvd1xuICAqL1xuICBhc3luYyBjYWxsT3JlSWRBcGkoXG4gICAgcmVxdWVzdE1ldGhvZDogUmVxdWVzdFR5cGUsXG4gICAgZW5kcG9pbnQ6IEFwaUVuZHBvaW50LFxuICAgIHBhcmFtczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9LFxuICAgIC8qKiBSZXF1aXJlZCBpZiBhcGlLZXkgaXMgbm90IHByb3ZpZGVyIChvcHRpb25hbCBvdGhlcndpc2UpICovXG4gICAgb3ZlcnJpZGVBY2Nlc3NUb2tlbj86IHN0cmluZyxcbiAgICBwcm9jZXNzSWQ6IFByb2Nlc3NJZCA9IG51bGwsXG4gICkge1xuICAgIGxldCB1cmxTdHJpbmdcbiAgICBsZXQgcmVzcG9uc2VcbiAgICBjb25zdCBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge31cbiAgICBjb25zdCB7IGFwaUtleSwgb3JlSWRVcmwgfSA9IHRoaXMub3B0aW9uc1xuICAgIC8vIGlmIHJ1bm5pbmcgaW4gYnJvd3Nlciwgd2UgZG9udCBjYWxsIHRoZSBhcGkgZGlyZWN0bHksIHdlIHVzZSBhIHByb3h5IHNlcnZlciAodW5sZXNzIHdlJ3JlIHJ1bm5pbmcgYSBkZW1vIGFwcClcbiAgICAvLyBjYWxscyB0byB0aGUgcHJveHkgc2VydmVyIG11c3Qgc3RhcnQgd2l0aCAnLycgKG5vdCBhbiBob3N0IGxpa2UgaHR0cDovL3NlcnZlcikgYW5kIHdlJ2xsIHByZXBlbmQgJ29yZWlkJyB0byBpdCBlLmcuIC9vcmVpZC9hcGkveHh4IHRvIG1ha2UgaXQgZWFzaWVyIHRvIGRvIHByb3h5IHNlcnZlciByb3V0aW5nXG4gICAgY29uc3Qgb3JlSWRVcmxCYXNlID0gdGhpcy5yZXF1aXJlc1Byb3h5U2VydmVyID8gJy9vcmVpZCcgOiBvcmVJZFVybFxuICAgIGNvbnN0IHVybCA9IGAke29yZUlkVXJsQmFzZX0vYXBpLyR7ZW5kcG9pbnR9YFxuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gb3ZlcnJpZGVBY2Nlc3NUb2tlbiB8fCB0aGlzLmFjY2Vzc1Rva2VuXG5cbiAgICBpZiAoIWFwaUtleSAmJiAhYWNjZXNzVG9rZW4gJiYgIXB1YmxpY0FwaUVuZHBvaW50cy5pbmNsdWRlcyhlbmRwb2ludCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3JlSWQgQVBJIHJlcXVlc3QgcmVxdWlyZXMgZWl0aGVyIGFwaUtleSBvciBhY2Nlc3NUb2tlbicpXG4gICAgfVxuXG4gICAgLy8gYXBpS2V5IGlzIG9wdGlvbmFsIChhY2Nlc3NUb2tlbiBpcyByZXF1aXJlZCBpZiBhcGlLZXkgbm90IHByb3ZpZGVkKVxuICAgIGlmIChhcGlLZXkpIHtcbiAgICAgIGhlYWRlcnNbJ2FwaS1rZXknXSA9IGFwaUtleVxuICAgIH1cblxuICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke2FjY2Vzc1Rva2VufWBcbiAgICB9XG5cbiAgICBpZiAoIWlzTnVsbE9yRW1wdHkocHJvY2Vzc0lkKSkge1xuICAgICAgaGVhZGVyc1sncHJvY2Vzcy1pZCddID0gcHJvY2Vzc0lkXG4gICAgfVxuICAgIC8vIGFkZCBzZGsgdmVyc2lvbiB0byByZXF1ZXN0IGhlYWRlclxuICAgIGhlYWRlcnNbJ3Nkay12ZXJzaW9uJ10gPSBgb3JlaWRqcy8ke3ZlcnNpb259YFxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdFVFxuICAgICAgaWYgKHJlcXVlc3RNZXRob2QgPT09IFJlcXVlc3RUeXBlLkdldCkge1xuICAgICAgICBpZiAoIWlzTnVsbE9yRW1wdHkocGFyYW1zKSkge1xuICAgICAgICAgIHVybFN0cmluZyA9IE9iamVjdC5rZXlzKHBhcmFtcylcbiAgICAgICAgICAgIC5tYXAoa2V5ID0+IGAke2tleX09JHtwYXJhbXNba2V5XX1gKVxuICAgICAgICAgICAgLmpvaW4oJyYnKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXJsV2l0aFBhcmFtcyA9IHVybFN0cmluZyA/IGAke3VybH0/JHt1cmxTdHJpbmd9YCA6IHVybFxuICAgICAgICByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldCh1cmxXaXRoUGFyYW1zLCB7IGhlYWRlcnMgfSlcbiAgICAgIH1cbiAgICAgIC8vIFBPU1RcbiAgICAgIGlmIChyZXF1ZXN0TWV0aG9kID09PSBSZXF1ZXN0VHlwZS5Qb3N0KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSAhaXNOdWxsT3JFbXB0eShwYXJhbXMpID8gSlNPTi5zdHJpbmdpZnkocGFyYW1zKSA6IG51bGxcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KHVybCwgYm9keSwge1xuICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJywgLi4uaGVhZGVycyB9LFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKG5ldHdvcmtFcnJvcikge1xuICAgICAgY29uc3QgZXJyb3IgPSBIZWxwZXJzLmdldEVycm9yRnJvbUF4aW9zRXJyb3IobmV0d29ya0Vycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlPy5kYXRhXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIC8qKiBBZGQgYW4gYXBwIGFjY2VzcyB0b2tlbiBhbmQgaG1hYyBzaWduYXR1cmUgdG8gdGhlIHVybFxuICAgKiAgSWYgcnVubmluZyBpbiBicm93c2VyLCBjYWxscyBwcm94eSBzZXJ2ZXIgYXQgL29yZWlkL3ByZXBhcmUtdXJsIHRvIGRvIGJvdGggKHNpbmNlIHRoZXkgcmVxdWlyZSB0ZWggYXBpS2V5IHNlY3JldCkgKi9cbiAgYXN5bmMgYWRkQWNjZXNzVG9rZW5BbmRIbWFjVG9VcmwoXG4gICAgdXJsU3RyaW5nOiBzdHJpbmcsXG4gICAgYXBwQWNjZXNzVG9rZW5NZXRhZGF0YTogQXBwQWNjZXNzVG9rZW5NZXRhZGF0YSxcbiAgICBvdmVycmlkZUFwcEFjY2Vzc1Rva2VuPzogQXBwQWNjZXNzVG9rZW4sXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgeyBhcHBJZCB9ID0gdGhpcy5vcHRpb25zXG4gICAgLy8gcnVubmluZyBpbiBicm93c2VyXG4gICAgaWYgKHRoaXMucmVxdWlyZXNQcm94eVNlcnZlcikge1xuICAgICAgLy8gcmV0cmlldmUgYW5kIGFwcGVuZCBhbiBhcHAtYWNjZXNzLXRva2VuIGFuZCBhIG1hdGNoaW5nIGhtYWMgc2lnbmF0dXJlIHRvIHRoZSBlbmQgb2YgdGhlIHVybFxuICAgICAgLy8gY2FsbGluZyB0aGUgcHJveHkgc2VydmVyIGlzIHJlcXVpcmVkIHRvIHByb3RlY3QgdGhlIHNlY3JldHMgbmVlZGVkIHRvIGdldCB0aGUgYWNjZXNzIHRva2VuIGFuZCB0byBnZW5lcmF0ZSB0aGUgaG1hY1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KCcvb3JlaWQvcHJlcGFyZS11cmwnLCB7IGFwcEFjY2Vzc1Rva2VuTWV0YWRhdGEsIHVybFN0cmluZyB9KVxuICAgICAgcmV0dXJuIHJlc3BvbnNlPy5kYXRhPy51cmxTdHJpbmdcbiAgICB9XG4gICAgbGV0IGNvbXBsZXRlVXJsID0gYCR7dXJsU3RyaW5nfSZhcHBfaWQ9JHthcHBJZH1gXG5cbiAgICAvLyBpZiB3ZSBuZWVkIGFwcCB0b2tlbiBtZXRhZGF0YSwgdGhlbiB3ZSBnZW5lcmF0ZSBhbmQgYWRkIGFuIGFwcEFjY2Vzc1Rva2VuXG4gICAgaWYgKCFpc051bGxPckVtcHR5KGFwcEFjY2Vzc1Rva2VuTWV0YWRhdGEpKSB7XG4gICAgICBjb25zdCBhcHBBY2Nlc3NUb2tlbiA9IG92ZXJyaWRlQXBwQWNjZXNzVG9rZW4gfHwgKGF3YWl0IHRoaXMuZ2V0QXBwQWNjZXNzVG9rZW4oeyBhcHBBY2Nlc3NUb2tlbk1ldGFkYXRhIH0pKVxuICAgICAgY29tcGxldGVVcmwgPSBgJHtjb21wbGV0ZVVybH0mYXBwX2FjY2Vzc190b2tlbj0ke2FwcEFjY2Vzc1Rva2VufWBcbiAgICB9XG5cbiAgICAvLyBBbiBobWFjIGlzIG5vIGxvbmdlciBhbHdheXMgcmVxdWlyZWQgLSBob3dldmVyLCBpZiB3ZSBoYXZlIGFuIGFwaUtleSwgd2UgY2FuIGdlbmVyYXRlIG9uZVxuICAgIGlmICh0aGlzLm9wdGlvbnM/LmFwaUtleSkge1xuICAgICAgY29tcGxldGVVcmwgPSBhd2FpdCBhcHBlbmRIbWFjVG9VcmwoZmFsc2UsIHRoaXMub3B0aW9ucz8uYXBpS2V5LCBjb21wbGV0ZVVybClcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcGxldGVVcmxcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICAvLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG4gIGluc3RhbmNlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCBpbnN0YW5jZUNvbmZpZykpO1xuICB9O1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcbmF4aW9zLlZFUlNJT04gPSByZXF1aXJlKCcuL2Vudi9kYXRhJykudmVyc2lvbjtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxuYXhpb3MuaXNBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzQXhpb3NFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsKSAmJiB2YWwuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbC5jb25zdHJ1Y3RvcilcbiAgICAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZvcm1EYXRhXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKGlzQXJyYXlCdWZmZXIodmFsLmJ1ZmZlcikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBVUkxTZWFyY2hQYXJhbXNdJztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOUycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuZnVuY3Rpb24gc3RyaXBCT00oY29udGVudCkge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW0sXG4gIHN0cmlwQk9NOiBzdHJpcEJPTVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vbWVyZ2VDb25maWcnKTtcbnZhciB2YWxpZGF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ZhbGlkYXRvcicpO1xuXG52YXIgdmFsaWRhdG9ycyA9IHZhbGlkYXRvci52YWxpZGF0b3JzO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZ09yVXJsID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICBjb25maWcudXJsID0gY29uZmlnT3JVcmw7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0gY29uZmlnT3JVcmwgfHwge307XG4gIH1cblxuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gIC8vIFNldCBjb25maWcubWV0aG9kXG4gIGlmIChjb25maWcubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSB0aGlzLmRlZmF1bHRzLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5tZXRob2QgPSAnZ2V0JztcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uYWwgPSBjb25maWcudHJhbnNpdGlvbmFsO1xuXG4gIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgc2lsZW50SlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbilcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gIHZhciByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICB2YXIgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciBwcm9taXNlO1xuXG4gIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcblxuICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGNoYWluLCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbik7XG4gICAgY2hhaW4gPSBjaGFpbi5jb25jYXQocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluKTtcblxuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cblxuICB2YXIgbmV3Q29uZmlnID0gY29uZmlnO1xuICB3aGlsZSAocmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgdmFyIG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB2YXIgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCk7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NvbmZpZyA9IG9uRnVsZmlsbGVkKG5ld0NvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uUmVqZWN0ZWQoZXJyb3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0KG5ld0NvbmZpZyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuXG4gIHdoaWxlIChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5BeGlvcy5wcm90b3R5cGUuZ2V0VXJpID0gZnVuY3Rpb24gZ2V0VXJpKGNvbmZpZykge1xuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICByZXR1cm4gYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLnJlcGxhY2UoL15cXD8vLCAnJyk7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB2YXIgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuXG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkLCBvcHRpb25zKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkLFxuICAgIHN5bmNocm9ub3VzOiBvcHRpb25zID8gb3B0aW9ucy5zeW5jaHJvbm91cyA6IGZhbHNlLFxuICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9DYW5jZWwnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxuXG4gIGlmIChjb25maWcuc2lnbmFsICYmIGNvbmZpZy5zaWduYWwuYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBDYW5jZWwoJ2NhbmNlbGVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgIGNvbmZpZyxcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1xuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgY29uZmlnLFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIHZhciBjb250ZXh0ID0gdGhpcyB8fCBkZWZhdWx0cztcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4uY2FsbChjb250ZXh0LCBkYXRhLCBoZWFkZXJzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2VuaGFuY2VFcnJvcicpO1xudmFyIHRyYW5zaXRpb25hbERlZmF1bHRzID0gcmVxdWlyZSgnLi90cmFuc2l0aW9uYWwnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVNhZmVseShyYXdWYWx1ZSwgcGFyc2VyLCBlbmNvZGVyKSB7XG4gIGlmICh1dGlscy5pc1N0cmluZyhyYXdWYWx1ZSkpIHtcbiAgICB0cnkge1xuICAgICAgKHBhcnNlciB8fCBKU09OLnBhcnNlKShyYXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdXRpbHMudHJpbShyYXdWYWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubmFtZSAhPT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoZW5jb2RlciB8fCBKU09OLnN0cmluZ2lmeSkocmF3VmFsdWUpO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG5cbiAgdHJhbnNpdGlvbmFsOiB0cmFuc2l0aW9uYWxEZWZhdWx0cyxcblxuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdBY2NlcHQnKTtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpIHx8IChoZWFkZXJzICYmIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID09PSAnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlTYWZlbHkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICB2YXIgdHJhbnNpdGlvbmFsID0gdGhpcy50cmFuc2l0aW9uYWwgfHwgZGVmYXVsdHMudHJhbnNpdGlvbmFsO1xuICAgIHZhciBzaWxlbnRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuc2lsZW50SlNPTlBhcnNpbmc7XG4gICAgdmFyIGZvcmNlZEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5mb3JjZWRKU09OUGFyc2luZztcbiAgICB2YXIgc3RyaWN0SlNPTlBhcnNpbmcgPSAhc2lsZW50SlNPTlBhcnNpbmcgJiYgdGhpcy5yZXNwb25zZVR5cGUgPT09ICdqc29uJztcblxuICAgIGlmIChzdHJpY3RKU09OUGFyc2luZyB8fCAoZm9yY2VkSlNPTlBhcnNpbmcgJiYgdXRpbHMuaXNTdHJpbmcoZGF0YSkgJiYgZGF0YS5sZW5ndGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHN0cmljdEpTT05QYXJzaW5nKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgZW5oYW5jZUVycm9yKGUsIHRoaXMsICdFX0pTT05fUEFSU0UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfSxcblxuICBoZWFkZXJzOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgICB9XG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG5cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIGVycm9yLmlzQXhpb3NFcnJvciA9IHRydWU7XG5cbiAgZXJyb3IudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgc3RhdHVzOiB0aGlzLnJlc3BvbnNlICYmIHRoaXMucmVzcG9uc2Uuc3RhdHVzID8gdGhpcy5yZXNwb25zZS5zdGF0dXMgOiBudWxsXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGVycm9yO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNpbGVudEpTT05QYXJzaW5nOiB0cnVlLFxuICBmb3JjZWRKU09OUGFyc2luZzogdHJ1ZSxcbiAgY2xhcmlmeVRpbWVvdXRFcnJvcjogZmFsc2Vcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBidWlsZEZ1bGxQYXRoID0gcmVxdWlyZSgnLi4vY29yZS9idWlsZEZ1bGxQYXRoJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcbnZhciB0cmFuc2l0aW9uYWxEZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzL3RyYW5zaXRpb25hbCcpO1xudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9DYW5jZWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuICAgIHZhciByZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIHZhciBvbkNhbmNlbGVkO1xuICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi51bnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgY29uZmlnLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgOiAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgZnVuY3Rpb24gb25sb2FkZW5kKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIXJlc3BvbnNlVHlwZSB8fCByZXNwb25zZVR5cGUgPT09ICd0ZXh0JyB8fCAgcmVzcG9uc2VUeXBlID09PSAnanNvbicgP1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUoZnVuY3Rpb24gX3Jlc29sdmUodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIGZ1bmN0aW9uIF9yZWplY3QoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICgnb25sb2FkZW5kJyBpbiByZXF1ZXN0KSB7XG4gICAgICAvLyBVc2Ugb25sb2FkZW5kIGlmIGF2YWlsYWJsZVxuICAgICAgcmVxdWVzdC5vbmxvYWRlbmQgPSBvbmxvYWRlbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGUgdG8gZW11bGF0ZSBvbmxvYWRlbmRcbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkeXN0YXRlIGhhbmRsZXIgaXMgY2FsbGluZyBiZWZvcmUgb25lcnJvciBvciBvbnRpbWVvdXQgaGFuZGxlcnMsXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBjYWxsIG9ubG9hZGVuZCBvbiB0aGUgbmV4dCAndGljaydcbiAgICAgICAgc2V0VGltZW91dChvbmxvYWRlbmQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgdmFyIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dCA/ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcgOiAndGltZW91dCBleGNlZWRlZCc7XG4gICAgICB2YXIgdHJhbnNpdGlvbmFsID0gY29uZmlnLnRyYW5zaXRpb25hbCB8fCB0cmFuc2l0aW9uYWxEZWZhdWx0cztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgdHJhbnNpdGlvbmFsLmNsYXJpZnlUaW1lb3V0RXJyb3IgPyAnRVRJTUVET1VUJyA6ICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4gfHwgY29uZmlnLnNpZ25hbCkge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICAgIG9uQ2FuY2VsZWQgPSBmdW5jdGlvbihjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlamVjdCghY2FuY2VsIHx8IChjYW5jZWwgJiYgY2FuY2VsLnR5cGUpID8gbmV3IENhbmNlbCgnY2FuY2VsZWQnKSA6IGNhbmNlbCk7XG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4gJiYgY29uZmlnLmNhbmNlbFRva2VuLnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIGlmIChjb25maWcuc2lnbmFsKSB7XG4gICAgICAgIGNvbmZpZy5zaWduYWwuYWJvcnRlZCA/IG9uQ2FuY2VsZWQoKSA6IGNvbmZpZy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJlcXVlc3REYXRhKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi9jcmVhdGVFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkK1xcLS5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLy8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbnZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSAocGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSA6IFtdKS5jb25jYXQoW3ZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEaXJlY3RLZXlzKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtZXJnZU1hcCA9IHtcbiAgICAndXJsJzogdmFsdWVGcm9tQ29uZmlnMixcbiAgICAnbWV0aG9kJzogdmFsdWVGcm9tQ29uZmlnMixcbiAgICAnZGF0YSc6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgJ2Jhc2VVUkwnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0cmFuc2Zvcm1SZXF1ZXN0JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndHJhbnNmb3JtUmVzcG9uc2UnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdwYXJhbXNTZXJpYWxpemVyJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndGltZW91dCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RpbWVvdXRNZXNzYWdlJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnd2l0aENyZWRlbnRpYWxzJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnYWRhcHRlcic6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3Jlc3BvbnNlVHlwZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3hzcmZDb29raWVOYW1lJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAneHNyZkhlYWRlck5hbWUnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdvblVwbG9hZFByb2dyZXNzJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnb25Eb3dubG9hZFByb2dyZXNzJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnZGVjb21wcmVzcyc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ21heENvbnRlbnRMZW5ndGgnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdtYXhCb2R5TGVuZ3RoJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndHJhbnNwb3J0JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnaHR0cEFnZW50JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnaHR0cHNBZ2VudCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ2NhbmNlbFRva2VuJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnc29ja2V0UGF0aCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3Jlc3BvbnNlRW5jb2RpbmcnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd2YWxpZGF0ZVN0YXR1cyc6IG1lcmdlRGlyZWN0S2V5c1xuICB9O1xuXG4gIHV0aWxzLmZvckVhY2goT2JqZWN0LmtleXMoY29uZmlnMSkuY29uY2F0KE9iamVjdC5rZXlzKGNvbmZpZzIpKSwgZnVuY3Rpb24gY29tcHV0ZUNvbmZpZ1ZhbHVlKHByb3ApIHtcbiAgICB2YXIgbWVyZ2UgPSBtZXJnZU1hcFtwcm9wXSB8fCBtZXJnZURlZXBQcm9wZXJ0aWVzO1xuICAgIHZhciBjb25maWdWYWx1ZSA9IG1lcmdlKHByb3ApO1xuICAgICh1dGlscy5pc1VuZGVmaW5lZChjb25maWdWYWx1ZSkgJiYgbWVyZ2UgIT09IG1lcmdlRGlyZWN0S2V5cykgfHwgKGNvbmZpZ1twcm9wXSA9IGNvbmZpZ1ZhbHVlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWRVJTSU9OID0gcmVxdWlyZSgnLi4vZW52L2RhdGEnKS52ZXJzaW9uO1xuXG52YXIgdmFsaWRhdG9ycyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuWydvYmplY3QnLCAnYm9vbGVhbicsICdudW1iZXInLCAnZnVuY3Rpb24nLCAnc3RyaW5nJywgJ3N5bWJvbCddLmZvckVhY2goZnVuY3Rpb24odHlwZSwgaSkge1xuICB2YWxpZGF0b3JzW3R5cGVdID0gZnVuY3Rpb24gdmFsaWRhdG9yKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gdHlwZSB8fCAnYScgKyAoaSA8IDEgPyAnbiAnIDogJyAnKSArIHR5cGU7XG4gIH07XG59KTtcblxudmFyIGRlcHJlY2F0ZWRXYXJuaW5ncyA9IHt9O1xuXG4vKipcbiAqIFRyYW5zaXRpb25hbCBvcHRpb24gdmFsaWRhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufGJvb2xlYW4/fSB2YWxpZGF0b3IgLSBzZXQgdG8gZmFsc2UgaWYgdGhlIHRyYW5zaXRpb25hbCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZFxuICogQHBhcmFtIHtzdHJpbmc/fSB2ZXJzaW9uIC0gZGVwcmVjYXRlZCB2ZXJzaW9uIC8gcmVtb3ZlZCBzaW5jZSB2ZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZz99IG1lc3NhZ2UgLSBzb21lIG1lc3NhZ2Ugd2l0aCBhZGRpdGlvbmFsIGluZm9cbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xudmFsaWRhdG9ycy50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBWRVJTSU9OICsgJ10gVHJhbnNpdGlvbmFsIG9wdGlvbiBcXCcnICsgb3B0ICsgJ1xcJycgKyBkZXNjICsgKG1lc3NhZ2UgPyAnLiAnICsgbWVzc2FnZSA6ICcnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3B0LCBvcHRzKSB7XG4gICAgaWYgKHZhbGlkYXRvciA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXRNZXNzYWdlKG9wdCwgJyBoYXMgYmVlbiByZW1vdmVkJyArICh2ZXJzaW9uID8gJyBpbiAnICsgdmVyc2lvbiA6ICcnKSkpO1xuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBhbGxvd1Vua25vd25cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICB2YXIgb3B0ID0ga2V5c1tpXTtcbiAgICB2YXIgdmFsaWRhdG9yID0gc2NoZW1hW29wdF07XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NlcnRPcHRpb25zOiBhc3NlcnRPcHRpb25zLFxuICB2YWxpZGF0b3JzOiB2YWxpZGF0b3JzXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFwidmVyc2lvblwiOiBcIjAuMjYuMVwiXG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcblxuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICB0aGlzLnByb21pc2UudGhlbihmdW5jdGlvbihjYW5jZWwpIHtcbiAgICBpZiAoIXRva2VuLl9saXN0ZW5lcnMpIHJldHVybjtcblxuICAgIHZhciBpO1xuICAgIHZhciBsID0gdG9rZW4uX2xpc3RlbmVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0b2tlbi5fbGlzdGVuZXJzW2ldKGNhbmNlbCk7XG4gICAgfVxuICAgIHRva2VuLl9saXN0ZW5lcnMgPSBudWxsO1xuICB9KTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICB0aGlzLnByb21pc2UudGhlbiA9IGZ1bmN0aW9uKG9uZnVsZmlsbGVkKSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICB0b2tlbi5zdWJzY3JpYmUocmVzb2x2ZSk7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSkudGhlbihvbmZ1bGZpbGxlZCk7XG5cbiAgICBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uIHJlamVjdCgpIHtcbiAgICAgIHRva2VuLnVuc3Vic2NyaWJlKF9yZXNvbHZlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIHRoZSBjYW5jZWwgc2lnbmFsXG4gKi9cblxuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICBsaXN0ZW5lcih0aGlzLnJlYXNvbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX2xpc3RlbmVycykge1xuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbbGlzdGVuZXJdO1xuICB9XG59O1xuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGNhbmNlbCBzaWduYWxcbiAqL1xuXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaW5kZXggPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gdXRpbHMuaXNPYmplY3QocGF5bG9hZCkgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn07XG4iLCJpbXBvcnQgeyBBcGlFbmRwb2ludCB9IGZyb20gJy4vbW9kZWxzJ1xuaW1wb3J0IHZlcnNpb25Kc29uIGZyb20gJy4vdmVyc2lvbi5qc29uJ1xuXG5leHBvcnQgY29uc3QgZXh0ZXJuYWxXYWxsZXRzTm90SW1wbGVtZW50ZWQgPSBbJ21ldHJvJ11cbmV4cG9ydCBjb25zdCBkZWZhdWx0T3JlSWRTZXJ2aWNlVXJsID0gJ2h0dHBzOi8vc2VydmljZS5vcmVpZC5pbydcbmV4cG9ydCBjb25zdCB7IHZlcnNpb24gfSA9IHZlcnNpb25Kc29uXG5leHBvcnQgY29uc3QgcHVibGljQXBpRW5kcG9pbnRzID0gW0FwaUVuZHBvaW50LkxvZ2luVXNlcldpdGhUb2tlbiwgQXBpRW5kcG9pbnQuTmV3VXNlcldpdGhUb2tlbl0gLy8gYXBpIGVuZHBvaW50cyB0aGF0IGRvbnQgcmVxdWlyZSBhdXRob3JpemF0aW9uXG4iLCJpbXBvcnQgT3JlSWRDb250ZXh0IGZyb20gJy4uL2NvcmUvSU9yZWlkQ29udGV4dCdcbmltcG9ydCB7XG4gIEFwaUtleVVzZWRGb3IsXG4gIENyZWF0ZVRyYW5zYWN0aW9uRGF0YSxcbiAgRXh0ZXJuYWxXYWxsZXRUeXBlLFxuICBTaWduYXR1cmVQcm92aWRlclNpZ25SZXN1bHQsXG4gIFNpZ25XaXRoT3JlSWRSZXN1bHQsXG4gIFRyYW5zYWN0aW9uRGF0YSxcbn0gZnJvbSAnLi4vbW9kZWxzJ1xuaW1wb3J0IFRyYW5zaXRIZWxwZXIgZnJvbSAnLi4vdHJhbnNpdC9UcmFuc2l0SGVscGVyJ1xuaW1wb3J0IHtcbiAgYXNzZXJ0SGFzQXBpS2V5LFxuICBjYWxsQXBpQ2FuQXV0b3NpZ25UcmFuc2FjdGlvbixcbiAgY2FsbEFwaUN1c3RvZGlhbFNpZ25UcmFuc2FjdGlvbixcbiAgY2FsbEFwaVNpZ25UcmFuc2FjdGlvbixcbn0gZnJvbSAnLi4vYXBpJ1xuaW1wb3J0IHsgZ2V0T3JlSWRTaWduVXJsIH0gZnJvbSAnLi4vY29yZS91cmxHZW5lcmF0b3JzJ1xuaW1wb3J0IEhlbHBlcnMgZnJvbSAnLi4vdXRpbHMvaGVscGVycydcbmltcG9ydCBVYWxIZWxwZXIgZnJvbSAnLi4vdWFsL1VhbEhlbHBlcidcbmltcG9ydCB7IFVzZXIgfSBmcm9tICcuLi91c2VyL3VzZXInXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgY29uc3RydWN0b3IoYXJnczogeyBvcmVJZENvbnRleHQ6IE9yZUlkQ29udGV4dDsgdXNlcjogVXNlcjsgZGF0YTogVHJhbnNhY3Rpb25EYXRhIH0pIHtcbiAgICB0aGlzLl9vcmVJZENvbnRleHQgPSBhcmdzLm9yZUlkQ29udGV4dFxuICAgIHRoaXMuX3VzZXIgPSBhcmdzLnVzZXJcbiAgICB0aGlzLmFzc2VydFZhbGlkVHJhbnNhY3Rpb25BbmRTZXREYXRhKGFyZ3MuZGF0YSlcbiAgICB0aGlzLl90cmFuc2l0SGVscGVyID0gbmV3IFRyYW5zaXRIZWxwZXIoeyBvcmVJZENvbnRleHQ6IHRoaXMuX29yZUlkQ29udGV4dCwgdXNlcjogdGhpcy5fdXNlciB9KVxuICAgIHRoaXMuX3VhbEhlbHBlciA9IG5ldyBVYWxIZWxwZXIoeyBvcmVJZENvbnRleHQ6IHRoaXMuX29yZUlkQ29udGV4dCwgdXNlcjogdGhpcy5fdXNlciB9KVxuICB9XG5cbiAgcHJpdmF0ZSBfb3JlSWRDb250ZXh0OiBPcmVJZENvbnRleHRcblxuICBwcml2YXRlIF9kYXRhOiBUcmFuc2FjdGlvbkRhdGFcblxuICBwcml2YXRlIF90cmFuc2l0SGVscGVyOiBUcmFuc2l0SGVscGVyXG5cbiAgcHJpdmF0ZSBfdWFsSGVscGVyOiBVYWxIZWxwZXJcblxuICBwcml2YXRlIF91c2VyOiBVc2VyXG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFcbiAgfVxuXG4gIC8qKiBlbnN1cmUgYWxsIHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIHByb3ZpZGVkICovXG4gIGFzc2VydFZhbGlkVHJhbnNhY3Rpb25BbmRTZXREYXRhKGNyZWF0ZVRyYW5zYWN0aW9uRGF0YTogQ3JlYXRlVHJhbnNhY3Rpb25EYXRhKSB7XG4gICAgY29uc3QgeyBjaGFpbk5ldHdvcmssIHRyYW5zYWN0aW9uLCBzaWduZWRUcmFuc2FjdGlvbiB9ID0gY3JlYXRlVHJhbnNhY3Rpb25EYXRhIHx8IHt9XG4gICAgY29uc3QgbWlzc2luZ0ZpZWxkczogc3RyaW5nW10gPSBbXVxuICAgIGNvbnN0IHZhbGlkYXRpb25Jc3N1ZXM6IHN0cmluZ1tdID0gW11cblxuICAgIGlmICghdGhpcy5fdXNlciB8fCAhdGhpcy5fdXNlci5oYXNEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ha2Ugc3VyZSB0aGF0IGEgdXNlciBoYXMgYmVlbiBhdXRoZW50aWNhdGVkIGFuZCB0aGF0IHlvdXZlIGNhbGxlZCB1c2VyLmdldERhdGEoKScpXG4gICAgfVxuXG4gICAgLy8gcmVxdWlyZWQgZmllbGRzXG4gICAgaWYgKCFjaGFpbk5ldHdvcmspIG1pc3NpbmdGaWVsZHMucHVzaCgnY2hhaW5OZXR3b3JrJylcbiAgICBpZiAoIXRyYW5zYWN0aW9uICYmICFzaWduZWRUcmFuc2FjdGlvbikgbWlzc2luZ0ZpZWxkcy5wdXNoKCd0cmFuc2FjdGlvbiBPUiBzaWduZWRUcmFuc2FjdGlvbicpXG4gICAgLy8gdmFsaWRhdG9uIHJ1bGVzXG4gICAgaWYgKCF0aGlzLl91c2VyLmFjY291bnROYW1lKVxuICAgICAgdmFsaWRhdGlvbklzc3Vlcy5wdXNoKCdUcmFuc2FjdGlvbiBEYXRhIGVycm9yIC0gRXhwZWN0aW5nIGEgdXNlci5hY2NvdW50TmFtZSAtIGlzIHRoZSB1c2VyIGxvZ2dlZC1pbiBpbj8nKVxuICAgIGlmICh0cmFuc2FjdGlvbiAmJiBzaWduZWRUcmFuc2FjdGlvbikgdmFsaWRhdGlvbklzc3Vlcy5wdXNoKCdPbmx5IHByb3ZpZGUgb25lOiB0cmFuc2FjdGlvbiBPUiBzaWduZWRUcmFuc2FjdGlvbicpXG5cbiAgICAvLyBUT0RPOiBjYWxsIHRoaXMudmFsaWRhdGUoKVxuXG4gICAgLy8gdHJhbnNhY3Rpb24gT1Igc2lnbmVkVHJhbnNhY3Rpb24gLSBjaGVjayBmb3IgdmFsaWQgSlNPTiBvYmplY3RcblxuICAgIGlmICghSGVscGVycy5pc051bGxPckVtcHR5KG1pc3NpbmdGaWVsZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIHBhcmFtZXRlcihzKSBtaXNzaW5nOiAke21pc3NpbmdGaWVsZHMuam9pbignLCAnKX1gKVxuICAgIH1cbiAgICBpZiAoIUhlbHBlcnMuaXNOdWxsT3JFbXB0eSh2YWxpZGF0aW9uSXNzdWVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBwYXJhbWV0ZXIgZXJyb3I6ICR7dmFsaWRhdGlvbklzc3Vlcy5qb2luKCcsICcpfWApXG4gICAgfVxuXG4gICAgdGhpcy5zZXRUcmFuc2FjdGlvbkRhdGEoY3JlYXRlVHJhbnNhY3Rpb25EYXRhKVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRUcmFuc2FjdGlvbkRhdGEoY3JlYXRlVHJhbnNhY3Rpb25EYXRhOiBDcmVhdGVUcmFuc2FjdGlvbkRhdGEpIHtcbiAgICAvLyBhY2NvdW50IHBhcmFtIGlzIHNldCB0byBsb2dnZWQtaW4gdXNlclxuICAgIHRoaXMuX2RhdGEgPSB7XG4gICAgICBhY2NvdW50OiB0aGlzLl91c2VyLmFjY291bnROYW1lLFxuICAgICAgLi4uY3JlYXRlVHJhbnNhY3Rpb25EYXRhLFxuICAgIH1cbiAgICAvLyBzZXQgZW5jb2RlZCB0cmFuc2FjdGlvbiBwcm9wZXJ0aWVzXG4gICAgaWYgKGNyZWF0ZVRyYW5zYWN0aW9uRGF0YT8udHJhbnNhY3Rpb24pXG4gICAgICB0aGlzLl9kYXRhLmVuY29kZWRUcmFuc2FjdGlvbiA9IEhlbHBlcnMuYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGNyZWF0ZVRyYW5zYWN0aW9uRGF0YS50cmFuc2FjdGlvbikpXG4gICAgaWYgKGNyZWF0ZVRyYW5zYWN0aW9uRGF0YT8uc2lnbmVkVHJhbnNhY3Rpb24pXG4gICAgICB0aGlzLl9kYXRhLmVuY29kZWRTaWduZWRUcmFuc2FjdGlvbiA9IEhlbHBlcnMuYmFzZTY0RW5jb2RlKFxuICAgICAgICBKU09OLnN0cmluZ2lmeShjcmVhdGVUcmFuc2FjdGlvbkRhdGEuc2lnbmVkVHJhbnNhY3Rpb24pLFxuICAgICAgKVxuICB9XG5cbiAgLy8gVE9ETzogQ29uc2lkZXIgcHJvdmlkaW5nIHByb3BlcnR5IHRvIGV4cGxhaW4gdGhhdCBhY2NvdW50L3Blcm1pc3Npb24gaXMgaW4gZXh0ZXJuYWwgd2FsbGV0IHNvIGRldmVsb3BlciBjYW4gZWFzaWx5IGNoZWNrXG4gIC8vIFRPRE86IENvbnNpZGVyIHdlYi13aWRnZXQgYXV0b21hdGljYWxseSBoYW5kbGluZyBwb3AtdXAgb2Ygd2FsbGV0IHdoZW4gc2lnbiBpcyBjYWxsZWRcblxuICAvKiogZW5zdXJlIHRoYXQgdGhlIGNoYWluTmV0d29yayBhbmQgY2hhaW5BY2NvdW50IGZvciB0aGUgdHJhbnNhY3Rpb24gYXJlIGluIHRoZSB1c2VyJ3Mgd2FsbGV0XG4gICAqICBOT1RFOiBUaGlzIGNoZWNrIGlzIG5vdCByZXF1aXJlZCBmb3IgYSB1c2VyIHNpZ25pbmcgd2l0aCBhIHdhbGxldCBhcHAgLSBTaW5jZSB0aGUgYWNjb3VudCBtYXkgYmUgaW4gdGhlIHdhbGxldCBhbmQgbm90IHlldCBhZGRlZCB0byBPcmVJZFxuICAgKi9cbiAgYXNzZXJ0VHJhbnNhY3Rpb25BY2NvdW50VmFsaWRGb3JVc2VyKCkge1xuICAgIGNvbnN0IHsgY2hhaW5BY2NvdW50LCBjaGFpbk5ldHdvcmsgfSA9IHRoaXMuX2RhdGFcbiAgICBjb25zdCB7IGFjY291bnROYW1lIH0gPSB0aGlzLl91c2VyXG5cbiAgICBjb25zdCBjaGFpbkFjY291bnRzSW5XYWxsZXQgPSB0aGlzLl91c2VyPy5kYXRhPy5jaGFpbkFjY291bnRzPy5maW5kKFxuICAgICAgcGVybSA9PiBwZXJtLmNoYWluTmV0d29yayA9PT0gY2hhaW5OZXR3b3JrICYmIHBlcm0uY2hhaW5BY2NvdW50ID09PSBjaGFpbkFjY291bnQsXG4gICAgKVxuXG4gICAgY29uc3QgYWxsUGVybWlzc2lvbnNFeHRlcm5hbCA9IGNoYWluQWNjb3VudHNJbldhbGxldD8ucGVybWlzc2lvbnM/LmV2ZXJ5KHAgPT4gcC5wcml2YXRlS2V5U3RvcmVkRXh0ZXJhbGx5ID09PSB0cnVlKVxuICAgIGNvbnN0IGV4dGVybmFsV2FsbGV0VHlwZSA9IGNoYWluQWNjb3VudHNJbldhbGxldD8ucGVybWlzc2lvbnM/LmZpbmQoXG4gICAgICBwID0+IHAucHJpdmF0ZUtleVN0b3JlZEV4dGVyYWxseSA9PT0gdHJ1ZSxcbiAgICApPy5leHRlcm5hbFdhbGxldFR5cGVcblxuICAgIGlmICghY2hhaW5BY2NvdW50c0luV2FsbGV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW4ndCBmaW5kIGEgY2hhaW5BY2NvdW50OiAke2NoYWluQWNjb3VudH0gZm9yIGNoYWluTmV0d29yazogJHtjaGFpbk5ldHdvcmt9IGluIHVzZXIncyBvcmVJZCBhY2NvdW50OiAke2FjY291bnROYW1lfWAsXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKGFsbFBlcm1pc3Npb25zRXh0ZXJuYWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENoYWluQWNjb3VudDogJHtjaGFpbkFjY291bnR9IGZvciBjaGFpbk5ldHdvcms6ICR7Y2hhaW5OZXR3b3JrfSBhcHBlYXJzIHRvIGJlIGluIGEgd2FsbGV0IGFwcCAodHlwZTogJHtleHRlcm5hbFdhbGxldFR5cGV9KSAtIHVzZSBzaWduV2l0aFdhbGxldCgpIHRvIHNpZ25gLFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IGNoZWNrIHVzZXIuY2hhaW5BY2NvdW50cyB0aGF0XG5cbiAgLyoqIHZhbGlkYXRlcyB0aGF0IHRyYW5zYWN0aW9uIGlzIHdlbGwtZm9ybWVkIGZvciB0aGUgYmxvY2tjYWhpblxuICAgKiBSZXR1cm5zIGFycmF5IG9mIGVycm9yc1xuICAgKi9cbiAgYXN5bmMgdmFsaWRhdGUoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIC8vIFRPRE86IGNhbGwgQVBJIHZhbGlkYXRlVHJhbnNhY3Rpb24gb24gT1JFSUQgU2VydmljZSAtIHRyYW5zYWN0aW9uL3ZhbGlkYXRlIGFwaSBlbmRwb2ludFxuICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJylcbiAgfVxuXG4gIC8vIFRPRE86IGFkZCBkZXByaWNhdGVkXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdXJsIHRvIHJlZGlyZWN0IHRoZSB1c2VyJ3MgYnJvd3NlciB0byAtIHRvIHNpZ24gdHJhbnNhY3Rpb24gdXNpbmcgT1JFSUQgd2ViIGludGVyZmFjZVxuICAgKi9cbiAgYXN5bmMgZ2V0U2lnblVybCgpOiBQcm9taXNlPFNpZ25XaXRoT3JlSWRSZXN1bHQ+IHtcbiAgICB0aGlzLmFzc2VydFRyYW5zYWN0aW9uQWNjb3VudFZhbGlkRm9yVXNlcigpXG4gICAgY29uc3QgdHJhbnNhY3Rpb25EYXRhID0gdGhpcy5kYXRhXG4gICAgY29uc3QgeyBzaWduQ2FsbGJhY2tVcmwgfSA9IHRoaXMuX29yZUlkQ29udGV4dC5vcHRpb25zXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgaWYgKCF0cmFuc2FjdGlvbkRhdGE/LnNpZ25PcHRpb25zKSB0cmFuc2FjdGlvbkRhdGEuc2lnbk9wdGlvbnMgPSB7fVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHRyYW5zYWN0aW9uRGF0YS5zaWduT3B0aW9ucy5jYWxsYmFja1VybCA9IHNpZ25DYWxsYmFja1VybFxuICAgIGNvbnN0IHNpZ25VcmwgPSBhd2FpdCBnZXRPcmVJZFNpZ25VcmwodGhpcy5fb3JlSWRDb250ZXh0LCB0cmFuc2FjdGlvbkRhdGEpXG4gICAgcmV0dXJuIHsgc2lnblVybCwgZXJyb3JzOiBudWxsIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwcm92aWRlZCB0cmFuc2FjdGlvbiAob3Igc2lnbmVkVHJhbnNhY3Rpb24pIGNhbiBiZSBhdXRvU2lnbmVkIHZpYSBhcGkgKHdpdGhvdXQgdXNlciBpbnRlcmFjdGlvbilcbiAgICogUmVxdWlyZXMgYW4gYXBpS2V5IHdpdGggdGhlIGF1dG9TaWduIHJpZ2h0XG4gICAqIFJldHVybnM6IHRydWUgaWYgdHJhbnNhY3Rpb24gY2FuIGJlIHNpZ25lZCB1c2luZyB0YW5zYWN0aW9uLnNpZ24oKVxuICAgKiAqL1xuICBhc3luYyBjaGVja0NhbkF1dG9TaWduKCkge1xuICAgIGxldCBhdXRvU2lnbkNyZWRlbnRpYWxzRXhpc3Q6IGJvb2xlYW5cbiAgICB0cnkge1xuICAgICAgYXNzZXJ0SGFzQXBpS2V5KHRoaXMuX29yZUlkQ29udGV4dCwgQXBpS2V5VXNlZEZvci5BdXRvU2lnbmluZywgJycpXG4gICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgaWYgd2UgZG9uJ3QgaGF2ZSBhbiBhcGkga2V5IHdpdGggdGhlIHJpZ2h0IHJpZ2h0c1xuICAgICAgOyh7IGF1dG9TaWduQ3JlZGVudGlhbHNFeGlzdCB9ID0gYXdhaXQgY2FsbEFwaUNhbkF1dG9zaWduVHJhbnNhY3Rpb24odGhpcy5fb3JlSWRDb250ZXh0LCB0aGlzLl9kYXRhKSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlIC8vIGNhbid0IGF1dG8tc2lnblxuICAgIH1cbiAgICByZXR1cm4gYXV0b1NpZ25DcmVkZW50aWFsc0V4aXN0XG4gIH1cblxuICAvKiogQXR0ZW1wdCB0byBzaWduIGEgdHJhbnNhY3Rpb24gd2l0aG91dCB1c2VyIGludGVyYWN0aW9uXG4gICAqICBFeHBlY3RzIHVzZXIgdG8gaGF2ZSBwcmV2aW91c2x5IGFwcHJvdmVkIGF1dG9TaWduIGZvciB0cmFuc2FjdGlvbiB0eXBlIGFuZCBpdCBoYXNuJ3QgZXhwaXJlZFxuICAgKiAgQ2FsbCBjYWxsQXBpQ2FuQXV0b3NpZ25UcmFuc2FjdGlvbigpIGZpcnN0IHRvIGNvbmZpcm0gdGhhdCB0aGlzIHRyYW5zYWN0aW9uIGNhbiBiZSBhdXRvU2lnbmVkIGJlZm9yZSBhdHRlbXB0aW5nIHRoaXMgY2FsbFxuICAgKi9cbiAgYXN5bmMgYXV0b1NpZ24oKSB7XG4gICAgdGhpcy5hc3NlcnRUcmFuc2FjdGlvbkFjY291bnRWYWxpZEZvclVzZXIoKVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHRoaXMuZGF0YVxuICAgIGNvbnN0IHsgcHJvY2Vzc0lkLCBzaWduZWRUcmFuc2FjdGlvbiwgdHJhbnNhY3Rpb25JZCwgZXJyb3JDb2RlLCBlcnJvck1lc3NhZ2UgfSA9IGF3YWl0IGNhbGxBcGlTaWduVHJhbnNhY3Rpb24oXG4gICAgICB0aGlzLl9vcmVJZENvbnRleHQsXG4gICAgICB7IHRyYW5zYWN0aW9uRGF0YSwgYXV0b1NpZ246IHRydWUgfSxcbiAgICApXG5cbiAgICBpZiAoZXJyb3JDb2RlIHx8IGVycm9yTWVzc2FnZSkgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSlcbiAgICByZXR1cm4geyBwcm9jZXNzSWQsIHNpZ25lZFRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbklkIH1cbiAgfVxuXG4gIC8qKiBTaWduIGEgdHJhbnNhY3Rpb24gd2l0aG91dCB1c2VyIGludGVyYWN0aW9uXG4gICAqICBSZXF1aXJlcyBhIHVzZXIncyB3YWxsZXQgcGFzc3dvcmQgb3IgZW5jcnlwdGVkIHBhc3N3b3JkIChhICdjdXN0b2RpYWwnIGFjY291bnQgbWFuYWdlZCBieSB5b3UpXG4gICAqICBSZXF1aXJlcyBhbiBhcGlLZXkgd2l0aCB0aGUgcHJveHlTaWduIHJpZ2h0XG4gICAqL1xuICBhc3luYyBzaWduV2l0aFBhc3N3b3JkKHVzZXJQYXNzd29yZD86IHN0cmluZywgdXNlclBhc3N3b3JkRW5jcnlwdGVkPzogc3RyaW5nKSB7XG4gICAgdGhpcy5hc3NlcnRUcmFuc2FjdGlvbkFjY291bnRWYWxpZEZvclVzZXIoKVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHRoaXMuZGF0YVxuICAgIGlmICghdHJhbnNhY3Rpb25EYXRhPy5zaWduT3B0aW9ucykgdHJhbnNhY3Rpb25EYXRhLnNpZ25PcHRpb25zID0ge31cbiAgICBpZiAodXNlclBhc3N3b3JkKSB0cmFuc2FjdGlvbkRhdGEuc2lnbk9wdGlvbnMudXNlclBhc3N3b3JkID0gdXNlclBhc3N3b3JkXG4gICAgaWYgKHVzZXJQYXNzd29yZEVuY3J5cHRlZCkgdHJhbnNhY3Rpb25EYXRhLnNpZ25PcHRpb25zLnVzZXJQYXNzd29yZEVuY3J5cHRlZCA9IHVzZXJQYXNzd29yZEVuY3J5cHRlZFxuXG4gICAgaWYgKHRyYW5zYWN0aW9uRGF0YS5zaWduT3B0aW9ucy51c2VyUGFzc3dvcmQgJiYgdHJhbnNhY3Rpb25EYXRhLnNpZ25PcHRpb25zLnVzZXJQYXNzd29yZEVuY3J5cHRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlIGVpdGhlciBhIHVzZXJQYXNzd29yZCBPUiB1c2VyUGFzc3dvcmRFbmNyeXB0ZWQgcGFyYW0uIEJvdGggd2VyZSBwcm92aWRlZC4nKVxuICAgIH1cblxuICAgIGNvbnN0IHsgcHJvY2Vzc0lkLCBzaWduZWRUcmFuc2FjdGlvbiwgdHJhbnNhY3Rpb25JZCwgZXJyb3JDb2RlLCBlcnJvck1lc3NhZ2UgfSA9XG4gICAgICBhd2FpdCBjYWxsQXBpQ3VzdG9kaWFsU2lnblRyYW5zYWN0aW9uKHRoaXMuX29yZUlkQ29udGV4dCwgeyB0cmFuc2FjdGlvbkRhdGEsIGF1dG9TaWduOiBmYWxzZSB9KVxuICAgIGlmIChlcnJvckNvZGUgfHwgZXJyb3JNZXNzYWdlKSB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKVxuICAgIHJldHVybiB7IHByb2Nlc3NJZCwgc2lnbmVkVHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uSWQgfVxuICB9XG5cbiAgLyoqIFNpZ24gd2l0aCBhIHN1cHBvcnRlZCBibG9ja2NoYWluIHdhbGxldCB2aWEgVHJhbnNpdCBwcm92aWRlciAqL1xuICBhc3luYyBzaWduV2l0aFdhbGxldCh3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUpOiBQcm9taXNlPHtcbiAgICBzaWduZWRUcmFuc2FjdGlvbjogU2lnbmF0dXJlUHJvdmlkZXJTaWduUmVzdWx0XG4gIH0+IHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkRhdGEgPSB0aGlzLmRhdGFcbiAgICBjb25zdCBzaWduUmVzdWx0ID0gYXdhaXQgdGhpcy5fb3JlSWRDb250ZXh0LndhbGxldEhlbHBlci5zaWduV2l0aFdhbGxldCh3YWxsZXRUeXBlLCB0cmFuc2FjdGlvbkRhdGEpXG4gICAgcmV0dXJuIHNpZ25SZXN1bHRcbiAgfVxufVxuIiwiaW1wb3J0IEhtYWNTSEEyNTYgZnJvbSAnY3J5cHRvLWpzL2htYWMtc2hhMjU2J1xuaW1wb3J0IEF4aW9zIGZyb20gJ2F4aW9zJ1xuaW1wb3J0IEhlbHBlcnMgZnJvbSAnLi9oZWxwZXJzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVIbWFjKHNlY3JldDogc3RyaW5nLCBkYXRhOiBzdHJpbmcpIHtcbiAgY29uc3QgaG1hYyA9IEhtYWNTSEEyNTYoZGF0YSwgc2VjcmV0KVxuICByZXR1cm4gaG1hYy50b1N0cmluZygpXG59XG5cbi8qKiBHZW5lcmF0ZSBITUFDIGZvciBkYXRhIHN0cmluZ1xuICogIGRhdGEgcGFyYW0gY2FuIGJlIHN0cmluZ2lmaWVkIG9iamVjdFxuICogIElmIGFwaUtleSBpcyBub3QgcHJvdmlkZWQsIGV4cGVjdHMgdXNlUHJveHlTZXJ2ZXI6dHJ1ZSBhbmQgYSBwcm94eSBzZXJ2ZXIgdG8gYmUgYXZhaWxhYmxlIHRvIGdlbmVyYXRlIHRoZSBobWFjXG4gKiAgRXhwZWN0cyBwcm94eXNlcnZlciAvb3JlaWQvaG1hYyB0byBob3N0IGFuIGVuZHBvaW50IHRvIHNpZ24gd2l0aCB0aGUgYXBpS2V5IGFuZCByZXR1cm4gdGhlIGhtYWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlSG1hY1dpdGhBcGlLZXlPclByb3h5U2VydmVyKHVzZVByb3h5U2VydmVyOiBib29sZWFuLCBhcGlLZXk6IHN0cmluZywgZGF0YTogc3RyaW5nKSB7XG4gIGlmICghdXNlUHJveHlTZXJ2ZXIgJiYgSGVscGVycy5pc051bGxPckVtcHR5KGFwaUtleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbnQgZ2VuZXJhdGUgaG1hYy4gYXBpS2V5IG1pc3Npbmcgb3IgZW1wdHkgLSBpdHMgcmVxdWlyZWQgaWYgbm90IHVzaW5nIGEgcHJveHkgc2VydmVyJylcbiAgfVxuXG4gIGxldCBobWFjOiBzdHJpbmdcbiAgaWYgKHVzZVByb3h5U2VydmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGdldCBhbiBobWFjIGZyb20gdGhlIHByb3h5IHNlcnZlciBlbmRwb2ludCAoc2luY2UgaXQgaGFzIHRoZSBzZWNyZXQgYXBpS2V5KVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBBeGlvcy5wb3N0KCcvb3JlaWQvaG1hYycsIEpTT04uc3RyaW5naWZ5KHsgZGF0YSB9KSwge1xuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgIH0pXG4gICAgICBobWFjID0gcmVzcG9uc2U/LmRhdGE/LmhtYWNcbiAgICB9IGNhdGNoIChuZXR3b3JrRXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5nZXRFcnJvckZyb21BeGlvc0Vycm9yKG5ldHdvcmtFcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhtYWMgPSBnZW5lcmF0ZUhtYWMoYXBpS2V5LCBkYXRhKVxuICB9XG4gIHJldHVybiBobWFjXG59XG5cbi8qKiBHZW5lcmF0ZSBITUFDIGZvciB1cmwgc3RyaW5nIGFuZCBhcHBlbmQgaXQgdG8gZW5kIG9yIHVybCBlLmcuIGh0dHA6L25ubm5ubiZobWFjPXh4eCAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFwcGVuZEhtYWNUb1VybCh1c2VQcm94eVNlcnZlcjogYm9vbGVhbiwgYXBpS2V5OiBzdHJpbmcsIHVybDogc3RyaW5nKSB7XG4gIGlmIChIZWxwZXJzLmlzTnVsbE9yRW1wdHkodXJsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FudCBnZW5lcmF0ZSBobWFjLiB1cmwgbWlzc2luZyBvciBlbXB0eScpXG4gIH1cblxuICBjb25zdCBobWFjID0gYXdhaXQgZ2VuZXJhdGVIbWFjV2l0aEFwaUtleU9yUHJveHlTZXJ2ZXIodXNlUHJveHlTZXJ2ZXIsIGFwaUtleSwgdXJsKVxuXG4gIGNvbnN0IHVybEVuY29kZWRIbWFjID0gZW5jb2RlVVJJQ29tcG9uZW50KGhtYWMpXG4gIC8vIGNvcnJlY3QgaG1hYyBhbHJlYWR5IGluIHBsYWNlXG4gIGlmICh1cmwuaW5jbHVkZXMoYCZobWFjPSR7dXJsRW5jb2RlZEhtYWN9YCkpIHtcbiAgICByZXR1cm4gdXJsXG4gIH1cbiAgcmV0dXJuIGAke3VybH0maG1hYz0ke3VybEVuY29kZWRIbWFjfWBcbn1cbiIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9zaGEyNTZcIiksIHJlcXVpcmUoXCIuL2htYWNcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vc2hhMjU2XCIsIFwiLi9obWFjXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlMuSG1hY1NIQTI1NjtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRyb290LkNyeXB0b0pTID0gZmFjdG9yeSgpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuXHQvKmdsb2JhbHMgd2luZG93LCBnbG9iYWwsIHJlcXVpcmUqL1xuXG5cdC8qKlxuXHQgKiBDcnlwdG9KUyBjb3JlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHR2YXIgQ3J5cHRvSlMgPSBDcnlwdG9KUyB8fCAoZnVuY3Rpb24gKE1hdGgsIHVuZGVmaW5lZCkge1xuXG5cdCAgICB2YXIgY3J5cHRvO1xuXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGZyb20gd2luZG93IChCcm93c2VyKVxuXHQgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSB3aW5kb3cuY3J5cHRvO1xuXHQgICAgfVxuXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGluIHdlYiB3b3JrZXIgKEJyb3dzZXIpXG5cdCAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuY3J5cHRvKSB7XG5cdCAgICAgICAgY3J5cHRvID0gc2VsZi5jcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gZnJvbSB3b3JrZXJcblx0ICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5jcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSBnbG9iYWxUaGlzLmNyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIChleHBlcmltZW50YWwgSUUgMTEpIGNyeXB0byBmcm9tIHdpbmRvdyAoQnJvd3Nlcilcblx0ICAgIGlmICghY3J5cHRvICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5tc0NyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IHdpbmRvdy5tc0NyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBmcm9tIGdsb2JhbCAoTm9kZUpTKVxuXHQgICAgaWYgKCFjcnlwdG8gJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmNyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IGdsb2JhbC5jcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gaW1wb3J0IHZpYSByZXF1aXJlIChOb2RlSlMpXG5cdCAgICBpZiAoIWNyeXB0byAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgIH1cblxuXHQgICAgLypcblx0ICAgICAqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvclxuXHQgICAgICpcblx0ICAgICAqIEFzIE1hdGgucmFuZG9tKCkgaXMgY3J5cHRvZ3JhcGhpY2FsbHkgbm90IHNhZmUgdG8gdXNlXG5cdCAgICAgKi9cblx0ICAgIHZhciBjcnlwdG9TZWN1cmVSYW5kb21JbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKGNyeXB0bykge1xuXHQgICAgICAgICAgICAvLyBVc2UgZ2V0UmFuZG9tVmFsdWVzIG1ldGhvZCAoQnJvd3Nlcilcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgxKSlbMF07XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBVc2UgcmFuZG9tQnl0ZXMgbWV0aG9kIChOb2RlSlMpXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoNCkucmVhZEludDMyTEUoKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignTmF0aXZlIGNyeXB0byBtb2R1bGUgY291bGQgbm90IGJlIHVzZWQgdG8gZ2V0IHNlY3VyZSByYW5kb20gbnVtYmVyLicpO1xuXHQgICAgfTtcblxuXHQgICAgLypcblx0ICAgICAqIExvY2FsIHBvbHlmaWxsIG9mIE9iamVjdC5jcmVhdGVcblxuXHQgICAgICovXG5cdCAgICB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxuXG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgICAgdmFyIHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBvYmo7XG5cblx0ICAgICAgICAgICAgc3VidHlwZSA9IG5ldyBGKCk7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBudWxsO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgIH07XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIENyeXB0b0pTIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMaWJyYXJ5IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbGliID0gQy5saWIgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlIG9iamVjdCBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlID0gKGZ1bmN0aW9uICgpIHtcblxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyBQcm9wZXJ0aWVzIHRvIGNvcHkgaW50byB0aGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZScsXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNwYXduXG5cdCAgICAgICAgICAgICAgICB2YXIgc3VidHlwZSA9IGNyZWF0ZSh0aGlzKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gQXVnbWVudFxuXHQgICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUubWl4SW4ob3ZlcnJpZGVzKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgaW5pdGlhbGl6ZXJcblx0ICAgICAgICAgICAgICAgIGlmICghc3VidHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5pdCcpIHx8IHRoaXMuaW5pdCA9PT0gc3VidHlwZS5pbml0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZXIncyBwcm90b3R5cGUgaXMgdGhlIHN1YnR5cGUgb2JqZWN0XG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQucHJvdG90eXBlID0gc3VidHlwZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlIHN1cGVydHlwZVxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogRXh0ZW5kcyB0aGlzIG9iamVjdCBhbmQgcnVucyB0aGUgaW5pdCBtZXRob2QuXG5cdCAgICAgICAgICAgICAqIEFyZ3VtZW50cyB0byBjcmVhdGUoKSB3aWxsIGJlIHBhc3NlZCB0byBpbml0KCkuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBpbnN0YW5jZSA9IE15VHlwZS5jcmVhdGUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5leHRlbmQoKTtcblx0ICAgICAgICAgICAgICAgIGluc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG9iamVjdC5cblx0ICAgICAgICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIHNvbWUgbG9naWMgd2hlbiB5b3VyIG9iamVjdHMgYXJlIGNyZWF0ZWQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgICAgIC8vIC4uLlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBpbnRvIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBUaGUgcHJvcGVydGllcyB0byBtaXggaW4uXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBNeVR5cGUubWl4SW4oe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnXG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIG1peEluOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIElFIHdvbid0IGNvcHkgdG9TdHJpbmcgdXNpbmcgdGhlIGxvb3AgYWJvdmVcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmluZyA9IHByb3BlcnRpZXMudG9TdHJpbmc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGluc3RhbmNlLmNsb25lKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgKi9cblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddLCA2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XG5cdCAgICAgICAgICAgIHdvcmRzID0gdGhpcy53b3JkcyA9IHdvcmRzIHx8IFtdO1xuXG5cdCAgICAgICAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgd29yZCBhcnJheSB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciAoT3B0aW9uYWwpIFRoZSBlbmNvZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IENyeXB0b0pTLmVuYy5IZXhcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGVuY29kZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChlbmNvZGVyIHx8IEhleCkuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25jYXRlbmF0ZXMgYSB3b3JkIGFycmF5IHRvIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0V29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGlzU2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHRoaXMuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb25jYXRcblx0ICAgICAgICAgICAgaWYgKHRoaXNTaWdCeXRlcyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXRCeXRlID0gKHRoYXRXb3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gfD0gdGhhdEJ5dGUgPDwgKDI0IC0gKCh0aGlzU2lnQnl0ZXMgKyBpKSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSB3b3JkIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGF0U2lnQnl0ZXM7IGogKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaikgPj4+IDJdID0gdGhhdFdvcmRzW2ogPj4+IDJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgKz0gdGhhdFNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVtb3ZlcyBpbnNpZ25pZmljYW50IGJpdHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsYW1wOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wXG5cdCAgICAgICAgICAgIHdvcmRzW3NpZ0J5dGVzID4+PiAyXSAmPSAweGZmZmZmZmZmIDw8ICgzMiAtIChzaWdCeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIHdvcmRzLmxlbmd0aCA9IE1hdGguY2VpbChzaWdCeXRlcyAvIDQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gd29yZEFycmF5LmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgd29yZCBhcnJheSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmFuZG9tOiBmdW5jdGlvbiAobkJ5dGVzKSB7XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkJ5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY3J5cHRvU2VjdXJlUmFuZG9tSW50KCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbkJ5dGVzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBFbmNvZGVyIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBIZXggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGhleENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhleENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGhleFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChoZXhTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhleFN0ckxlbmd0aCA9IGhleFN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZXhTdHJMZW5ndGg7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8ICgyNCAtIChpICUgOCkgKiA0KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGhleFN0ckxlbmd0aCAvIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGF0aW4xIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgTGF0aW4xID0gQ19lbmMuTGF0aW4xID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGxhdGluMVN0cmluZyA9IENyeXB0b0pTLmVuYy5MYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbGF0aW4xQ2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgTGF0aW4xIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0aW4xU3RyIFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5MYXRpbjEucGFyc2UobGF0aW4xU3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGxhdGluMVN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xU3RyTGVuZ3RoID0gbGF0aW4xU3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSAobGF0aW4xU3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBsYXRpbjFTdHJMZW5ndGgpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmOCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmOFN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFVURi04IGRhdGEnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi04IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmOFN0ciBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKHV0ZjhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmOFN0cikge1xuXHQgICAgICAgICAgICByZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYnVmZmVyZWQgYmxvY2sgYWxnb3JpdGhtIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIFRoZSBwcm9wZXJ0eSBibG9ja1NpemUgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9taW5CdWZmZXJTaXplIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIGtlcHQgdW5wcm9jZXNzZWQgaW4gdGhlIGJ1ZmZlci4gRGVmYXVsdDogMFxuXHQgICAgICovXG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgZGF0YSBidWZmZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLl9kYXRhID0gbmV3IFdvcmRBcnJheS5pbml0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgPSAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIG5ldyBkYXRhIHRvIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgYnVmZmVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGFwcGVuZC4gU3RyaW5ncyBhcmUgY29udmVydGVkIHRvIGEgV29yZEFycmF5IHVzaW5nIFVURi04LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2FwcGVuZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSBVdGY4LnBhcnNlKGRhdGEpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEuY29uY2F0KGRhdGEpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFByb2Nlc3NlcyBhdmFpbGFibGUgZGF0YSBibG9ja3MuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIF9kb1Byb2Nlc3NCbG9jayhvZmZzZXQpLCB3aGljaCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9GbHVzaCBXaGV0aGVyIGFsbCBibG9ja3MgYW5kIHBhcnRpYWwgYmxvY2tzIHNob3VsZCBiZSBwcm9jZXNzZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwcm9jZXNzZWQgZGF0YS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wcm9jZXNzOiBmdW5jdGlvbiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkV29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcblx0ICAgICAgICAgICAgaWYgKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGguY2VpbChuQmxvY2tzUmVhZHkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXG5cdCAgICAgICAgICAgICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb3VudCB3b3JkcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYnl0ZXMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CeXRlc1JlYWR5ID0gTWF0aC5taW4obldvcmRzUmVhZHkgKiA0LCBkYXRhU2lnQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXG5cdCAgICAgICAgICAgIGlmIChuV29yZHNSZWFkeSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICAgICAgcHJvY2Vzc2VkV29yZHMgPSBkYXRhV29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcblx0ICAgICAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQocHJvY2Vzc2VkV29yZHMsIG5CeXRlc1JlYWR5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWluQnVmZmVyU2l6ZTogMFxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgaGFzaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBoYXNoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDE2ICg1MTIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaGVyID0gQ3J5cHRvSlMuYWxnby5TSEEyNTYuY3JlYXRlKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBoYXNoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SGFzaGVyfSBUaGlzIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaGFzaFxuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBtZXNzYWdlIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogNTEyLzMyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGEgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIFNIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGNmZykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBoYXNoZXIuaW5pdChjZmcpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEhtYWNTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSG1hY0hlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbGdvcml0aG0gbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvID0ge307XG5cblx0ICAgIHJldHVybiBDO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpOyIsIi8qIChpZ25vcmVkKSAqLyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gSW5pdGlhbGl6YXRpb24gYW5kIHJvdW5kIGNvbnN0YW50cyB0YWJsZXNcblx0ICAgIHZhciBIID0gW107XG5cdCAgICB2YXIgSyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGNvbnN0YW50c1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBpc1ByaW1lKG4pIHtcblx0ICAgICAgICAgICAgdmFyIHNxcnROID0gTWF0aC5zcXJ0KG4pO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBmYWN0b3IgPSAyOyBmYWN0b3IgPD0gc3FydE47IGZhY3RvcisrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIShuICUgZmFjdG9yKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEZyYWN0aW9uYWxCaXRzKG4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgobiAtIChuIHwgMCkpICogMHgxMDAwMDAwMDApIHwgMDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgbiA9IDI7XG5cdCAgICAgICAgdmFyIG5QcmltZSA9IDA7XG5cdCAgICAgICAgd2hpbGUgKG5QcmltZSA8IDY0KSB7XG5cdCAgICAgICAgICAgIGlmIChpc1ByaW1lKG4pKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoblByaW1lIDwgOCkge1xuXHQgICAgICAgICAgICAgICAgICAgIEhbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAyKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBLW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMykpO1xuXG5cdCAgICAgICAgICAgICAgICBuUHJpbWUrKztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG4rKztcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3Rcblx0ICAgIHZhciBXID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTI1NiBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTI1NiA9IENfYWxnby5TSEEyNTYgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KEguc2xpY2UoMCkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuXHQgICAgICAgICAgICB2YXIgZiA9IEhbNV07XG5cdCAgICAgICAgICAgIHZhciBnID0gSFs2XTtcblx0ICAgICAgICAgICAgdmFyIGggPSBIWzddO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMHggPSBXW2kgLSAxNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMCAgPSAoKGdhbW1hMHggPDwgMjUpIHwgKGdhbW1hMHggPj4+IDcpKSAgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChnYW1tYTB4IDw8IDE0KSB8IChnYW1tYTB4ID4+PiAxOCkpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2FtbWEweCA+Pj4gMyk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExeCA9IFdbaSAtIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTEgID0gKChnYW1tYTF4IDw8IDE1KSB8IChnYW1tYTF4ID4+PiAxNykpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZ2FtbWExeCA8PCAxMykgfCAoZ2FtbWExeCA+Pj4gMTkpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMXggPj4+IDEwKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIGNoICA9IChlICYgZikgXiAofmUgJiBnKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYWogPSAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTAgPSAoKGEgPDwgMzApIHwgKGEgPj4+IDIpKSBeICgoYSA8PCAxOSkgfCAoYSA+Pj4gMTMpKSBeICgoYSA8PCAxMCkgfCAoYSA+Pj4gMjIpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTEgPSAoKGUgPDwgMjYpIHwgKGUgPj4+IDYpKSBeICgoZSA8PCAyMSkgfCAoZSA+Pj4gMTEpKSBeICgoZSA8PCA3KSAgfCAoZSA+Pj4gMjUpKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tpXSArIFdbaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgdDIgPSBzaWdtYTAgKyBtYWo7XG5cblx0ICAgICAgICAgICAgICAgIGggPSBnO1xuXHQgICAgICAgICAgICAgICAgZyA9IGY7XG5cdCAgICAgICAgICAgICAgICBmID0gZTtcblx0ICAgICAgICAgICAgICAgIGUgPSAoZCArIHQxKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBkID0gYztcblx0ICAgICAgICAgICAgICAgIGMgPSBiO1xuXHQgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICBhID0gKHQxICsgdDIpIHwgMDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuXHQgICAgICAgICAgICBIWzVdID0gKEhbNV0gKyBmKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNl0gPSAoSFs2XSArIGcpIHwgMDtcblx0ICAgICAgICAgICAgSFs3XSA9IChIWzddICsgaCkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTI1Nih3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTI1NiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTI1Nik7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMjU2KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTI1NiA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEEyNTYpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEEyNTY7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBITUFDIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEhNQUMgPSBDX2FsZ28uSE1BQyA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgSE1BQy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWNIYXNoZXIgPSBDcnlwdG9KUy5hbGdvLkhNQUMuY3JlYXRlKENyeXB0b0pTLmFsZ28uU0hBMjU2LCBrZXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChoYXNoZXIsIGtleSkge1xuXHQgICAgICAgICAgICAvLyBJbml0IGhhc2hlclxuXHQgICAgICAgICAgICBoYXNoZXIgPSB0aGlzLl9oYXNoZXIgPSBuZXcgaGFzaGVyLmluaXQoKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSBVdGY4LnBhcnNlKGtleSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZSA9IGhhc2hlci5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXJCbG9ja1NpemVCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQWxsb3cgYXJiaXRyYXJ5IGxlbmd0aCBrZXlzXG5cdCAgICAgICAgICAgIGlmIChrZXkuc2lnQnl0ZXMgPiBoYXNoZXJCbG9ja1NpemVCeXRlcykge1xuXHQgICAgICAgICAgICAgICAga2V5ID0gaGFzaGVyLmZpbmFsaXplKGtleSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICBrZXkuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDbG9uZSBrZXkgZm9yIGlubmVyIGFuZCBvdXRlciBwYWRzXG5cdCAgICAgICAgICAgIHZhciBvS2V5ID0gdGhpcy5fb0tleSA9IGtleS5jbG9uZSgpO1xuXHQgICAgICAgICAgICB2YXIgaUtleSA9IHRoaXMuX2lLZXkgPSBrZXkuY2xvbmUoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIG9LZXlXb3JkcyA9IG9LZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBpS2V5V29yZHMgPSBpS2V5LndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFhPUiBrZXlzIHdpdGggcGFkIGNvbnN0YW50c1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhc2hlckJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBvS2V5V29yZHNbaV0gXj0gMHg1YzVjNWM1Yztcblx0ICAgICAgICAgICAgICAgIGlLZXlXb3Jkc1tpXSBePSAweDM2MzYzNjM2O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9LZXkuc2lnQnl0ZXMgPSBpS2V5LnNpZ0J5dGVzID0gaGFzaGVyQmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgSE1BQyB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cblx0ICAgICAgICAgICAgLy8gUmVzZXRcblx0ICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgIGhhc2hlci51cGRhdGUodGhpcy5faUtleSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBITUFDIHdpdGggYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0hNQUN9IFRoaXMgSE1BQyBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci51cGRhdGUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2hlci51cGRhdGUobWVzc2FnZVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIEhNQUMgY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gdGhpcy5faGFzaGVyO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgSE1BQ1xuXHQgICAgICAgICAgICB2YXIgaW5uZXJIYXNoID0gaGFzaGVyLmZpbmFsaXplKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgdmFyIGhtYWMgPSBoYXNoZXIuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChpbm5lckhhc2gpKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gaG1hYztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fSgpKTtcblxuXG59KSk7IiwiaW1wb3J0IHsgVXNlclNvdXJjZURhdGEgfSBmcm9tICcuLi91c2VyL21vZGVscydcbmltcG9ydCBJU3RvcmFnZSBmcm9tICcuLi9jb3JlL0lTdG9yYWdlJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhbFN0YXRlIHtcbiAgY29uc3RydWN0b3IoYXBwSWQ6IHN0cmluZywgc3RvcmFnZTogSVN0b3JhZ2UpIHtcbiAgICB0aGlzLmFwcElkID0gYXBwSWRcbiAgICB0aGlzLmNhY2hlZGFjY2Vzc1Rva2VuID0gbnVsbFxuICAgIHRoaXMuY2FjaGVkVXNlciA9IG51bGxcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlXG4gIH1cblxuICBhcHBJZDogc3RyaW5nXG5cbiAgY2FjaGVkYWNjZXNzVG9rZW46IHN0cmluZ1xuXG4gIGNhY2hlZFVzZXI6IFVzZXJTb3VyY2VEYXRhXG5cbiAgc3RvcmFnZTogSVN0b3JhZ2VcblxuICBhY2Nlc3NUb2tlbktleSgpIHtcbiAgICByZXR1cm4gYG9yZWlkLiR7dGhpcy5hcHBJZH0uYWNjZXNzVG9rZW5gXG4gIH1cblxuICBnZXQgYWNjZXNzVG9rZW4oKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuY2FjaGVkYWNjZXNzVG9rZW4pIHRoaXMubG9hZEFjY2Vzc1Rva2VuKClcbiAgICByZXR1cm4gdGhpcy5jYWNoZWRhY2Nlc3NUb2tlblxuICB9XG5cbiAgbG9hZEFjY2Vzc1Rva2VuKCkge1xuICAgIHRoaXMuY2FjaGVkYWNjZXNzVG9rZW4gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmFjY2Vzc1Rva2VuS2V5KCkpXG4gIH1cblxuICBzYXZlQWNjZXNzVG9rZW4oYWNjZXNzVG9rZW46IHN0cmluZykge1xuICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgdGhpcy5jYWNoZWRhY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuXG4gICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLmFjY2Vzc1Rva2VuS2V5KCksIGFjY2Vzc1Rva2VuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyQWNjZXNzVG9rZW4oKVxuICAgIH1cbiAgfVxuXG4gIGNsZWFyQWNjZXNzVG9rZW4oKSB7XG4gICAgdGhpcy5jYWNoZWRhY2Nlc3NUb2tlbiA9IG51bGxcbiAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmFjY2Vzc1Rva2VuS2V5KCkpXG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLmNsZWFyQWNjZXNzVG9rZW4oKVxuICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXG4vKlxuXG5IYW5kbGVzIHN0b3JhZ2UgdG8gbG9jYWwgc3RvcmFnZSwgb3IgY29va2llcywgd2hhdGV2ZXIgaXMgYXZhaWxhYmxlIHRvIHRoZSBjbGllbnRcblxuTW9zdGx5IGNvcGllZCBvcmlnaW5hbGx5IGNvcGllZCBmcm9tIEF1dGgwLmpzIGJ1dCBtb2RpZmVkIHRvIHVzZSBhIGNsYXNzXG5odHRwczovL2dpdGh1Yi5jb20vYXV0aDAvYXV0aDAuanMvdHJlZS9tYXN0ZXIvc3JjL2hlbHBlci9zdG9yYWdlXG5cbiovXG5cbmltcG9ydCAqIGFzIENvb2tpZSBmcm9tICdqcy1jb29raWUnXG5pbXBvcnQgeyBKU09OT2JqZWN0IH0gZnJvbSAnLi4vbW9kZWxzJ1xuaW1wb3J0IElTdG9yYWdlIGZyb20gJy4uL2NvcmUvSVN0b3JhZ2UnXG5pbXBvcnQgSGVscGVycyBmcm9tICcuL2hlbHBlcnMnXG5cbmNsYXNzIENvb2tpZVN0b3JhZ2UgaW1wbGVtZW50cyBJU3RvcmFnZSB7XG4gIGdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBDb29raWUuZ2V0KGtleSlcbiAgfVxuXG4gIHJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcpIHtcbiAgICBDb29raWUucmVtb3ZlKGtleSlcbiAgfVxuXG4gIHNldEl0ZW0oa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCBvYmplY3QsIG9wdGlvbnM/OiBDb29raWUuQ29va2llQXR0cmlidXRlcyk6IHN0cmluZyB7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgZXhwaXJlczogMSwgLy8gMSBkYXlcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfVxuICAgIHJldHVybiBDb29raWUuc2V0KGtleSwgdmFsdWUsIHBhcmFtcylcbiAgfVxufVxuXG5jbGFzcyBMb2NhbFN0b3JhZ2UgaW1wbGVtZW50cyBJU3RvcmFnZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgIC8vIHNvbWUgYnJvd3NlcnMgdGhyb3cgYW4gZXJyb3Igd2hlbiB0cnlpbmcgdG8gYWNjZXNzIGxvY2FsU3RvcmFnZVxuICAgICAgLy8gd2hlbiBsb2NhbFN0b3JhZ2UgaXMgZGlzYWJsZWQuXG4gICAgICB0aGlzLnN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlXG4gICAgfSBlbHNlIHtcbiAgICAgIEhlbHBlcnMubG9nKCdOb3QgcnVubmluZyBpbiBCcm93c2VyLiBVc2luZyBDb29raWVTdG9yYWdlIGluc3RlYWQuJylcbiAgICB9XG4gIH1cblxuICBzdG9yYWdlOiBTdG9yYWdlXG5cbiAgZ2V0SXRlbShrZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuc3RvcmFnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSlcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5zdG9yYWdlKSB7XG4gICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG4gICAgfVxuICB9XG5cbiAgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZywgb3B0aW9ucz86IGFueSkge1xuICAgIGlmICh0aGlzLnN0b3JhZ2UpIHtcbiAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8qKiBkb2VzIG5vdCBzdG9yZSBvciByZXRyaWV2ZSBhbnkgdmFsdWVzIC0gYWxsb3dzICdkaXNhYmxpbmcnIG9mIHN0b3JhZ2UgKi9cbmV4cG9ydCBjbGFzcyBEdW1teVN0b3JhZ2UgaW1wbGVtZW50cyBJU3RvcmFnZSB7XG4gIGdldEl0ZW0oa2V5OiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZW1vdmVJdGVtKGtleTogYW55KSB7XG4gICAgLy8gZW1wdHlcbiAgfVxuXG4gIHNldEl0ZW0oa2V5OiBhbnksIHZhbHVlOiBhbnksIG9wdGlvbnM/OiBhbnkpIHtcbiAgICAvLyBlbXB0eVxuICB9XG59XG5cbi8qKiBzdG9yZXMgaXRlbXMgaW4gbWVtb3J5IC0gZG9lcyBub3QgcGVyc2lzdCBhY3Jvc3MgaW5zdGFuY2VzICovXG5leHBvcnQgY2xhc3MgTWVtb3J5U3RvcmFnZSBpbXBsZW1lbnRzIElTdG9yYWdlIHtcbiAgbWVtb3J5Q2FjaGU6IEpTT05PYmplY3QgPSB7fVxuXG4gIGdldEl0ZW0oa2V5OiBhbnkpOiBhbnkge1xuICAgIGlmIChrZXkgaW4gdGhpcy5tZW1vcnlDYWNoZSkgcmV0dXJuIHRoaXMubWVtb3J5Q2FjaGVba2V5XVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZW1vdmVJdGVtKGtleTogYW55KTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmdldEl0ZW0oa2V5KSkgcmV0dXJuXG4gICAgZGVsZXRlIHRoaXMubWVtb3J5Q2FjaGVba2V5XVxuICB9XG5cbiAgc2V0SXRlbShrZXk6IGFueSwgdmFsdWU6IGFueSwgb3B0aW9ucz86IGFueSkge1xuICAgIHRoaXMubWVtb3J5Q2FjaGVba2V5XSA9IHZhbHVlXG4gIH1cbn1cblxuY2xhc3MgU3RvcmFnZUhhbmRsZXIgaW1wbGVtZW50cyBJU3RvcmFnZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7IHRyeUxvY2FsU3RvcmFnZUZpcnN0OiB0cnVlIH0pIHtcbiAgICB0aGlzLnRyaWVkTG9jYWxTdG9yYWdlID0gZmFsc2VcbiAgICB0aGlzLnRyaWVkQ29va2llU3RvcmFnZSA9IGZhbHNlXG5cbiAgICBpZiAob3B0aW9ucy50cnlMb2NhbFN0b3JhZ2VGaXJzdCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy50cmllZExvY2FsU3RvcmFnZSA9IHRydWVcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gZGVzaWduZWQgdG8gd29yayBvbiBicm93c2VyIG9yIHNlcnZlciwgc28gd2luZG93IG1pZ2h0IG5vdCBleGlzdFxuICAgICAgICBjb25zdCBsb2NhbFN0b3JhZ2UgPSBuZXcgTG9jYWxTdG9yYWdlKClcblxuICAgICAgICBpZiAobG9jYWxTdG9yYWdlICYmIGxvY2FsU3RvcmFnZS5zdG9yYWdlKSB7XG4gICAgICAgICAgdGhpcy5zdG9yYWdlID0gbG9jYWxTdG9yYWdlXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgSGVscGVycy5sb2coJ0NhbnQgdXNlIGxvY2FsU3RvcmFnZS4gVXNpbmcgQ29va2llU3RvcmFnZSBpbnN0ZWFkLicsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0b3JhZ2UpIHtcbiAgICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBDb29raWVTdG9yYWdlKClcbiAgICAgIHRoaXMudHJpZWRDb29raWVTdG9yYWdlID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHN0b3JhZ2U6IExvY2FsU3RvcmFnZSB8IENvb2tpZVN0b3JhZ2UgfCBEdW1teVN0b3JhZ2UgfCBJU3RvcmFnZVxuXG4gIHRyaWVkTG9jYWxTdG9yYWdlOiBib29sZWFuXG5cbiAgdHJpZWRDb29raWVTdG9yYWdlOiBib29sZWFuXG5cbiAgZmFpbG92ZXIoKSB7XG4gICAgaWYgKHRoaXMuc3RvcmFnZSBpbnN0YW5jZW9mIER1bW15U3RvcmFnZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGRpZFNldCA9IGZhbHNlXG5cbiAgICBpZiAodGhpcy5zdG9yYWdlIGluc3RhbmNlb2YgTG9jYWxTdG9yYWdlKSB7XG4gICAgICBpZiAoIXRoaXMudHJpZWRDb29raWVTdG9yYWdlKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBDb29raWVTdG9yYWdlKClcbiAgICAgICAgdGhpcy50cmllZENvb2tpZVN0b3JhZ2UgPSB0cnVlXG4gICAgICAgIGRpZFNldCA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RvcmFnZSBpbnN0YW5jZW9mIENvb2tpZVN0b3JhZ2UpIHtcbiAgICAgIGlmICghdGhpcy50cmllZExvY2FsU3RvcmFnZSkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgTG9jYWxTdG9yYWdlKClcbiAgICAgICAgdGhpcy50cmllZExvY2FsU3RvcmFnZSA9IHRydWVcbiAgICAgICAgZGlkU2V0ID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZGlkU2V0KSB7XG4gICAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgRHVtbXlTdG9yYWdlKClcbiAgICB9XG4gIH1cblxuICBnZXRJdGVtKGtleTogc3RyaW5nKTogYW55IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBIZWxwZXJzLmxvZygnQ2FudCBnZXRJdGVtIGluIHN0b3JhZ2UuJywgZSlcbiAgICAgIHRoaXMuZmFpbG92ZXIoKVxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSlcbiAgICB9XG4gIH1cblxuICByZW1vdmVJdGVtKGtleTogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcbiAgICAgIHJldHVyblxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIEhlbHBlcnMubG9nKCdDYW50IHJlbW92ZUl0ZW0gaW4gc3RvcmFnZS4nLCBlKVxuICAgICAgdGhpcy5mYWlsb3ZlcigpXG4gICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG4gICAgfVxuICB9XG5cbiAgc2V0SXRlbShrZXk6IGFueSwgdmFsdWU6IHN0cmluZyB8IG9iamVjdCwgb3B0aW9ucz86IGFueSk6IHN0cmluZyB8IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSwgb3B0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBIZWxwZXJzLmxvZygnQ2FudCBzZXRJdGVtIGluIHN0b3JhZ2UuJywgZSlcbiAgICAgIHRoaXMuZmFpbG92ZXIoKVxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUsIG9wdGlvbnMpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0b3JhZ2VIYW5kbGVyXG4iLCIvKiFcbiAqIEphdmFTY3JpcHQgQ29va2llIHYyLjIuMVxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzLWNvb2tpZS9qcy1jb29raWVcbiAqXG4gKiBDb3B5cmlnaHQgMjAwNiwgMjAxNSBLbGF1cyBIYXJ0bCAmIEZhZ25lciBCcmFja1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbjsoZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0dmFyIHJlZ2lzdGVyZWRJbk1vZHVsZUxvYWRlcjtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShmYWN0b3J5KTtcblx0XHRyZWdpc3RlcmVkSW5Nb2R1bGVMb2FkZXIgPSB0cnVlO1xuXHR9XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0XHRyZWdpc3RlcmVkSW5Nb2R1bGVMb2FkZXIgPSB0cnVlO1xuXHR9XG5cdGlmICghcmVnaXN0ZXJlZEluTW9kdWxlTG9hZGVyKSB7XG5cdFx0dmFyIE9sZENvb2tpZXMgPSB3aW5kb3cuQ29va2llcztcblx0XHR2YXIgYXBpID0gd2luZG93LkNvb2tpZXMgPSBmYWN0b3J5KCk7XG5cdFx0YXBpLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR3aW5kb3cuQ29va2llcyA9IE9sZENvb2tpZXM7XG5cdFx0XHRyZXR1cm4gYXBpO1xuXHRcdH07XG5cdH1cbn0oZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBleHRlbmQgKCkge1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgcmVzdWx0ID0ge307XG5cdFx0Zm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzWyBpIF07XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdFx0XHRyZXN1bHRba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAocykge1xuXHRcdHJldHVybiBzLnJlcGxhY2UoLyglWzAtOUEtWl17Mn0pKy9nLCBkZWNvZGVVUklDb21wb25lbnQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdCAoY29udmVydGVyKSB7XG5cdFx0ZnVuY3Rpb24gYXBpKCkge31cblxuXHRcdGZ1bmN0aW9uIHNldCAoa2V5LCB2YWx1ZSwgYXR0cmlidXRlcykge1xuXHRcdFx0aWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRhdHRyaWJ1dGVzID0gZXh0ZW5kKHtcblx0XHRcdFx0cGF0aDogJy8nXG5cdFx0XHR9LCBhcGkuZGVmYXVsdHMsIGF0dHJpYnV0ZXMpO1xuXG5cdFx0XHRpZiAodHlwZW9mIGF0dHJpYnV0ZXMuZXhwaXJlcyA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0YXR0cmlidXRlcy5leHBpcmVzID0gbmV3IERhdGUobmV3IERhdGUoKSAqIDEgKyBhdHRyaWJ1dGVzLmV4cGlyZXMgKiA4NjRlKzUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZSdyZSB1c2luZyBcImV4cGlyZXNcIiBiZWNhdXNlIFwibWF4LWFnZVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUVcblx0XHRcdGF0dHJpYnV0ZXMuZXhwaXJlcyA9IGF0dHJpYnV0ZXMuZXhwaXJlcyA/IGF0dHJpYnV0ZXMuZXhwaXJlcy50b1VUQ1N0cmluZygpIDogJyc7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cdFx0XHRcdGlmICgvXltcXHtcXFtdLy50ZXN0KHJlc3VsdCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge31cblxuXHRcdFx0dmFsdWUgPSBjb252ZXJ0ZXIud3JpdGUgP1xuXHRcdFx0XHRjb252ZXJ0ZXIud3JpdGUodmFsdWUsIGtleSkgOlxuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHZhbHVlKSlcblx0XHRcdFx0XHQucmVwbGFjZSgvJSgyM3wyNHwyNnwyQnwzQXwzQ3wzRXwzRHwyRnwzRnw0MHw1Qnw1RHw1RXw2MHw3Qnw3RHw3QykvZywgZGVjb2RlVVJJQ29tcG9uZW50KTtcblxuXHRcdFx0a2V5ID0gZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhrZXkpKVxuXHRcdFx0XHQucmVwbGFjZSgvJSgyM3wyNHwyNnwyQnw1RXw2MHw3QykvZywgZGVjb2RlVVJJQ29tcG9uZW50KVxuXHRcdFx0XHQucmVwbGFjZSgvW1xcKFxcKV0vZywgZXNjYXBlKTtcblxuXHRcdFx0dmFyIHN0cmluZ2lmaWVkQXR0cmlidXRlcyA9ICcnO1xuXHRcdFx0Zm9yICh2YXIgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGlmICghYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0cmluZ2lmaWVkQXR0cmlidXRlcyArPSAnOyAnICsgYXR0cmlidXRlTmFtZTtcblx0XHRcdFx0aWYgKGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPT09IHRydWUpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENvbnNpZGVycyBSRkMgNjI2NSBzZWN0aW9uIDUuMjpcblx0XHRcdFx0Ly8gLi4uXG5cdFx0XHRcdC8vIDMuICBJZiB0aGUgcmVtYWluaW5nIHVucGFyc2VkLWF0dHJpYnV0ZXMgY29udGFpbnMgYSAleDNCIChcIjtcIilcblx0XHRcdFx0Ly8gICAgIGNoYXJhY3Rlcjpcblx0XHRcdFx0Ly8gQ29uc3VtZSB0aGUgY2hhcmFjdGVycyBvZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcyB1cCB0byxcblx0XHRcdFx0Ly8gbm90IGluY2x1ZGluZywgdGhlIGZpcnN0ICV4M0IgKFwiO1wiKSBjaGFyYWN0ZXIuXG5cdFx0XHRcdC8vIC4uLlxuXHRcdFx0XHRzdHJpbmdpZmllZEF0dHJpYnV0ZXMgKz0gJz0nICsgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXS5zcGxpdCgnOycpWzBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKGRvY3VtZW50LmNvb2tpZSA9IGtleSArICc9JyArIHZhbHVlICsgc3RyaW5naWZpZWRBdHRyaWJ1dGVzKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXQgKGtleSwganNvbikge1xuXHRcdFx0aWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgamFyID0ge307XG5cdFx0XHQvLyBUbyBwcmV2ZW50IHRoZSBmb3IgbG9vcCBpbiB0aGUgZmlyc3QgcGxhY2UgYXNzaWduIGFuIGVtcHR5IGFycmF5XG5cdFx0XHQvLyBpbiBjYXNlIHRoZXJlIGFyZSBubyBjb29raWVzIGF0IGFsbC5cblx0XHRcdHZhciBjb29raWVzID0gZG9jdW1lbnQuY29va2llID8gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7ICcpIDogW107XG5cdFx0XHR2YXIgaSA9IDA7XG5cblx0XHRcdGZvciAoOyBpIDwgY29va2llcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgcGFydHMgPSBjb29raWVzW2ldLnNwbGl0KCc9Jyk7XG5cdFx0XHRcdHZhciBjb29raWUgPSBwYXJ0cy5zbGljZSgxKS5qb2luKCc9Jyk7XG5cblx0XHRcdFx0aWYgKCFqc29uICYmIGNvb2tpZS5jaGFyQXQoMCkgPT09ICdcIicpIHtcblx0XHRcdFx0XHRjb29raWUgPSBjb29raWUuc2xpY2UoMSwgLTEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgbmFtZSA9IGRlY29kZShwYXJ0c1swXSk7XG5cdFx0XHRcdFx0Y29va2llID0gKGNvbnZlcnRlci5yZWFkIHx8IGNvbnZlcnRlcikoY29va2llLCBuYW1lKSB8fFxuXHRcdFx0XHRcdFx0ZGVjb2RlKGNvb2tpZSk7XG5cblx0XHRcdFx0XHRpZiAoanNvbikge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0Y29va2llID0gSlNPTi5wYXJzZShjb29raWUpO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqYXJbbmFtZV0gPSBjb29raWU7XG5cblx0XHRcdFx0XHRpZiAoa2V5ID09PSBuYW1lKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBrZXkgPyBqYXJba2V5XSA6IGphcjtcblx0XHR9XG5cblx0XHRhcGkuc2V0ID0gc2V0O1xuXHRcdGFwaS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRyZXR1cm4gZ2V0KGtleSwgZmFsc2UgLyogcmVhZCBhcyByYXcgKi8pO1xuXHRcdH07XG5cdFx0YXBpLmdldEpTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRyZXR1cm4gZ2V0KGtleSwgdHJ1ZSAvKiByZWFkIGFzIGpzb24gKi8pO1xuXHRcdH07XG5cdFx0YXBpLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXksIGF0dHJpYnV0ZXMpIHtcblx0XHRcdHNldChrZXksICcnLCBleHRlbmQoYXR0cmlidXRlcywge1xuXHRcdFx0XHRleHBpcmVzOiAtMVxuXHRcdFx0fSkpO1xuXHRcdH07XG5cblx0XHRhcGkuZGVmYXVsdHMgPSB7fTtcblxuXHRcdGFwaS53aXRoQ29udmVydGVyID0gaW5pdDtcblxuXHRcdHJldHVybiBhcGk7XG5cdH1cblxuXHRyZXR1cm4gaW5pdChmdW5jdGlvbiAoKSB7fSk7XG59KSk7XG4iLCJpbXBvcnQgeyBjYWxsQXBpR2V0Q29uZmlnIH0gZnJvbSAnLi4vYXBpJ1xuaW1wb3J0IHsgQ2hhaW5OZXR3b3JrLCBDaGFpblBsYXRmb3JtVHlwZSwgQ29uZmlnVHlwZSwgU2V0dGluZ0NoYWluTmV0d29yaywgU2V0dGluZ0NoYWluTmV0d29ya0hvc3QgfSBmcm9tICcuLi9tb2RlbHMnXG5pbXBvcnQgSGVscGVycyBmcm9tICcuLi91dGlscy9oZWxwZXJzJ1xuaW1wb3J0IE9yZUlkQ29udGV4dCBmcm9tICcuL0lPcmVpZENvbnRleHQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNldHRpbmdzIHtcbiAgY29uc3RydWN0b3IoYXJnczogeyBvcmVJZENvbnRleHQ6IE9yZUlkQ29udGV4dCB9KSB7XG4gICAgdGhpcy5fb3JlSWRDb250ZXh0ID0gYXJncy5vcmVJZENvbnRleHRcbiAgICB0aGlzLl9jYWNoZWRDaGFpbk5ldHdvcmtzID0gbnVsbFxuICB9XG5cbiAgcHJpdmF0ZSBfY2FjaGVkQ2hhaW5OZXR3b3JrczogU2V0dGluZ0NoYWluTmV0d29ya1tdID0gW11cblxuICBwcml2YXRlIF9vcmVJZENvbnRleHQ6IE9yZUlkQ29udGV4dFxuXG4gIC8qKiBDYWxscyBnZXRDb25maWdGcm9tQXBpKCkgdG8gcmV0cmlldmUgc2V0dGluZ3MgZm9yIGFsbCBjaGFpbiBuZXR3b3JrcyBkZWZpbmVkIGJ5IE9yZUlEIHNlcnZpY2VcbiAgICogYW5kIGNhY2hlcyB0aGUgcmVzdWx0ICovXG4gIGFzeW5jIGdldEFsbENoYWluTmV0d29ya1NldHRpbmdzKCk6IFByb21pc2U8U2V0dGluZ0NoYWluTmV0d29ya1tdPiB7XG4gICAgaWYgKEhlbHBlcnMuaXNOdWxsT3JFbXB0eSh0aGlzLl9jYWNoZWRDaGFpbk5ldHdvcmtzKSkge1xuICAgICAgLy8gbG9hZCB0aGUgY2hhaW5OZXR3b3JrcyBsaXN0IGZyb20gdGhlIE9SRSBJRCBBUElcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmdldENvbmZpZ0Zyb21BcGkoQ29uZmlnVHlwZS5DaGFpbnMpXG4gICAgICB0aGlzLl9jYWNoZWRDaGFpbk5ldHdvcmtzID0gcmVzdWx0cy5jaGFpbnMgLy8gYXMgU2V0dGluZ0NoYWluTmV0d29ya1tdXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZENoYWluTmV0d29ya3NcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIENoYWluIE5ldHdvcmsgU2V0dGluZ3MgZm9yIGEgc3BlY2lmaWMgY2hhaW4gKi9cbiAgYXN5bmMgZ2V0Q2hhaW5OZXR3b3JrU2V0dGluZ3MoY2hhaW5OZXR3b3JrOiBDaGFpbk5ldHdvcmspIHtcbiAgICBjb25zdCBuZXR3b3JrcyA9IGF3YWl0IHRoaXMuZ2V0QWxsQ2hhaW5OZXR3b3JrU2V0dGluZ3MoKVxuICAgIHJldHVybiBuZXR3b3Jrcy5maW5kKG4gPT4gbi5uZXR3b3JrID09PSBjaGFpbk5ldHdvcmspXG4gIH1cblxuICAvKiogTG9hZHMgc2V0dGluZ3MgdmFsdWUgZnJvbSB0aGUgc2VydmVyXG4gICAgZS5nLiBjb25maWdUeXBlPSdjaGFpbnMnIHJldHVybnMgdmFsaWQgY2hhaW4gdHlwZXMgYW5kIGFkZHJlc3NlcyAqL1xuICBhc3luYyBnZXRDb25maWcoY29uZmlnVHlwZTogQ29uZmlnVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmdldENvbmZpZ0Zyb21BcGkoY29uZmlnVHlwZSlcbiAgfVxuXG4gIC8qKlxuICAgKiAgQ2FsbCBhcGkgc2VydmljZXMvY29uZmlnIHRvIGdldCBjb25maWd1cmF0aW9uIHZhbHVlcyBvZiBhIHNwZWNpZmljIHR5cGVcbiAgICogIFJldHVybnM6IGZvciBjb25maWdUeXBlOkNvbmZpZy5DaGFpbnMsIHJldHVybnMgYXJyYXkgb2YgU2V0dGluZ0NoYWluTmV0d29yayBvYmplY3RzIGZvciBhbGwgY2hhaW5zIHN1cG9ydGVkIGJ5IHRoZSBzZXJ2aWNlXG4gICAqICovXG4gIGFzeW5jIGdldENvbmZpZ0Zyb21BcGkoY29uZmlnVHlwZTogQ29uZmlnVHlwZS5DaGFpbnMpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBhd2FpdCBjYWxsQXBpR2V0Q29uZmlnKHRoaXMuX29yZUlkQ29udGV4dCwgeyBjb25maWdUeXBlIH0pXG4gICAgaWYgKEhlbHBlcnMuaXNOdWxsT3JFbXB0eSh2YWx1ZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhYmxlIHRvIHJldHJpZXZlIGNvbmZpZyB2YWx1ZXMgZm9yICR7Y29uZmlnVHlwZX1gKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzXG4gIH1cblxuICAvKiogUmV0dXJucyBuZXR3b3JrIGNvbmZpZyAodXJsLCBwb3J0LCBldGMuKSBmb3Igc3BlY2lmaWVkIGNoYWluTmV0d29yayAqL1xuICBhc3luYyBnZXRDaGFpbk5ldHdvcmtOZXh0d29ya0NvbmZpZyhjaGFpbk5ldHdvcms6IENoYWluTmV0d29yayk6IFByb21pc2U8U2V0dGluZ0NoYWluTmV0d29ya0hvc3Q+IHtcbiAgICBjb25zdCBuZXR3b3JrU2V0dGluZ3MgPSBhd2FpdCB0aGlzLmdldENoYWluTmV0d29ya1NldHRpbmdzKGNoYWluTmV0d29yaylcbiAgICBpZiAoIW5ldHdvcmtTZXR0aW5ncykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYWluIG5ldHdvcms6ICR7Y2hhaW5OZXR3b3JrfS5gKVxuICAgIH1cbiAgICBjb25zdCB7IGNoYWluSWQsIGhvc3QsIHBvcnQsIHByb3RvY29sIH0gPSBuZXR3b3JrU2V0dGluZ3M/Lmhvc3RzWzBdIHx8IHt9IC8vIHVzaW5nIGZpcnN0IGhvc3RcbiAgICByZXR1cm4geyBob3N0LCBwb3J0LCBwcm90b2NvbCwgY2hhaW5JZCB9XG4gIH1cblxuICAvKiogUmV0dXJuIENoYWluTmV0d29yayB0aGF0IG1hdGNoZXMgY2hhaW5JZCAoYXMgZGVmaW5lZCBpbiBPcmVJZCBDaGFpbiBOZXR3b3JrIFNldHRpbmdzKSAqL1xuICBhc3luYyBnZXRDaGFpbk5ldHdvcmtCeUNoYWluSWQoY2hhaW5JZDogc3RyaW5nKSB7XG4gICAgY29uc3QgbmV0d29ya3MgPSBhd2FpdCB0aGlzLmdldEFsbENoYWluTmV0d29ya1NldHRpbmdzKClcbiAgICBjb25zdCBjaGFpblNldHRpbmdzID0gbmV0d29ya3MuZmluZChuID0+IG4uaG9zdHMuZmluZChoID0+IGguY2hhaW5JZCA9PT0gY2hhaW5JZCkpXG5cbiAgICBpZiAoIUhlbHBlcnMuaXNOdWxsT3JFbXB0eShjaGFpblNldHRpbmdzKSkge1xuICAgICAgcmV0dXJuIGNoYWluU2V0dGluZ3MubmV0d29ya1xuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiBuZXR3b3JrIGlzIE5PVCBhbiBFT1Mgc2lzdGVyY2hhaW4gKi9cbiAgYXN5bmMgaXNOb3RFb3NOZXR3b3JrKGNoYWluTmV0d29yazogQ2hhaW5OZXR3b3JrKSB7XG4gICAgY29uc3QgbmV0d29ya1NldHRpbmcgPSBhd2FpdCB0aGlzLl9vcmVJZENvbnRleHQuc2V0dGluZ3MuZ2V0Q2hhaW5OZXR3b3JrU2V0dGluZ3MoY2hhaW5OZXR3b3JrKVxuICAgIHJldHVybiAhKG5ldHdvcmtTZXR0aW5nLnR5cGUgPT09IENoYWluUGxhdGZvcm1UeXBlLmVvcyB8fCBuZXR3b3JrU2V0dGluZy50eXBlID09PSBDaGFpblBsYXRmb3JtVHlwZS5vcmUpXG4gIH1cbn1cbiIsImltcG9ydCB7IGdldFVhbFByb3ZpZGVyQXR0cmlidXRlcywgc3VwcG9ydGVkVUFMUHJvdmlkZXJzLCB1YWxQcm92aWRlckF0dHJpYnV0ZXNEYXRhIH0gZnJvbSAnLi4vdWFsL3VhbFByb3ZpZGVycydcbmltcG9ydCB7IGdldFRyYW5zaXRQcm92aWRlckF0dHJpYnV0ZXMsIHRyYW5zaXRQcm92aWRlckF0dHJpYnV0ZXNEYXRhIH0gZnJvbSAnLi4vdHJhbnNpdCdcbmltcG9ydCB7IGV4dGVybmFsV2FsbGV0c05vdEltcGxlbWVudGVkIH0gZnJvbSAnLi4vY29uc3RhbnRzJ1xuaW1wb3J0IE9yZUlkQ29udGV4dCBmcm9tICcuLi9jb3JlL0lPcmVpZENvbnRleHQnXG5pbXBvcnQgSGVscGVycyBmcm9tICcuLi91dGlscy9oZWxwZXJzJ1xuaW1wb3J0IHtcbiAgQXV0aFByb3ZpZGVyLFxuICBDaGFpbk5ldHdvcmssXG4gIENoYWluUGxhdGZvcm1UeXBlLFxuICBFeHRlcm5hbFdhbGxldFR5cGUsXG4gIExvZ2luV2l0aFdhbGxldE9wdGlvbnMsXG4gIFNpZ25hdHVyZVByb3ZpZGVyU2lnblJlc3VsdCxcbiAgU2lnblN0cmluZ1BhcmFtcyxcbiAgU2lnblN0cmluZ1Jlc3VsdCxcbiAgVHJhbnNhY3Rpb25EYXRhLFxufSBmcm9tICcuLi9tb2RlbHMnXG5pbXBvcnQgVHJhbnNpdEhlbHBlciBmcm9tICcuLi90cmFuc2l0L1RyYW5zaXRIZWxwZXInXG5pbXBvcnQgVWFsSGVscGVyIGZyb20gJy4uL3VhbC9VYWxIZWxwZXInXG5pbXBvcnQgeyBFeHRlcm5hbFdhbGxldEludGVyZmFjZSwgV2FsbGV0UHJvdmlkZXJBdHRyaWJ1dGVzIH0gZnJvbSAnLi9tb2RlbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhbGxldEhlbHBlciB7XG4gIGNvbnN0cnVjdG9yKGFyZ3M6IHsgb3JlSWRDb250ZXh0OiBPcmVJZENvbnRleHQ7IHRyYW5zaXRIZWxwZXI6IFRyYW5zaXRIZWxwZXI7IHVhbEhlbHBlcjogVWFsSGVscGVyIH0pIHtcbiAgICB0aGlzLl9vcmVJZENvbnRleHQgPSBhcmdzLm9yZUlkQ29udGV4dFxuICAgIHRoaXMuX3RyYW5zaXRIZWxwZXIgPSBhcmdzLnRyYW5zaXRIZWxwZXJcbiAgICB0aGlzLl91YWxIZWxwZXIgPSBhcmdzLnVhbEhlbHBlclxuICB9XG5cbiAgX29yZUlkQ29udGV4dDogT3JlSWRDb250ZXh0XG5cbiAgX3RyYW5zaXRIZWxwZXI6IFRyYW5zaXRIZWxwZXJcblxuICBfdWFsSGVscGVyOiBVYWxIZWxwZXJcblxuICAvKiogVHJhbnNpdCB3YWxsZXQgcGx1Z2luIGhlbHBlciBmdW5jdGlvbnMgYW5kIGNvbm5lY3Rpb25zICovXG4gIGdldCB0cmFuc2l0SGVscGVyKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2l0SGVscGVyXG4gIH1cblxuICAvKiogVWFsIHdhbGxldCBwbHVnaW4gaGVscGVyIGZ1bmN0aW9ucyBhbmQgY29ubmVjdGlvbnMgKi9cbiAgZ2V0IHVhbEhlbHBlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdWFsSGVscGVyXG4gIH1cblxuICAvLyoqIFdoZXRoZXIgd2FsbGV0IHR5cGUgaXMgYSBUcmFuc2l0IG9yIFVhbCB3YWxsZXQgKi9cbiAgaXNBVmFsaWRFeHRlcm5hbFdhbGxldFR5cGUod2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICh0aGlzLl90cmFuc2l0SGVscGVyLmlzVHJhbnNpdFByb3ZpZGVyKHdhbGxldFR5cGUpIHx8IHRoaXMuX3VhbEhlbHBlci5pc1VhbFByb3ZpZGVyKHdhbGxldFR5cGUpKSAmJlxuICAgICAgIWV4dGVybmFsV2FsbGV0c05vdEltcGxlbWVudGVkLmluY2x1ZGVzKHdhbGxldFR5cGUpXG4gICAgKVxuICB9XG5cbiAgLyoqIFJldHVybnMgbWV0YWRhdGEgYWJvdXQgdGhlIGluc3RhbGxlZCBleHRlcm5hbCB3YWxsZXQgdHlwZSAoZS5nLiBuYW1lLCBsb2dvKSBhbmQgd2hpY2ggZmVhdHVyZXMgaXQgc3VwcG9ydHNcbiAgICogIElmIG9wdGlvbmFsIGV4dGVybmFsV2FsbGV0SW50ZXJmYWNlIHBhcmFtIHByb3ZpZGVkLCB0aGVuIGdldHMgSW5mbyBmb3IgdGhlIHNwZWNpZmllZCB0eXBlIChUcmFuc2l0IG9yIFVBTCkgaW5zdGVhZCBvZiBzZWVpbmcgd2hhdCdzIGluc3RhbGxlZFxuICAgKi9cbiAgZ2V0RXh0ZXJuYWxXYWxsZXRJbmZvKFxuICAgIHdhbGxldFR5cGU6IEV4dGVybmFsV2FsbGV0VHlwZSxcbiAgICBleHRlcm5hbFdhbGxldEludGVyZmFjZT86IEV4dGVybmFsV2FsbGV0SW50ZXJmYWNlLFxuICApOiBXYWxsZXRQcm92aWRlckF0dHJpYnV0ZXMge1xuICAgIGlmICghdGhpcy5pc0FWYWxpZEV4dGVybmFsV2FsbGV0VHlwZSh3YWxsZXRUeXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgYSB2YWxpZCBleHRlcm5hbCB3YWxsZXQgdHlwZTogJHt3YWxsZXRUeXBlfWApXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHRoaXMuX3RyYW5zaXRIZWxwZXIuaGFzVHJhbnNpdFByb3ZpZGVyKHdhbGxldFR5cGUpIHx8XG4gICAgICBleHRlcm5hbFdhbGxldEludGVyZmFjZSA9PT0gRXh0ZXJuYWxXYWxsZXRJbnRlcmZhY2UuVHJhbnNpdFxuICAgICkge1xuICAgICAgcmV0dXJuIGdldFRyYW5zaXRQcm92aWRlckF0dHJpYnV0ZXMod2FsbGV0VHlwZSlcbiAgICB9XG4gICAgaWYgKHRoaXMuX3VhbEhlbHBlci5oYXNVYWxQcm92aWRlcih3YWxsZXRUeXBlKSB8fCBleHRlcm5hbFdhbGxldEludGVyZmFjZSA9PT0gRXh0ZXJuYWxXYWxsZXRJbnRlcmZhY2UuVWFsKSB7XG4gICAgICByZXR1cm4gZ2V0VWFsUHJvdmlkZXJBdHRyaWJ1dGVzKHdhbGxldFR5cGUpXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKiogUmV0dXJucyB3YWxsZXQgbWV0YWRhdGEgKGZvciBpbnN0YWxsZWQgd2FsbGV0IHByb3ZpZGVycykgZm9yIGEgZ2l2ZW4gY2hhaW4gKi9cbiAgZ2V0RXh0ZXJuYWxXYWxsZXRJbmZvQnlDaGFpbihjaGFpbjogQ2hhaW5QbGF0Zm9ybVR5cGUpOiBXYWxsZXRQcm92aWRlckF0dHJpYnV0ZXNbXSB7XG4gICAgY29uc3QgdHJhbnNpdFdhbGxldHNJbnN0YWxsZWRJbmZvID0gdHJhbnNpdFByb3ZpZGVyQXR0cmlidXRlc0RhdGEuZmlsdGVyKGluZm8gPT5cbiAgICAgIHRoaXMuX29yZUlkQ29udGV4dC50cmFuc2l0UHJvdmlkZXJzSW5zdGFsbGVkLmluY2x1ZGVzKGluZm8ucHJvdmlkZXJOYW1lKSxcbiAgICApXG4gICAgY29uc3QgdWFsV2FsbGV0c0luc3RhbGxlZEluZm8gPSB1YWxQcm92aWRlckF0dHJpYnV0ZXNEYXRhLmZpbHRlcihpbmZvID0+XG4gICAgICB0aGlzLl9vcmVJZENvbnRleHQudWFsUHJvdmlkZXJzSW5zdGFsbGVkLmluY2x1ZGVzKGluZm8ucHJvdmlkZXJOYW1lKSxcbiAgICApXG5cbiAgICByZXR1cm4gWy4uLnRyYW5zaXRXYWxsZXRzSW5zdGFsbGVkSW5mbywgLi4udWFsV2FsbGV0c0luc3RhbGxlZEluZm9dLmZpbHRlcihwID0+IHAuY2hhaW5UeXBlID09PSBjaGFpbilcbiAgfVxuXG4gIC8qKiBDb25uZWN0IHRvIHRoZSB3YWxsZXQgcHJvdmlkZXJcbiAgICogIEZvciBzb21lIHdhbGxldCB0eXBlcywgdGhpcyB3aWxsIGluY2x1ZGUgYW4gdW5sb2NrIGFuZCAnbG9naW4nIGZsb3cgdG8gc2VsZWN0IGEgY2hhaW4gYWNjb3VudFxuICAgKiAgSWYgYSBjaGFpbkFjY291bnQgaXMgc2VsZWN0ZWQsIGl0IGFuZCBpdCdzIGFzc29jaWF0ZWQgcHVibGljS2V5IChpZiBhdmFpbGFibGUpIHdpbGwgYmUgc2F2ZWQgdG8gdGhlIHVzZXIncyBPcmVJZCB3YWxsZXQgYXMgYW4gJ2V4dGVybmFsIGtleScgKi9cbiAgYXN5bmMgY29ubmVjdFRvV2FsbGV0UHJvdmlkZXIobG9naW5PcHRpb25zOiBMb2dpbldpdGhXYWxsZXRPcHRpb25zKSB7XG4gICAgY29uc3QgeyB3YWxsZXRUeXBlIH0gPSBsb2dpbk9wdGlvbnNcbiAgICBpZiAoIXRoaXMuaXNBVmFsaWRFeHRlcm5hbFdhbGxldFR5cGUod2FsbGV0VHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgdmFsaWQgZXh0ZXJuYWwgd2FsbGV0IHR5cGU6ICR7d2FsbGV0VHlwZX1gKVxuICAgIH1cbiAgICBpZiAodGhpcy5fdHJhbnNpdEhlbHBlci5oYXNUcmFuc2l0UHJvdmlkZXIod2FsbGV0VHlwZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0SGVscGVyLmxvZ2luV2l0aFRyYW5zaXRQcm92aWRlcihsb2dpbk9wdGlvbnMpXG4gICAgfSBlbHNlIGlmICh0aGlzLl91YWxIZWxwZXIuaGFzVWFsUHJvdmlkZXIod2FsbGV0VHlwZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl91YWxIZWxwZXIubG9naW5XaXRoVWFsUHJvdmlkZXIobG9naW5PcHRpb25zKVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFdhbGxldCB0eXBlICR7d2FsbGV0VHlwZX0gaW52YWxpZCBvciBub3QgaW5zdGFsbGVkYClcbiAgfVxuXG4gIC8qKiBTaWduIHdpdGggYSBzdXBwb3J0ZWQgYmxvY2tjaGFpbiB3YWxsZXQgdmlhIFRyYW5zaXQgcHJvdmlkZXIgKi9cbiAgYXN5bmMgc2lnbldpdGhXYWxsZXQoXG4gICAgd2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlLFxuICAgIHRyYW5zYWN0aW9uRGF0YTogVHJhbnNhY3Rpb25EYXRhLFxuICApOiBQcm9taXNlPHsgc2lnbmVkVHJhbnNhY3Rpb246IFNpZ25hdHVyZVByb3ZpZGVyU2lnblJlc3VsdCB9PiB7XG4gICAgbGV0IHNpZ25SZXN1bHQ6IHsgc2lnbmVkVHJhbnNhY3Rpb246IFNpZ25hdHVyZVByb3ZpZGVyU2lnblJlc3VsdCB9XG4gICAgaWYgKCF0aGlzLl9vcmVJZENvbnRleHQud2FsbGV0SGVscGVyLmlzQVZhbGlkRXh0ZXJuYWxXYWxsZXRUeXBlKHdhbGxldFR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHNpZ25XaXRoV2FsbGV0IG5vdCBzdXBwb3J0ZWQgZm9yIGV4dGVybmFsIHdhbGxldCB0eXBlOiAke3dhbGxldFR5cGV9YClcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZXIgPSBIZWxwZXJzLnRvRW51bVZhbHVlKEF1dGhQcm92aWRlciwgd2FsbGV0VHlwZSlcblxuICAgIGlmICh0aGlzLl90cmFuc2l0SGVscGVyLmhhc1RyYW5zaXRQcm92aWRlcih3YWxsZXRUeXBlKSkge1xuICAgICAgLy8gVHJlYXQgYXMgVHJhbnNpdCBpbnRlcmZhY2VcbiAgICAgIHNpZ25SZXN1bHQgPSBhd2FpdCB0aGlzLl90cmFuc2l0SGVscGVyLnNpZ25XaXRoVHJhbnNpdFByb3ZpZGVyKHRyYW5zYWN0aW9uRGF0YSwgd2FsbGV0VHlwZSlcbiAgICAgIC8vIElmIHdlJ3ZlIHNpZ25lZCBhIHRyYW5zYWN0aW9uIHdpdGggYSBrZXkgaW4gYSB3YWxsZXQsIGNhbGxEaXNjb3ZlckFmdGVyU2lnbigpIHdpbGwgYWRkIGl0IHRvIHRoZSB1c2VyJ3Mgd2FsbGV0XG4gICAgICBjb25zdCB7IGFjY291bnQsIGNoYWluTmV0d29yayB9ID0gdHJhbnNhY3Rpb25EYXRhXG4gICAgICBhd2FpdCB0aGlzLl90cmFuc2l0SGVscGVyLmNhbGxEaXNjb3ZlckFmdGVyU2lnbih7IGFjY291bnQsIGNoYWluTmV0d29yaywgc2lnbk9wdGlvbnM6IHsgcHJvdmlkZXIgfSB9KVxuICAgIH0gZWxzZSBpZiAodGhpcy5fdWFsSGVscGVyLmhhc1VhbFByb3ZpZGVyKHdhbGxldFR5cGUpKSB7XG4gICAgICAvLyBUcmVhdCBhcyBVQUwgaW50ZXJmYWNlXG4gICAgICBzaWduUmVzdWx0ID0gYXdhaXQgdGhpcy5fdWFsSGVscGVyLnNpZ25XaXRoVWFsUHJvdmlkZXIodHJhbnNhY3Rpb25EYXRhLCB3YWxsZXRUeXBlKVxuICAgICAgLy8gYXdhaXQgdGhpcy51YWxIZWxwZXIuY2FsbERpc2NvdmVyQWZ0ZXJTaWduKHsgYWNjb3VudCwgY2hhaW5OZXR3b3JrLCBzaWduT3B0aW9uczogeyBwcm92aWRlciB9IH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHNpZ25SZXN1bHRcbiAgfVxuXG4gIC8qKiBTaWduIGFuIGFyYml0cmFyeSBzdHJpbmcgKGluc3RlYWQgb2YgYSB0cmFuc2FjdGlvbilcbiAgICogVGhpcyBvbmx5IHN1cHBvcnRzIFRyYW5zaXQgYW5kIFVhbCB3YWxsZXRzXG4gICAqL1xuICBhc3luYyBzaWduU3RyaW5nV2l0aFdhbGxldChwYXJhbXM6IFNpZ25TdHJpbmdQYXJhbXMpOiBQcm9taXNlPFNpZ25TdHJpbmdSZXN1bHQ+IHtcbiAgICBjb25zdCB7IGFjY291bnQsIHdhbGxldFR5cGUsIGNoYWluTmV0d29yayB9ID0gcGFyYW1zXG4gICAgbGV0IHNpZ25SZXN1bHQ6IFNpZ25TdHJpbmdSZXN1bHRcbiAgICBpZiAoIXRoaXMuaXNBVmFsaWRFeHRlcm5hbFdhbGxldFR5cGUod2FsbGV0VHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnblN0cmluZ1dpdGhXYWxsZXQgbm90IHN1cHBvcnRlZCBmb3IgZXh0ZXJuYWwgd2FsbGV0IHR5cGU6ICR7d2FsbGV0VHlwZX1gKVxuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IEhlbHBlcnMudG9FbnVtVmFsdWUoQXV0aFByb3ZpZGVyLCB3YWxsZXRUeXBlKVxuXG4gICAgaWYgKHRoaXMuX3RyYW5zaXRIZWxwZXIuaGFzVHJhbnNpdFByb3ZpZGVyKHdhbGxldFR5cGUpKSB7XG4gICAgICAvLyBUcmVhdCBhcyBUcmFuc2l0IGludGVyZmFjZVxuICAgICAgaWYgKCF0aGlzLl90cmFuc2l0SGVscGVyLmNhblNpZ25TdHJpbmcod2FsbGV0VHlwZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFRoZSB3YWxsZXRUeXBlICR7d2FsbGV0VHlwZX0gZG9lcyBub3Qgc3VwcG9ydCBzaWduU3RyaW5nYClcbiAgICAgIH1cbiAgICAgIHNpZ25SZXN1bHQgPSBhd2FpdCB0aGlzLl90cmFuc2l0SGVscGVyLnNpZ25TdHJpbmdXaXRoVHJhbnNpdFByb3ZpZGVyKHBhcmFtcylcbiAgICAgIGF3YWl0IHRoaXMuX3RyYW5zaXRIZWxwZXIuY2FsbERpc2NvdmVyQWZ0ZXJTaWduKHsgYWNjb3VudCwgY2hhaW5OZXR3b3JrLCBzaWduT3B0aW9uczogeyBwcm92aWRlciB9IH0pXG4gICAgfSBlbHNlIGlmICh0aGlzLl91YWxIZWxwZXIuaGFzVWFsUHJvdmlkZXIod2FsbGV0VHlwZSkpIHtcbiAgICAgIC8vIFRyZWF0IGFzIFVBTCBpbnRlcmZhY2VcbiAgICAgIGlmICghdGhpcy5fdWFsSGVscGVyLmNhblNpZ25TdHJpbmcod2FsbGV0VHlwZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFRoZSB3YWxsZXRUeXBlICR7d2FsbGV0VHlwZX0gZG9lcyBub3Qgc3VwcG9ydCBzaWduU3RyaW5nYClcbiAgICAgIH1cbiAgICAgIHNpZ25SZXN1bHQgPSBhd2FpdCB0aGlzLl91YWxIZWxwZXIuc2lnblN0cmluZ1dpdGhVYWxQcm92aWRlcihwYXJhbXMpXG4gICAgICAvLyBhd2FpdCB0aGlzLnVhbEhlbHBlci5jYWxsRGlzY292ZXJBZnRlclNpZ24oeyBhY2NvdW50LCBjaGFpbk5ldHdvcmssIHNpZ25PcHRpb25zOiB7IHByb3ZpZGVyIH0gfSlcbiAgICB9XG4gICAgcmV0dXJuIHNpZ25SZXN1bHRcbiAgfVxuXG4gIC8qKiBUaHJvdyBpZiB0aGUgcHJvdmlkZXIgZG9lc250IHN1cHBvcnQgdGhlIHNwZWNpZmllZCBjaGFpbk5ldHdvcmsgKi9cbiAgYXN5bmMgYXNzZXJ0V2FsbGV0VHlwZVZhbGlkRm9yQ2hhaW5OZXR3b3JrKFxuICAgIHdhbGxldFR5cGU6IEV4dGVybmFsV2FsbGV0VHlwZSxcbiAgICBjaGFpbk5ldHdvcms6IENoYWluTmV0d29yayxcbiAgICBleHRlcm5hbFdhbGxldEludGVyZmFjZT86IEV4dGVybmFsV2FsbGV0SW50ZXJmYWNlLFxuICApIHtcbiAgICBjb25zdCB7IGNoYWluVHlwZSB9ID0gdGhpcy5nZXRFeHRlcm5hbFdhbGxldEluZm8od2FsbGV0VHlwZSwgZXh0ZXJuYWxXYWxsZXRJbnRlcmZhY2UpXG4gICAgY29uc3QgbmV0d29ya3MgPSBhd2FpdCB0aGlzLl9vcmVJZENvbnRleHQuc2V0dGluZ3MuZ2V0QWxsQ2hhaW5OZXR3b3JrU2V0dGluZ3MoKVxuICAgIGNvbnN0IGlzVmFsaWQgPSAhIW5ldHdvcmtzLmZpbmQobiA9PiBuLm5ldHdvcmsgPT09IGNoYWluTmV0d29yayAmJiBuLnR5cGUgPT09IGNoYWluVHlwZSlcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgRXh0ZXJuYWwgV2FsbGV0IFR5cGU6ICR7d2FsbGV0VHlwZX0gZG9lc250IHN1cHBvcnQgY2hhaW5OZXR3b3JrICR7Y2hhaW5OZXR3b3JrfS4gSGludDogSXQgc3VwcG9ydHMgbmV0d29ya3Mgb2YgdHlwZSAke2NoYWluVHlwZX0uYCxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvLyBTdXBwb3J0ZWQgZmVhdHVyZXMgYnkgd2FsbGV0IHByb3ZpZGVyXG5cbiAgLyoqIHdoZXRoZXIgZGlzY292ZXJ5IGlzIHN1cHBvcnRlZCBieSB0aGUgcHJvdmlkZXIgKi9cbiAgY2FuRGlzY292ZXIod2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlLCBleHRlcm5hbFdhbGxldEludGVyZmFjZT86IEV4dGVybmFsV2FsbGV0SW50ZXJmYWNlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RXh0ZXJuYWxXYWxsZXRJbmZvKHdhbGxldFR5cGUsIGV4dGVybmFsV2FsbGV0SW50ZXJmYWNlKT8uc3VwcG9ydHNEaXNjb3ZlcnkgfHwgZmFsc2VcbiAgfVxuXG4gIC8qKiB3aGV0aGVyIHNpZ25TdHJpbmcgaXMgc3VwcG9ydGVkIGJ5IHRoZSBwcm92aWRlciAqL1xuICBjYW5TaWduU3RyaW5nKHdhbGxldFR5cGU6IEV4dGVybmFsV2FsbGV0VHlwZSwgZXh0ZXJuYWxXYWxsZXRJbnRlcmZhY2U/OiBFeHRlcm5hbFdhbGxldEludGVyZmFjZSkge1xuICAgIHJldHVybiB0aGlzLmdldEV4dGVybmFsV2FsbGV0SW5mbyh3YWxsZXRUeXBlLCBleHRlcm5hbFdhbGxldEludGVyZmFjZSk/LnN1cHBvcnRzU2lnbkFyYml0cmFyeSB8fCBmYWxzZVxuICB9XG5cbiAgLyoqIHdoZXRoZXIgY2FsbCB0byBkaXNjb3ZlciBpcyByZXF1aXJlZCBieSBwcm92aWRlciBiZWZvcmUgbG9naW4gKi9cbiAgcmVxdWlyZXNEaXNjb3ZlclRvTG9naW4od2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlLCBleHRlcm5hbFdhbGxldEludGVyZmFjZT86IEV4dGVybmFsV2FsbGV0SW50ZXJmYWNlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RXh0ZXJuYWxXYWxsZXRJbmZvKHdhbGxldFR5cGUsIGV4dGVybmFsV2FsbGV0SW50ZXJmYWNlKT8ucmVxdWlyZXNEaXNjb3ZlclRvTG9naW4gfHwgZmFsc2VcbiAgfVxuXG4gIC8qKiB3aGV0aGVyIGNhbGwgdG8gbG9nb3V0IHRoZW4gbG9naW4gaXMgcmVxdWlyZWQgYnkgcHJvdmlkZXIgYmVmb3JlIGRpc2NvdmVyICovXG4gIHJlcXVpcmVzTG9nb3V0TG9naW5Ub0Rpc2NvdmVyKHdhbGxldFR5cGU6IEV4dGVybmFsV2FsbGV0VHlwZSwgZXh0ZXJuYWxXYWxsZXRJbnRlcmZhY2U/OiBFeHRlcm5hbFdhbGxldEludGVyZmFjZSkge1xuICAgIHJldHVybiB0aGlzLmdldEV4dGVybmFsV2FsbGV0SW5mbyh3YWxsZXRUeXBlLCBleHRlcm5hbFdhbGxldEludGVyZmFjZSk/LnJlcXVpcmVzTG9nb3V0TG9naW5Ub0Rpc2NvdmVyIHx8IGZhbHNlXG4gIH1cblxuICAvKiogZGVmYXVsdCBwYXRoIGluZGV4IGZvciBwcm92aWRlciAoaWYgYW55KSAqL1xuICBkZWZhdWx0RGlzY292ZXJ5UGF0aEluZGV4TGlzdChcbiAgICB3YWxsZXRUeXBlOiBFeHRlcm5hbFdhbGxldFR5cGUsXG4gICAgZXh0ZXJuYWxXYWxsZXRJbnRlcmZhY2U/OiBFeHRlcm5hbFdhbGxldEludGVyZmFjZSxcbiAgKTogbnVtYmVyW10ge1xuICAgIHJldHVybiB0aGlzLmdldEV4dGVybmFsV2FsbGV0SW5mbyh3YWxsZXRUeXBlLCBleHRlcm5hbFdhbGxldEludGVyZmFjZSk/LmRlZmF1bHREaXNjb3ZlcnlQYXRoSW5kZXhMaXN0IHx8IG51bGxcbiAgfVxuXG4gIC8qKiBoZWxwIHRleHQgZGlzcGxheWVkIHRvIHVzZXIgZm9yIHByb3ZpZGVyICovXG4gIGhlbHBUZXh0Rm9yUHJvdmlkZXIod2FsbGV0VHlwZTogRXh0ZXJuYWxXYWxsZXRUeXBlLCBleHRlcm5hbFdhbGxldEludGVyZmFjZT86IEV4dGVybmFsV2FsbGV0SW50ZXJmYWNlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RXh0ZXJuYWxXYWxsZXRJbmZvKHdhbGxldFR5cGUsIGV4dGVybmFsV2FsbGV0SW50ZXJmYWNlKT8uaGVscFRleHQgfHwgbnVsbFxuICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL21vZGVscydcbmV4cG9ydCAqIGZyb20gJy4vdHJhbnNpdFByb3ZpZGVycydcbiIsImV4cG9ydCAqIGZyb20gJy4vcGx1Z2luJ1xuZXhwb3J0ICogZnJvbSAnLi9tb2RlbHMnXG4iLCIvLyBOT1RFOiBkaXNhYmxpbmcgY3ljbGljYWwgcmVmZXJlbmNlIGVycm9yIGhlcmUgYXMgd2UgbmVlZCB0byByZWZlcmVuY2UgVHJhbnNhY3Rpb24gaW4gUG9wdXBQbHVnaW5TaWduUGFyYW1zIHJlZmVyZW5jZWQgaW4gUG9wdXBQbHVnaW4gd2hpY2ggcmVmZXJlbmNlcyBPcmVJZENvbnRleHRcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tY3ljbGVcbmltcG9ydCBPcmVJZCBmcm9tICcuLi9jb3JlL29yZUlkJ1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1jeWNsZVxuaW1wb3J0IHsgUGx1Z2luVHlwZSB9IGZyb20gJy4vbW9kZWxzJ1xuXG4vKiogUGx1Z2luIGludGVyZmFjZSAqL1xuZXhwb3J0IGludGVyZmFjZSBQbHVnaW48VD4ge1xuICB0eXBlOiBQbHVnaW5UeXBlXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgaW5pdDogKG9yZUlkOiBPcmVJZCkgPT4gUHJvbWlzZTxUPlxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9wb3B1cFBsdWdpbi9tb2RlbHMnXG5cbmV4cG9ydCBlbnVtIFBsdWdpblR5cGUge1xuICBQb3B1cCA9ICdwb3B1cCcsXG59XG4iLCJpbXBvcnQgeyBTaWduU3RyaW5nRGF0YSB9IGZyb20gJy4uLy4uL3RyYW5zYWN0aW9uL21vZGVscydcbmltcG9ydCBUcmFuc2FjdGlvbiBmcm9tICcuLi8uLi90cmFuc2FjdGlvbi90cmFuc2FjdGlvbidcbmltcG9ydCB7IFVzZXJEYXRhIH0gZnJvbSAnLi4vLi4vdXNlci9tb2RlbHMnXG5pbXBvcnQge1xuICBXZWJXaWRnZXRBdXRoUGFyYW1zLFxuICBXZWJXaWRnZXRBdXRoUmVzdWx0LFxuICBXZWJXaWRnZXRCdXlQYXJhbXMsXG4gIFdlYldpZGdldEJ1eVJlc3VsdCxcbiAgV2ViV2lkZ2V0S2V5RXhwb3J0UGFyYW1zLFxuICBXZWJXaWRnZXRLZXlFeHBvcnRSZXN1bHQsXG4gIFdlYldpZGdldExvZ291dFBhcmFtcyxcbiAgV2ViV2lkZ2V0TmV3Q2hhaW5BY2NvdW50UGFyYW1zLFxuICBXZWJXaWRnZXROZXdDaGFpbkFjY291bnRSZXN1bHQsXG4gIFdlYldpZGdldFJlY292ZXJBY2NvdW50UGFyYW1zLFxuICBXZWJXaWRnZXRSZWNvdmVyQWNjb3VudFJlc3VsdCxcbiAgV2ViV2lkZ2V0U2lnblJlc3VsdCxcbn0gZnJvbSAnLi4vLi4vd2ViV2lkZ2V0L21vZGVscydcblxuLy8gcGFyYW1zXG5cbmV4cG9ydCB0eXBlIFBvcHVwUGx1Z2luQnV5UGFyYW1zID0gV2ViV2lkZ2V0QnV5UGFyYW1zXG5cbmV4cG9ydCB0eXBlIFBvcHVwUGx1Z2luQXV0aFBhcmFtcyA9IFdlYldpZGdldEF1dGhQYXJhbXNcblxuZXhwb3J0IHR5cGUgUG9wdXBQbHVnaW5Mb2dvdXRQYXJhbXMgPSBQYXJ0aWFsPFdlYldpZGdldExvZ291dFBhcmFtcz5cblxuZXhwb3J0IHR5cGUgUG9wdXBQbHVnaW5OZXdDaGFpbkFjY291bnRQYXJhbXMgPSBQYXJ0aWFsPFdlYldpZGdldE5ld0NoYWluQWNjb3VudFBhcmFtcz5cblxuZXhwb3J0IHR5cGUgUG9wdXBQbHVnaW5SZWNvdmVyQWNjb3VudFBhcmFtcyA9IFBhcnRpYWw8V2ViV2lkZ2V0UmVjb3ZlckFjY291bnRQYXJhbXM+XG5cbmV4cG9ydCB0eXBlIFBvcHVwUGx1Z2luS2V5RXhwb3J0UGFyYW1zID0gV2ViV2lkZ2V0S2V5RXhwb3J0UGFyYW1zXG5cbmV4cG9ydCB0eXBlIFBvcHVwUGx1Z2luU2lnblBhcmFtcyA9IHtcbiAgc2lnblN0cmluZz86IFNpZ25TdHJpbmdEYXRhXG4gIHRyYW5zYWN0aW9uPzogVHJhbnNhY3Rpb25cbn1cblxuLy8gcmVzdWx0c1xuXG5leHBvcnQgdHlwZSBQb3B1cFBsdWdpbkF1dGhTdWNjZXNzUmVzdWx0cyA9IFdlYldpZGdldEF1dGhSZXN1bHQgJiB7IHVzZXI6IFVzZXJEYXRhIH1cblxuZXhwb3J0IHR5cGUgUG9wdXBQbHVnaW5CdXlTdWNjZXNzUmVzdWx0cyA9IFdlYldpZGdldEJ1eVJlc3VsdFxuXG5leHBvcnQgdHlwZSBQb3B1cFBsdWdpbkxvZ291dFJlc3VsdHMgPSBXZWJXaWRnZXROZXdDaGFpbkFjY291bnRSZXN1bHRcblxuZXhwb3J0IHR5cGUgUG9wdXBQbHVnaW5OZXdDaGFpbkFjY291bnRSZXN1bHRzID0gV2ViV2lkZ2V0TmV3Q2hhaW5BY2NvdW50UmVzdWx0ICYgeyBjaGFpbk5ldHdvcms6IHN0cmluZyB9XG5cbmV4cG9ydCB0eXBlIFBvcHVwUGx1Z2luUmVjb3ZlckFjY291bnRSZXN1bHRzID0gV2ViV2lkZ2V0UmVjb3ZlckFjY291bnRSZXN1bHRcblxuZXhwb3J0IHR5cGUgUG9wdXBQbHVnaW5TaWduUmVzdWx0cyA9IFdlYldpZGdldFNpZ25SZXN1bHRcblxuZXhwb3J0IHR5cGUgUG9wdXBQbHVnaW5LZXlFeHBvcnRTdWNjZXNzUmVzdWx0cyA9IFdlYldpZGdldEtleUV4cG9ydFJlc3VsdFxuXG5leHBvcnQgaW50ZXJmYWNlIFBvcHVwUGx1Z2luIHtcbiAgYXV0aDogKGFyZ3M6IFBvcHVwUGx1Z2luQXV0aFBhcmFtcykgPT4gUHJvbWlzZTxQb3B1cFBsdWdpbkF1dGhTdWNjZXNzUmVzdWx0cz5cbiAgc2lnbjogKGFyZ3M6IFBvcHVwUGx1Z2luU2lnblBhcmFtcykgPT4gUHJvbWlzZTxQb3B1cFBsdWdpblNpZ25SZXN1bHRzPlxuICBuZXdDaGFpbkFjY291bnQ6IChhcmdzOiBQb3B1cFBsdWdpbk5ld0NoYWluQWNjb3VudFBhcmFtcykgPT4gUHJvbWlzZTxQb3B1cFBsdWdpbk5ld0NoYWluQWNjb3VudFJlc3VsdHM+XG4gIHJlY292ZXJBY2NvdW50OiAoYXJnczogUG9wdXBQbHVnaW5SZWNvdmVyQWNjb3VudFBhcmFtcykgPT4gUHJvbWlzZTxQb3B1cFBsdWdpblJlY292ZXJBY2NvdW50UmVzdWx0cz5cbiAgYnV5OiAoYXJnczogUG9wdXBQbHVnaW5CdXlQYXJhbXMpID0+IFByb21pc2U8UG9wdXBQbHVnaW5CdXlTdWNjZXNzUmVzdWx0cz5cbiAga2V5RXhwb3J0OiAoYXJnczogUG9wdXBQbHVnaW5LZXlFeHBvcnRQYXJhbXMpID0+IFByb21pc2U8UG9wdXBQbHVnaW5LZXlFeHBvcnRTdWNjZXNzUmVzdWx0cz5cbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCB7IEF1dGggfSBmcm9tICcuL2F1dGgvYXV0aCdcbmltcG9ydCB7IE9yZUlkT3B0aW9ucyBhcyBPcmVJZE9wdGlvbnNUeXBlIH0gZnJvbSAnLi9jb3JlL0lPcmVJZE9wdGlvbnMnXG5pbXBvcnQgT3JlSWQgZnJvbSAnLi9jb3JlL29yZUlkJ1xuaW1wb3J0IFRyYW5zYWN0aW9uIGZyb20gJy4vdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24nXG5pbXBvcnQgeyBXYWxsZXRQcm92aWRlckF0dHJpYnV0ZXMgYXMgV2FsbGV0UHJvdmlkZXJBdHRyaWJ1dGVzVHlwZSB9IGZyb20gJy4vd2FsbGV0cy9tb2RlbHMnXG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi91c2VyL3VzZXInXG5pbXBvcnQgSGVscGVycyBmcm9tICcuL3V0aWxzL2hlbHBlcnMnXG5pbXBvcnQgeyBhcHBlbmRIbWFjVG9VcmwsIGdlbmVyYXRlSG1hYywgZ2VuZXJhdGVIbWFjV2l0aEFwaUtleU9yUHJveHlTZXJ2ZXIgfSBmcm9tICcuL3V0aWxzL2htYWMnXG5pbXBvcnQgeyBEdW1teVN0b3JhZ2UsIE1lbW9yeVN0b3JhZ2UgfSBmcm9tICcuL3V0aWxzL3N0b3JhZ2UnXG5cbmV4cG9ydCAqIGZyb20gJy4vbW9kZWxzJ1xuZXhwb3J0ICogZnJvbSAnLi9wbHVnaW5zJ1xuZXhwb3J0IHtcbiAgYXBwZW5kSG1hY1RvVXJsLFxuICBBdXRoLFxuICBEdW1teVN0b3JhZ2UsXG4gIGdlbmVyYXRlSG1hYyxcbiAgZ2VuZXJhdGVIbWFjV2l0aEFwaUtleU9yUHJveHlTZXJ2ZXIsXG4gIEhlbHBlcnMsXG4gIE1lbW9yeVN0b3JhZ2UsXG4gIE9yZUlkLFxuICBUcmFuc2FjdGlvbixcbiAgVXNlcixcbn1cblxuZXhwb3J0IHR5cGUgT3JlSWRPcHRpb25zID0gT3JlSWRPcHRpb25zVHlwZVxuZXhwb3J0IHR5cGUgV2FsbGV0UHJvdmlkZXJBdHRyaWJ1dGVzID0gV2FsbGV0UHJvdmlkZXJBdHRyaWJ1dGVzVHlwZVxuIl0sIm5hbWVzIjpbImNhbGxBcGlDb252ZXJ0T2F1dGhUb2tlbnMiLCJjYWxsQXBpTG9naW5Vc2VyV2l0aFRva2VuIiwiY2FsbEFwaU5ld1VzZXJXaXRoVG9rZW4iLCJnZXRPcmVJZEF1dGhVcmwiLCJUcmFuc2l0SGVscGVyIiwiVWFsSGVscGVyIiwiVXNlciIsIkhlbHBlcnMiLCJPYnNlcnZhYmxlIiwiQWNjZXNzVG9rZW5IZWxwZXIiLCJBdXRoIiwiYXJncyIsIm5ld0FjY2Vzc1Rva2VuSGVscGVyIiwic2F2ZUFjY2Vzc1Rva2VuQW5kTm90aWZ5U3Vic2NyaWJlcnMiLCJfYWNjZXNzVG9rZW5IZWxwZXIiLCJhY2Nlc3NUb2tlbiIsIl9vcmVJZENvbnRleHQiLCJvcmVJZENvbnRleHQiLCJfbG9jYWxTdGF0ZSIsImxvY2FsU3RhdGUiLCJfdHJhbnNpdEhlbHBlciIsInVzZXIiLCJfdXNlciIsIl91YWxIZWxwZXIiLCJpbml0QWNjZXNzVG9rZW5IZWxwZXIiLCJzYXZlZFRva2VuIiwic3Vic2NyaWJlIiwib25VcGRhdGVBY2Nlc3NUb2tlbkhlbHBlciIsImFjY291bnROYW1lIiwiaWRUb2tlbiIsInNldEFjY2Vzc1Rva2VuIiwiZXJyb3IiLCJjb25zb2xlIiwibG9nIiwibWVzc2FnZSIsInNhdmVBY2Nlc3NUb2tlbiIsImFjY2Vzc1Rva2VuSGVscGVyIiwiY2xlYXJBY2Nlc3NUb2tlbiIsImxvZ2luT3B0aW9ucyIsIndhbGxldFR5cGUiLCJ3YWxsZXRIZWxwZXIiLCJpc0FWYWxpZEV4dGVybmFsV2FsbGV0VHlwZSIsIkVycm9yIiwiY29ubmVjdFRvV2FsbGV0UHJvdmlkZXIiLCJwYXJtcyIsImxvZ2luV2l0aEFjY2Vzc09ySWRUb2tlblRva2VuIiwicHJvY2Vzc0lkIiwiZ2V0RGF0YSIsImVycm9ycyIsInVzZXJPcHRpb25zIiwibmV3QWNjb3VudFdpdGhJZFRva2VuIiwicGFyYW1zIiwiand0RGVjb2RlU2FmZSIsInRva2VuQ2hlY2tFcnJvciIsImNoZWNrSnd0VG9rZW5BbmRSZXR1cm5FcnJvciIsInJlc3BvbnNlIiwiZXJyb3JDb2RlIiwic2V0QXV0aFJlc3VsdCIsImVycm9yTWVzc2FnZSIsImlkVG9rZW5DaGVja0Vycm9yIiwiY29kZSIsImVtYWlsIiwicGhvbmUiLCJwcm92aWRlciIsInN0YXRlIiwibGlua1RvQWNjb3VudCIsInJldHVybkFjY2Vzc1Rva2VuIiwicmV0dXJuSWRUb2tlbiIsIm9wdGlvbnMiLCJhdXRoQ2FsbGJhY2tVcmwiLCJiYWNrZ3JvdW5kQ29sb3IiLCJjYWxsYmFja1VybCIsImlzTnVsbE9yRW1wdHkiLCJsb2dpblVybCIsImNhbGxiYWNrVXJsU3RyaW5nIiwiZXh0cmFjdERhdGFGcm9tQ2FsbGJhY2tVcmwiLCJhY2Nlc3NfdG9rZW4iLCJhY2NvdW50IiwiaWRfdG9rZW4iLCJwcm9jZXNzX2lkIiwic2V0SXNCdXN5IiwiYXV0aFJlc3BvbnNlIiwic2V0SWRUb2tlbiIsImp3dFRva2VuU3RyaW5nIiwiQXBpRW5kcG9pbnQiLCJSZXF1ZXN0VHlwZSIsImFzc2VydEhhc0FwaUtleU9yQWNjZXNzVG9rZW4iLCJhc3NlcnRQYXJhbXNIYXZlUmVxdWlyZWRWYWx1ZXMiLCJjYWxsQXBpQWRkUGVybWlzc2lvbiIsImFwaU5hbWUiLCJBZGRQZXJtaXNzaW9uIiwicGVybWlzc2lvbiIsInBhcmVudFBlcm1pc3Npb24iLCJvcHRpb25hbFBhcmFtcyIsInF1ZXJ5UGFyYW1zIiwiY2hhaW5BY2NvdW50IiwiY2hhaW5OZXR3b3JrIiwicHVibGljS2V5IiwiY2FsbE9yZUlkQXBpIiwiR2V0IiwiQ29uZmlnVHlwZSIsIkNoYWluUGxhdGZvcm1UeXBlIiwiQ2hhaW5OZXR3b3JrIiwiQWNjb3VudFR5cGUiLCJMb2dpblByb3ZpZGVyIiwiRXh0ZXJuYWxXYWxsZXRUeXBlIiwiQXV0aFByb3ZpZGVyIiwiQXBpS2V5VXNlZEZvciIsIlJlY292ZXJBY2NvdW50QWN0aW9uIiwiRXh0ZXJuYWxXYWxsZXRJbnRlcmZhY2UiLCJXaWRnZXRWZXJzaW9uIiwiV2ViV2lkZ2V0QWN0aW9uIiwiU2lnblN0cmluZ01ldGhvZCIsImFzc2VydEhlYWRlcmhhc1JlcXVpcmVkVmFsdWVzIiwicGFyYW1OYW1lcyIsIm1pc3NpbmciLCJmb3JFYWNoIiwicCIsInB1c2giLCJqb2luIiwiYXBpS2V5IiwiYXNzZXJ0SGFzQWNjZXNzVG9rZW4iLCJhc3NlcnRIYXNBcGlLZXkiLCJ1c2VkRm9yIiwidXNlZEZwck1zZyIsImFzc2VydFBhcmFtc0hhdmVBdExlYXN0T25lT2ZWYWx1ZXMiLCJtYXRjaGVzIiwiZmlsdGVyIiwibGVuZ3RoIiwiYXNzZXJ0UGFyYW1zSGF2ZU9ubHlPbmVPZlZhbHVlcyIsImV4dHJhY3RQcm9jZXNzSWRGcm9tRGF0YSIsImRhdGEiLCJ2NCIsInV1aWR2NCIsImNhbm9uaWNhbGl6ZSIsImp3dERlY29kZSIsIkJhc2U2NCIsIlRSQUNJTkciLCJzcGxpdEF0IiwiaW5kZXgiLCJkcm9wQ2hhcnMiLCJ4Iiwic2xpY2UiLCJyZXBsYWNlQWxsIiwiaW5TdHJpbmciLCJzZWFyY2giLCJyZXBsYWNlbWVudCIsInJlcGxhY2UiLCJSZWdFeHAiLCJvYmoiLCJ1bmRlZmluZWQiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJrZXlzIiwiY29uc3RydWN0b3IiLCJ0b2tlbiIsImRlY29kZWQiLCJmdWxsUGF0aCIsInVybFBhcmFtc09iamVjdCIsInNlYXJjaFN0cmluZyIsInVybE9iamVjdCIsIlVSTCIsImhhc2giLCJ1cmxQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ2YWx1ZSIsImtleSIsImRlY29kZVVSSUNvbXBvbmVudCIsImpzb25TdHJpbmciLCJ1bmVzY2FwZSIsInJlcGxhY2VRdW90ZXMiLCJmaW5hbEpzb25TdHJpbmciLCJpc0FTdHJpbmciLCJ0cmltIiwiZGVjb2RlVVJJIiwibyIsIkpTT04iLCJwYXJzZSIsImpzb25QYXJzZUNvbXBsZXhPYmplY3RSZXZpdmVyIiwidHlwZSIsIkJ1ZmZlciIsImZyb20iLCJpc0FOdW1iZXIiLCJ2YWx1ZXMiLCJlbnRyaWVzIiwibWFwIiwidmFsIiwiZXZlcnkiLCJVaW50OEFycmF5IiwiZW5jb2RlZFN0cmluZyIsImRlY29kZSIsInRyeVBhcnNlSlNPTiIsInZhbHVlSW4iLCJpc0FuT2JqZWN0Iiwic3RyaW5naWZ5IiwiZW5jb2RlIiwibXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJlbnVtVHlwZSIsImluY2x1ZGVzIiwiZSIsInRocm93SWZJbnZhbGlkIiwiaXNJbkVudW0iLCJlcnJNc2ciLCJlcnJvckNvZGVzIiwiZXJyb3JTdHJpbmciLCJlcnJvcl9jb2RlIiwiZXJyb3JfbWVzc2FnZSIsInNwbGl0IiwidXJsIiwicGFyc2VVcmxQYXJhbXMiLCJnZXRFcnJvckNvZGVzRnJvbVBhcmFtcyIsImFycmF5IiwiY2FsbGJhY2siLCJkZWNvZGVkVG9rZW4iLCJpdGVtIiwidG9Mb3dlckNhc2UiLCJpc0F4aW9zRXJyb3IiLCJlcnJvckNvZGVzTGlzdCIsIlN0cmluZyIsIkRhdGUiLCJCb29sZWFuIiwiTnVtYmVyIiwiaXNOYU4iLCJ0b0VudW1WYWx1ZSIsIkN1c3RvZGlhbCIsImVtYWlsUmVnZXgiLCJ0ZXN0Iiwic3RyaW5naWZpZWQiLCJTZXQiLCJleGVjdXRpb25Fb29jaFRpbWUiLCJub3ciLCJydW5BdFRpbWUiLCJNYXRoIiwibWF4IiwiYSIsImIiLCJrZXlzQSIsImtleXNCIiwidG9TdHJpbmciLCJvYmplY3RzQXJlRXF1YWwiLCJ3aW5kb3ciLCJjYWxsQXBpR2V0QXBwVG9rZW4iLCJBcHBUb2tlbiIsImFwcEFjY2Vzc1Rva2VuTWV0YWRhdGEiLCJDcmVhdGVVc2VyIiwiUG9zdCIsImFwcEFjY2Vzc1Rva2VuIiwiY2FsbEFwaUNhbkF1dG9zaWduVHJhbnNhY3Rpb24iLCJDYW5BdXRvU2lnbiIsInNpZ25lZFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbkNoYWluQWNjb3VudCIsIkF1dG9TaWduaW5nIiwiYm9keSIsImNoYWluX2FjY291bnQiLCJjaGFpbl9uZXR3b3JrIiwiYmFzZTY0RW5jb2RlIiwic2lnbmVkX3RyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25fY2hhaW5fYWNjY291bnQiLCJyZXN1bHRzIiwiQ29udmVydE9hdXRoVG9rZW5zIiwiY2FsbEFwaUN1c3RvZGlhbE1pZ3JhdGVBY2NvdW50IiwiQ3VzdG9kaWFsTWlncmF0ZUFjY291bnQiLCJ0b1R5cGUiLCJ1c2VyUGFzc3dvcmQiLCJ1c2VyUGFzc3dvcmRFbmNyeXB0ZWQiLCJ0b190eXBlIiwidXNlcl9wYXNzd29yZCIsInVzZXJfcGFzc3dvcmRfZW5jcnlwdGVkIiwiQWNjb3VudE1pZ3JhdGlvbiIsImNhbGxBcGlDdXN0b2RpYWxOZXdBY2NvdW50IiwiQ3VzdG9kaWFsTmV3QWNjb3VudCIsImFjY291bnRUeXBlIiwiZGVsYXlXYWxsZXRTZXR1cCIsImVtYWlsVmVyaWZpZWQiLCJpc1Rlc3RVc2VyIiwibmFtZSIsInBpY3R1cmUiLCJwaG9uZVZlcmlmaWVkIiwidXNlck5hbWUiLCJhY2NvdW50X3R5cGUiLCJkZWxheV93YWxsZXRfc2V0dXAiLCJlbWFpbF92ZXJpZmllZCIsImlzX3Rlc3RfdXNlciIsInBob25lX3ZlcmlmaWVkIiwidXNlcl9uYW1lIiwiY2FsbEFwaUN1c3RvZGlhbFNpZ25TdHJpbmciLCJDdXN0b2RpYWxTaWduU3RyaW5nIiwic3RyaW5nVG9TaWduIiwic2lnbk1ldGhvZCIsInN0cmluZ190b19zaWduIiwic2lnbl9tZXRob2QiLCJQcm94eVNpZ25pbmciLCJjYWxsQXBpRGVsZXRlVGVzdFVzZXIiLCJEZWxldGVUZXN0VXNlciIsImNhbGxBcGlHZXRDb25maWciLCJHZXRDb25maWciLCJjb25maWdUeXBlIiwiY2FsbEFwaUdldFVzZXIiLCJHZXRVc2VyIiwiTG9naW5Vc2VyV2l0aFRva2VuIiwiTmV3VXNlcldpdGhUb2tlbiIsImNhbGxBcGlQYXNzd29yZExlc3NTZW5kQ29kZSIsIlBhc3N3b3JkTGVzc1NlbmRDb2RlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiY2FsbEFwaVBhc3N3b3JkTGVzc1ZlcmlmeUNvZGUiLCJQYXNzd29yZExlc3NWZXJpZnlDb2RlIiwiY29tcG9zZVNpZ25Cb2R5RnJvbVRyYW5zYWN0aW9uRGF0YSIsInRyYW5zYWN0aW9uRGF0YSIsImV4cGlyZVNlY29uZHMiLCJzaWduZWRUcmFuc2FjdGlvblBhcmFtIiwidHJhbnNhY3Rpb25QYXJhbSIsInRyYW5zYWN0aW9uUmVjb3JkSWQiLCJzaWduT3B0aW9ucyIsImFsbG93Q2hhaW5BY2NvdW50U2VsZWN0aW9uIiwiYnJvYWRjYXN0IiwiZ2VuZXJhdGVBdXRvU2lnbkNyZWRlbnRpYWwiLCJtdWx0aVNpZ0NoYWluQWNjb3VudHMiLCJyZXR1cm5TaWduZWRUcmFuc2FjdGlvbiIsImF1dG9TaWduIiwiYWxsb3dfY2hhaW5fYWNjb3VudF9zZWxlY3Rpb24iLCJhdXRvX3NpZ24iLCJleHBpcmVfc2Vjb25kcyIsImdlbmVyYXRlX2F1dG9fc2lnbl9jcmVkZW50aWFsIiwibXVsdGlzaWdfY2hhaW5fYWNjb3VudHMiLCJyZXR1cm5fc2lnbmVkX3RyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25fcmVjb3JkX2lkIiwibWFwU2lnblJlc3VsdEZyb21BcGkiLCJhcGlSZXN1bHQiLCJ0cmFuc2FjdGlvbklkIiwidHJhbnNhY3Rpb25faWQiLCJyZXN0IiwiY2FsbEFwaVNpZ25UcmFuc2FjdGlvbiIsIlRyYW5zYWN0aW9uU2lnbiIsImNhbGxBcGlDdXN0b2RpYWxTaWduVHJhbnNhY3Rpb24iLCJDdXN0b2RpYWxTaWduIiwiZ2V0T3JlSWROZXdDaGFpbkFjY291bnRVcmwiLCJhY2NvdW50T3B0aW9ucyIsIm9yZUlkVXJsIiwicGFyYW1zTmV3QWNjb3VudCIsImFjY2Vzc1Rva2VuUGFyYW0iLCJlbmNvZGVkU3RhdGVQYXJhbSIsImFkZEFjY2Vzc1Rva2VuQW5kSG1hY1RvVXJsIiwibGlua1RvQWNjb3VudFBhcmFtIiwiY29kZVBhcmFtIiwiZW1haWxQYXJhbSIsInBob25lUGFyYW0iLCJyZXR1cm5BY2Nlc3NUb2tlblBhcmFtIiwicmV0dXJuSWRUb2tlblBhcmFtIiwiZ2V0T3JlSWRTaWduVXJsIiwiZW5jb2RlZFRyYW5zYWN0aW9uIiwiZW5jb2RlZFNpZ25lZFRyYW5zYWN0aW9uIiwiZ2V0UmVjb3ZlckFjY291bnRVcmwiLCJyZWNvdmVyQWN0aW9uIiwib3ZlcnJpZGVBcHBBY2Nlc3NUb2tlbiIsImFjdGlvblR5cGVQYXJhbSIsImluaXRBY2Nlc3NDb250ZXh0IiwibXNnUGFja0VuY29kZSIsImdldFRyYW5zaXRQcm92aWRlckF0dHJpYnV0ZXMiLCJnZXRUcmFuc2l0UHJvdmlkZXJBdHRyaWJ1dGVzQnlQcm92aWRlcklkIiwic3VwcG9ydGVkVHJhbnNpdFByb3ZpZGVycyIsInRyYW5zaXRBY2Nlc3NDb250ZXh0cyIsImVvc1RyYW5zaXRXYWxsZXRQcm92aWRlcnMiLCJ0cmFuc2l0UHJvdmlkZXJzSW5zdGFsbGVkIiwibWFrZVdhbGxldFByb3ZpZGVyIiwid2FsbGV0UHJvdmlkZXIiLCJpZCIsInByb3ZpZGVyTmFtZSIsImFzc2VydEhhc1Byb3ZpZGVySW5zdGFsbGVkIiwiVHJhbnNpdCIsImFzc2VydFByb3ZpZGVyVmFsaWRGb3JDaGFpbk5ldHdvcmsiLCJwcm92aWRlcklkIiwiZ2V0T3JDcmVhdGVUcmFuc2l0QWNjZXNzQ29udGV4dCIsImNoYWluQ29udGV4dCIsInRyYW5zaXRQcm92aWRlciIsImdldFdhbGxldFByb3ZpZGVycyIsImZpbmQiLCJ3cCIsInRyYW5zaXRXYWxsZXQiLCJpbml0V2FsbGV0IiwiY29ubmVjdCIsIndhaXRXaGlsZVdhbGxldElzQnVzeSIsImFwcE5hbWUiLCJzZXR0aW5ncyIsImdldENoYWluTmV0d29ya05leHR3b3JrQ29uZmlnIiwibmV0d29ya0NvbmZpZyIsImlzTm90RW9zTmV0d29yayIsIndhbGxldENvbnRleHQiLCJuZXR3b3JrIiwid2FsbGV0UHJvdmlkZXJzIiwic2V0dXBUcmFuc2l0V2FsbGV0IiwicmVxdWlyZXNMb2dpbiIsImF1dGhlbnRpY2F0ZWQiLCJsb2dpblRvVHJhbnNpdFByb3ZpZGVyIiwiY29ubmVjdGVkIiwiYXV0aCIsInVwZGF0ZU9yZUFjY291bnRQZXJtaXNzaW9uc2Zyb21UcmFuc2l0V2FsbGV0QXV0aCIsImlzTG9nZ2VkSW4iLCJwZXJtaXNzaW9ucyIsImhhc0Vycm9yIiwicmV0cnlDb3VudCIsInJlcXVpcmVzRGlzY292ZXJUb0xvZ2luIiwiZGlzY292ZXIiLCJkaXNjb3Zlck9wdGlvbnNGb3JQcm92aWRlciIsImRpc2NvdmVyeURhdGEiLCJmb3VuZERhdGEiLCJmaW5kQWNjb3VudEluRGlzY292ZXJEYXRhIiwibG9naW4iLCJhdXRob3JpemF0aW9uIiwiaW5mbyIsInRyYW5zaXRBY2NvdW50TmFtZSIsImxvZ291dCIsImRvVHJhbnNpdFByb3ZpZGVyTG9naW4iLCJtYXBBdXRoUHJvdmlkZXJUb1dhbGxldFR5cGUiLCJjb25uZWN0VG9UcmFuc2l0UHJvdmlkZXIiLCJ3YWxsZXQiLCJwcm92aWRlclR5cGUiLCJoYXNUcmFuc2l0UHJvdmlkZXIiLCJkaXNjb3Zlck9wdGlvbnMiLCJFb3NNYWluIiwib3JlQWNjb3VudCIsImRpc2NvdmVyeVBhdGhJbmRleExpc3QiLCJyZXN1bHQiLCJjYW5EaXNjb3ZlciIsImRpc2NvdmVyQ3JlZGVudGlhbHNJblRyYW5zaXRXYWxsZXQiLCJyZXF1aXJlc0xvZ291dExvZ2luVG9EaXNjb3ZlciIsImFjY291bnRzQW5kUGVybWlzc2lvbnMiLCJjcmVkZW50aWFscyIsImtleVRvQWNjb3VudE1hcCIsImFzeW5jRm9yRWFjaCIsImNyZWRlbnRpYWwiLCJhY2NvdW50cyIsInBhcmVudCIsImdldENoYWluTmV0d29ya0Zyb21UcmFuc2l0V2FsbGV0IiwidHJhbnNpdENoYWluTmV0d29yayIsImFkZFdhbGxldFBlcm1pc3Npb25zVG9PcmVJZEFjY291bnQiLCJjb25jYXQiLCJwYXRoSW5kZXhMaXN0UGFyYW0iLCJwYXRoSW5kZXhMaXN0Iiwia2V5TG9va3VwRnVuYyIsIndhbGxldFByb3ZpZGVyVHlwZSIsImRlZmF1bHREaXNjb3ZlcnlQYXRoSW5kZXhMaXN0IiwiZGlzY292ZXJ5S2V5TG9va3VwRnVuYyIsImFjY3QiLCJhY3RpdmUiLCJmaXJzdCIsImNoYWluVHlwZSIsImVvcyIsInNpZ25UcmFuc2FjdGlvbldpdGhUcmFuc2l0QW5kRW9zU0RLIiwiYWxnb3JhbmQiLCJzaWduVHJhbnNhY3Rpb25XaXRoVHJhbnNpdEFuZEFsZ29yYW5kU0RLIiwiZXRoZXJldW0iLCJzaWduVHJhbnNhY3Rpb25XaXRoVHJhbnNpdEFuZEV0aGVyZXVtU0RLIiwic2VyaWFsaXplZFRyYW5zYWN0aW9uIiwic3RyaW5nIiwibWV0YWRhdGEiLCJzaWduQXJiaXRyYXJ5Iiwic2lnbmVkU3RyaW5nIiwiZW9zQXBpIiwidHJhbnNhY3QiLCJhY3Rpb25zIiwiYmxvY2tzQmVoaW5kIiwic2lnbmF0dXJlcyIsImNhbGxEaXNjb3ZlckFmdGVyU2lnbiIsInNpZ25QYXJhbXMiLCJjaGFpbklkIiwicmVxdWlyZWRLZXlzIiwiYWJpcyIsInNpZ25hdHVyZVByb3ZpZGVyIiwic2lnbiIsImN0eCIsImdldEFsbENoYWluTmV0d29ya1NldHRpbmdzIiwibmV0d29ya3MiLCJuZXQiLCJob3N0cyIsImhvc3QiLCJ1cGRhdGVQZXJtaXNzaW9uc0lmTmVjZXNzYXJ5IiwiaXNWYWxpZCIsIm4iLCJpblByb2dyZXNzIiwic2xlZXAiLCJkaXNjb3ZlcldpdGhUcmFuc2l0Iiwic3VwcG9ydHNEaXNjb3ZlcnkiLCJzdXBwb3J0c1NpZ25BcmJpdHJhcnkiLCJoZWxwVGV4dCIsImNvbnRhaW5zRW1wdHkiLCJoYXNPd25Qcm9wZXJ0eSIsImZpcnN0RW1wdHlLZXkiLCJFUlJPUl9DT05UQUlOU19FTVBUWV9TVFJJTkciLCJlbXB0eUNoZWNrIiwic29ydEtleXMiLCJBbGdvcmFuZERpc2NvdmVyeUtleUxvb2t1cEZ1bmMiLCJhY2NvdW50SW5mb0FycmF5Iiwibm90ZSIsIk5vbkVvc0Rpc2NvdmVyeUtleUxvb2t1cEZ1bmMiLCJ0cmFuc2l0UHJvdmlkZXJBdHRyaWJ1dGVzRGF0YSIsIkFsZ29TaWduZXIiLCJ2ZXJzaW9uc1JlcXVpcmVkIiwibG9nb1VybCIsIktleWNhdCIsIkxlZGdlciIsIkx5bngiLCJNZWV0b25lIiwiTWV0cm8iLCJQb3J0aXMiLCJTY2F0dGVyIiwiU2ltcGxlRW9zIiwiVG9rZW5Qb2NrZXQiLCJXYWxsZXRDb25uZWN0IiwiV2ViMyIsIldoYWxlVmF1bHQiLCJ0cCIsImdldFRyYW5zaXRQcm92aWRlckF0dHJpYnV0ZXNCeUNoYWluIiwiY2hhaW4iLCJnZXRVYWxQcm92aWRlckF0dHJpYnV0ZXMiLCJnZXRVYWxQcm92aWRlckF0dHJpYnV0ZXNCeVVhbE5hbWUiLCJzdXBwb3J0ZWRVQUxQcm92aWRlcnMiLCJ1YWxXYWxsZXRQcm92aWRlcnMiLCJ1YWxQcm92aWRlcnNJbnN0YWxsZWQiLCJ1YWxQcm92aWRlckZhY3RvcnkiLCJhdXRoZW50aWNhdG9yIiwiVWFsIiwidXNlcnMiLCJ1c2Vyc1dpdGhBY2NvdW50c0RldGFpbHMiLCJnZXRBY2NvdW50QW5kUGVybWlzc2lvbnNGcm9tVWFsVXNlciIsInVzZXJQZXJtaXNzaW9ucyIsInVzZXJGb3JDaGFpbiIsInV3YSIsIlNlbGVjdGVkQXV0aGVudGljYXRvciIsInVhbEF1dGhlbnRpY2F0b3JzIiwidWFsQXV0aGVudGljYXRvciIsInVhbE5ldHdvcmtDb25maWciLCJycGNFbmRwb2ludHMiLCJpbml0IiwiaXNFcnJvcmVkIiwidWFsRXJyb3IiLCJnZXRFcnJvciIsImNhdXNlIiwibG9naW5Ub1VhbFByb3ZpZGVyIiwidXBkYXRlT3JlQWNjb3VudFBlcm1pc3Npb25zZnJvbVVhbFVzZXIiLCJ1YWxVc2VyIiwiZ2V0Q2hhaW5JZCIsImdldENoYWluTmV0d29ya0J5Q2hhaW5JZCIsImdldEFjY291bnROYW1lIiwiZ2V0S2V5cyIsInB1YmxpY0tleXMiLCJjb25uZWN0VG9VYWxQcm92aWRlciIsImhhc1VhbFByb3ZpZGVyIiwic2lnblRyYW5zYWN0aW9uIiwic2lnbmVkVHJhbnNhY3Rpb25SZXNwb25zZSIsImlzTG9hZGluZyIsInVhbFByb3ZpZGVyQXR0cmlidXRlc0RhdGEiLCJBbmNob3IiLCJXb21iYXQiLCJ1cCIsImNhbGxBcGlVcGRhdGVEZWxheVdhbGxldFNldHVwIiwiX2FjY291bnROYW1lIiwiYXNzZXJ0VXNlckhhc0RhdGEiLCJfdXNlclNvdXJjZURhdGEiLCJvdGhlckluZm8iLCJjaGFpbkFjY291bnRzIiwiZ2V0Q2hhaW5BY2NvdW50cyIsInVzZXJTb3VyY2VEYXRhIiwicGVybSIsImdldERlZmF1bHRQZXJtaXNzaW9uRm9yQ2hhaW5BY2NvdW50IiwiZGVmYXVsdFBlcm1pc3Npb24iLCJnZXRQZXJtaXNzaW9uRm9yQ2hhaW5BY2NvdW50IiwiZ2V0VW5pcXVlVmFsdWVzIiwiaGFzRGF0YSIsImlzVmFsaWRFbWFpbCIsImZvcmNlUmVmcmVzaCIsInNldFVzZXJTb3VyY2VEYXRhIiwibmV3QWNjb3VudE9wdGlvbnMiLCJuZXdBY2NvdW50Q2FsbGJhY2tVcmwiLCJuZXdBY2NvdW50VXJsIiwiYXNzZXJ0VXNlckhhc1ZhbGlkRW1haWwiLCJFbWFpbCIsInBlcm1pc3Npb25OYW1lIiwib3RoZXIiLCJhY2NvdW50UGVybWlzc2lvbnMiLCJtYXBVc2VyUGVybWlzc2lvbiIsImlzRGVmYXVsdCIsInNraXBUaGlzUGVybWlzc2lvbiIsInNvbWUiLCJfc3Vic2NyaWJlcnMiLCJzdWJzY3JpYmVyIiwiaGFzVGhpc1N1YnNjcmliZXIiLCJzIiwiZiIsIlVwZGF0ZURlbGF5V2FsbGV0U2V0dXAiLCJpZ25vcmVJc3N1ZXIiLCJfaWdub3JlSXNzdWVyIiwiX2FjY2Vzc1Rva2VuIiwiX2RlY29kZWRBY2Nlc3NUb2tlbiIsIl9pZFRva2VuIiwiX2RlY29kZWRJZFRva2VuIiwiYXNzZXJ0SXNUb2tlblZhbGlkIiwiZGVjb2RlZEFjY2Vzc1Rva2VuIiwiZ2V0Q2xhaW1Gcm9tSnd0VG9rZW5CeVNlYXJjaFN0cmluZyIsImlzVG9rZW5EYXRlVmFsaWROb3ciLCJhc3NlcnRJZFRva2VuTWF0Y2hlc0FjY2Vzc1Rva2VuIiwiZGVjb2RlZElkVG9rZW4iLCJleHAiLCJjbGVhcklkVG9rZW4iLCJpc3MiLCJzdWIiLCJub3dEYXRlIiwibm93SW5NcyIsImdldFRpbWUiLCJuYmYiLCJheGlvcyIsImRlZmF1bHRPcmVJZFNlcnZpY2VVcmwiLCJwdWJsaWNBcGlFbmRwb2ludHMiLCJ2ZXJzaW9uIiwiVHJhbnNhY3Rpb24iLCJhcHBlbmRIbWFjVG9VcmwiLCJnZW5lcmF0ZUhtYWNXaXRoQXBpS2V5T3JQcm94eVNlcnZlciIsIkxvY2FsU3RhdGUiLCJTdG9yYWdlSGFuZGxlciIsIlNldHRpbmdzIiwiV2FsbGV0SGVscGVyIiwiT3JlSWQiLCJfb3B0aW9ucyIsInZhbGlkYXRlQW5kU2V0T3B0aW9ucyIsInN0b3JhZ2VIYW5kbGVyIiwiYXBwSWQiLCJfc2V0dGluZ3MiLCJfYXV0aCIsImluc3RhbGxUcmFuc2l0UHJvdmlkZXJzIiwiaW5zdGFsbFVhbFByb3ZpZGVycyIsIl93YWxsZXRIZWxwZXIiLCJ0cmFuc2l0SGVscGVyIiwidWFsSGVscGVyIiwiX2luaXRpYWxpemVyUGx1Z2lucyIsInBsdWdpbnMiLCJfaXNJbml0aWFsaXplZCIsInN0YXJ0c1dpdGgiLCJhc3NlcnRJc0luaXRpYWxpemVkIiwiX3BvcHVwIiwiaXNVc2luZ1Byb3h5U2VydmVyIiwiaXNJbkJyb3dzZXIiLCJpc0RlbW9BcHAiLCJpc0luaXRpYWxpemVkIiwicG9wdXAiLCJzaWduU3RyaW5nV2l0aFdhbGxldCIsIm1pZ3JhdGVPcHRpb25zIiwiZ2V0RXh0ZXJuYWxXYWxsZXRJbmZvIiwiaXNCdXN5Iiwic2V0QnVzeUNhbGxiYWNrIiwicmVxdWlyZXNQcm94eVNlcnZlciIsImJhc2U2NERlY29kZVNhZmUiLCJ0aW1lc3RhbXAiLCJzaWduYXR1cmUiLCJzaWduZWRQcm9wcyIsIm5vd1RpbWVzdGFtcCIsIm9yaWdpbiIsImxvY2F0aW9uIiwic29ydEpzb24iLCJyZXF1ZXN0TWV0aG9kIiwiZW5kcG9pbnQiLCJvdmVycmlkZUFjY2Vzc1Rva2VuIiwiaGVhZGVycyIsIm9yZUlkVXJsQmFzZSIsIkF1dGhvcml6YXRpb24iLCJ1cmxTdHJpbmciLCJ1cmxXaXRoUGFyYW1zIiwiZ2V0IiwicG9zdCIsImdldEVycm9yRnJvbUF4aW9zRXJyb3IiLCJjb21wbGV0ZVVybCIsImdldEFwcEFjY2Vzc1Rva2VuIiwidmVyc2lvbkpzb24iLCJleHRlcm5hbFdhbGxldHNOb3RJbXBsZW1lbnRlZCIsImFzc2VydFZhbGlkVHJhbnNhY3Rpb25BbmRTZXREYXRhIiwiX2RhdGEiLCJjcmVhdGVUcmFuc2FjdGlvbkRhdGEiLCJtaXNzaW5nRmllbGRzIiwidmFsaWRhdGlvbklzc3VlcyIsInNldFRyYW5zYWN0aW9uRGF0YSIsImNoYWluQWNjb3VudHNJbldhbGxldCIsImFsbFBlcm1pc3Npb25zRXh0ZXJuYWwiLCJwcml2YXRlS2V5U3RvcmVkRXh0ZXJhbGx5IiwiZXh0ZXJuYWxXYWxsZXRUeXBlIiwiYXNzZXJ0VHJhbnNhY3Rpb25BY2NvdW50VmFsaWRGb3JVc2VyIiwic2lnbkNhbGxiYWNrVXJsIiwic2lnblVybCIsImF1dG9TaWduQ3JlZGVudGlhbHNFeGlzdCIsInNpZ25XaXRoV2FsbGV0Iiwic2lnblJlc3VsdCIsIkhtYWNTSEEyNTYiLCJBeGlvcyIsImdlbmVyYXRlSG1hYyIsInNlY3JldCIsImhtYWMiLCJ1c2VQcm94eVNlcnZlciIsInVybEVuY29kZWRIbWFjIiwic3RvcmFnZSIsImNhY2hlZGFjY2Vzc1Rva2VuIiwiY2FjaGVkVXNlciIsImxvYWRBY2Nlc3NUb2tlbiIsImdldEl0ZW0iLCJhY2Nlc3NUb2tlbktleSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiQ29va2llIiwiQ29va2llU3RvcmFnZSIsInJlbW92ZSIsImV4cGlyZXMiLCJzZXQiLCJMb2NhbFN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2UiLCJEdW1teVN0b3JhZ2UiLCJNZW1vcnlTdG9yYWdlIiwibWVtb3J5Q2FjaGUiLCJ0cnlMb2NhbFN0b3JhZ2VGaXJzdCIsInRyaWVkTG9jYWxTdG9yYWdlIiwidHJpZWRDb29raWVTdG9yYWdlIiwiZGlkU2V0IiwiZmFpbG92ZXIiLCJfY2FjaGVkQ2hhaW5OZXR3b3JrcyIsImdldENvbmZpZ0Zyb21BcGkiLCJDaGFpbnMiLCJjaGFpbnMiLCJnZXRDaGFpbk5ldHdvcmtTZXR0aW5ncyIsIm5ldHdvcmtTZXR0aW5ncyIsInBvcnQiLCJwcm90b2NvbCIsImNoYWluU2V0dGluZ3MiLCJoIiwibmV0d29ya1NldHRpbmciLCJvcmUiLCJpc1RyYW5zaXRQcm92aWRlciIsImlzVWFsUHJvdmlkZXIiLCJleHRlcm5hbFdhbGxldEludGVyZmFjZSIsInRyYW5zaXRXYWxsZXRzSW5zdGFsbGVkSW5mbyIsInVhbFdhbGxldHNJbnN0YWxsZWRJbmZvIiwibG9naW5XaXRoVHJhbnNpdFByb3ZpZGVyIiwibG9naW5XaXRoVWFsUHJvdmlkZXIiLCJzaWduV2l0aFRyYW5zaXRQcm92aWRlciIsInNpZ25XaXRoVWFsUHJvdmlkZXIiLCJjYW5TaWduU3RyaW5nIiwic2lnblN0cmluZ1dpdGhUcmFuc2l0UHJvdmlkZXIiLCJzaWduU3RyaW5nV2l0aFVhbFByb3ZpZGVyIiwiUGx1Z2luVHlwZSJdLCJzb3VyY2VSb290IjoiIn0=