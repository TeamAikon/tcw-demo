import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS
} from "./chunk-6NOISVLF.js";

// node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-browser/rng.js"() {
    getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
    rnds8 = new Uint8Array(16);
  }
});

// node_modules/uuid/dist/esm-browser/bytesToUuid.js
function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join("");
}
var byteToHex, i, bytesToUuid_default;
var init_bytesToUuid = __esm({
  "node_modules/uuid/dist/esm-browser/bytesToUuid.js"() {
    byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    bytesToUuid_default = bytesToUuid;
  }
});

// node_modules/uuid/dist/esm-browser/v1.js
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf ? buf : bytesToUuid_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-browser/v1.js"() {
    init_rng();
    init_bytesToUuid();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-browser/v35.js
function uuidToBytes(uuid) {
  var bytes = [];
  uuid.replace(/[a-fA-F0-9]{2}/g, function(hex) {
    bytes.push(parseInt(hex, 16));
  });
  return bytes;
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = new Array(str.length);
  for (var i = 0; i < str.length; i++) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
function v35_default(name, version, hashfunc) {
  var generateUUID = function generateUUID2(value, namespace, buf, offset) {
    var off = buf && offset || 0;
    if (typeof value == "string")
      value = stringToBytes(value);
    if (typeof namespace == "string")
      namespace = uuidToBytes(namespace);
    if (!Array.isArray(value))
      throw TypeError("value must be an array of bytes");
    if (!Array.isArray(namespace) || namespace.length !== 16)
      throw TypeError("namespace must be uuid string or an Array of 16 byte values");
    var bytes = hashfunc(namespace.concat(value));
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      for (var idx = 0; idx < 16; ++idx) {
        buf[off + idx] = bytes[idx];
      }
    }
    return buf || bytesToUuid_default(bytes);
  };
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-browser/v35.js"() {
    init_bytesToUuid();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes == "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Array(msg.length);
    for (var i = 0; i < msg.length; i++) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var i;
  var x;
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  var hex;
  for (i = 0; i < length32; i += 8) {
    x = input[i >> 5] >>> i % 32 & 255;
    hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[(len + 64 >>> 9 << 4) + 14] = len;
  var i;
  var olda;
  var oldb;
  var oldc;
  var oldd;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (i = 0; i < x.length; i += 16) {
    olda = a;
    oldb = b;
    oldc = c;
    oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  var i;
  var output = [];
  output[(input.length >> 2) - 1] = void 0;
  for (i = 0; i < output.length; i += 1) {
    output[i] = 0;
  }
  var length8 = input.length * 8;
  for (i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-browser/md5.js"() {
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-browser/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-browser/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  var i = buf && offset || 0;
  if (typeof options == "string") {
    buf = options === "binary" ? new Array(16) : null;
    options = null;
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }
  return buf || bytesToUuid_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-browser/v4.js"() {
    init_rng();
    init_bytesToUuid();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes == "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Array(msg.length);
    for (var i = 0; i < msg.length; i++) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var i = 0; i < N; i++) {
    M[i] = new Array(16);
    for (var j = 0; j < 16; j++) {
      M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var i = 0; i < N; i++) {
    var W = new Array(80);
    for (var t = 0; t < 16; t++) {
      W[t] = M[i][t];
    }
    for (var t = 16; t < 80; t++) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var t = 0; t < 80; t++) {
      var s = Math.floor(t / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-browser/sha1.js"() {
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-browser/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-browser/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/uuid/dist/esm-browser/index.js
var esm_browser_exports = {};
__export(esm_browser_exports, {
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default
});
var init_esm_browser = __esm({
  "node_modules/uuid/dist/esm-browser/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
  }
});

// node_modules/canonicalize/lib/canonicalize.js
var require_canonicalize = __commonJS({
  "node_modules/canonicalize/lib/canonicalize.js"(exports, module) {
    "use strict";
    module.exports = function serialize(object) {
      if (object === null || typeof object !== "object" || object.toJSON != null) {
        return JSON.stringify(object);
      }
      if (Array.isArray(object)) {
        return "[" + object.reduce((t, cv, ci) => {
          const comma = ci === 0 ? "" : ",";
          const value = cv === void 0 || typeof cv === "symbol" ? null : cv;
          return t + comma + serialize(value);
        }, "") + "]";
      }
      return "{" + Object.keys(object).sort().reduce((t, cv, ci) => {
        if (object[cv] === void 0 || typeof object[cv] === "symbol") {
          return t;
        }
        const comma = t.length === 0 ? "" : ",";
        return t + comma + serialize(cv) + ":" + serialize(object[cv]);
      }, "") + "}";
    };
  }
});

// node_modules/jwt-decode/lib/atob.js
var require_atob = __commonJS({
  "node_modules/jwt-decode/lib/atob.js"(exports, module) {
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    function InvalidCharacterError(message) {
      this.message = message;
    }
    InvalidCharacterError.prototype = new Error();
    InvalidCharacterError.prototype.name = "InvalidCharacterError";
    function polyfill(input) {
      var str = String(input).replace(/=+$/, "");
      if (str.length % 4 == 1) {
        throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
      }
      for (
        var bc = 0, bs, buffer, idx = 0, output = "";
        // get next character
        buffer = str.charAt(idx++);
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
      ) {
        buffer = chars.indexOf(buffer);
      }
      return output;
    }
    module.exports = typeof window !== "undefined" && window.atob && window.atob.bind(window) || polyfill;
  }
});

// node_modules/jwt-decode/lib/base64_url_decode.js
var require_base64_url_decode = __commonJS({
  "node_modules/jwt-decode/lib/base64_url_decode.js"(exports, module) {
    var atob2 = require_atob();
    function b64DecodeUnicode(str) {
      return decodeURIComponent(atob2(str).replace(/(.)/g, function(m, p) {
        var code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) {
          code = "0" + code;
        }
        return "%" + code;
      }));
    }
    module.exports = function(str) {
      var output = str.replace(/-/g, "+").replace(/_/g, "/");
      switch (output.length % 4) {
        case 0:
          break;
        case 2:
          output += "==";
          break;
        case 3:
          output += "=";
          break;
        default:
          throw "Illegal base64url string!";
      }
      try {
        return b64DecodeUnicode(output);
      } catch (err) {
        return atob2(output);
      }
    };
  }
});

// node_modules/jwt-decode/lib/index.js
var require_lib = __commonJS({
  "node_modules/jwt-decode/lib/index.js"(exports, module) {
    "use strict";
    var base64_url_decode = require_base64_url_decode();
    function InvalidTokenError(message) {
      this.message = message;
    }
    InvalidTokenError.prototype = new Error();
    InvalidTokenError.prototype.name = "InvalidTokenError";
    module.exports = function(token, options) {
      if (typeof token !== "string") {
        throw new InvalidTokenError("Invalid token specified");
      }
      options = options || {};
      var pos = options.header === true ? 0 : 1;
      try {
        return JSON.parse(base64_url_decode(token.split(".")[pos]));
      } catch (e) {
        throw new InvalidTokenError("Invalid token specified: " + e.message);
      }
    };
    module.exports.InvalidTokenError = InvalidTokenError;
  }
});

// node_modules/js-base64/base64.js
var require_base64 = __commonJS({
  "node_modules/js-base64/base64.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (
        // cf. https://github.com/dankogai/js-base64/issues/119
        function() {
          var _Base64 = global2.Base64;
          var gBase64 = factory();
          gBase64.noConflict = function() {
            global2.Base64 = _Base64;
            return gBase64;
          };
          if (global2.Meteor) {
            Base64 = gBase64;
          }
          global2.Base64 = gBase64;
        }()
      );
    })(typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports, function() {
      "use strict";
      var version = "3.7.5";
      var VERSION = version;
      var _hasatob = typeof atob === "function";
      var _hasbtoa = typeof btoa === "function";
      var _hasBuffer = typeof Buffer === "function";
      var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
      var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
      var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var b64chs = Array.prototype.slice.call(b64ch);
      var b64tab = function(a) {
        var tab = {};
        a.forEach(function(c, i) {
          return tab[c] = i;
        });
        return tab;
      }(b64chs);
      var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
      var _fromCC = String.fromCharCode.bind(String);
      var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : function(it) {
        return new Uint8Array(Array.prototype.slice.call(it, 0));
      };
      var _mkUriSafe = function(src) {
        return src.replace(/=/g, "").replace(/[+\/]/g, function(m0) {
          return m0 == "+" ? "-" : "_";
        });
      };
      var _tidyB64 = function(s) {
        return s.replace(/[^A-Za-z0-9\+\/]/g, "");
      };
      var btoaPolyfill = function(bin) {
        var u32, c0, c1, c2, asc = "";
        var pad = bin.length % 3;
        for (var i = 0; i < bin.length; ) {
          if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
            throw new TypeError("invalid character found");
          u32 = c0 << 16 | c1 << 8 | c2;
          asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
        }
        return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
      };
      var _btoa = _hasbtoa ? function(bin) {
        return btoa(bin);
      } : _hasBuffer ? function(bin) {
        return Buffer.from(bin, "binary").toString("base64");
      } : btoaPolyfill;
      var _fromUint8Array = _hasBuffer ? function(u8a) {
        return Buffer.from(u8a).toString("base64");
      } : function(u8a) {
        var maxargs = 4096;
        var strs = [];
        for (var i = 0, l = u8a.length; i < l; i += maxargs) {
          strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
        }
        return _btoa(strs.join(""));
      };
      var fromUint8Array = function(u8a, urlsafe) {
        if (urlsafe === void 0) {
          urlsafe = false;
        }
        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
      };
      var cb_utob = function(c) {
        if (c.length < 2) {
          var cc = c.charCodeAt(0);
          return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        } else {
          var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
          return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        }
      };
      var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
      var utob = function(u) {
        return u.replace(re_utob, cb_utob);
      };
      var _encode = _hasBuffer ? function(s) {
        return Buffer.from(s, "utf8").toString("base64");
      } : _TE ? function(s) {
        return _fromUint8Array(_TE.encode(s));
      } : function(s) {
        return _btoa(utob(s));
      };
      var encode2 = function(src, urlsafe) {
        if (urlsafe === void 0) {
          urlsafe = false;
        }
        return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
      };
      var encodeURI = function(src) {
        return encode2(src, true);
      };
      var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
      var cb_btou = function(cccc) {
        switch (cccc.length) {
          case 4:
            var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
            return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
          case 3:
            return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
          default:
            return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
        }
      };
      var btou = function(b) {
        return b.replace(re_btou, cb_btou);
      };
      var atobPolyfill = function(asc) {
        asc = asc.replace(/\s+/g, "");
        if (!b64re.test(asc))
          throw new TypeError("malformed base64.");
        asc += "==".slice(2 - (asc.length & 3));
        var u24, bin = "", r1, r2;
        for (var i = 0; i < asc.length; ) {
          u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
          bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
        }
        return bin;
      };
      var _atob = _hasatob ? function(asc) {
        return atob(_tidyB64(asc));
      } : _hasBuffer ? function(asc) {
        return Buffer.from(asc, "base64").toString("binary");
      } : atobPolyfill;
      var _toUint8Array = _hasBuffer ? function(a) {
        return _U8Afrom(Buffer.from(a, "base64"));
      } : function(a) {
        return _U8Afrom(_atob(a).split("").map(function(c) {
          return c.charCodeAt(0);
        }));
      };
      var toUint8Array = function(a) {
        return _toUint8Array(_unURI(a));
      };
      var _decode = _hasBuffer ? function(a) {
        return Buffer.from(a, "base64").toString("utf8");
      } : _TD ? function(a) {
        return _TD.decode(_toUint8Array(a));
      } : function(a) {
        return btou(_atob(a));
      };
      var _unURI = function(a) {
        return _tidyB64(a.replace(/[-_]/g, function(m0) {
          return m0 == "-" ? "+" : "/";
        }));
      };
      var decode2 = function(src) {
        return _decode(_unURI(src));
      };
      var isValid = function(src) {
        if (typeof src !== "string")
          return false;
        var s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
        return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
      };
      var _noEnum = function(v) {
        return {
          value: v,
          enumerable: false,
          writable: true,
          configurable: true
        };
      };
      var extendString = function() {
        var _add = function(name, body) {
          return Object.defineProperty(String.prototype, name, _noEnum(body));
        };
        _add("fromBase64", function() {
          return decode2(this);
        });
        _add("toBase64", function(urlsafe) {
          return encode2(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return encode2(this, true);
        });
        _add("toBase64URL", function() {
          return encode2(this, true);
        });
        _add("toUint8Array", function() {
          return toUint8Array(this);
        });
      };
      var extendUint8Array = function() {
        var _add = function(name, body) {
          return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
        };
        _add("toBase64", function(urlsafe) {
          return fromUint8Array(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return fromUint8Array(this, true);
        });
        _add("toBase64URL", function() {
          return fromUint8Array(this, true);
        });
      };
      var extendBuiltins = function() {
        extendString();
        extendUint8Array();
      };
      var gBase64 = {
        version,
        VERSION,
        atob: _atob,
        atobPolyfill,
        btoa: _btoa,
        btoaPolyfill,
        fromBase64: decode2,
        toBase64: encode2,
        encode: encode2,
        encodeURI,
        encodeURL: encodeURI,
        utob,
        btou,
        decode: decode2,
        isValid,
        fromUint8Array,
        toUint8Array,
        extendString,
        extendUint8Array,
        extendBuiltins
      };
      gBase64.Base64 = {};
      Object.keys(gBase64).forEach(function(k) {
        return gBase64.Base64[k] = gBase64[k];
      });
      return gBase64;
    });
  }
});

// node_modules/eosjs/dist/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/eosjs/dist/ripemd.js"(exports, module) {
    "use strict";
    var _slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var RIPEMD160 = function() {
      function RIPEMD1602() {
        _classCallCheck(this, RIPEMD1602);
      }
      _createClass(RIPEMD1602, null, [{
        key: "get_n_pad_bytes",
        value: function get_n_pad_bytes(message_size) {
          return 64 - (message_size + 8 & 63);
        }
      }, {
        key: "pad",
        value: function pad(message) {
          var message_size = message.byteLength;
          var n_pad = RIPEMD1602.get_n_pad_bytes(message_size);
          var divmod = function divmod2(dividend, divisor) {
            return [Math.floor(dividend / divisor), dividend % divisor];
          };
          var _divmod$map = divmod(
            message_size,
            536870912
            /* (2 ** 29) */
          ).map(function(x, index) {
            return index ? x * 8 : x;
          }), _divmod$map2 = _slicedToArray(_divmod$map, 2), msg_bit_size_most = _divmod$map2[0], msg_bit_size_least = _divmod$map2[1];
          var padded = new Uint8Array(message_size + n_pad + 8);
          padded.set(new Uint8Array(message), 0);
          var data_view = new DataView(padded.buffer);
          data_view.setUint8(message_size, 128);
          data_view.setUint32(
            message_size + n_pad,
            msg_bit_size_least,
            true
            // Little-endian
          );
          data_view.setUint32(
            message_size + n_pad + 4,
            msg_bit_size_most,
            true
            // Little-endian
          );
          return padded.buffer;
        }
      }, {
        key: "f",
        value: function f2(j, x, y, z) {
          if (0 <= j && j <= 15) {
            return x ^ y ^ z;
          }
          if (16 <= j && j <= 31) {
            return x & y | ~x & z;
          }
          if (32 <= j && j <= 47) {
            return (x | ~y) ^ z;
          }
          if (48 <= j && j <= 63) {
            return x & z | y & ~z;
          }
          if (64 <= j && j <= 79) {
            return x ^ (y | ~z);
          }
        }
      }, {
        key: "K",
        value: function K(j) {
          if (0 <= j && j <= 15) {
            return 0;
          }
          if (16 <= j && j <= 31) {
            return 1518500249;
          }
          if (32 <= j && j <= 47) {
            return 1859775393;
          }
          if (48 <= j && j <= 63) {
            return 2400959708;
          }
          if (64 <= j && j <= 79) {
            return 2840853838;
          }
        }
      }, {
        key: "KP",
        value: function KP(j) {
          if (0 <= j && j <= 15) {
            return 1352829926;
          }
          if (16 <= j && j <= 31) {
            return 1548603684;
          }
          if (32 <= j && j <= 47) {
            return 1836072691;
          }
          if (48 <= j && j <= 63) {
            return 2053994217;
          }
          if (64 <= j && j <= 79) {
            return 0;
          }
        }
      }, {
        key: "add_modulo32",
        value: function add_modulo32() {
          return Array.from(arguments).reduce(function(a, b) {
            return a + b;
          }, 0) | 0;
        }
      }, {
        key: "rol32",
        value: function rol32(value, count) {
          return value << count | value >>> 32 - count;
        }
      }, {
        key: "hash",
        value: function hash(message) {
          var padded = RIPEMD1602.pad(message);
          var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
          var rP = [
            // r'
            5,
            14,
            7,
            0,
            9,
            2,
            11,
            4,
            13,
            6,
            15,
            8,
            1,
            10,
            3,
            12,
            6,
            11,
            3,
            7,
            0,
            13,
            5,
            10,
            14,
            15,
            8,
            12,
            4,
            9,
            1,
            2,
            15,
            5,
            1,
            3,
            7,
            14,
            6,
            9,
            11,
            8,
            12,
            2,
            10,
            0,
            4,
            13,
            8,
            6,
            4,
            1,
            3,
            11,
            15,
            0,
            5,
            12,
            2,
            13,
            9,
            7,
            10,
            14,
            12,
            15,
            10,
            4,
            1,
            5,
            8,
            7,
            6,
            2,
            13,
            14,
            0,
            3,
            9,
            11
          ];
          var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
          var sP = [
            // s'
            8,
            9,
            9,
            11,
            13,
            15,
            15,
            5,
            7,
            7,
            8,
            11,
            14,
            14,
            12,
            6,
            9,
            13,
            15,
            7,
            12,
            8,
            9,
            11,
            7,
            7,
            12,
            7,
            6,
            15,
            13,
            11,
            9,
            7,
            15,
            11,
            8,
            6,
            6,
            14,
            12,
            13,
            5,
            14,
            13,
            13,
            7,
            5,
            15,
            5,
            8,
            11,
            14,
            14,
            6,
            14,
            6,
            9,
            12,
            9,
            12,
            5,
            15,
            8,
            8,
            5,
            12,
            9,
            12,
            5,
            14,
            6,
            8,
            13,
            6,
            5,
            15,
            13,
            11,
            11
          ];
          var word_size = 4;
          var block_size = 64;
          var t = padded.byteLength / block_size;
          var X = new Array(t).fill(void 0).map(function(_, i2) {
            return function(j2) {
              return new DataView(padded, i2 * block_size, block_size).getUint32(
                j2 * word_size,
                true
                // Little-endian
              );
            };
          });
          var h = [
            1732584193,
            // h_0
            4023233417,
            // h_1
            2562383102,
            // h_2
            271733878,
            // h_3
            3285377520
            // h_4
          ];
          for (var i = 0; i < t; ++i) {
            var A = h[0], B = h[1], C = h[2], D = h[3], E = h[4];
            var AP = A, BP = B, CP = C, DP = D, EP = E;
            for (var j = 0; j < 80; ++j) {
              var _T = RIPEMD1602.add_modulo32(RIPEMD1602.rol32(RIPEMD1602.add_modulo32(A, RIPEMD1602.f(j, B, C, D), X[i](r[j]), RIPEMD1602.K(j)), s[j]), E);
              A = E;
              E = D;
              D = RIPEMD1602.rol32(C, 10);
              C = B;
              B = _T;
              _T = RIPEMD1602.add_modulo32(RIPEMD1602.rol32(RIPEMD1602.add_modulo32(AP, RIPEMD1602.f(79 - j, BP, CP, DP), X[i](rP[j]), RIPEMD1602.KP(j)), sP[j]), EP);
              AP = EP;
              EP = DP;
              DP = RIPEMD1602.rol32(CP, 10);
              CP = BP;
              BP = _T;
            }
            var T = RIPEMD1602.add_modulo32(h[1], C, DP);
            h[1] = RIPEMD1602.add_modulo32(h[2], D, EP);
            h[2] = RIPEMD1602.add_modulo32(h[3], E, AP);
            h[3] = RIPEMD1602.add_modulo32(h[4], A, BP);
            h[4] = RIPEMD1602.add_modulo32(h[0], B, CP);
            h[0] = T;
          }
          var result = new ArrayBuffer(20);
          var data_view = new DataView(result);
          h.forEach(function(h_i, i2) {
            return data_view.setUint32(i2 * 4, h_i, true);
          });
          return result;
        }
      }]);
      return RIPEMD1602;
    }();
    module.exports = {
      RIPEMD160
    };
  }
});

// node_modules/eosjs/dist/eosjs-numeric.js
var require_eosjs_numeric = __commonJS({
  "node_modules/eosjs/dist/eosjs-numeric.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spread = exports && exports.__spread || function() {
      for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    var __values2 = exports && exports.__values || function(o) {
      var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
      if (m)
        return m.call(o);
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ripemd160 = require_ripemd().RIPEMD160.hash;
    var base58Chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    var base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    function create_base58_map() {
      var base58M = Array(256).fill(-1);
      for (var i = 0; i < base58Chars.length; ++i) {
        base58M[base58Chars.charCodeAt(i)] = i;
      }
      return base58M;
    }
    var base58Map = create_base58_map();
    function create_base64_map() {
      var base64M = Array(256).fill(-1);
      for (var i = 0; i < base64Chars.length; ++i) {
        base64M[base64Chars.charCodeAt(i)] = i;
      }
      base64M["=".charCodeAt(0)] = 0;
      return base64M;
    }
    var base64Map = create_base64_map();
    function isNegative(bignum) {
      return (bignum[bignum.length - 1] & 128) !== 0;
    }
    exports.isNegative = isNegative;
    function negate(bignum) {
      var carry = 1;
      for (var i = 0; i < bignum.length; ++i) {
        var x = (~bignum[i] & 255) + carry;
        bignum[i] = x;
        carry = x >> 8;
      }
    }
    exports.negate = negate;
    function decimalToBinary(size, s) {
      var result = new Uint8Array(size);
      for (var i = 0; i < s.length; ++i) {
        var srcDigit = s.charCodeAt(i);
        if (srcDigit < "0".charCodeAt(0) || srcDigit > "9".charCodeAt(0)) {
          throw new Error("invalid number");
        }
        var carry = srcDigit - "0".charCodeAt(0);
        for (var j = 0; j < size; ++j) {
          var x = result[j] * 10 + carry;
          result[j] = x;
          carry = x >> 8;
        }
        if (carry) {
          throw new Error("number is out of range");
        }
      }
      return result;
    }
    exports.decimalToBinary = decimalToBinary;
    function signedDecimalToBinary(size, s) {
      var negative = s[0] === "-";
      if (negative) {
        s = s.substr(1);
      }
      var result = decimalToBinary(size, s);
      if (negative) {
        negate(result);
        if (!isNegative(result)) {
          throw new Error("number is out of range");
        }
      } else if (isNegative(result)) {
        throw new Error("number is out of range");
      }
      return result;
    }
    exports.signedDecimalToBinary = signedDecimalToBinary;
    function binaryToDecimal(bignum, minDigits) {
      if (minDigits === void 0) {
        minDigits = 1;
      }
      var result = Array(minDigits).fill("0".charCodeAt(0));
      for (var i = bignum.length - 1; i >= 0; --i) {
        var carry = bignum[i];
        for (var j = 0; j < result.length; ++j) {
          var x = (result[j] - "0".charCodeAt(0) << 8) + carry;
          result[j] = "0".charCodeAt(0) + x % 10;
          carry = x / 10 | 0;
        }
        while (carry) {
          result.push("0".charCodeAt(0) + carry % 10);
          carry = carry / 10 | 0;
        }
      }
      result.reverse();
      return String.fromCharCode.apply(String, __spread(result));
    }
    exports.binaryToDecimal = binaryToDecimal;
    function signedBinaryToDecimal(bignum, minDigits) {
      if (minDigits === void 0) {
        minDigits = 1;
      }
      if (isNegative(bignum)) {
        var x = bignum.slice();
        negate(x);
        return "-" + binaryToDecimal(x, minDigits);
      }
      return binaryToDecimal(bignum, minDigits);
    }
    exports.signedBinaryToDecimal = signedBinaryToDecimal;
    function base58ToBinary(size, s) {
      var result = new Uint8Array(size);
      for (var i = 0; i < s.length; ++i) {
        var carry = base58Map[s.charCodeAt(i)];
        if (carry < 0) {
          throw new Error("invalid base-58 value");
        }
        for (var j = 0; j < size; ++j) {
          var x = result[j] * 58 + carry;
          result[j] = x;
          carry = x >> 8;
        }
        if (carry) {
          throw new Error("base-58 value is out of range");
        }
      }
      result.reverse();
      return result;
    }
    exports.base58ToBinary = base58ToBinary;
    function binaryToBase58(bignum, minDigits) {
      if (minDigits === void 0) {
        minDigits = 1;
      }
      var e_1, _a2, e_2, _b2;
      var result = [];
      try {
        for (var bignum_1 = __values2(bignum), bignum_1_1 = bignum_1.next(); !bignum_1_1.done; bignum_1_1 = bignum_1.next()) {
          var byte = bignum_1_1.value;
          var carry = byte;
          for (var j = 0; j < result.length; ++j) {
            var x = (base58Map[result[j]] << 8) + carry;
            result[j] = base58Chars.charCodeAt(x % 58);
            carry = x / 58 | 0;
          }
          while (carry) {
            result.push(base58Chars.charCodeAt(carry % 58));
            carry = carry / 58 | 0;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (bignum_1_1 && !bignum_1_1.done && (_a2 = bignum_1.return))
            _a2.call(bignum_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      try {
        for (var bignum_2 = __values2(bignum), bignum_2_1 = bignum_2.next(); !bignum_2_1.done; bignum_2_1 = bignum_2.next()) {
          var byte = bignum_2_1.value;
          if (byte) {
            break;
          } else {
            result.push("1".charCodeAt(0));
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (bignum_2_1 && !bignum_2_1.done && (_b2 = bignum_2.return))
            _b2.call(bignum_2);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      result.reverse();
      return String.fromCharCode.apply(String, __spread(result));
    }
    exports.binaryToBase58 = binaryToBase58;
    function base64ToBinary(s) {
      var len = s.length;
      if ((len & 3) === 1 && s[len - 1] === "=") {
        len -= 1;
      }
      if ((len & 3) !== 0) {
        throw new Error("base-64 value is not padded correctly");
      }
      var groups = len >> 2;
      var bytes = groups * 3;
      if (len > 0 && s[len - 1] === "=") {
        if (s[len - 2] === "=") {
          bytes -= 2;
        } else {
          bytes -= 1;
        }
      }
      var result = new Uint8Array(bytes);
      for (var group = 0; group < groups; ++group) {
        var digit0 = base64Map[s.charCodeAt(group * 4 + 0)];
        var digit1 = base64Map[s.charCodeAt(group * 4 + 1)];
        var digit2 = base64Map[s.charCodeAt(group * 4 + 2)];
        var digit3 = base64Map[s.charCodeAt(group * 4 + 3)];
        result[group * 3 + 0] = digit0 << 2 | digit1 >> 4;
        if (group * 3 + 1 < bytes) {
          result[group * 3 + 1] = (digit1 & 15) << 4 | digit2 >> 2;
        }
        if (group * 3 + 2 < bytes) {
          result[group * 3 + 2] = (digit2 & 3) << 6 | digit3;
        }
      }
      return result;
    }
    exports.base64ToBinary = base64ToBinary;
    var KeyType;
    (function(KeyType2) {
      KeyType2[KeyType2["k1"] = 0] = "k1";
      KeyType2[KeyType2["r1"] = 1] = "r1";
    })(KeyType = exports.KeyType || (exports.KeyType = {}));
    exports.publicKeyDataSize = 33;
    exports.privateKeyDataSize = 32;
    exports.signatureDataSize = 65;
    function digestSuffixRipemd160(data, suffix) {
      var d = new Uint8Array(data.length + suffix.length);
      for (var i = 0; i < data.length; ++i) {
        d[i] = data[i];
      }
      for (var i = 0; i < suffix.length; ++i) {
        d[data.length + i] = suffix.charCodeAt(i);
      }
      return ripemd160(d);
    }
    function stringToKey(s, type, size, suffix) {
      var whole = base58ToBinary(size + 4, s);
      var result = { type, data: new Uint8Array(whole.buffer, 0, size) };
      var digest = new Uint8Array(digestSuffixRipemd160(result.data, suffix));
      if (digest[0] !== whole[size + 0] || digest[1] !== whole[size + 1] || digest[2] !== whole[size + 2] || digest[3] !== whole[size + 3]) {
        throw new Error("checksum doesn't match");
      }
      return result;
    }
    function keyToString(key, suffix, prefix) {
      var digest = new Uint8Array(digestSuffixRipemd160(key.data, suffix));
      var whole = new Uint8Array(key.data.length + 4);
      for (var i = 0; i < key.data.length; ++i) {
        whole[i] = key.data[i];
      }
      for (var i = 0; i < 4; ++i) {
        whole[i + key.data.length] = digest[i];
      }
      return prefix + binaryToBase58(whole);
    }
    function stringToPublicKey(s) {
      if (typeof s !== "string") {
        throw new Error("expected string containing public key");
      }
      if (s.substr(0, 3) === "EOS") {
        var whole = base58ToBinary(exports.publicKeyDataSize + 4, s.substr(3));
        var key = { type: KeyType.k1, data: new Uint8Array(exports.publicKeyDataSize) };
        for (var i = 0; i < exports.publicKeyDataSize; ++i) {
          key.data[i] = whole[i];
        }
        var digest = new Uint8Array(ripemd160(key.data));
        if (digest[0] !== whole[exports.publicKeyDataSize] || digest[1] !== whole[34] || digest[2] !== whole[35] || digest[3] !== whole[36]) {
          throw new Error("checksum doesn't match");
        }
        return key;
      } else if (s.substr(0, 7) === "PUB_K1_") {
        return stringToKey(s.substr(7), KeyType.k1, exports.publicKeyDataSize, "K1");
      } else if (s.substr(0, 7) === "PUB_R1_") {
        return stringToKey(s.substr(7), KeyType.r1, exports.publicKeyDataSize, "R1");
      } else {
        throw new Error("unrecognized public key format");
      }
    }
    exports.stringToPublicKey = stringToPublicKey;
    function publicKeyToString(key) {
      if (key.type === KeyType.k1 && key.data.length === exports.publicKeyDataSize) {
        return keyToString(key, "K1", "PUB_K1_");
      } else if (key.type === KeyType.r1 && key.data.length === exports.publicKeyDataSize) {
        return keyToString(key, "R1", "PUB_R1_");
      } else {
        throw new Error("unrecognized public key format");
      }
    }
    exports.publicKeyToString = publicKeyToString;
    function convertLegacyPublicKey(s) {
      if (s.substr(0, 3) === "EOS") {
        return publicKeyToString(stringToPublicKey(s));
      }
      return s;
    }
    exports.convertLegacyPublicKey = convertLegacyPublicKey;
    function convertLegacyPublicKeys(keys) {
      return keys.map(convertLegacyPublicKey);
    }
    exports.convertLegacyPublicKeys = convertLegacyPublicKeys;
    function stringToPrivateKey(s) {
      if (typeof s !== "string") {
        throw new Error("expected string containing private key");
      }
      if (s.substr(0, 7) === "PVT_R1_") {
        return stringToKey(s.substr(7), KeyType.r1, exports.privateKeyDataSize, "R1");
      } else {
        throw new Error("unrecognized private key format");
      }
    }
    exports.stringToPrivateKey = stringToPrivateKey;
    function privateKeyToString(key) {
      if (key.type === KeyType.r1) {
        return keyToString(key, "R1", "PVT_R1_");
      } else {
        throw new Error("unrecognized private key format");
      }
    }
    exports.privateKeyToString = privateKeyToString;
    function stringToSignature(s) {
      if (typeof s !== "string") {
        throw new Error("expected string containing signature");
      }
      if (s.substr(0, 7) === "SIG_K1_") {
        return stringToKey(s.substr(7), KeyType.k1, exports.signatureDataSize, "K1");
      } else if (s.substr(0, 7) === "SIG_R1_") {
        return stringToKey(s.substr(7), KeyType.r1, exports.signatureDataSize, "R1");
      } else {
        throw new Error("unrecognized signature format");
      }
    }
    exports.stringToSignature = stringToSignature;
    function signatureToString(signature) {
      if (signature.type === KeyType.k1) {
        return keyToString(signature, "K1", "SIG_K1_");
      } else if (signature.type === KeyType.r1) {
        return keyToString(signature, "R1", "SIG_R1_");
      } else {
        throw new Error("unrecognized signature format");
      }
    }
    exports.signatureToString = signatureToString;
  }
});

// node_modules/eosjs/dist/eosjs-serialize.js
var require_eosjs_serialize = __commonJS({
  "node_modules/eosjs/dist/eosjs-serialize.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spread = exports && exports.__spread || function() {
      for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    var __values2 = exports && exports.__values || function(o) {
      var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
      if (m)
        return m.call(o);
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var numeric = require_eosjs_numeric();
    var SerializerState = (
      /** @class */
      function() {
        function SerializerState2(options) {
          if (options === void 0) {
            options = {};
          }
          this.skippedBinaryExtension = false;
          this.options = options;
        }
        return SerializerState2;
      }()
    );
    exports.SerializerState = SerializerState;
    var SerialBuffer = (
      /** @class */
      function() {
        function SerialBuffer2(_a2) {
          var _b2 = _a2 === void 0 ? {} : _a2, textEncoder = _b2.textEncoder, textDecoder = _b2.textDecoder, array = _b2.array;
          this.readPos = 0;
          this.array = array || new Uint8Array(1024);
          this.length = array ? array.length : 0;
          this.textEncoder = textEncoder || new TextEncoder();
          this.textDecoder = textDecoder || new TextDecoder("utf-8", { fatal: true });
        }
        SerialBuffer2.prototype.reserve = function(size) {
          if (this.length + size <= this.array.length) {
            return;
          }
          var l = this.array.length;
          while (this.length + size > l) {
            l = Math.ceil(l * 1.5);
          }
          var newArray = new Uint8Array(l);
          newArray.set(this.array);
          this.array = newArray;
        };
        SerialBuffer2.prototype.haveReadData = function() {
          return this.readPos < this.length;
        };
        SerialBuffer2.prototype.restartRead = function() {
          this.readPos = 0;
        };
        SerialBuffer2.prototype.asUint8Array = function() {
          return new Uint8Array(this.array.buffer, this.array.byteOffset, this.length);
        };
        SerialBuffer2.prototype.pushArray = function(v) {
          this.reserve(v.length);
          this.array.set(v, this.length);
          this.length += v.length;
        };
        SerialBuffer2.prototype.push = function() {
          var v = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            v[_i] = arguments[_i];
          }
          this.pushArray(v);
        };
        SerialBuffer2.prototype.get = function() {
          if (this.readPos < this.length) {
            return this.array[this.readPos++];
          }
          throw new Error("Read past end of buffer");
        };
        SerialBuffer2.prototype.pushUint8ArrayChecked = function(v, len) {
          if (v.length !== len) {
            throw new Error("Binary data has incorrect size");
          }
          this.pushArray(v);
        };
        SerialBuffer2.prototype.getUint8Array = function(len) {
          if (this.readPos + len > this.length) {
            throw new Error("Read past end of buffer");
          }
          var result = new Uint8Array(this.array.buffer, this.array.byteOffset + this.readPos, len);
          this.readPos += len;
          return result;
        };
        SerialBuffer2.prototype.pushUint16 = function(v) {
          this.push(v >> 0 & 255, v >> 8 & 255);
        };
        SerialBuffer2.prototype.getUint16 = function() {
          var v = 0;
          v |= this.get() << 0;
          v |= this.get() << 8;
          return v;
        };
        SerialBuffer2.prototype.pushUint32 = function(v) {
          this.push(v >> 0 & 255, v >> 8 & 255, v >> 16 & 255, v >> 24 & 255);
        };
        SerialBuffer2.prototype.getUint32 = function() {
          var v = 0;
          v |= this.get() << 0;
          v |= this.get() << 8;
          v |= this.get() << 16;
          v |= this.get() << 24;
          return v >>> 0;
        };
        SerialBuffer2.prototype.pushNumberAsUint64 = function(v) {
          this.pushUint32(v >>> 0);
          this.pushUint32(Math.floor(v / 4294967296) >>> 0);
        };
        SerialBuffer2.prototype.getUint64AsNumber = function() {
          var low = this.getUint32();
          var high = this.getUint32();
          return (high >>> 0) * 4294967296 + (low >>> 0);
        };
        SerialBuffer2.prototype.pushVaruint32 = function(v) {
          while (true) {
            if (v >>> 7) {
              this.push(128 | v & 127);
              v = v >>> 7;
            } else {
              this.push(v);
              break;
            }
          }
        };
        SerialBuffer2.prototype.getVaruint32 = function() {
          var v = 0;
          var bit = 0;
          while (true) {
            var b = this.get();
            v |= (b & 127) << bit;
            bit += 7;
            if (!(b & 128)) {
              break;
            }
          }
          return v >>> 0;
        };
        SerialBuffer2.prototype.pushVarint32 = function(v) {
          this.pushVaruint32(v << 1 ^ v >> 31);
        };
        SerialBuffer2.prototype.getVarint32 = function() {
          var v = this.getVaruint32();
          if (v & 1) {
            return ~v >> 1 | 2147483648;
          } else {
            return v >>> 1;
          }
        };
        SerialBuffer2.prototype.pushFloat32 = function(v) {
          this.pushArray(new Uint8Array(new Float32Array([v]).buffer));
        };
        SerialBuffer2.prototype.getFloat32 = function() {
          return new Float32Array(this.getUint8Array(4).slice().buffer)[0];
        };
        SerialBuffer2.prototype.pushFloat64 = function(v) {
          this.pushArray(new Uint8Array(new Float64Array([v]).buffer));
        };
        SerialBuffer2.prototype.getFloat64 = function() {
          return new Float64Array(this.getUint8Array(8).slice().buffer)[0];
        };
        SerialBuffer2.prototype.pushName = function(s) {
          if (typeof s !== "string") {
            throw new Error("Expected string containing name");
          }
          function charToSymbol(c2) {
            if (c2 >= "a".charCodeAt(0) && c2 <= "z".charCodeAt(0)) {
              return c2 - "a".charCodeAt(0) + 6;
            }
            if (c2 >= "1".charCodeAt(0) && c2 <= "5".charCodeAt(0)) {
              return c2 - "1".charCodeAt(0) + 1;
            }
            return 0;
          }
          var a = new Uint8Array(8);
          var bit = 63;
          for (var i = 0; i < s.length; ++i) {
            var c = charToSymbol(s.charCodeAt(i));
            if (bit < 5) {
              c = c << 1;
            }
            for (var j = 4; j >= 0; --j) {
              if (bit >= 0) {
                a[Math.floor(bit / 8)] |= (c >> j & 1) << bit % 8;
                --bit;
              }
            }
          }
          this.pushArray(a);
        };
        SerialBuffer2.prototype.getName = function() {
          var a = this.getUint8Array(8);
          var result = "";
          for (var bit = 63; bit >= 0; ) {
            var c = 0;
            for (var i = 0; i < 5; ++i) {
              if (bit >= 0) {
                c = c << 1 | a[Math.floor(bit / 8)] >> bit % 8 & 1;
                --bit;
              }
            }
            if (c >= 6) {
              result += String.fromCharCode(c + "a".charCodeAt(0) - 6);
            } else if (c >= 1) {
              result += String.fromCharCode(c + "1".charCodeAt(0) - 1);
            } else {
              result += ".";
            }
          }
          while (result.endsWith(".")) {
            result = result.substr(0, result.length - 1);
          }
          return result;
        };
        SerialBuffer2.prototype.pushBytes = function(v) {
          this.pushVaruint32(v.length);
          this.pushArray(v);
        };
        SerialBuffer2.prototype.getBytes = function() {
          return this.getUint8Array(this.getVaruint32());
        };
        SerialBuffer2.prototype.pushString = function(v) {
          this.pushBytes(this.textEncoder.encode(v));
        };
        SerialBuffer2.prototype.getString = function() {
          return this.textDecoder.decode(this.getBytes());
        };
        SerialBuffer2.prototype.pushSymbolCode = function(name) {
          if (typeof name !== "string") {
            throw new Error("Expected string containing symbol_code");
          }
          var a = [];
          a.push.apply(a, __spread(this.textEncoder.encode(name)));
          while (a.length < 8) {
            a.push(0);
          }
          this.pushArray(a.slice(0, 8));
        };
        SerialBuffer2.prototype.getSymbolCode = function() {
          var a = this.getUint8Array(8);
          var len;
          for (len = 0; len < a.length; ++len) {
            if (!a[len]) {
              break;
            }
          }
          var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
          return name;
        };
        SerialBuffer2.prototype.pushSymbol = function(_a2) {
          var name = _a2.name, precision = _a2.precision;
          var a = [precision & 255];
          a.push.apply(a, __spread(this.textEncoder.encode(name)));
          while (a.length < 8) {
            a.push(0);
          }
          this.pushArray(a.slice(0, 8));
        };
        SerialBuffer2.prototype.getSymbol = function() {
          var precision = this.get();
          var a = this.getUint8Array(7);
          var len;
          for (len = 0; len < a.length; ++len) {
            if (!a[len]) {
              break;
            }
          }
          var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
          return { name, precision };
        };
        SerialBuffer2.prototype.pushAsset = function(s) {
          if (typeof s !== "string") {
            throw new Error("Expected string containing asset");
          }
          s = s.trim();
          var pos = 0;
          var amount = "";
          var precision = 0;
          if (s[pos] === "-") {
            amount += "-";
            ++pos;
          }
          var foundDigit = false;
          while (pos < s.length && s.charCodeAt(pos) >= "0".charCodeAt(0) && s.charCodeAt(pos) <= "9".charCodeAt(0)) {
            foundDigit = true;
            amount += s[pos];
            ++pos;
          }
          if (!foundDigit) {
            throw new Error("Asset must begin with a number");
          }
          if (s[pos] === ".") {
            ++pos;
            while (pos < s.length && s.charCodeAt(pos) >= "0".charCodeAt(0) && s.charCodeAt(pos) <= "9".charCodeAt(0)) {
              amount += s[pos];
              ++precision;
              ++pos;
            }
          }
          var name = s.substr(pos).trim();
          this.pushArray(numeric.signedDecimalToBinary(8, amount));
          this.pushSymbol({ name, precision });
        };
        SerialBuffer2.prototype.getAsset = function() {
          var amount = this.getUint8Array(8);
          var _a2 = this.getSymbol(), name = _a2.name, precision = _a2.precision;
          var s = numeric.signedBinaryToDecimal(amount, precision + 1);
          if (precision) {
            s = s.substr(0, s.length - precision) + "." + s.substr(s.length - precision);
          }
          return s + " " + name;
        };
        SerialBuffer2.prototype.pushPublicKey = function(s) {
          var key = numeric.stringToPublicKey(s);
          this.push(key.type);
          this.pushArray(key.data);
        };
        SerialBuffer2.prototype.getPublicKey = function() {
          var type = this.get();
          var data = this.getUint8Array(numeric.publicKeyDataSize);
          return numeric.publicKeyToString({ type, data });
        };
        SerialBuffer2.prototype.pushPrivateKey = function(s) {
          var key = numeric.stringToPrivateKey(s);
          this.push(key.type);
          this.pushArray(key.data);
        };
        SerialBuffer2.prototype.getPrivateKey = function() {
          var type = this.get();
          var data = this.getUint8Array(numeric.privateKeyDataSize);
          return numeric.privateKeyToString({ type, data });
        };
        SerialBuffer2.prototype.pushSignature = function(s) {
          var key = numeric.stringToSignature(s);
          this.push(key.type);
          this.pushArray(key.data);
        };
        SerialBuffer2.prototype.getSignature = function() {
          var type = this.get();
          var data = this.getUint8Array(numeric.signatureDataSize);
          return numeric.signatureToString({ type, data });
        };
        return SerialBuffer2;
      }()
    );
    exports.SerialBuffer = SerialBuffer;
    function supportedAbiVersion(version) {
      return version.startsWith("eosio::abi/1.");
    }
    exports.supportedAbiVersion = supportedAbiVersion;
    function checkDateParse(date) {
      var result = Date.parse(date);
      if (Number.isNaN(result)) {
        throw new Error("Invalid time format");
      }
      return result;
    }
    function dateToTimePoint(date) {
      return Math.round(checkDateParse(date + "Z") * 1e3);
    }
    exports.dateToTimePoint = dateToTimePoint;
    function timePointToDate(us) {
      var s = new Date(us / 1e3).toISOString();
      return s.substr(0, s.length - 1);
    }
    exports.timePointToDate = timePointToDate;
    function dateToTimePointSec(date) {
      return Math.round(checkDateParse(date + "Z") / 1e3);
    }
    exports.dateToTimePointSec = dateToTimePointSec;
    function timePointSecToDate(sec) {
      var s = new Date(sec * 1e3).toISOString();
      return s.substr(0, s.length - 1);
    }
    exports.timePointSecToDate = timePointSecToDate;
    function dateToBlockTimestamp(date) {
      return Math.round((checkDateParse(date + "Z") - 9466848e5) / 500);
    }
    exports.dateToBlockTimestamp = dateToBlockTimestamp;
    function blockTimestampToDate(slot) {
      var s = new Date(slot * 500 + 9466848e5).toISOString();
      return s.substr(0, s.length - 1);
    }
    exports.blockTimestampToDate = blockTimestampToDate;
    function stringToSymbol(s) {
      if (typeof s !== "string") {
        throw new Error("Expected string containing symbol");
      }
      var m = s.match(/^([0-9]+),([A-Z]+)$/);
      if (!m) {
        throw new Error("Invalid symbol");
      }
      return { name: m[2], precision: +m[1] };
    }
    exports.stringToSymbol = stringToSymbol;
    function symbolToString(_a2) {
      var name = _a2.name, precision = _a2.precision;
      return precision + "," + name;
    }
    exports.symbolToString = symbolToString;
    function arrayToHex(data) {
      var e_1, _a2;
      var result = "";
      try {
        for (var data_1 = __values2(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
          var x = data_1_1.value;
          result += ("00" + x.toString(16)).slice(-2);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (data_1_1 && !data_1_1.done && (_a2 = data_1.return))
            _a2.call(data_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return result.toUpperCase();
    }
    exports.arrayToHex = arrayToHex;
    function hexToUint8Array(hex) {
      if (typeof hex !== "string") {
        throw new Error("Expected string containing hex digits");
      }
      if (hex.length % 2) {
        throw new Error("Odd number of hex digits");
      }
      var l = hex.length / 2;
      var result = new Uint8Array(l);
      for (var i = 0; i < l; ++i) {
        var x = parseInt(hex.substr(i * 2, 2), 16);
        if (Number.isNaN(x)) {
          throw new Error("Expected hex string");
        }
        result[i] = x;
      }
      return result;
    }
    exports.hexToUint8Array = hexToUint8Array;
    function serializeUnknown(buffer, data) {
      throw new Error("Don't know how to serialize " + this.name);
    }
    function deserializeUnknown(buffer) {
      throw new Error("Don't know how to deserialize " + this.name);
    }
    function serializeStruct(buffer, data, state, allowExtensions) {
      if (state === void 0) {
        state = new SerializerState();
      }
      if (allowExtensions === void 0) {
        allowExtensions = true;
      }
      var e_2, _a2;
      if (typeof data !== "object") {
        throw new Error("expected object containing data: " + JSON.stringify(data));
      }
      if (this.base) {
        this.base.serialize(buffer, data, state, allowExtensions);
      }
      try {
        for (var _b2 = __values2(this.fields), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
          var field = _c2.value;
          if (field.name in data) {
            if (state.skippedBinaryExtension) {
              throw new Error("unexpected " + this.name + "." + field.name);
            }
            field.type.serialize(buffer, data[field.name], state, allowExtensions && field === this.fields[this.fields.length - 1]);
          } else {
            if (allowExtensions && field.type.extensionOf) {
              state.skippedBinaryExtension = true;
            } else {
              throw new Error("missing " + this.name + "." + field.name + " (type=" + field.type.name + ")");
            }
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_c2 && !_c2.done && (_a2 = _b2.return))
            _a2.call(_b2);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
    function deserializeStruct(buffer, state, allowExtensions) {
      if (state === void 0) {
        state = new SerializerState();
      }
      if (allowExtensions === void 0) {
        allowExtensions = true;
      }
      var e_3, _a2;
      var result;
      if (this.base) {
        result = this.base.deserialize(buffer, state, allowExtensions);
      } else {
        result = {};
      }
      try {
        for (var _b2 = __values2(this.fields), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
          var field = _c2.value;
          if (allowExtensions && field.type.extensionOf && !buffer.haveReadData()) {
            state.skippedBinaryExtension = true;
          } else {
            result[field.name] = field.type.deserialize(buffer, state, allowExtensions);
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_c2 && !_c2.done && (_a2 = _b2.return))
            _a2.call(_b2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return result;
    }
    function serializeVariant(buffer, data, state, allowExtensions) {
      if (!Array.isArray(data) || data.length !== 2 || typeof data[0] !== "string") {
        throw new Error('expected variant: ["type", value]');
      }
      var i = this.fields.findIndex(function(field) {
        return field.name === data[0];
      });
      if (i < 0) {
        throw new Error('type "' + data[0] + '" is not valid for variant');
      }
      buffer.pushVaruint32(i);
      this.fields[i].type.serialize(buffer, data[1], state, allowExtensions);
    }
    function deserializeVariant(buffer, state, allowExtensions) {
      var i = buffer.getVaruint32();
      if (i >= this.fields.length) {
        throw new Error("type index " + i + " is not valid for variant");
      }
      var field = this.fields[i];
      return [field.name, field.type.deserialize(buffer, state, allowExtensions)];
    }
    function serializeArray(buffer, data, state, allowExtensions) {
      var e_4, _a2;
      buffer.pushVaruint32(data.length);
      try {
        for (var data_2 = __values2(data), data_2_1 = data_2.next(); !data_2_1.done; data_2_1 = data_2.next()) {
          var item = data_2_1.value;
          this.arrayOf.serialize(buffer, item, state, false);
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (data_2_1 && !data_2_1.done && (_a2 = data_2.return))
            _a2.call(data_2);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
    }
    function deserializeArray(buffer, state, allowExtensions) {
      var len = buffer.getVaruint32();
      var result = [];
      for (var i = 0; i < len; ++i) {
        result.push(this.arrayOf.deserialize(buffer, state, false));
      }
      return result;
    }
    function serializeOptional(buffer, data, state, allowExtensions) {
      if (data === null || data === void 0) {
        buffer.push(0);
      } else {
        buffer.push(1);
        this.optionalOf.serialize(buffer, data, state, allowExtensions);
      }
    }
    function deserializeOptional(buffer, state, allowExtensions) {
      if (buffer.get()) {
        return this.optionalOf.deserialize(buffer, state, allowExtensions);
      } else {
        return null;
      }
    }
    function serializeExtension(buffer, data, state, allowExtensions) {
      this.extensionOf.serialize(buffer, data, state, allowExtensions);
    }
    function deserializeExtension(buffer, state, allowExtensions) {
      return this.extensionOf.deserialize(buffer, state, allowExtensions);
    }
    function createType(attrs) {
      return __assign({ name: "<missing name>", aliasOfName: "", arrayOf: null, optionalOf: null, extensionOf: null, baseName: "", base: null, fields: [], serialize: serializeUnknown, deserialize: deserializeUnknown }, attrs);
    }
    function checkRange(orig, converted) {
      if (Number.isNaN(+orig) || Number.isNaN(+converted) || typeof orig !== "number" && typeof orig !== "string") {
        throw new Error("Expected number");
      }
      if (+orig !== +converted) {
        throw new Error("Number is out of range");
      }
      return +orig;
    }
    function createInitialTypes() {
      var result = new Map(Object.entries({
        bool: createType({
          name: "bool",
          serialize: function(buffer, data) {
            if (typeof data !== "boolean") {
              throw new Error("Expected true or false");
            }
            buffer.push(data ? 1 : 0);
          },
          deserialize: function(buffer) {
            return !!buffer.get();
          }
        }),
        uint8: createType({
          name: "uint8",
          serialize: function(buffer, data) {
            buffer.push(checkRange(data, data & 255));
          },
          deserialize: function(buffer) {
            return buffer.get();
          }
        }),
        int8: createType({
          name: "int8",
          serialize: function(buffer, data) {
            buffer.push(checkRange(data, data << 24 >> 24));
          },
          deserialize: function(buffer) {
            return buffer.get() << 24 >> 24;
          }
        }),
        uint16: createType({
          name: "uint16",
          serialize: function(buffer, data) {
            buffer.pushUint16(checkRange(data, data & 65535));
          },
          deserialize: function(buffer) {
            return buffer.getUint16();
          }
        }),
        int16: createType({
          name: "int16",
          serialize: function(buffer, data) {
            buffer.pushUint16(checkRange(data, data << 16 >> 16));
          },
          deserialize: function(buffer) {
            return buffer.getUint16() << 16 >> 16;
          }
        }),
        uint32: createType({
          name: "uint32",
          serialize: function(buffer, data) {
            buffer.pushUint32(checkRange(data, data >>> 0));
          },
          deserialize: function(buffer) {
            return buffer.getUint32();
          }
        }),
        uint64: createType({
          name: "uint64",
          serialize: function(buffer, data) {
            buffer.pushArray(numeric.decimalToBinary(8, "" + data));
          },
          deserialize: function(buffer) {
            return numeric.binaryToDecimal(buffer.getUint8Array(8));
          }
        }),
        int64: createType({
          name: "int64",
          serialize: function(buffer, data) {
            buffer.pushArray(numeric.signedDecimalToBinary(8, "" + data));
          },
          deserialize: function(buffer) {
            return numeric.signedBinaryToDecimal(buffer.getUint8Array(8));
          }
        }),
        int32: createType({
          name: "int32",
          serialize: function(buffer, data) {
            buffer.pushUint32(checkRange(data, data | 0));
          },
          deserialize: function(buffer) {
            return buffer.getUint32() | 0;
          }
        }),
        varuint32: createType({
          name: "varuint32",
          serialize: function(buffer, data) {
            buffer.pushVaruint32(checkRange(data, data >>> 0));
          },
          deserialize: function(buffer) {
            return buffer.getVaruint32();
          }
        }),
        varint32: createType({
          name: "varint32",
          serialize: function(buffer, data) {
            buffer.pushVarint32(checkRange(data, data | 0));
          },
          deserialize: function(buffer) {
            return buffer.getVarint32();
          }
        }),
        uint128: createType({
          name: "uint128",
          serialize: function(buffer, data) {
            buffer.pushArray(numeric.decimalToBinary(16, "" + data));
          },
          deserialize: function(buffer) {
            return numeric.binaryToDecimal(buffer.getUint8Array(16));
          }
        }),
        int128: createType({
          name: "int128",
          serialize: function(buffer, data) {
            buffer.pushArray(numeric.signedDecimalToBinary(16, "" + data));
          },
          deserialize: function(buffer) {
            return numeric.signedBinaryToDecimal(buffer.getUint8Array(16));
          }
        }),
        float32: createType({
          name: "float32",
          serialize: function(buffer, data) {
            buffer.pushFloat32(data);
          },
          deserialize: function(buffer) {
            return buffer.getFloat32();
          }
        }),
        float64: createType({
          name: "float64",
          serialize: function(buffer, data) {
            buffer.pushFloat64(data);
          },
          deserialize: function(buffer) {
            return buffer.getFloat64();
          }
        }),
        float128: createType({
          name: "float128",
          serialize: function(buffer, data) {
            buffer.pushUint8ArrayChecked(hexToUint8Array(data), 16);
          },
          deserialize: function(buffer) {
            return arrayToHex(buffer.getUint8Array(16));
          }
        }),
        bytes: createType({
          name: "bytes",
          serialize: function(buffer, data) {
            if (data instanceof Uint8Array || Array.isArray(data)) {
              buffer.pushBytes(data);
            } else {
              buffer.pushBytes(hexToUint8Array(data));
            }
          },
          deserialize: function(buffer, state) {
            if (state && state.options.bytesAsUint8Array) {
              return buffer.getBytes();
            } else {
              return arrayToHex(buffer.getBytes());
            }
          }
        }),
        string: createType({
          name: "string",
          serialize: function(buffer, data) {
            buffer.pushString(data);
          },
          deserialize: function(buffer) {
            return buffer.getString();
          }
        }),
        name: createType({
          name: "name",
          serialize: function(buffer, data) {
            buffer.pushName(data);
          },
          deserialize: function(buffer) {
            return buffer.getName();
          }
        }),
        time_point: createType({
          name: "time_point",
          serialize: function(buffer, data) {
            buffer.pushNumberAsUint64(dateToTimePoint(data));
          },
          deserialize: function(buffer) {
            return timePointToDate(buffer.getUint64AsNumber());
          }
        }),
        time_point_sec: createType({
          name: "time_point_sec",
          serialize: function(buffer, data) {
            buffer.pushUint32(dateToTimePointSec(data));
          },
          deserialize: function(buffer) {
            return timePointSecToDate(buffer.getUint32());
          }
        }),
        block_timestamp_type: createType({
          name: "block_timestamp_type",
          serialize: function(buffer, data) {
            buffer.pushUint32(dateToBlockTimestamp(data));
          },
          deserialize: function(buffer) {
            return blockTimestampToDate(buffer.getUint32());
          }
        }),
        symbol_code: createType({
          name: "symbol_code",
          serialize: function(buffer, data) {
            buffer.pushSymbolCode(data);
          },
          deserialize: function(buffer) {
            return buffer.getSymbolCode();
          }
        }),
        symbol: createType({
          name: "symbol",
          serialize: function(buffer, data) {
            buffer.pushSymbol(stringToSymbol(data));
          },
          deserialize: function(buffer) {
            return symbolToString(buffer.getSymbol());
          }
        }),
        asset: createType({
          name: "asset",
          serialize: function(buffer, data) {
            buffer.pushAsset(data);
          },
          deserialize: function(buffer) {
            return buffer.getAsset();
          }
        }),
        checksum160: createType({
          name: "checksum160",
          serialize: function(buffer, data) {
            buffer.pushUint8ArrayChecked(hexToUint8Array(data), 20);
          },
          deserialize: function(buffer) {
            return arrayToHex(buffer.getUint8Array(20));
          }
        }),
        checksum256: createType({
          name: "checksum256",
          serialize: function(buffer, data) {
            buffer.pushUint8ArrayChecked(hexToUint8Array(data), 32);
          },
          deserialize: function(buffer) {
            return arrayToHex(buffer.getUint8Array(32));
          }
        }),
        checksum512: createType({
          name: "checksum512",
          serialize: function(buffer, data) {
            buffer.pushUint8ArrayChecked(hexToUint8Array(data), 64);
          },
          deserialize: function(buffer) {
            return arrayToHex(buffer.getUint8Array(64));
          }
        }),
        public_key: createType({
          name: "public_key",
          serialize: function(buffer, data) {
            buffer.pushPublicKey(data);
          },
          deserialize: function(buffer) {
            return buffer.getPublicKey();
          }
        }),
        private_key: createType({
          name: "private_key",
          serialize: function(buffer, data) {
            buffer.pushPrivateKey(data);
          },
          deserialize: function(buffer) {
            return buffer.getPrivateKey();
          }
        }),
        signature: createType({
          name: "signature",
          serialize: function(buffer, data) {
            buffer.pushSignature(data);
          },
          deserialize: function(buffer) {
            return buffer.getSignature();
          }
        })
      }));
      result.set("extended_asset", createType({
        name: "extended_asset",
        baseName: "",
        fields: [
          { name: "quantity", typeName: "asset", type: result.get("asset") },
          { name: "contract", typeName: "name", type: result.get("name") }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      return result;
    }
    exports.createInitialTypes = createInitialTypes;
    function getType(types, name) {
      var type = types.get(name);
      if (type && type.aliasOfName) {
        return getType(types, type.aliasOfName);
      }
      if (type) {
        return type;
      }
      if (name.endsWith("[]")) {
        return createType({
          name,
          arrayOf: getType(types, name.substr(0, name.length - 2)),
          serialize: serializeArray,
          deserialize: deserializeArray
        });
      }
      if (name.endsWith("?")) {
        return createType({
          name,
          optionalOf: getType(types, name.substr(0, name.length - 1)),
          serialize: serializeOptional,
          deserialize: deserializeOptional
        });
      }
      if (name.endsWith("$")) {
        return createType({
          name,
          extensionOf: getType(types, name.substr(0, name.length - 1)),
          serialize: serializeExtension,
          deserialize: deserializeExtension
        });
      }
      throw new Error("Unknown type: " + name);
    }
    exports.getType = getType;
    function getTypesFromAbi(initialTypes, abi) {
      var e_5, _a2, e_6, _b2, e_7, _c2, e_8, _d, e_9, _e;
      var types = new Map(initialTypes);
      if (abi.types) {
        try {
          for (var _f = __values2(abi.types), _g = _f.next(); !_g.done; _g = _f.next()) {
            var _h = _g.value, new_type_name = _h.new_type_name, type = _h.type;
            types.set(new_type_name, createType({ name: new_type_name, aliasOfName: type }));
          }
        } catch (e_5_1) {
          e_5 = { error: e_5_1 };
        } finally {
          try {
            if (_g && !_g.done && (_a2 = _f.return))
              _a2.call(_f);
          } finally {
            if (e_5)
              throw e_5.error;
          }
        }
      }
      if (abi.structs) {
        try {
          for (var _j = __values2(abi.structs), _k = _j.next(); !_k.done; _k = _j.next()) {
            var _l = _k.value, name_1 = _l.name, base = _l.base, fields = _l.fields;
            types.set(name_1, createType({
              name: name_1,
              baseName: base,
              fields: fields.map(function(_a3) {
                var n = _a3.name, type2 = _a3.type;
                return { name: n, typeName: type2, type: null };
              }),
              serialize: serializeStruct,
              deserialize: deserializeStruct
            }));
          }
        } catch (e_6_1) {
          e_6 = { error: e_6_1 };
        } finally {
          try {
            if (_k && !_k.done && (_b2 = _j.return))
              _b2.call(_j);
          } finally {
            if (e_6)
              throw e_6.error;
          }
        }
      }
      if (abi.variants) {
        try {
          for (var _m = __values2(abi.variants), _o = _m.next(); !_o.done; _o = _m.next()) {
            var _p = _o.value, name_2 = _p.name, t = _p.types;
            types.set(name_2, createType({
              name: name_2,
              fields: t.map(function(s) {
                return { name: s, typeName: s, type: null };
              }),
              serialize: serializeVariant,
              deserialize: deserializeVariant
            }));
          }
        } catch (e_7_1) {
          e_7 = { error: e_7_1 };
        } finally {
          try {
            if (_o && !_o.done && (_c2 = _m.return))
              _c2.call(_m);
          } finally {
            if (e_7)
              throw e_7.error;
          }
        }
      }
      try {
        for (var types_1 = __values2(types), types_1_1 = types_1.next(); !types_1_1.done; types_1_1 = types_1.next()) {
          var _q = __read(types_1_1.value, 2), name_3 = _q[0], type = _q[1];
          if (type.baseName) {
            type.base = getType(types, type.baseName);
          }
          try {
            for (var _r = __values2(type.fields), _s = _r.next(); !_s.done; _s = _r.next()) {
              var field = _s.value;
              field.type = getType(types, field.typeName);
            }
          } catch (e_9_1) {
            e_9 = { error: e_9_1 };
          } finally {
            try {
              if (_s && !_s.done && (_e = _r.return))
                _e.call(_r);
            } finally {
              if (e_9)
                throw e_9.error;
            }
          }
        }
      } catch (e_8_1) {
        e_8 = { error: e_8_1 };
      } finally {
        try {
          if (types_1_1 && !types_1_1.done && (_d = types_1.return))
            _d.call(types_1);
        } finally {
          if (e_8)
            throw e_8.error;
        }
      }
      return types;
    }
    exports.getTypesFromAbi = getTypesFromAbi;
    function transactionHeader(refBlock, expireSeconds) {
      return {
        expiration: timePointSecToDate(dateToTimePointSec(refBlock.timestamp) + expireSeconds),
        ref_block_num: refBlock.block_num & 65535,
        ref_block_prefix: refBlock.ref_block_prefix
      };
    }
    exports.transactionHeader = transactionHeader;
    function serializeActionData(contract, account, name, data, textEncoder, textDecoder) {
      var action = contract.actions.get(name);
      if (!action) {
        throw new Error("Unknown action " + name + " in contract " + account);
      }
      var buffer = new SerialBuffer({ textEncoder, textDecoder });
      action.serialize(buffer, data);
      return arrayToHex(buffer.asUint8Array());
    }
    exports.serializeActionData = serializeActionData;
    function serializeAction(contract, account, name, authorization, data, textEncoder, textDecoder) {
      return {
        account,
        name,
        authorization,
        data: serializeActionData(contract, account, name, data, textEncoder, textDecoder)
      };
    }
    exports.serializeAction = serializeAction;
    function deserializeActionData(contract, account, name, data, textEncoder, textDecoder) {
      var action = contract.actions.get(name);
      if (typeof data === "string") {
        data = hexToUint8Array(data);
      }
      if (!action) {
        throw new Error("Unknown action " + name + " in contract " + account);
      }
      var buffer = new SerialBuffer({ textDecoder, textEncoder });
      buffer.pushArray(data);
      return action.deserialize(buffer);
    }
    exports.deserializeActionData = deserializeActionData;
    function deserializeAction(contract, account, name, authorization, data, textEncoder, textDecoder) {
      return {
        account,
        name,
        authorization,
        data: deserializeActionData(contract, account, name, data, textEncoder, textDecoder)
      };
    }
    exports.deserializeAction = deserializeAction;
  }
});

// node_modules/eosjs/src/abi.abi.json
var require_abi_abi = __commonJS({
  "node_modules/eosjs/src/abi.abi.json"(exports, module) {
    module.exports = {
      version: "eosio::abi/1.1",
      structs: [
        {
          name: "extensions_entry",
          base: "",
          fields: [
            {
              name: "tag",
              type: "uint16"
            },
            {
              name: "value",
              type: "bytes"
            }
          ]
        },
        {
          name: "type_def",
          base: "",
          fields: [
            {
              name: "new_type_name",
              type: "string"
            },
            {
              name: "type",
              type: "string"
            }
          ]
        },
        {
          name: "field_def",
          base: "",
          fields: [
            {
              name: "name",
              type: "string"
            },
            {
              name: "type",
              type: "string"
            }
          ]
        },
        {
          name: "struct_def",
          base: "",
          fields: [
            {
              name: "name",
              type: "string"
            },
            {
              name: "base",
              type: "string"
            },
            {
              name: "fields",
              type: "field_def[]"
            }
          ]
        },
        {
          name: "action_def",
          base: "",
          fields: [
            {
              name: "name",
              type: "name"
            },
            {
              name: "type",
              type: "string"
            },
            {
              name: "ricardian_contract",
              type: "string"
            }
          ]
        },
        {
          name: "table_def",
          base: "",
          fields: [
            {
              name: "name",
              type: "name"
            },
            {
              name: "index_type",
              type: "string"
            },
            {
              name: "key_names",
              type: "string[]"
            },
            {
              name: "key_types",
              type: "string[]"
            },
            {
              name: "type",
              type: "string"
            }
          ]
        },
        {
          name: "clause_pair",
          base: "",
          fields: [
            {
              name: "id",
              type: "string"
            },
            {
              name: "body",
              type: "string"
            }
          ]
        },
        {
          name: "error_message",
          base: "",
          fields: [
            {
              name: "error_code",
              type: "uint64"
            },
            {
              name: "error_msg",
              type: "string"
            }
          ]
        },
        {
          name: "variant_def",
          base: "",
          fields: [
            {
              name: "name",
              type: "string"
            },
            {
              name: "types",
              type: "string[]"
            }
          ]
        },
        {
          name: "abi_def",
          base: "",
          fields: [
            {
              name: "version",
              type: "string"
            },
            {
              name: "types",
              type: "type_def[]"
            },
            {
              name: "structs",
              type: "struct_def[]"
            },
            {
              name: "actions",
              type: "action_def[]"
            },
            {
              name: "tables",
              type: "table_def[]"
            },
            {
              name: "ricardian_clauses",
              type: "clause_pair[]"
            },
            {
              name: "error_messages",
              type: "error_message[]"
            },
            {
              name: "abi_extensions",
              type: "extensions_entry[]"
            },
            {
              name: "variants",
              type: "variant_def[]$"
            }
          ]
        }
      ]
    };
  }
});

// node_modules/eosjs/src/transaction.abi.json
var require_transaction_abi = __commonJS({
  "node_modules/eosjs/src/transaction.abi.json"(exports, module) {
    module.exports = {
      version: "eosio::abi/1.0",
      types: [
        {
          new_type_name: "account_name",
          type: "name"
        },
        {
          new_type_name: "action_name",
          type: "name"
        },
        {
          new_type_name: "permission_name",
          type: "name"
        }
      ],
      structs: [
        {
          name: "permission_level",
          base: "",
          fields: [
            {
              name: "actor",
              type: "account_name"
            },
            {
              name: "permission",
              type: "permission_name"
            }
          ]
        },
        {
          name: "action",
          base: "",
          fields: [
            {
              name: "account",
              type: "account_name"
            },
            {
              name: "name",
              type: "action_name"
            },
            {
              name: "authorization",
              type: "permission_level[]"
            },
            {
              name: "data",
              type: "bytes"
            }
          ]
        },
        {
          name: "extension",
          base: "",
          fields: [
            {
              name: "type",
              type: "uint16"
            },
            {
              name: "data",
              type: "bytes"
            }
          ]
        },
        {
          name: "transaction_header",
          base: "",
          fields: [
            {
              name: "expiration",
              type: "time_point_sec"
            },
            {
              name: "ref_block_num",
              type: "uint16"
            },
            {
              name: "ref_block_prefix",
              type: "uint32"
            },
            {
              name: "max_net_usage_words",
              type: "varuint32"
            },
            {
              name: "max_cpu_usage_ms",
              type: "uint8"
            },
            {
              name: "delay_sec",
              type: "varuint32"
            }
          ]
        },
        {
          name: "transaction",
          base: "transaction_header",
          fields: [
            {
              name: "context_free_actions",
              type: "action[]"
            },
            {
              name: "actions",
              type: "action[]"
            },
            {
              name: "transaction_extensions",
              type: "extension[]"
            }
          ]
        }
      ]
    };
  }
});

// node_modules/eosjs/dist/eosjs-api.js
var require_eosjs_api = __commonJS({
  "node_modules/eosjs/dist/eosjs-api.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : new P(function(resolve2) {
            resolve2(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator4 = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
          if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
      }
      return t;
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spread = exports && exports.__spread || function() {
      for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    var __values2 = exports && exports.__values || function(o) {
      var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
      if (m)
        return m.call(o);
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ser = require_eosjs_serialize();
    var abiAbi = require_abi_abi();
    var transactionAbi = require_transaction_abi();
    var Api = (
      /** @class */
      function() {
        function Api2(args) {
          this.contracts = /* @__PURE__ */ new Map();
          this.cachedAbis = /* @__PURE__ */ new Map();
          this.rpc = args.rpc;
          this.authorityProvider = args.authorityProvider || args.rpc;
          this.abiProvider = args.abiProvider || args.rpc;
          this.signatureProvider = args.signatureProvider;
          this.chainId = args.chainId;
          this.textEncoder = args.textEncoder;
          this.textDecoder = args.textDecoder;
          this.abiTypes = ser.getTypesFromAbi(ser.createInitialTypes(), abiAbi);
          this.transactionTypes = ser.getTypesFromAbi(ser.createInitialTypes(), transactionAbi);
        }
        Api2.prototype.rawAbiToJson = function(rawAbi) {
          var buffer = new ser.SerialBuffer({
            textEncoder: this.textEncoder,
            textDecoder: this.textDecoder,
            array: rawAbi
          });
          if (!ser.supportedAbiVersion(buffer.getString())) {
            throw new Error("Unsupported abi version");
          }
          buffer.restartRead();
          return this.abiTypes.get("abi_def").deserialize(buffer);
        };
        Api2.prototype.getCachedAbi = function(accountName, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter3(this, void 0, void 0, function() {
            var cachedAbi, rawAbi, abi, e_1;
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (!reload && this.cachedAbis.get(accountName)) {
                    return [2, this.cachedAbis.get(accountName)];
                  }
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, 3, , 4]);
                  return [4, this.abiProvider.getRawAbi(accountName)];
                case 2:
                  rawAbi = _a2.sent().abi;
                  abi = this.rawAbiToJson(rawAbi);
                  cachedAbi = { rawAbi, abi };
                  return [3, 4];
                case 3:
                  e_1 = _a2.sent();
                  e_1.message = "fetching abi for " + accountName + ": " + e_1.message;
                  throw e_1;
                case 4:
                  if (!cachedAbi) {
                    throw new Error("Missing abi for " + accountName);
                  }
                  this.cachedAbis.set(accountName, cachedAbi);
                  return [2, cachedAbi];
              }
            });
          });
        };
        Api2.prototype.getAbi = function(accountName, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.getCachedAbi(accountName, reload)];
                case 1:
                  return [2, _a2.sent().abi];
              }
            });
          });
        };
        Api2.prototype.getTransactionAbis = function(transaction, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter3(this, void 0, void 0, function() {
            var accounts, uniqueAccounts, actionPromises;
            var _this = this;
            return __generator4(this, function(_a2) {
              accounts = transaction.actions.map(function(action) {
                return action.account;
              });
              uniqueAccounts = new Set(accounts);
              actionPromises = __spread(uniqueAccounts).map(function(account) {
                return __awaiter3(_this, void 0, void 0, function() {
                  var _a3;
                  return __generator4(this, function(_b2) {
                    switch (_b2.label) {
                      case 0:
                        _a3 = {
                          accountName: account
                        };
                        return [4, this.getCachedAbi(account, reload)];
                      case 1:
                        return [2, (_a3.abi = _b2.sent().rawAbi, _a3)];
                    }
                  });
                });
              });
              return [2, Promise.all(actionPromises)];
            });
          });
        };
        Api2.prototype.getContract = function(accountName, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter3(this, void 0, void 0, function() {
            var e_2, _a2, abi, types, actions, _b2, _c2, _d, name_1, type, result;
            return __generator4(this, function(_e) {
              switch (_e.label) {
                case 0:
                  if (!reload && this.contracts.get(accountName)) {
                    return [2, this.contracts.get(accountName)];
                  }
                  return [4, this.getAbi(accountName, reload)];
                case 1:
                  abi = _e.sent();
                  types = ser.getTypesFromAbi(ser.createInitialTypes(), abi);
                  actions = /* @__PURE__ */ new Map();
                  try {
                    for (_b2 = __values2(abi.actions), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
                      _d = _c2.value, name_1 = _d.name, type = _d.type;
                      actions.set(name_1, ser.getType(types, type));
                    }
                  } catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                  } finally {
                    try {
                      if (_c2 && !_c2.done && (_a2 = _b2.return))
                        _a2.call(_b2);
                    } finally {
                      if (e_2)
                        throw e_2.error;
                    }
                  }
                  result = { types, actions };
                  this.contracts.set(accountName, result);
                  return [2, result];
              }
            });
          });
        };
        Api2.prototype.serialize = function(buffer, type, value) {
          this.transactionTypes.get(type).serialize(buffer, value);
        };
        Api2.prototype.deserialize = function(buffer, type) {
          return this.transactionTypes.get(type).deserialize(buffer);
        };
        Api2.prototype.serializeTransaction = function(transaction) {
          var buffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
          this.serialize(buffer, "transaction", __assign({ max_net_usage_words: 0, max_cpu_usage_ms: 0, delay_sec: 0, context_free_actions: [], actions: [], transaction_extensions: [] }, transaction));
          return buffer.asUint8Array();
        };
        Api2.prototype.deserializeTransaction = function(transaction) {
          var buffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
          buffer.pushArray(transaction);
          return this.deserialize(buffer, "transaction");
        };
        Api2.prototype.serializeActions = function(actions) {
          return __awaiter3(this, void 0, void 0, function() {
            var _this = this;
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, Promise.all(actions.map(function(_a3) {
                    var account = _a3.account, name = _a3.name, authorization = _a3.authorization, data = _a3.data;
                    return __awaiter3(_this, void 0, void 0, function() {
                      var contract;
                      return __generator4(this, function(_b2) {
                        switch (_b2.label) {
                          case 0:
                            return [4, this.getContract(account)];
                          case 1:
                            contract = _b2.sent();
                            return [2, ser.serializeAction(contract, account, name, authorization, data, this.textEncoder, this.textDecoder)];
                        }
                      });
                    });
                  }))];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Api2.prototype.deserializeActions = function(actions) {
          return __awaiter3(this, void 0, void 0, function() {
            var _this = this;
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, Promise.all(actions.map(function(_a3) {
                    var account = _a3.account, name = _a3.name, authorization = _a3.authorization, data = _a3.data;
                    return __awaiter3(_this, void 0, void 0, function() {
                      var contract;
                      return __generator4(this, function(_b2) {
                        switch (_b2.label) {
                          case 0:
                            return [4, this.getContract(account)];
                          case 1:
                            contract = _b2.sent();
                            return [2, ser.deserializeAction(contract, account, name, authorization, data, this.textEncoder, this.textDecoder)];
                        }
                      });
                    });
                  }))];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Api2.prototype.deserializeTransactionWithActions = function(transaction) {
          return __awaiter3(this, void 0, void 0, function() {
            var deserializedTransaction, deserializedActions;
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (typeof transaction === "string") {
                    transaction = ser.hexToUint8Array(transaction);
                  }
                  deserializedTransaction = this.deserializeTransaction(transaction);
                  return [4, this.deserializeActions(deserializedTransaction.actions)];
                case 1:
                  deserializedActions = _a2.sent();
                  return [2, __assign({}, deserializedTransaction, { actions: deserializedActions })];
              }
            });
          });
        };
        Api2.prototype.transact = function(transaction, _a2) {
          var _b2 = _a2 === void 0 ? {} : _a2, _c2 = _b2.broadcast, broadcast = _c2 === void 0 ? true : _c2, _d = _b2.sign, sign = _d === void 0 ? true : _d, blocksBehind = _b2.blocksBehind, expireSeconds = _b2.expireSeconds;
          return __awaiter3(this, void 0, void 0, function() {
            var info, refBlock, abis, _e, _f, serializedTransaction, pushTransactionArgs, availableKeys, requiredKeys;
            return __generator4(this, function(_g) {
              switch (_g.label) {
                case 0:
                  if (!!this.chainId)
                    return [3, 2];
                  return [4, this.rpc.get_info()];
                case 1:
                  info = _g.sent();
                  this.chainId = info.chain_id;
                  _g.label = 2;
                case 2:
                  if (!(typeof blocksBehind === "number" && expireSeconds))
                    return [3, 6];
                  if (!!info)
                    return [3, 4];
                  return [4, this.rpc.get_info()];
                case 3:
                  info = _g.sent();
                  _g.label = 4;
                case 4:
                  return [4, this.rpc.get_block(info.head_block_num - blocksBehind)];
                case 5:
                  refBlock = _g.sent();
                  transaction = __assign({}, ser.transactionHeader(refBlock, expireSeconds), transaction);
                  _g.label = 6;
                case 6:
                  if (!this.hasRequiredTaposFields(transaction)) {
                    throw new Error("Required configuration or TAPOS fields are not present");
                  }
                  return [4, this.getTransactionAbis(transaction)];
                case 7:
                  abis = _g.sent();
                  _e = [{}, transaction];
                  _f = {};
                  return [4, this.serializeActions(transaction.actions)];
                case 8:
                  transaction = __assign.apply(void 0, _e.concat([(_f.actions = _g.sent(), _f)]));
                  serializedTransaction = this.serializeTransaction(transaction);
                  pushTransactionArgs = { serializedTransaction, signatures: [] };
                  if (!sign)
                    return [3, 12];
                  return [4, this.signatureProvider.getAvailableKeys()];
                case 9:
                  availableKeys = _g.sent();
                  return [4, this.authorityProvider.getRequiredKeys({ transaction, availableKeys })];
                case 10:
                  requiredKeys = _g.sent();
                  return [4, this.signatureProvider.sign({
                    chainId: this.chainId,
                    requiredKeys,
                    serializedTransaction,
                    abis
                  })];
                case 11:
                  pushTransactionArgs = _g.sent();
                  _g.label = 12;
                case 12:
                  if (broadcast) {
                    return [2, this.pushSignedTransaction(pushTransactionArgs)];
                  }
                  return [2, pushTransactionArgs];
              }
            });
          });
        };
        Api2.prototype.pushSignedTransaction = function(_a2) {
          var signatures = _a2.signatures, serializedTransaction = _a2.serializedTransaction;
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_b2) {
              return [2, this.rpc.push_transaction({
                signatures,
                serializedTransaction
              })];
            });
          });
        };
        Api2.prototype.hasRequiredTaposFields = function(_a2) {
          var expiration = _a2.expiration, ref_block_num = _a2.ref_block_num, ref_block_prefix = _a2.ref_block_prefix, transaction = __rest(_a2, ["expiration", "ref_block_num", "ref_block_prefix"]);
          return !!(expiration && ref_block_num && ref_block_prefix);
        };
        return Api2;
      }()
    );
    exports.Api = Api;
  }
});

// node_modules/eosjs/dist/eosjs-api-interfaces.js
var require_eosjs_api_interfaces = __commonJS({
  "node_modules/eosjs/dist/eosjs-api-interfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/eosjs/dist/eosjs-rpcerror.js
var require_eosjs_rpcerror = __commonJS({
  "node_modules/eosjs/dist/eosjs-rpcerror.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var RpcError = (
      /** @class */
      function(_super) {
        __extends2(RpcError2, _super);
        function RpcError2(json) {
          var _this = this;
          if (json.error && json.error.details && json.error.details.length && json.error.details[0].message) {
            _this = _super.call(this, json.error.details[0].message) || this;
          } else if (json.processed && json.processed.except && json.processed.except.message) {
            _this = _super.call(this, json.processed.except.message) || this;
          } else {
            _this = _super.call(this, json.message) || this;
          }
          Object.setPrototypeOf(_this, RpcError2.prototype);
          _this.json = json;
          return _this;
        }
        return RpcError2;
      }(Error)
    );
    exports.RpcError = RpcError;
  }
});

// node_modules/eosjs/dist/eosjs-jsonrpc.js
var require_eosjs_jsonrpc = __commonJS({
  "node_modules/eosjs/dist/eosjs-jsonrpc.js"(exports) {
    "use strict";
    var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : new P(function(resolve2) {
            resolve2(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator4 = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __values2 = exports && exports.__values || function(o) {
      var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
      if (m)
        return m.call(o);
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var eosjs_numeric_1 = require_eosjs_numeric();
    var eosjs_rpcerror_1 = require_eosjs_rpcerror();
    function arrayToHex(data) {
      var e_1, _a2;
      var result = "";
      try {
        for (var data_1 = __values2(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
          var x = data_1_1.value;
          result += ("00" + x.toString(16)).slice(-2);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (data_1_1 && !data_1_1.done && (_a2 = data_1.return))
            _a2.call(data_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return result;
    }
    var JsonRpc = (
      /** @class */
      function() {
        function JsonRpc2(endpoint, args) {
          if (args === void 0) {
            args = {};
          }
          this.endpoint = endpoint;
          if (args.fetch) {
            this.fetchBuiltin = args.fetch;
          } else {
            this.fetchBuiltin = global.fetch;
          }
        }
        JsonRpc2.prototype.fetch = function(path, body) {
          return __awaiter3(this, void 0, void 0, function() {
            var response, json, f2, e_2;
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  _a2.trys.push([0, 3, , 4]);
                  f2 = this.fetchBuiltin;
                  return [4, f2(this.endpoint + path, {
                    body: JSON.stringify(body),
                    method: "POST"
                  })];
                case 1:
                  response = _a2.sent();
                  return [4, response.json()];
                case 2:
                  json = _a2.sent();
                  if (json.processed && json.processed.except) {
                    throw new eosjs_rpcerror_1.RpcError(json);
                  }
                  return [3, 4];
                case 3:
                  e_2 = _a2.sent();
                  e_2.isFetchError = true;
                  throw e_2;
                case 4:
                  if (!response.ok) {
                    throw new eosjs_rpcerror_1.RpcError(json);
                  }
                  return [2, json];
              }
            });
          });
        };
        JsonRpc2.prototype.get_abi = function(accountName) {
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_abi", { account_name: accountName })];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_account = function(accountName) {
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_account", { account_name: accountName })];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_block_header_state = function(blockNumOrId) {
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_block_header_state", { block_num_or_id: blockNumOrId })];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_block = function(blockNumOrId) {
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_block", { block_num_or_id: blockNumOrId })];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_code = function(accountName) {
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_code", { account_name: accountName })];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_currency_balance = function(code, account, symbol) {
          if (symbol === void 0) {
            symbol = null;
          }
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_currency_balance", { code, account, symbol })];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_currency_stats = function(code, symbol) {
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_currency_stats", { code, symbol })];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_info = function() {
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_info", {})];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_producer_schedule = function() {
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_producer_schedule", {})];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_producers = function(json, lowerBound, limit) {
          if (json === void 0) {
            json = true;
          }
          if (lowerBound === void 0) {
            lowerBound = "";
          }
          if (limit === void 0) {
            limit = 50;
          }
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_producers", { json, lower_bound: lowerBound, limit })];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_raw_code_and_abi = function(accountName) {
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_raw_code_and_abi", { account_name: accountName })];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.getRawAbi = function(accountName) {
          return __awaiter3(this, void 0, void 0, function() {
            var rawCodeAndAbi, abi;
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.get_raw_code_and_abi(accountName)];
                case 1:
                  rawCodeAndAbi = _a2.sent();
                  abi = eosjs_numeric_1.base64ToBinary(rawCodeAndAbi.abi);
                  return [2, { accountName: rawCodeAndAbi.account_name, abi }];
              }
            });
          });
        };
        JsonRpc2.prototype.get_table_rows = function(_a2) {
          var _b2 = _a2.json, json = _b2 === void 0 ? true : _b2, code = _a2.code, scope = _a2.scope, table = _a2.table, _c2 = _a2.table_key, table_key = _c2 === void 0 ? "" : _c2, _d = _a2.lower_bound, lower_bound = _d === void 0 ? "" : _d, _e = _a2.upper_bound, upper_bound = _e === void 0 ? "" : _e, _f = _a2.index_position, index_position = _f === void 0 ? 1 : _f, _g = _a2.key_type, key_type = _g === void 0 ? "" : _g, _h = _a2.limit, limit = _h === void 0 ? 10 : _h, _j = _a2.reverse, reverse = _j === void 0 ? false : _j, _k = _a2.show_payer, show_payer = _k === void 0 ? false : _k;
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_l) {
              switch (_l.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_table_rows", {
                    json,
                    code,
                    scope,
                    table,
                    table_key,
                    lower_bound,
                    upper_bound,
                    index_position,
                    key_type,
                    limit,
                    reverse,
                    show_payer
                  })];
                case 1:
                  return [2, _l.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_table_by_scope = function(_a2) {
          var code = _a2.code, table = _a2.table, _b2 = _a2.lower_bound, lower_bound = _b2 === void 0 ? "" : _b2, _c2 = _a2.upper_bound, upper_bound = _c2 === void 0 ? "" : _c2, _d = _a2.limit, limit = _d === void 0 ? 10 : _d;
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_e) {
              switch (_e.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_table_by_scope", {
                    code,
                    table,
                    lower_bound,
                    upper_bound,
                    limit
                  })];
                case 1:
                  return [2, _e.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.getRequiredKeys = function(args) {
          return __awaiter3(this, void 0, void 0, function() {
            var _a2;
            return __generator4(this, function(_b2) {
              switch (_b2.label) {
                case 0:
                  _a2 = eosjs_numeric_1.convertLegacyPublicKeys;
                  return [4, this.fetch("/v1/chain/get_required_keys", {
                    transaction: args.transaction,
                    available_keys: args.availableKeys
                  })];
                case 1:
                  return [2, _a2.apply(void 0, [_b2.sent().required_keys])];
              }
            });
          });
        };
        JsonRpc2.prototype.push_transaction = function(_a2) {
          var signatures = _a2.signatures, serializedTransaction = _a2.serializedTransaction;
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_b2) {
              switch (_b2.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/push_transaction", {
                    signatures,
                    compression: 0,
                    packed_context_free_data: "",
                    packed_trx: arrayToHex(serializedTransaction)
                  })];
                case 1:
                  return [2, _b2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.db_size_get = function() {
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/db_size/get", {})];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_actions = function(accountName, pos, offset) {
          if (pos === void 0) {
            pos = null;
          }
          if (offset === void 0) {
            offset = null;
          }
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_actions", { account_name: accountName, pos, offset })];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_transaction = function(id, blockNumHint) {
          if (blockNumHint === void 0) {
            blockNumHint = null;
          }
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_transaction", { id, block_num_hint: blockNumHint })];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_key_accounts = function(publicKey) {
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_key_accounts", { public_key: publicKey })];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_controlled_accounts = function(controllingAccount) {
          return __awaiter3(this, void 0, void 0, function() {
            return __generator4(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_controlled_accounts", { controlling_account: controllingAccount })];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        return JsonRpc2;
      }()
    );
    exports.JsonRpc = JsonRpc;
  }
});

// node_modules/eosjs/dist/eosjs-rpc-interfaces.js
var require_eosjs_rpc_interfaces = __commonJS({
  "node_modules/eosjs/dist/eosjs-rpc-interfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/eosjs/dist/index.js
var require_dist = __commonJS({
  "node_modules/eosjs/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var eosjs_api_1 = require_eosjs_api();
    exports.Api = eosjs_api_1.Api;
    var ApiInterfaces = require_eosjs_api_interfaces();
    exports.ApiInterfaces = ApiInterfaces;
    var eosjs_jsonrpc_1 = require_eosjs_jsonrpc();
    exports.JsonRpc = eosjs_jsonrpc_1.JsonRpc;
    var Numeric = require_eosjs_numeric();
    exports.Numeric = Numeric;
    var RpcInterfaces = require_eosjs_rpc_interfaces();
    exports.RpcInterfaces = RpcInterfaces;
    var eosjs_rpcerror_1 = require_eosjs_rpcerror();
    exports.RpcError = eosjs_rpcerror_1.RpcError;
    var Serialize = require_eosjs_serialize();
    exports.Serialize = Serialize;
  }
});

// node_modules/@aikon/eos-transit/lib/stateContainer.js
var require_stateContainer = __commonJS({
  "node_modules/@aikon/eos-transit/lib/stateContainer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeStateContainer(initialState) {
      var state = initialState;
      var listeners = [];
      return {
        getState: function() {
          return state;
        },
        updateState: function(updater) {
          state = typeof updater === "function" ? updater(state) : updater;
          for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {
            var listener = listeners_1[_i];
            listener(state);
          }
        },
        subscribe: function(listenerFn) {
          listeners.push(listenerFn);
          return function unsubscribe() {
            listeners = listeners.filter(function(l) {
              return l !== listenerFn;
            });
          };
        }
      };
    }
    exports.makeStateContainer = makeStateContainer;
  }
});

// node_modules/@aikon/eos-transit/node_modules/uuid/lib/rng-browser.js
var require_rng_browser = __commonJS({
  "node_modules/@aikon/eos-transit/node_modules/uuid/lib/rng-browser.js"(exports, module) {
    var getRandomValues2 = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (getRandomValues2) {
      rnds82 = new Uint8Array(16);
      module.exports = function whatwgRNG() {
        getRandomValues2(rnds82);
        return rnds82;
      };
    } else {
      rnds = new Array(16);
      module.exports = function mathRNG() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 3) === 0)
            r = Math.random() * 4294967296;
          rnds[i] = r >>> ((i & 3) << 3) & 255;
        }
        return rnds;
      };
    }
    var rnds82;
    var rnds;
  }
});

// node_modules/@aikon/eos-transit/node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/@aikon/eos-transit/node_modules/uuid/lib/bytesToUuid.js"(exports, module) {
    var byteToHex2 = [];
    for (i = 0; i < 256; ++i) {
      byteToHex2[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid2(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex2;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module.exports = bytesToUuid2;
  }
});

// node_modules/@aikon/eos-transit/node_modules/uuid/v4.js
var require_v4 = __commonJS({
  "node_modules/@aikon/eos-transit/node_modules/uuid/v4.js"(exports, module) {
    var rng2 = require_rng_browser();
    var bytesToUuid2 = require_bytesToUuid();
    function v42(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng2)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid2(rnds);
    }
    module.exports = v42;
  }
});

// node_modules/@aikon/eos-transit/lib/util.js
var require_util = __commonJS({
  "node_modules/@aikon/eos-transit/lib/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getNetworkUrl(_a2) {
      var protocol = _a2.protocol, host = _a2.host, port = _a2.port;
      return (protocol ? protocol : "http") + "://" + host + (port ? ":" + port : "");
    }
    exports.getNetworkUrl = getNetworkUrl;
    function getErrorMessage(error, fallbackMessage) {
      if (fallbackMessage === void 0) {
        fallbackMessage = "Error";
      }
      if (error) {
        return typeof error === "string" ? error : error.message || fallbackMessage;
      }
      return fallbackMessage;
    }
    exports.getErrorMessage = getErrorMessage;
  }
});

// node_modules/@aikon/eos-transit/lib/wallet.js
var require_wallet = __commonJS({
  "node_modules/@aikon/eos-transit/lib/wallet.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : new P(function(resolve2) {
            resolve2(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator4 = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var eosjs_1 = require_dist();
    var v4_1 = __importDefault(require_v4());
    var stateContainer_1 = require_stateContainer();
    var util_1 = require_util();
    var DEFAULT_STATE = {
      connecting: false,
      connected: false,
      connectionError: false,
      connectionErrorMessage: void 0,
      auth: void 0,
      authenticating: false,
      authenticated: false,
      authenticationConfirmed: false,
      authenticationError: false,
      authenticationErrorMessage: void 0,
      accountInfo: void 0,
      accountFetching: false,
      accountFetchError: false,
      accountFetchErrorMessage: void 0
    };
    function initWallet(walletProvider, ctx) {
      var _instanceId = v4_1.default();
      var _stateContainer = stateContainer_1.makeStateContainer(__assign({}, DEFAULT_STATE));
      var discoverData = { keyToAccountMap: [] };
      var counter = 0;
      var getState = _stateContainer.getState;
      var eosApi = new eosjs_1.Api({
        // Api() constructor requires a JsonRpc - even if we dont want one for non-eos, so create empty JsonRpc here
        rpc: ctx.eosRpc ? ctx.eosRpc : new eosjs_1.JsonRpc(""),
        chainId: ctx.network.chainId,
        signatureProvider: walletProvider.signatureProvider
      });
      function fetchAccountInfo(accountName) {
        if (!accountName) {
          return Promise.reject("No `accountName` was passed in order to fetch the account info");
        }
        _stateContainer.updateState(function(state) {
          return __assign({}, state, { accountFetching: true, accountFetchError: false, accountFetchErrorMessage: void 0 });
        });
        if (!ctx.eosRpc) {
          var accountInfo_1 = { name: accountName };
          _stateContainer.updateState(function(state) {
            return __assign({}, state, { accountFetching: false, accountInfo: accountInfo_1 });
          });
          return Promise.resolve(accountInfo_1);
        }
        return ctx.eosRpc.get_account(accountName).then(function(accountData) {
          var accountInfo = __assign({}, accountData);
          _stateContainer.updateState(function(state) {
            return __assign({}, state, { accountFetching: false, accountInfo });
          });
          return accountInfo;
        }).catch(function(error) {
          _stateContainer.updateState(function(state) {
            return __assign({}, state, { accountFetching: false, accountInfo: void 0, accountFetchError: true, accountFetchErrorMessage: util_1.getErrorMessage(error) });
          });
          return Promise.reject(error);
        });
      }
      function connect() {
        _stateContainer.updateState(function(state) {
          return __assign({}, state, { connected: false, connecting: true, connectionError: false, connectionErrorMessage: void 0 });
        });
        return walletProvider.connect(ctx.appName).then(function() {
          _stateContainer.updateState(function(state) {
            return __assign({}, state, { connecting: false, connected: true });
          });
          return true;
        }).catch(function(error) {
          _stateContainer.updateState(function(state) {
            return __assign({}, state, { connecting: false, connectionError: true, connectionErrorMessage: util_1.getErrorMessage(error) });
          });
          return Promise.reject(error);
        });
      }
      function discover(discoveryOptions) {
        return __awaiter3(this, void 0, void 0, function() {
          var accountsDataObjToMerge, discoverResult;
          var _this = this;
          return __generator4(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                accountsDataObjToMerge = { keyToAccountMap: [] };
                return [4, walletProvider.discover(discoveryOptions).then(function(walletDiscoveryData) {
                  return __awaiter3(_this, void 0, void 0, function() {
                    var modifiedData, promises, _loop_1, _i, _a3, keyData;
                    var _this2 = this;
                    return __generator4(this, function(_b2) {
                      switch (_b2.label) {
                        case 0:
                          console.log("walletDiscoveryData");
                          console.log(walletDiscoveryData);
                          accountsDataObjToMerge = __assign({}, accountsDataObjToMerge, walletDiscoveryData);
                          delete accountsDataObjToMerge.keys;
                          if (discoveryOptions.keyModifierFunc !== void 0) {
                            modifiedData = discoveryOptions.keyModifierFunc(walletDiscoveryData);
                            walletDiscoveryData = modifiedData;
                          }
                          if (!(discoveryOptions.keyLookupFunc !== void 0))
                            return [3, 1];
                          discoveryOptions.keyLookupFunc(walletDiscoveryData, function(discoveredAccounts) {
                            accountsDataObjToMerge.keyToAccountMap = discoveredAccounts;
                            console.log("accountsDataObjToMerge(keyLookupFunc)");
                            console.log({ accountsDataObjToMerge });
                            return Promise.resolve({ accountsDataObjToMerge });
                          });
                          return [3, 3];
                        case 1:
                          promises = [];
                          _loop_1 = function(keyData2) {
                            var key = keyData2.key;
                            var keyIndex = keyData2.index;
                            var cached = false;
                            if (discoverData.keyToAccountMap) {
                              var foundInCache = discoverData.keyToAccountMap.findIndex(function(y) {
                                return y.index == keyIndex;
                              });
                              if (foundInCache > -1)
                                cached = true;
                            }
                            if (key && !cached && ctx.eosRpc) {
                              var p = ctx.eosRpc.history_get_key_accounts(key).then(function(accountData) {
                                return __awaiter3(_this2, void 0, void 0, function() {
                                  var accountEntry, _loop_2, _i2, _a4, account;
                                  var _this3 = this;
                                  return __generator4(this, function(_b3) {
                                    switch (_b3.label) {
                                      case 0:
                                        accountEntry = {
                                          index: keyIndex,
                                          key,
                                          accounts: []
                                        };
                                        if (!(accountData.account_names.length > 0))
                                          return [3, 4];
                                        _loop_2 = function(account2) {
                                          return __generator4(this, function(_a5) {
                                            switch (_a5.label) {
                                              case 0:
                                                return [4, ctx.eosRpc.get_account(account2).then(function(accountInfo) {
                                                  return __awaiter3(_this3, void 0, void 0, function() {
                                                    var _i3, _a6, permission, _b4, _c2, permissionKey;
                                                    return __generator4(this, function(_d) {
                                                      for (_i3 = 0, _a6 = accountInfo.permissions; _i3 < _a6.length; _i3++) {
                                                        permission = _a6[_i3];
                                                        for (_b4 = 0, _c2 = permission.required_auth.keys; _b4 < _c2.length; _b4++) {
                                                          permissionKey = _c2[_b4];
                                                          if (permissionKey.key == key) {
                                                            accountEntry.accounts.push({
                                                              account: account2,
                                                              authorization: permission.perm_name
                                                            });
                                                          }
                                                        }
                                                      }
                                                      return [
                                                        2
                                                        /*return*/
                                                      ];
                                                    });
                                                  });
                                                })];
                                              case 1:
                                                _a5.sent();
                                                return [
                                                  2
                                                  /*return*/
                                                ];
                                            }
                                          });
                                        };
                                        _i2 = 0, _a4 = accountData.account_names;
                                        _b3.label = 1;
                                      case 1:
                                        if (!(_i2 < _a4.length))
                                          return [3, 4];
                                        account = _a4[_i2];
                                        return [5, _loop_2(account)];
                                      case 2:
                                        _b3.sent();
                                        _b3.label = 3;
                                      case 3:
                                        _i2++;
                                        return [3, 1];
                                      case 4:
                                        return [2, accountEntry];
                                    }
                                  });
                                });
                              });
                              promises.push(p);
                            }
                          };
                          for (_i = 0, _a3 = walletDiscoveryData.keys; _i < _a3.length; _i++) {
                            keyData = _a3[_i];
                            _loop_1(keyData);
                          }
                          return [4, Promise.all(promises).then(function(results) {
                            accountsDataObjToMerge.keyToAccountMap = results || [];
                            console.log("accountsDataObjToMerge");
                            console.log({ accountsDataObjToMerge });
                            return Promise.resolve({ accountsDataObjToMerge });
                          })];
                        case 2:
                          _b2.sent();
                          _b2.label = 3;
                        case 3:
                          return [
                            2
                            /*return*/
                          ];
                      }
                    });
                  });
                })];
              case 1:
                discoverResult = _a2.sent();
                counter++;
                if (discoverData.keyToAccountMap.length == 0) {
                  discoverData = __assign({}, discoverData, accountsDataObjToMerge);
                } else {
                  accountsDataObjToMerge.keyToAccountMap.forEach(function(newKey) {
                    discoverData.keyToAccountMap.push(newKey);
                  });
                }
                return [2, Promise.resolve(discoverData)];
            }
          });
        });
      }
      function disconnect() {
        return walletProvider.disconnect().then(function() {
          _stateContainer.updateState(function(state) {
            return __assign({}, state, { connecting: false, connected: false, connectionError: false, connectionErrorMessage: void 0 });
          });
          return true;
        });
      }
      function login(accountName, authorization) {
        _stateContainer.updateState(function(state) {
          return __assign({}, state, { accountInfo: void 0, authenticated: false, authenticationConfirmed: false, authenticating: true, authenticationError: false, authenticationErrorMessage: void 0 });
        });
        var index = -1;
        var key = void 0;
        if (discoverData.keyToAccountMap.length > 0) {
          if (accountName && authorization) {
            discoverData.keyToAccountMap.forEach(function(indexObj) {
              var found = indexObj.accounts.find(function(account) {
                return account.account == accountName && account.authorization == authorization;
              });
              if (found) {
                index = indexObj.index;
                key = indexObj.key;
              }
            });
          }
          if (!key) {
            throw "Loging was not able to determine the Key and Index for " + authorization + "@" + accountName;
          }
        }
        return walletProvider.login(accountName, authorization, index, key).then(function(walletAuth) {
          _stateContainer.updateState(function(state) {
            return __assign({}, state, { auth: walletAuth, authenticated: true, authenticating: false });
          });
          return fetchAccountInfo(walletAuth.accountName);
        }).then(function(accountInfo) {
          _stateContainer.updateState(function(state) {
            return __assign({}, state, { accountInfo });
          });
          return accountInfo;
        }).catch(function(error) {
          _stateContainer.updateState(function(state) {
            return __assign({}, state, { authenticating: false, authenticationError: true, authenticationErrorMessage: util_1.getErrorMessage(error) });
          });
          return Promise.reject(error);
        });
      }
      function logout() {
        return walletProvider.logout().then(function() {
          _stateContainer.updateState(function(state) {
            return __assign({}, state, { accountInfo: void 0, authenticating: false, authenticated: false, authenticationError: false, authenticationErrorMessage: void 0 });
          });
          return true;
        });
      }
      function signArbitrary(data, userMessage, metadata) {
        return walletProvider.signArbitrary(data, userMessage, metadata);
      }
      var wallet = {
        _instanceId,
        ctx,
        provider: walletProvider,
        eosApi,
        get state() {
          return getState() || __assign({}, DEFAULT_STATE);
        },
        // Shortcut state accessors
        get auth() {
          var state = getState();
          return state && state.auth || void 0;
        },
        get accountInfo() {
          var state = getState();
          return state && state.accountInfo || void 0;
        },
        get connected() {
          var state = getState();
          return state && state.connected || false;
        },
        get authenticated() {
          var state = getState();
          return state && state.authenticated || false;
        },
        get inProgress() {
          var state = getState();
          if (!state)
            return false;
          var connecting = state.connecting, authenticating = state.authenticating, accountFetching = state.accountFetching;
          return !!(connecting || authenticating || accountFetching);
        },
        get active() {
          var state = getState();
          if (!state)
            return false;
          var connected = state.connected, authenticated = state.authenticated, accountInfo = state.accountInfo;
          return !!(connected && authenticated && accountInfo);
        },
        get hasError() {
          var state = getState();
          if (!state)
            return false;
          var connectionError = state.connectionError, authenticationError = state.authenticationError, accountFetchError = state.accountFetchError;
          return !!(connectionError || authenticationError || accountFetchError);
        },
        get errorMessage() {
          var state = getState();
          if (!state)
            return void 0;
          if (!wallet.hasError)
            return void 0;
          var connectionErrorMessage = state.connectionErrorMessage, authenticationErrorMessage = state.authenticationErrorMessage, accountFetchErrorMessage = state.accountFetchErrorMessage;
          return connectionErrorMessage || authenticationErrorMessage || accountFetchErrorMessage || "Wallet connection error";
        },
        connect,
        discover,
        disconnect,
        login,
        logout,
        fetchAccountInfo,
        terminate: function() {
          return logout().then(disconnect).then(function() {
            ctx.detachWallet(wallet);
            return true;
          });
        },
        subscribe: function(listener) {
          return _stateContainer.subscribe(listener);
        },
        signArbitrary
      };
      return wallet;
    }
    exports.initWallet = initWallet;
  }
});

// node_modules/@aikon/eos-transit/lib/walletAccessContext.js
var require_walletAccessContext = __commonJS({
  "node_modules/@aikon/eos-transit/lib/walletAccessContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var eosjs_1 = require_dist();
    var stateContainer_1 = require_stateContainer();
    var wallet_1 = require_wallet();
    var util_1 = require_util();
    var DEFAULT_CONTEXT_STATE = {
      wallets: []
    };
    function findProviderById(walletProviders, providerId) {
      if (!walletProviders.length)
        return void 0;
      return walletProviders.find(function(wp) {
        return wp.id === providerId;
      });
    }
    function initAccessContext(options) {
      var appName = options.appName, network = options.network, isNotEosNetwork = options.isNotEosNetwork;
      var _makeWalletProviderFns = options.walletProviders;
      var walletProviders = _makeWalletProviderFns.map(function(makeWalletProvider) {
        return makeWalletProvider(network);
      });
      var _stateContainer = stateContainer_1.makeStateContainer(DEFAULT_CONTEXT_STATE);
      var _listeners = [];
      function _handleUpdate() {
        for (var _i = 0, _listeners_1 = _listeners; _i < _listeners_1.length; _i++) {
          var listener = _listeners_1[_i];
          listener(ctx);
        }
      }
      var _walletUnsubscribeFns = /* @__PURE__ */ new Map();
      var stateUnsubscribe = _stateContainer.subscribe(_handleUpdate);
      var eosRpc;
      if (!isNotEosNetwork) {
        var eosRpcUrl = util_1.getNetworkUrl(network);
        eosRpc = new eosjs_1.JsonRpc(eosRpcUrl);
      }
      var ctx = {
        appName,
        eosRpc,
        network,
        initWallet: function(walletProvider) {
          var _walletProvider = typeof walletProvider === "string" ? findProviderById(walletProviders, walletProvider) : walletProvider;
          if (!_walletProvider) {
            throw new Error("\n          Cannot initiate a session, invalid wallet provider\n          or wallet provider ID was passed\n        ");
          }
          var newWallet = wallet_1.initWallet(_walletProvider, ctx);
          _stateContainer.updateState(function(state) {
            return {
              wallets: (state && state.wallets || []).concat([newWallet])
            };
          });
          _walletUnsubscribeFns.set(newWallet._instanceId, newWallet.subscribe(_handleUpdate));
          return newWallet;
        },
        addWalletProvider: function(walletProvider) {
          walletProviders.push(walletProvider(network));
        },
        getWalletProviders: function() {
          return walletProviders;
        },
        getWallets: function() {
          var state = _stateContainer.getState();
          if (!state)
            return [];
          return state.wallets || [];
        },
        getActiveWallets: function() {
          return ctx.getWallets().filter(function(wallet) {
            return wallet.connected && wallet.authenticated;
          });
        },
        detachWallet: function(wallet) {
          _stateContainer.updateState(function(state) {
            return {
              wallets: (state && state.wallets || []).filter(function(w) {
                return w !== wallet;
              })
            };
          });
          var _instanceId = wallet._instanceId;
          if (_walletUnsubscribeFns.has(_instanceId)) {
            var unsubscribe = _walletUnsubscribeFns.get(_instanceId);
            if (typeof unsubscribe === "function")
              unsubscribe();
          }
        },
        logoutAll: function() {
          return Promise.all(ctx.getWallets().map(function(wallet) {
            return wallet.logout();
          })).then(function() {
            return true;
          });
        },
        disconnectAll: function() {
          return Promise.all(ctx.getWallets().map(function(wallet) {
            return wallet.disconnect();
          })).then(function() {
            return true;
          });
        },
        terminateAll: function() {
          return Promise.all(ctx.getWallets().map(function(wallet) {
            return wallet.terminate();
          })).then(function() {
            return true;
          });
        },
        destroy: function() {
          return ctx.terminateAll().then(function() {
            stateUnsubscribe();
            _walletUnsubscribeFns.forEach(function(unsubscribeFn) {
              if (typeof unsubscribeFn === "function")
                unsubscribeFn();
            });
            _listeners = [];
          });
        },
        subscribe: function(listener) {
          _listeners = _listeners.concat([listener]);
          return function unsubscribe() {
            _listeners = _listeners.filter(function(l) {
              return l !== listener;
            });
          };
        }
      };
      return ctx;
    }
    exports.initAccessContext = initAccessContext;
  }
});

// node_modules/@aikon/eos-transit/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@aikon/eos-transit/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var walletAccessContext_1 = require_walletAccessContext();
    exports.initAccessContext = walletAccessContext_1.initAccessContext;
    var wallet_1 = require_wallet();
    var wallet_2 = require_wallet();
    exports.initWallet = wallet_2.initWallet;
    function initDefaultAccessContext(options) {
      exports.defaultAccessContext = walletAccessContext_1.initAccessContext(options);
      return exports.defaultAccessContext;
    }
    exports.initDefaultAccessContext = initDefaultAccessContext;
    var WAL = {
      initDefaultAccessContext,
      get accessContext() {
        if (!exports.defaultAccessContext) {
          throw new Error("\n        No default WalletAccessContext is configured. \n        Make sure to first run 'initDefaultAccessContext' to set it up.\n      ");
        }
        return exports.defaultAccessContext;
      },
      initWallet: wallet_1.initWallet
    };
    exports.default = WAL;
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs
function setUint64(view, offset, value) {
  var high = value / 4294967296;
  var low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function setInt64(view, offset, value) {
  var high = Math.floor(value / 4294967296);
  var low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function getInt64(view, offset) {
  var high = view.getInt32(offset);
  var low = view.getUint32(offset + 4);
  return high * 4294967296 + low;
}
function getUint64(view, offset) {
  var high = view.getUint32(offset);
  var low = view.getUint32(offset + 4);
  return high * 4294967296 + low;
}
var UINT32_MAX;
var init_int = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs"() {
    UINT32_MAX = 4294967295;
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs
function utf8Count(str) {
  var strLength = str.length;
  var byteLength = 0;
  var pos = 0;
  while (pos < strLength) {
    var value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      byteLength++;
      continue;
    } else if ((value & 4294965248) === 0) {
      byteLength += 2;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          var extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        byteLength += 3;
      } else {
        byteLength += 4;
      }
    }
  }
  return byteLength;
}
function utf8EncodeJs(str, output, outputOffset) {
  var strLength = str.length;
  var offset = outputOffset;
  var pos = 0;
  while (pos < strLength) {
    var value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      output[offset++] = value;
      continue;
    } else if ((value & 4294965248) === 0) {
      output[offset++] = value >> 6 & 31 | 192;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          var extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        output[offset++] = value >> 12 & 15 | 224;
        output[offset++] = value >> 6 & 63 | 128;
      } else {
        output[offset++] = value >> 18 & 7 | 240;
        output[offset++] = value >> 12 & 63 | 128;
        output[offset++] = value >> 6 & 63 | 128;
      }
    }
    output[offset++] = value & 63 | 128;
  }
}
function utf8EncodeTEencode(str, output, outputOffset) {
  output.set(sharedTextEncoder.encode(str), outputOffset);
}
function utf8EncodeTEencodeInto(str, output, outputOffset) {
  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
}
function utf8DecodeJs(bytes, inputOffset, byteLength) {
  var offset = inputOffset;
  var end = offset + byteLength;
  var units = [];
  var result = "";
  while (offset < end) {
    var byte1 = bytes[offset++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      var byte2 = bytes[offset++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      var byte2 = bytes[offset++] & 63;
      var byte3 = bytes[offset++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      var byte2 = bytes[offset++] & 63;
      var byte3 = bytes[offset++] & 63;
      var byte4 = bytes[offset++] & 63;
      var unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= CHUNK_SIZE) {
      result += String.fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += String.fromCharCode.apply(String, units);
  }
  return result;
}
function utf8DecodeTD(bytes, inputOffset, byteLength) {
  var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
  return sharedTextDecoder.decode(stringBytes);
}
var _a, _b, _c, TEXT_ENCODING_AVAILABLE, sharedTextEncoder, TEXT_ENCODER_THRESHOLD, utf8EncodeTE, CHUNK_SIZE, sharedTextDecoder, TEXT_DECODER_THRESHOLD;
var init_utf8 = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs"() {
    init_int();
    TEXT_ENCODING_AVAILABLE = (typeof process === "undefined" || ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a["TEXT_ENCODING"]) !== "never") && typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined";
    sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;
    TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? UINT32_MAX : typeof process !== "undefined" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b["TEXT_ENCODING"]) !== "force" ? 200 : 0;
    utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;
    CHUNK_SIZE = 4096;
    sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;
    TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? UINT32_MAX : typeof process !== "undefined" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c["TEXT_DECODER"]) !== "force" ? 200 : 0;
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs
var ExtData;
var init_ExtData = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs"() {
    ExtData = /** @class */
    function() {
      function ExtData2(type, data) {
        this.type = type;
        this.data = data;
      }
      return ExtData2;
    }();
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs
var __extends, DecodeError;
var init_DecodeError = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs"() {
    __extends = function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DecodeError = /** @class */
    function(_super) {
      __extends(DecodeError2, _super);
      function DecodeError2(message) {
        var _this = _super.call(this, message) || this;
        var proto = Object.create(DecodeError2.prototype);
        Object.setPrototypeOf(_this, proto);
        Object.defineProperty(_this, "name", {
          configurable: true,
          enumerable: false,
          value: DecodeError2.name
        });
        return _this;
      }
      return DecodeError2;
    }(Error);
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs
function encodeTimeSpecToTimestamp(_a2) {
  var sec = _a2.sec, nsec = _a2.nsec;
  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
      var rv = new Uint8Array(4);
      var view = new DataView(rv.buffer);
      view.setUint32(0, sec);
      return rv;
    } else {
      var secHigh = sec / 4294967296;
      var secLow = sec & 4294967295;
      var rv = new Uint8Array(8);
      var view = new DataView(rv.buffer);
      view.setUint32(0, nsec << 2 | secHigh & 3);
      view.setUint32(4, secLow);
      return rv;
    }
  } else {
    var rv = new Uint8Array(12);
    var view = new DataView(rv.buffer);
    view.setUint32(0, nsec);
    setInt64(view, 4, sec);
    return rv;
  }
}
function encodeDateToTimeSpec(date) {
  var msec = date.getTime();
  var sec = Math.floor(msec / 1e3);
  var nsec = (msec - sec * 1e3) * 1e6;
  var nsecInSec = Math.floor(nsec / 1e9);
  return {
    sec: sec + nsecInSec,
    nsec: nsec - nsecInSec * 1e9
  };
}
function encodeTimestampExtension(object) {
  if (object instanceof Date) {
    var timeSpec = encodeDateToTimeSpec(object);
    return encodeTimeSpecToTimestamp(timeSpec);
  } else {
    return null;
  }
}
function decodeTimestampToTimeSpec(data) {
  var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  switch (data.byteLength) {
    case 4: {
      var sec = view.getUint32(0);
      var nsec = 0;
      return { sec, nsec };
    }
    case 8: {
      var nsec30AndSecHigh2 = view.getUint32(0);
      var secLow32 = view.getUint32(4);
      var sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
      var nsec = nsec30AndSecHigh2 >>> 2;
      return { sec, nsec };
    }
    case 12: {
      var sec = getInt64(view, 4);
      var nsec = view.getUint32(0);
      return { sec, nsec };
    }
    default:
      throw new DecodeError("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(data.length));
  }
}
function decodeTimestampExtension(data) {
  var timeSpec = decodeTimestampToTimeSpec(data);
  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
var EXT_TIMESTAMP, TIMESTAMP32_MAX_SEC, TIMESTAMP64_MAX_SEC, timestampExtension;
var init_timestamp = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs"() {
    init_DecodeError();
    init_int();
    EXT_TIMESTAMP = -1;
    TIMESTAMP32_MAX_SEC = 4294967296 - 1;
    TIMESTAMP64_MAX_SEC = 17179869184 - 1;
    timestampExtension = {
      type: EXT_TIMESTAMP,
      encode: encodeTimestampExtension,
      decode: decodeTimestampExtension
    };
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs
var ExtensionCodec;
var init_ExtensionCodec = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs"() {
    init_ExtData();
    init_timestamp();
    ExtensionCodec = /** @class */
    function() {
      function ExtensionCodec2() {
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        this.encoders = [];
        this.decoders = [];
        this.register(timestampExtension);
      }
      ExtensionCodec2.prototype.register = function(_a2) {
        var type = _a2.type, encode2 = _a2.encode, decode2 = _a2.decode;
        if (type >= 0) {
          this.encoders[type] = encode2;
          this.decoders[type] = decode2;
        } else {
          var index = 1 + type;
          this.builtInEncoders[index] = encode2;
          this.builtInDecoders[index] = decode2;
        }
      };
      ExtensionCodec2.prototype.tryToEncode = function(object, context) {
        for (var i = 0; i < this.builtInEncoders.length; i++) {
          var encodeExt = this.builtInEncoders[i];
          if (encodeExt != null) {
            var data = encodeExt(object, context);
            if (data != null) {
              var type = -1 - i;
              return new ExtData(type, data);
            }
          }
        }
        for (var i = 0; i < this.encoders.length; i++) {
          var encodeExt = this.encoders[i];
          if (encodeExt != null) {
            var data = encodeExt(object, context);
            if (data != null) {
              var type = i;
              return new ExtData(type, data);
            }
          }
        }
        if (object instanceof ExtData) {
          return object;
        }
        return null;
      };
      ExtensionCodec2.prototype.decode = function(data, type, context) {
        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decodeExt) {
          return decodeExt(data, type, context);
        } else {
          return new ExtData(type, data);
        }
      };
      ExtensionCodec2.defaultCodec = new ExtensionCodec2();
      return ExtensionCodec2;
    }();
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs
function ensureUint8Array(buffer) {
  if (buffer instanceof Uint8Array) {
    return buffer;
  } else if (ArrayBuffer.isView(buffer)) {
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  } else if (buffer instanceof ArrayBuffer) {
    return new Uint8Array(buffer);
  } else {
    return Uint8Array.from(buffer);
  }
}
function createDataView(buffer) {
  if (buffer instanceof ArrayBuffer) {
    return new DataView(buffer);
  }
  var bufferView = ensureUint8Array(buffer);
  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
}
var init_typedArrays = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs"() {
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs
var DEFAULT_MAX_DEPTH, DEFAULT_INITIAL_BUFFER_SIZE, Encoder;
var init_Encoder = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs"() {
    init_utf8();
    init_ExtensionCodec();
    init_int();
    init_typedArrays();
    DEFAULT_MAX_DEPTH = 100;
    DEFAULT_INITIAL_BUFFER_SIZE = 2048;
    Encoder = /** @class */
    function() {
      function Encoder2(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {
        if (extensionCodec === void 0) {
          extensionCodec = ExtensionCodec.defaultCodec;
        }
        if (context === void 0) {
          context = void 0;
        }
        if (maxDepth === void 0) {
          maxDepth = DEFAULT_MAX_DEPTH;
        }
        if (initialBufferSize === void 0) {
          initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE;
        }
        if (sortKeys === void 0) {
          sortKeys = false;
        }
        if (forceFloat32 === void 0) {
          forceFloat32 = false;
        }
        if (ignoreUndefined === void 0) {
          ignoreUndefined = false;
        }
        if (forceIntegerToFloat === void 0) {
          forceIntegerToFloat = false;
        }
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxDepth = maxDepth;
        this.initialBufferSize = initialBufferSize;
        this.sortKeys = sortKeys;
        this.forceFloat32 = forceFloat32;
        this.ignoreUndefined = ignoreUndefined;
        this.forceIntegerToFloat = forceIntegerToFloat;
        this.pos = 0;
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
        this.bytes = new Uint8Array(this.view.buffer);
      }
      Encoder2.prototype.reinitializeState = function() {
        this.pos = 0;
      };
      Encoder2.prototype.encodeSharedRef = function(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.subarray(0, this.pos);
      };
      Encoder2.prototype.encode = function(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.slice(0, this.pos);
      };
      Encoder2.prototype.doEncode = function(object, depth) {
        if (depth > this.maxDepth) {
          throw new Error("Too deep objects in depth ".concat(depth));
        }
        if (object == null) {
          this.encodeNil();
        } else if (typeof object === "boolean") {
          this.encodeBoolean(object);
        } else if (typeof object === "number") {
          this.encodeNumber(object);
        } else if (typeof object === "string") {
          this.encodeString(object);
        } else {
          this.encodeObject(object, depth);
        }
      };
      Encoder2.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {
        var requiredSize = this.pos + sizeToWrite;
        if (this.view.byteLength < requiredSize) {
          this.resizeBuffer(requiredSize * 2);
        }
      };
      Encoder2.prototype.resizeBuffer = function(newSize) {
        var newBuffer = new ArrayBuffer(newSize);
        var newBytes = new Uint8Array(newBuffer);
        var newView = new DataView(newBuffer);
        newBytes.set(this.bytes);
        this.view = newView;
        this.bytes = newBytes;
      };
      Encoder2.prototype.encodeNil = function() {
        this.writeU8(192);
      };
      Encoder2.prototype.encodeBoolean = function(object) {
        if (object === false) {
          this.writeU8(194);
        } else {
          this.writeU8(195);
        }
      };
      Encoder2.prototype.encodeNumber = function(object) {
        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {
          if (object >= 0) {
            if (object < 128) {
              this.writeU8(object);
            } else if (object < 256) {
              this.writeU8(204);
              this.writeU8(object);
            } else if (object < 65536) {
              this.writeU8(205);
              this.writeU16(object);
            } else if (object < 4294967296) {
              this.writeU8(206);
              this.writeU32(object);
            } else {
              this.writeU8(207);
              this.writeU64(object);
            }
          } else {
            if (object >= -32) {
              this.writeU8(224 | object + 32);
            } else if (object >= -128) {
              this.writeU8(208);
              this.writeI8(object);
            } else if (object >= -32768) {
              this.writeU8(209);
              this.writeI16(object);
            } else if (object >= -2147483648) {
              this.writeU8(210);
              this.writeI32(object);
            } else {
              this.writeU8(211);
              this.writeI64(object);
            }
          }
        } else {
          if (this.forceFloat32) {
            this.writeU8(202);
            this.writeF32(object);
          } else {
            this.writeU8(203);
            this.writeF64(object);
          }
        }
      };
      Encoder2.prototype.writeStringHeader = function(byteLength) {
        if (byteLength < 32) {
          this.writeU8(160 + byteLength);
        } else if (byteLength < 256) {
          this.writeU8(217);
          this.writeU8(byteLength);
        } else if (byteLength < 65536) {
          this.writeU8(218);
          this.writeU16(byteLength);
        } else if (byteLength < 4294967296) {
          this.writeU8(219);
          this.writeU32(byteLength);
        } else {
          throw new Error("Too long string: ".concat(byteLength, " bytes in UTF-8"));
        }
      };
      Encoder2.prototype.encodeString = function(object) {
        var maxHeaderSize = 1 + 4;
        var strLength = object.length;
        if (strLength > TEXT_ENCODER_THRESHOLD) {
          var byteLength = utf8Count(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          utf8EncodeTE(object, this.bytes, this.pos);
          this.pos += byteLength;
        } else {
          var byteLength = utf8Count(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          utf8EncodeJs(object, this.bytes, this.pos);
          this.pos += byteLength;
        }
      };
      Encoder2.prototype.encodeObject = function(object, depth) {
        var ext = this.extensionCodec.tryToEncode(object, this.context);
        if (ext != null) {
          this.encodeExtension(ext);
        } else if (Array.isArray(object)) {
          this.encodeArray(object, depth);
        } else if (ArrayBuffer.isView(object)) {
          this.encodeBinary(object);
        } else if (typeof object === "object") {
          this.encodeMap(object, depth);
        } else {
          throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(object)));
        }
      };
      Encoder2.prototype.encodeBinary = function(object) {
        var size = object.byteLength;
        if (size < 256) {
          this.writeU8(196);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(197);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(198);
          this.writeU32(size);
        } else {
          throw new Error("Too large binary: ".concat(size));
        }
        var bytes = ensureUint8Array(object);
        this.writeU8a(bytes);
      };
      Encoder2.prototype.encodeArray = function(object, depth) {
        var size = object.length;
        if (size < 16) {
          this.writeU8(144 + size);
        } else if (size < 65536) {
          this.writeU8(220);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(221);
          this.writeU32(size);
        } else {
          throw new Error("Too large array: ".concat(size));
        }
        for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {
          var item = object_1[_i];
          this.doEncode(item, depth + 1);
        }
      };
      Encoder2.prototype.countWithoutUndefined = function(object, keys) {
        var count = 0;
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
          var key = keys_1[_i];
          if (object[key] !== void 0) {
            count++;
          }
        }
        return count;
      };
      Encoder2.prototype.encodeMap = function(object, depth) {
        var keys = Object.keys(object);
        if (this.sortKeys) {
          keys.sort();
        }
        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
        if (size < 16) {
          this.writeU8(128 + size);
        } else if (size < 65536) {
          this.writeU8(222);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(223);
          this.writeU32(size);
        } else {
          throw new Error("Too large map object: ".concat(size));
        }
        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
          var key = keys_2[_i];
          var value = object[key];
          if (!(this.ignoreUndefined && value === void 0)) {
            this.encodeString(key);
            this.doEncode(value, depth + 1);
          }
        }
      };
      Encoder2.prototype.encodeExtension = function(ext) {
        var size = ext.data.length;
        if (size === 1) {
          this.writeU8(212);
        } else if (size === 2) {
          this.writeU8(213);
        } else if (size === 4) {
          this.writeU8(214);
        } else if (size === 8) {
          this.writeU8(215);
        } else if (size === 16) {
          this.writeU8(216);
        } else if (size < 256) {
          this.writeU8(199);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(200);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(201);
          this.writeU32(size);
        } else {
          throw new Error("Too large extension object: ".concat(size));
        }
        this.writeI8(ext.type);
        this.writeU8a(ext.data);
      };
      Encoder2.prototype.writeU8 = function(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setUint8(this.pos, value);
        this.pos++;
      };
      Encoder2.prototype.writeU8a = function(values) {
        var size = values.length;
        this.ensureBufferSizeToWrite(size);
        this.bytes.set(values, this.pos);
        this.pos += size;
      };
      Encoder2.prototype.writeI8 = function(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setInt8(this.pos, value);
        this.pos++;
      };
      Encoder2.prototype.writeU16 = function(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setUint16(this.pos, value);
        this.pos += 2;
      };
      Encoder2.prototype.writeI16 = function(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
      };
      Encoder2.prototype.writeU32 = function(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setUint32(this.pos, value);
        this.pos += 4;
      };
      Encoder2.prototype.writeI32 = function(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
      };
      Encoder2.prototype.writeF32 = function(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
      };
      Encoder2.prototype.writeF64 = function(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
      };
      Encoder2.prototype.writeU64 = function(value) {
        this.ensureBufferSizeToWrite(8);
        setUint64(this.view, this.pos, value);
        this.pos += 8;
      };
      Encoder2.prototype.writeI64 = function(value) {
        this.ensureBufferSizeToWrite(8);
        setInt64(this.view, this.pos, value);
        this.pos += 8;
      };
      return Encoder2;
    }();
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs
function encode(value, options) {
  if (options === void 0) {
    options = defaultEncodeOptions;
  }
  var encoder = new Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);
  return encoder.encodeSharedRef(value);
}
var defaultEncodeOptions;
var init_encode = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs"() {
    init_Encoder();
    defaultEncodeOptions = {};
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs
function prettyByte(byte) {
  return "".concat(byte < 0 ? "-" : "", "0x").concat(Math.abs(byte).toString(16).padStart(2, "0"));
}
var init_prettyByte = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs"() {
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs
var DEFAULT_MAX_KEY_LENGTH, DEFAULT_MAX_LENGTH_PER_KEY, CachedKeyDecoder;
var init_CachedKeyDecoder = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs"() {
    init_utf8();
    DEFAULT_MAX_KEY_LENGTH = 16;
    DEFAULT_MAX_LENGTH_PER_KEY = 16;
    CachedKeyDecoder = /** @class */
    function() {
      function CachedKeyDecoder2(maxKeyLength, maxLengthPerKey) {
        if (maxKeyLength === void 0) {
          maxKeyLength = DEFAULT_MAX_KEY_LENGTH;
        }
        if (maxLengthPerKey === void 0) {
          maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;
        }
        this.maxKeyLength = maxKeyLength;
        this.maxLengthPerKey = maxLengthPerKey;
        this.hit = 0;
        this.miss = 0;
        this.caches = [];
        for (var i = 0; i < this.maxKeyLength; i++) {
          this.caches.push([]);
        }
      }
      CachedKeyDecoder2.prototype.canBeCached = function(byteLength) {
        return byteLength > 0 && byteLength <= this.maxKeyLength;
      };
      CachedKeyDecoder2.prototype.find = function(bytes, inputOffset, byteLength) {
        var records = this.caches[byteLength - 1];
        FIND_CHUNK:
          for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {
            var record = records_1[_i];
            var recordBytes = record.bytes;
            for (var j = 0; j < byteLength; j++) {
              if (recordBytes[j] !== bytes[inputOffset + j]) {
                continue FIND_CHUNK;
              }
            }
            return record.str;
          }
        return null;
      };
      CachedKeyDecoder2.prototype.store = function(bytes, value) {
        var records = this.caches[bytes.length - 1];
        var record = { bytes, str: value };
        if (records.length >= this.maxLengthPerKey) {
          records[Math.random() * records.length | 0] = record;
        } else {
          records.push(record);
        }
      };
      CachedKeyDecoder2.prototype.decode = function(bytes, inputOffset, byteLength) {
        var cachedValue = this.find(bytes, inputOffset, byteLength);
        if (cachedValue != null) {
          this.hit++;
          return cachedValue;
        }
        this.miss++;
        var str = utf8DecodeJs(bytes, inputOffset, byteLength);
        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
        this.store(slicedCopyOfBytes, str);
        return str;
      };
      return CachedKeyDecoder2;
    }();
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs
var __awaiter, __generator, __asyncValues, __await, __asyncGenerator, isValidMapKeyType, HEAD_BYTE_REQUIRED, EMPTY_VIEW, EMPTY_BYTES, DataViewIndexOutOfBoundsError, MORE_DATA, sharedCachedKeyDecoder, Decoder;
var init_Decoder = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs"() {
    init_prettyByte();
    init_ExtensionCodec();
    init_int();
    init_utf8();
    init_typedArrays();
    init_CachedKeyDecoder();
    init_DecodeError();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f2, v) {
        if (f2(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    isValidMapKeyType = function(key) {
      var keyType = typeof key;
      return keyType === "string" || keyType === "number";
    };
    HEAD_BYTE_REQUIRED = -1;
    EMPTY_VIEW = new DataView(new ArrayBuffer(0));
    EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
    DataViewIndexOutOfBoundsError = function() {
      try {
        EMPTY_VIEW.getInt8(0);
      } catch (e) {
        return e.constructor;
      }
      throw new Error("never reached");
    }();
    MORE_DATA = new DataViewIndexOutOfBoundsError("Insufficient data");
    sharedCachedKeyDecoder = new CachedKeyDecoder();
    Decoder = /** @class */
    function() {
      function Decoder2(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {
        if (extensionCodec === void 0) {
          extensionCodec = ExtensionCodec.defaultCodec;
        }
        if (context === void 0) {
          context = void 0;
        }
        if (maxStrLength === void 0) {
          maxStrLength = UINT32_MAX;
        }
        if (maxBinLength === void 0) {
          maxBinLength = UINT32_MAX;
        }
        if (maxArrayLength === void 0) {
          maxArrayLength = UINT32_MAX;
        }
        if (maxMapLength === void 0) {
          maxMapLength = UINT32_MAX;
        }
        if (maxExtLength === void 0) {
          maxExtLength = UINT32_MAX;
        }
        if (keyDecoder === void 0) {
          keyDecoder = sharedCachedKeyDecoder;
        }
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxStrLength = maxStrLength;
        this.maxBinLength = maxBinLength;
        this.maxArrayLength = maxArrayLength;
        this.maxMapLength = maxMapLength;
        this.maxExtLength = maxExtLength;
        this.keyDecoder = keyDecoder;
        this.totalPos = 0;
        this.pos = 0;
        this.view = EMPTY_VIEW;
        this.bytes = EMPTY_BYTES;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = [];
      }
      Decoder2.prototype.reinitializeState = function() {
        this.totalPos = 0;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack.length = 0;
      };
      Decoder2.prototype.setBuffer = function(buffer) {
        this.bytes = ensureUint8Array(buffer);
        this.view = createDataView(this.bytes);
        this.pos = 0;
      };
      Decoder2.prototype.appendBuffer = function(buffer) {
        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
          this.setBuffer(buffer);
        } else {
          var remainingData = this.bytes.subarray(this.pos);
          var newData = ensureUint8Array(buffer);
          var newBuffer = new Uint8Array(remainingData.length + newData.length);
          newBuffer.set(remainingData);
          newBuffer.set(newData, remainingData.length);
          this.setBuffer(newBuffer);
        }
      };
      Decoder2.prototype.hasRemaining = function(size) {
        return this.view.byteLength - this.pos >= size;
      };
      Decoder2.prototype.createExtraByteError = function(posToShow) {
        var _a2 = this, view = _a2.view, pos = _a2.pos;
        return new RangeError("Extra ".concat(view.byteLength - pos, " of ").concat(view.byteLength, " byte(s) found at buffer[").concat(posToShow, "]"));
      };
      Decoder2.prototype.decode = function(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        var object = this.doDecodeSync();
        if (this.hasRemaining(1)) {
          throw this.createExtraByteError(this.pos);
        }
        return object;
      };
      Decoder2.prototype.decodeMulti = function(buffer) {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.reinitializeState();
              this.setBuffer(buffer);
              _a2.label = 1;
            case 1:
              if (!this.hasRemaining(1))
                return [3, 3];
              return [4, this.doDecodeSync()];
            case 2:
              _a2.sent();
              return [3, 1];
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      };
      Decoder2.prototype.decodeAsync = function(stream) {
        var stream_1, stream_1_1;
        var e_1, _a2;
        return __awaiter(this, void 0, void 0, function() {
          var decoded, object, buffer, e_1_1, _b2, headByte, pos, totalPos;
          return __generator(this, function(_c2) {
            switch (_c2.label) {
              case 0:
                decoded = false;
                _c2.label = 1;
              case 1:
                _c2.trys.push([1, 6, 7, 12]);
                stream_1 = __asyncValues(stream);
                _c2.label = 2;
              case 2:
                return [4, stream_1.next()];
              case 3:
                if (!(stream_1_1 = _c2.sent(), !stream_1_1.done))
                  return [3, 5];
                buffer = stream_1_1.value;
                if (decoded) {
                  throw this.createExtraByteError(this.totalPos);
                }
                this.appendBuffer(buffer);
                try {
                  object = this.doDecodeSync();
                  decoded = true;
                } catch (e) {
                  if (!(e instanceof DataViewIndexOutOfBoundsError)) {
                    throw e;
                  }
                }
                this.totalPos += this.pos;
                _c2.label = 4;
              case 4:
                return [3, 2];
              case 5:
                return [3, 12];
              case 6:
                e_1_1 = _c2.sent();
                e_1 = { error: e_1_1 };
                return [3, 12];
              case 7:
                _c2.trys.push([7, , 10, 11]);
                if (!(stream_1_1 && !stream_1_1.done && (_a2 = stream_1.return)))
                  return [3, 9];
                return [4, _a2.call(stream_1)];
              case 8:
                _c2.sent();
                _c2.label = 9;
              case 9:
                return [3, 11];
              case 10:
                if (e_1)
                  throw e_1.error;
                return [
                  7
                  /*endfinally*/
                ];
              case 11:
                return [
                  7
                  /*endfinally*/
                ];
              case 12:
                if (decoded) {
                  if (this.hasRemaining(1)) {
                    throw this.createExtraByteError(this.totalPos);
                  }
                  return [2, object];
                }
                _b2 = this, headByte = _b2.headByte, pos = _b2.pos, totalPos = _b2.totalPos;
                throw new RangeError("Insufficient data in parsing ".concat(prettyByte(headByte), " at ").concat(totalPos, " (").concat(pos, " in the current buffer)"));
            }
          });
        });
      };
      Decoder2.prototype.decodeArrayStream = function(stream) {
        return this.decodeMultiAsync(stream, true);
      };
      Decoder2.prototype.decodeStream = function(stream) {
        return this.decodeMultiAsync(stream, false);
      };
      Decoder2.prototype.decodeMultiAsync = function(stream, isArray) {
        return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {
          var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;
          var e_3, _a2;
          return __generator(this, function(_b2) {
            switch (_b2.label) {
              case 0:
                isArrayHeaderRequired = isArray;
                arrayItemsLeft = -1;
                _b2.label = 1;
              case 1:
                _b2.trys.push([1, 13, 14, 19]);
                stream_2 = __asyncValues(stream);
                _b2.label = 2;
              case 2:
                return [4, __await(stream_2.next())];
              case 3:
                if (!(stream_2_1 = _b2.sent(), !stream_2_1.done))
                  return [3, 12];
                buffer = stream_2_1.value;
                if (isArray && arrayItemsLeft === 0) {
                  throw this.createExtraByteError(this.totalPos);
                }
                this.appendBuffer(buffer);
                if (isArrayHeaderRequired) {
                  arrayItemsLeft = this.readArraySize();
                  isArrayHeaderRequired = false;
                  this.complete();
                }
                _b2.label = 4;
              case 4:
                _b2.trys.push([4, 9, , 10]);
                _b2.label = 5;
              case 5:
                if (false)
                  return [3, 8];
                return [4, __await(this.doDecodeSync())];
              case 6:
                return [4, _b2.sent()];
              case 7:
                _b2.sent();
                if (--arrayItemsLeft === 0) {
                  return [3, 8];
                }
                return [3, 5];
              case 8:
                return [3, 10];
              case 9:
                e_2 = _b2.sent();
                if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {
                  throw e_2;
                }
                return [3, 10];
              case 10:
                this.totalPos += this.pos;
                _b2.label = 11;
              case 11:
                return [3, 2];
              case 12:
                return [3, 19];
              case 13:
                e_3_1 = _b2.sent();
                e_3 = { error: e_3_1 };
                return [3, 19];
              case 14:
                _b2.trys.push([14, , 17, 18]);
                if (!(stream_2_1 && !stream_2_1.done && (_a2 = stream_2.return)))
                  return [3, 16];
                return [4, __await(_a2.call(stream_2))];
              case 15:
                _b2.sent();
                _b2.label = 16;
              case 16:
                return [3, 18];
              case 17:
                if (e_3)
                  throw e_3.error;
                return [
                  7
                  /*endfinally*/
                ];
              case 18:
                return [
                  7
                  /*endfinally*/
                ];
              case 19:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      Decoder2.prototype.doDecodeSync = function() {
        DECODE:
          while (true) {
            var headByte = this.readHeadByte();
            var object = void 0;
            if (headByte >= 224) {
              object = headByte - 256;
            } else if (headByte < 192) {
              if (headByte < 128) {
                object = headByte;
              } else if (headByte < 144) {
                var size = headByte - 128;
                if (size !== 0) {
                  this.pushMapState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = {};
                }
              } else if (headByte < 160) {
                var size = headByte - 144;
                if (size !== 0) {
                  this.pushArrayState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = [];
                }
              } else {
                var byteLength = headByte - 160;
                object = this.decodeUtf8String(byteLength, 0);
              }
            } else if (headByte === 192) {
              object = null;
            } else if (headByte === 194) {
              object = false;
            } else if (headByte === 195) {
              object = true;
            } else if (headByte === 202) {
              object = this.readF32();
            } else if (headByte === 203) {
              object = this.readF64();
            } else if (headByte === 204) {
              object = this.readU8();
            } else if (headByte === 205) {
              object = this.readU16();
            } else if (headByte === 206) {
              object = this.readU32();
            } else if (headByte === 207) {
              object = this.readU64();
            } else if (headByte === 208) {
              object = this.readI8();
            } else if (headByte === 209) {
              object = this.readI16();
            } else if (headByte === 210) {
              object = this.readI32();
            } else if (headByte === 211) {
              object = this.readI64();
            } else if (headByte === 217) {
              var byteLength = this.lookU8();
              object = this.decodeUtf8String(byteLength, 1);
            } else if (headByte === 218) {
              var byteLength = this.lookU16();
              object = this.decodeUtf8String(byteLength, 2);
            } else if (headByte === 219) {
              var byteLength = this.lookU32();
              object = this.decodeUtf8String(byteLength, 4);
            } else if (headByte === 220) {
              var size = this.readU16();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 221) {
              var size = this.readU32();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 222) {
              var size = this.readU16();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 223) {
              var size = this.readU32();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 196) {
              var size = this.lookU8();
              object = this.decodeBinary(size, 1);
            } else if (headByte === 197) {
              var size = this.lookU16();
              object = this.decodeBinary(size, 2);
            } else if (headByte === 198) {
              var size = this.lookU32();
              object = this.decodeBinary(size, 4);
            } else if (headByte === 212) {
              object = this.decodeExtension(1, 0);
            } else if (headByte === 213) {
              object = this.decodeExtension(2, 0);
            } else if (headByte === 214) {
              object = this.decodeExtension(4, 0);
            } else if (headByte === 215) {
              object = this.decodeExtension(8, 0);
            } else if (headByte === 216) {
              object = this.decodeExtension(16, 0);
            } else if (headByte === 199) {
              var size = this.lookU8();
              object = this.decodeExtension(size, 1);
            } else if (headByte === 200) {
              var size = this.lookU16();
              object = this.decodeExtension(size, 2);
            } else if (headByte === 201) {
              var size = this.lookU32();
              object = this.decodeExtension(size, 4);
            } else {
              throw new DecodeError("Unrecognized type byte: ".concat(prettyByte(headByte)));
            }
            this.complete();
            var stack = this.stack;
            while (stack.length > 0) {
              var state = stack[stack.length - 1];
              if (state.type === 0) {
                state.array[state.position] = object;
                state.position++;
                if (state.position === state.size) {
                  stack.pop();
                  object = state.array;
                } else {
                  continue DECODE;
                }
              } else if (state.type === 1) {
                if (!isValidMapKeyType(object)) {
                  throw new DecodeError("The type of key must be string or number but " + typeof object);
                }
                if (object === "__proto__") {
                  throw new DecodeError("The key __proto__ is not allowed");
                }
                state.key = object;
                state.type = 2;
                continue DECODE;
              } else {
                state.map[state.key] = object;
                state.readCount++;
                if (state.readCount === state.size) {
                  stack.pop();
                  object = state.map;
                } else {
                  state.key = null;
                  state.type = 1;
                  continue DECODE;
                }
              }
            }
            return object;
          }
      };
      Decoder2.prototype.readHeadByte = function() {
        if (this.headByte === HEAD_BYTE_REQUIRED) {
          this.headByte = this.readU8();
        }
        return this.headByte;
      };
      Decoder2.prototype.complete = function() {
        this.headByte = HEAD_BYTE_REQUIRED;
      };
      Decoder2.prototype.readArraySize = function() {
        var headByte = this.readHeadByte();
        switch (headByte) {
          case 220:
            return this.readU16();
          case 221:
            return this.readU32();
          default: {
            if (headByte < 160) {
              return headByte - 144;
            } else {
              throw new DecodeError("Unrecognized array type byte: ".concat(prettyByte(headByte)));
            }
          }
        }
      };
      Decoder2.prototype.pushMapState = function(size) {
        if (size > this.maxMapLength) {
          throw new DecodeError("Max length exceeded: map length (".concat(size, ") > maxMapLengthLength (").concat(this.maxMapLength, ")"));
        }
        this.stack.push({
          type: 1,
          size,
          key: null,
          readCount: 0,
          map: {}
        });
      };
      Decoder2.prototype.pushArrayState = function(size) {
        if (size > this.maxArrayLength) {
          throw new DecodeError("Max length exceeded: array length (".concat(size, ") > maxArrayLength (").concat(this.maxArrayLength, ")"));
        }
        this.stack.push({
          type: 0,
          size,
          array: new Array(size),
          position: 0
        });
      };
      Decoder2.prototype.decodeUtf8String = function(byteLength, headerOffset) {
        var _a2;
        if (byteLength > this.maxStrLength) {
          throw new DecodeError("Max length exceeded: UTF-8 byte length (".concat(byteLength, ") > maxStrLength (").concat(this.maxStrLength, ")"));
        }
        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
          throw MORE_DATA;
        }
        var offset = this.pos + headerOffset;
        var object;
        if (this.stateIsMapKey() && ((_a2 = this.keyDecoder) === null || _a2 === void 0 ? void 0 : _a2.canBeCached(byteLength))) {
          object = this.keyDecoder.decode(this.bytes, offset, byteLength);
        } else if (byteLength > TEXT_DECODER_THRESHOLD) {
          object = utf8DecodeTD(this.bytes, offset, byteLength);
        } else {
          object = utf8DecodeJs(this.bytes, offset, byteLength);
        }
        this.pos += headerOffset + byteLength;
        return object;
      };
      Decoder2.prototype.stateIsMapKey = function() {
        if (this.stack.length > 0) {
          var state = this.stack[this.stack.length - 1];
          return state.type === 1;
        }
        return false;
      };
      Decoder2.prototype.decodeBinary = function(byteLength, headOffset) {
        if (byteLength > this.maxBinLength) {
          throw new DecodeError("Max length exceeded: bin length (".concat(byteLength, ") > maxBinLength (").concat(this.maxBinLength, ")"));
        }
        if (!this.hasRemaining(byteLength + headOffset)) {
          throw MORE_DATA;
        }
        var offset = this.pos + headOffset;
        var object = this.bytes.subarray(offset, offset + byteLength);
        this.pos += headOffset + byteLength;
        return object;
      };
      Decoder2.prototype.decodeExtension = function(size, headOffset) {
        if (size > this.maxExtLength) {
          throw new DecodeError("Max length exceeded: ext length (".concat(size, ") > maxExtLength (").concat(this.maxExtLength, ")"));
        }
        var extType = this.view.getInt8(this.pos + headOffset);
        var data = this.decodeBinary(
          size,
          headOffset + 1
          /* extType */
        );
        return this.extensionCodec.decode(data, extType, this.context);
      };
      Decoder2.prototype.lookU8 = function() {
        return this.view.getUint8(this.pos);
      };
      Decoder2.prototype.lookU16 = function() {
        return this.view.getUint16(this.pos);
      };
      Decoder2.prototype.lookU32 = function() {
        return this.view.getUint32(this.pos);
      };
      Decoder2.prototype.readU8 = function() {
        var value = this.view.getUint8(this.pos);
        this.pos++;
        return value;
      };
      Decoder2.prototype.readI8 = function() {
        var value = this.view.getInt8(this.pos);
        this.pos++;
        return value;
      };
      Decoder2.prototype.readU16 = function() {
        var value = this.view.getUint16(this.pos);
        this.pos += 2;
        return value;
      };
      Decoder2.prototype.readI16 = function() {
        var value = this.view.getInt16(this.pos);
        this.pos += 2;
        return value;
      };
      Decoder2.prototype.readU32 = function() {
        var value = this.view.getUint32(this.pos);
        this.pos += 4;
        return value;
      };
      Decoder2.prototype.readI32 = function() {
        var value = this.view.getInt32(this.pos);
        this.pos += 4;
        return value;
      };
      Decoder2.prototype.readU64 = function() {
        var value = getUint64(this.view, this.pos);
        this.pos += 8;
        return value;
      };
      Decoder2.prototype.readI64 = function() {
        var value = getInt64(this.view, this.pos);
        this.pos += 8;
        return value;
      };
      Decoder2.prototype.readF32 = function() {
        var value = this.view.getFloat32(this.pos);
        this.pos += 4;
        return value;
      };
      Decoder2.prototype.readF64 = function() {
        var value = this.view.getFloat64(this.pos);
        this.pos += 8;
        return value;
      };
      return Decoder2;
    }();
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs
function decode(buffer, options) {
  if (options === void 0) {
    options = defaultDecodeOptions;
  }
  var decoder = new Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
  return decoder.decode(buffer);
}
function decodeMulti(buffer, options) {
  if (options === void 0) {
    options = defaultDecodeOptions;
  }
  var decoder = new Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
  return decoder.decodeMulti(buffer);
}
var defaultDecodeOptions;
var init_decode = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs"() {
    init_Decoder();
    defaultDecodeOptions = {};
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs
function isAsyncIterable(object) {
  return object[Symbol.asyncIterator] != null;
}
function assertNonNull(value) {
  if (value == null) {
    throw new Error("Assertion Failure: value must not be null nor undefined");
  }
}
function asyncIterableFromStream(stream) {
  return __asyncGenerator2(this, arguments, function asyncIterableFromStream_1() {
    var reader, _a2, done, value;
    return __generator2(this, function(_b2) {
      switch (_b2.label) {
        case 0:
          reader = stream.getReader();
          _b2.label = 1;
        case 1:
          _b2.trys.push([1, , 9, 10]);
          _b2.label = 2;
        case 2:
          if (false)
            return [3, 8];
          return [4, __await2(reader.read())];
        case 3:
          _a2 = _b2.sent(), done = _a2.done, value = _a2.value;
          if (!done)
            return [3, 5];
          return [4, __await2(void 0)];
        case 4:
          return [2, _b2.sent()];
        case 5:
          assertNonNull(value);
          return [4, __await2(value)];
        case 6:
          return [4, _b2.sent()];
        case 7:
          _b2.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [
            7
            /*endfinally*/
          ];
        case 10:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function ensureAsyncIterable(streamLike) {
  if (isAsyncIterable(streamLike)) {
    return streamLike;
  } else {
    return asyncIterableFromStream(streamLike);
  }
}
var __generator2, __await2, __asyncGenerator2;
var init_stream = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs"() {
    __generator2 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    __await2 = function(v) {
      return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
    };
    __asyncGenerator2 = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f2, v) {
        if (f2(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs
function decodeAsync(streamLike, options) {
  if (options === void 0) {
    options = defaultDecodeOptions;
  }
  return __awaiter2(this, void 0, void 0, function() {
    var stream, decoder;
    return __generator3(this, function(_a2) {
      stream = ensureAsyncIterable(streamLike);
      decoder = new Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return [2, decoder.decodeAsync(stream)];
    });
  });
}
function decodeArrayStream(streamLike, options) {
  if (options === void 0) {
    options = defaultDecodeOptions;
  }
  var stream = ensureAsyncIterable(streamLike);
  var decoder = new Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
  return decoder.decodeArrayStream(stream);
}
function decodeMultiStream(streamLike, options) {
  if (options === void 0) {
    options = defaultDecodeOptions;
  }
  var stream = ensureAsyncIterable(streamLike);
  var decoder = new Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
  return decoder.decodeStream(stream);
}
function decodeStream(streamLike, options) {
  if (options === void 0) {
    options = defaultDecodeOptions;
  }
  return decodeMultiStream(streamLike, options);
}
var __awaiter2, __generator3;
var init_decodeAsync = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs"() {
    init_Decoder();
    init_stream();
    init_decode();
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator3 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs
var dist_exports = {};
__export(dist_exports, {
  DataViewIndexOutOfBoundsError: () => DataViewIndexOutOfBoundsError,
  DecodeError: () => DecodeError,
  Decoder: () => Decoder,
  EXT_TIMESTAMP: () => EXT_TIMESTAMP,
  Encoder: () => Encoder,
  ExtData: () => ExtData,
  ExtensionCodec: () => ExtensionCodec,
  decode: () => decode,
  decodeArrayStream: () => decodeArrayStream,
  decodeAsync: () => decodeAsync,
  decodeMulti: () => decodeMulti,
  decodeMultiStream: () => decodeMultiStream,
  decodeStream: () => decodeStream,
  decodeTimestampExtension: () => decodeTimestampExtension,
  decodeTimestampToTimeSpec: () => decodeTimestampToTimeSpec,
  encode: () => encode,
  encodeDateToTimeSpec: () => encodeDateToTimeSpec,
  encodeTimeSpecToTimestamp: () => encodeTimeSpecToTimestamp,
  encodeTimestampExtension: () => encodeTimestampExtension
});
var init_dist = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs"() {
    init_encode();
    init_decode();
    init_decodeAsync();
    init_Decoder();
    init_DecodeError();
    init_Encoder();
    init_ExtensionCodec();
    init_ExtData();
    init_timestamp();
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    module.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return toString.call(val) === "[object FormData]";
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return toString.call(val) === "[object URLSearchParams]";
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    function encode2(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode2(key) + "=" + encode2(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports, module) {
    "use strict";
    module.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "node_modules/axios/lib/defaults/transitional.js"(exports, module) {
    "use strict";
    module.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports, module) {
    "use strict";
    var enhanceError = require_enhanceError();
    module.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    var createError = require_createError();
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module.exports = Cancel;
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var transitionalDefaults = require_transitional();
    var Cancel = require_Cancel();
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults/index.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var transitionalDefaults = require_transitional();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module) {
    module.exports = {
      "version": "0.26.1"
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    var VERSION = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.VERSION = require_data().version;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module.exports = axios;
    module.exports.default = axios;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module) {
    module.exports = require_axios();
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof global !== "undefined" && global.crypto) {
          crypto2 = global.crypto;
        }
        if (!crypto2 && typeof __require === "function") {
          try {
            crypto2 = require_crypto();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f2 = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f2 ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f2;
              f2 = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f2 | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "node_modules/crypto-js/hmac.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC = C_algo.HMAC = Base.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 1549556828;
              iKeyWords[i] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  }
});

// node_modules/crypto-js/hmac-sha256.js
var require_hmac_sha256 = __commonJS({
  "node_modules/crypto-js/hmac-sha256.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS.HmacSHA256;
    });
  }
});

// node_modules/js-cookie/src/js.cookie.js
var require_js_cookie = __commonJS({
  "node_modules/js-cookie/src/js.cookie.js"(exports, module) {
    (function(factory) {
      var registeredInModuleLoader;
      if (typeof define === "function" && define.amd) {
        define(factory);
        registeredInModuleLoader = true;
      }
      if (typeof exports === "object") {
        module.exports = factory();
        registeredInModuleLoader = true;
      }
      if (!registeredInModuleLoader) {
        var OldCookies = window.Cookies;
        var api = window.Cookies = factory();
        api.noConflict = function() {
          window.Cookies = OldCookies;
          return api;
        };
      }
    })(function() {
      function extend() {
        var i = 0;
        var result = {};
        for (; i < arguments.length; i++) {
          var attributes = arguments[i];
          for (var key in attributes) {
            result[key] = attributes[key];
          }
        }
        return result;
      }
      function decode2(s) {
        return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
      }
      function init(converter) {
        function api() {
        }
        function set(key, value, attributes) {
          if (typeof document === "undefined") {
            return;
          }
          attributes = extend({
            path: "/"
          }, api.defaults, attributes);
          if (typeof attributes.expires === "number") {
            attributes.expires = new Date(/* @__PURE__ */ new Date() * 1 + attributes.expires * 864e5);
          }
          attributes.expires = attributes.expires ? attributes.expires.toUTCString() : "";
          try {
            var result = JSON.stringify(value);
            if (/^[\{\[]/.test(result)) {
              value = result;
            }
          } catch (e) {
          }
          value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
          key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
          var stringifiedAttributes = "";
          for (var attributeName in attributes) {
            if (!attributes[attributeName]) {
              continue;
            }
            stringifiedAttributes += "; " + attributeName;
            if (attributes[attributeName] === true) {
              continue;
            }
            stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
          }
          return document.cookie = key + "=" + value + stringifiedAttributes;
        }
        function get(key, json) {
          if (typeof document === "undefined") {
            return;
          }
          var jar = {};
          var cookies = document.cookie ? document.cookie.split("; ") : [];
          var i = 0;
          for (; i < cookies.length; i++) {
            var parts = cookies[i].split("=");
            var cookie = parts.slice(1).join("=");
            if (!json && cookie.charAt(0) === '"') {
              cookie = cookie.slice(1, -1);
            }
            try {
              var name = decode2(parts[0]);
              cookie = (converter.read || converter)(cookie, name) || decode2(cookie);
              if (json) {
                try {
                  cookie = JSON.parse(cookie);
                } catch (e) {
                }
              }
              jar[name] = cookie;
              if (key === name) {
                break;
              }
            } catch (e) {
            }
          }
          return key ? jar[key] : jar;
        }
        api.set = set;
        api.get = function(key) {
          return get(
            key,
            false
            /* read as raw */
          );
        };
        api.getJSON = function(key) {
          return get(
            key,
            true
            /* read as json */
          );
        };
        api.remove = function(key, attributes) {
          set(key, "", extend(attributes, {
            expires: -1
          }));
        };
        api.defaults = {};
        api.withConverter = init;
        return api;
      }
      return init(function() {
      });
    });
  }
});

// node_modules/oreid-js/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/oreid-js/dist/index.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? t(exports, (init_esm_browser(), __toCommonJS(esm_browser_exports)), require_canonicalize(), require_lib(), require_base64(), require_lib2(), (init_dist(), __toCommonJS(dist_exports)), require_axios2(), require_hmac_sha256(), require_js_cookie()) : "function" == typeof define && define.amd ? define(["exports", "uuid", "canonicalize", "jwt-decode", "js-base64", "@aikon/eos-transit", "@msgpack/msgpack", "axios", "crypto-js/hmac-sha256", "js-cookie"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self)["oreid-js"] = {}, e.uuid, e.canonicalize, e.jwtDecode, e.jsBase64, e.eosTransit, e.msgpack, e.axios, e.HmacSHA256, e.Cookie);
    }(exports, function(e, t, r, n, o, i, s, a, c, u) {
      "use strict";
      function l(e2) {
        return e2 && "object" == typeof e2 && "default" in e2 ? e2 : { default: e2 };
      }
      function d(e2) {
        if (e2 && e2.__esModule)
          return e2;
        var t2 = /* @__PURE__ */ Object.create(null);
        return e2 && Object.keys(e2).forEach(function(r2) {
          if ("default" !== r2) {
            var n2 = Object.getOwnPropertyDescriptor(e2, r2);
            Object.defineProperty(t2, r2, n2.get ? n2 : { enumerable: true, get: function() {
              return e2[r2];
            } });
          }
        }), t2.default = e2, Object.freeze(t2);
      }
      var p = l(r), h = l(n), v = l(a), f2 = l(c), g = d(u), y = function(e2, t2) {
        return y = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
          e3.__proto__ = t3;
        } || function(e3, t3) {
          for (var r2 in t3)
            Object.prototype.hasOwnProperty.call(t3, r2) && (e3[r2] = t3[r2]);
        }, y(e2, t2);
      };
      function T(e2, t2) {
        if ("function" != typeof t2 && null !== t2)
          throw new TypeError("Class extends value " + String(t2) + " is not a constructor or null");
        function r2() {
          this.constructor = e2;
        }
        y(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
      }
      var w, m, k, b, A, I, _, P, C, E, x = function() {
        return x = Object.assign || function(e2) {
          for (var t2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
            for (var o2 in t2 = arguments[r2])
              Object.prototype.hasOwnProperty.call(t2, o2) && (e2[o2] = t2[o2]);
          return e2;
        }, x.apply(this, arguments);
      };
      function S(e2, t2) {
        var r2 = {};
        for (var n2 in e2)
          Object.prototype.hasOwnProperty.call(e2, n2) && t2.indexOf(n2) < 0 && (r2[n2] = e2[n2]);
        if (null != e2 && "function" == typeof Object.getOwnPropertySymbols) {
          var o2 = 0;
          for (n2 = Object.getOwnPropertySymbols(e2); o2 < n2.length; o2++)
            t2.indexOf(n2[o2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, n2[o2]) && (r2[n2[o2]] = e2[n2[o2]]);
        }
        return r2;
      }
      function N(e2, t2, r2, n2) {
        return new (r2 || (r2 = Promise))(function(o2, i2) {
          function s2(e3) {
            try {
              c2(n2.next(e3));
            } catch (e4) {
              i2(e4);
            }
          }
          function a2(e3) {
            try {
              c2(n2.throw(e3));
            } catch (e4) {
              i2(e4);
            }
          }
          function c2(e3) {
            var t3;
            e3.done ? o2(e3.value) : (t3 = e3.value, t3 instanceof r2 ? t3 : new r2(function(e4) {
              e4(t3);
            })).then(s2, a2);
          }
          c2((n2 = n2.apply(e2, t2 || [])).next());
        });
      }
      function W(e2, t2) {
        var r2, n2, o2, i2, s2 = { label: 0, sent: function() {
          if (1 & o2[0])
            throw o2[1];
          return o2[1];
        }, trys: [], ops: [] };
        return i2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
          return this;
        }), i2;
        function a2(i3) {
          return function(a3) {
            return function(i4) {
              if (r2)
                throw new TypeError("Generator is already executing.");
              for (; s2; )
                try {
                  if (r2 = 1, n2 && (o2 = 2 & i4[0] ? n2.return : i4[0] ? n2.throw || ((o2 = n2.return) && o2.call(n2), 0) : n2.next) && !(o2 = o2.call(n2, i4[1])).done)
                    return o2;
                  switch (n2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
                    case 0:
                    case 1:
                      o2 = i4;
                      break;
                    case 4:
                      return s2.label++, { value: i4[1], done: false };
                    case 5:
                      s2.label++, n2 = i4[1], i4 = [0];
                      continue;
                    case 7:
                      i4 = s2.ops.pop(), s2.trys.pop();
                      continue;
                    default:
                      if (!(o2 = s2.trys, (o2 = o2.length > 0 && o2[o2.length - 1]) || 6 !== i4[0] && 2 !== i4[0])) {
                        s2 = 0;
                        continue;
                      }
                      if (3 === i4[0] && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                        s2.label = i4[1];
                        break;
                      }
                      if (6 === i4[0] && s2.label < o2[1]) {
                        s2.label = o2[1], o2 = i4;
                        break;
                      }
                      if (o2 && s2.label < o2[2]) {
                        s2.label = o2[2], s2.ops.push(i4);
                        break;
                      }
                      o2[2] && s2.ops.pop(), s2.trys.pop();
                      continue;
                  }
                  i4 = t2.call(e2, s2);
                } catch (e3) {
                  i4 = [6, e3], n2 = 0;
                } finally {
                  r2 = o2 = 0;
                }
              if (5 & i4[0])
                throw i4[1];
              return { value: i4[0] ? i4[1] : void 0, done: true };
            }([i3, a3]);
          };
        }
      }
      function O(e2, t2) {
        var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
        if (!r2)
          return e2;
        var n2, o2, i2 = r2.call(e2), s2 = [];
        try {
          for (; (void 0 === t2 || t2-- > 0) && !(n2 = i2.next()).done; )
            s2.push(n2.value);
        } catch (e3) {
          o2 = { error: e3 };
        } finally {
          try {
            n2 && !n2.done && (r2 = i2.return) && r2.call(i2);
          } finally {
            if (o2)
              throw o2.error;
          }
        }
        return s2;
      }
      function U(e2, t2, r2) {
        if (r2 || 2 === arguments.length)
          for (var n2, o2 = 0, i2 = t2.length; o2 < i2; o2++)
            !n2 && o2 in t2 || (n2 || (n2 = Array.prototype.slice.call(t2, 0, o2)), n2[o2] = t2[o2]);
        return e2.concat(n2 || Array.prototype.slice.call(t2));
      }
      e.RequestType = void 0, (w = e.RequestType || (e.RequestType = {})).Get = "get", w.Post = "put", e.ApiEndpoint = void 0, (m = e.ApiEndpoint || (e.ApiEndpoint = {})).AddPermission = "account/add-permission", m.AppToken = "app-token", m.CanAutoSign = "transaction/can-auto-sign", m.ConvertOauthTokens = "account/convert-oauth", m.CustodialMigrateAccount = "custodial/migrate-account", m.CustodialNewAccount = "custodial/new-user", m.CustodialSignString = "custodial/sign-string", m.DeleteTestUser = "account/delete-test-user", m.CustodialSign = "custodial/sign", m.GetUser = "account/user", m.GetConfig = "services/config", m.LoginUserWithToken = "account/login-user-with-token", m.NewUserWithToken = "account/new-user-with-token", m.PasswordLessSendCode = "account/login-passwordless-send-code", m.PasswordLessVerifyCode = "account/login-passwordless-verify-code", m.TransactionSign = "transaction/sign", m.UpdateDelayWalletSetup = "account/update-delay-wallet-setup", e.ConfigType = void 0, (e.ConfigType || (e.ConfigType = {})).Chains = "chains", e.ChainPlatformType = void 0, (k = e.ChainPlatformType || (e.ChainPlatformType = {})).algorand = "algorand", k.eos = "eos", k.ethereum = "ethereum", k.ore = "ore", e.ChainNetwork = void 0, (b = e.ChainNetwork || (e.ChainNetwork = {})).AlgoMain = "algo_main", b.AlgoBeta = "algo_beta", b.AlgoTest = "algo_test", b.AvalancheC_Main = "avalanchec_main", b.AvalancheC_Fuji = "avalanchec_fuji", b.DspEosKylin1 = "kylin-dsp-1.liquidapps.io", b.DspEosKylin2 = "kylin-dsp-2.liquidapps.io", b.DspMoonlighting = "eos_moon_blockstartdsp_com", b.DspMoonlightingTest = "eos_moontest_blockstartdsp_com", b.DosMain = "dos_main", b.DosTest = "dos_test", b.EthMain = "eth_main", b.EthRopsten = "eth_ropsten", b.EthRinkeby = "eth_rinkeby", b.EthGoerli = "eth_goerli", b.EosMain = "eos_main", b.EosKylin = "eos_kylin", b.EosJungle = "eos_jungle", b.MigrateEosMain = "migrate_eos_main", b.OreMain = "ore_main", b.OreTest = "ore_test", b.PolygonMain = "polygon_main", b.PolygonMumbai = "polygon_mumbai", b.TelosMain = "telos_main", b.TelosTest = "telos_test", b.TelosEvmMain = "telosevm_main", b.TelosEvmTest = "telosevm_test", b.UxMain = "ux_main", b.WaxMain = "wax_main", b.WaxTest = "wax_test", e.AccountType = void 0, (A = e.AccountType || (e.AccountType = {})).Native = "native", A.Pending = "pending", A.VirtualLiquid = "liquid", A.VirtualNested = "nested", e.LoginProvider = void 0, (I = e.LoginProvider || (e.LoginProvider = {})).Custodial = "custodial", I.Apple = "apple", I.Email = "email", I.Facebook = "facebook", I.Github = "github", I.Google = "google", I.Instagram = "instagram", I.Kakao = "kakao", I.Line = "line", I.LinkedIn = "linkedin", I.Phone = "phone", I.Twitch = "twitch", I.Twitter = "twitter", e.ExternalWalletType = void 0, (_ = e.ExternalWalletType || (e.ExternalWalletType = {})).AlgoSigner = "algosigner", _.Anchor = "anchor", _.Keycat = "keycat", _.Ledger = "ledger", _.Lynx = "lynx", _.Meetone = "meetone", _.Metro = "metro", _.Portis = "portis", _.Scatter = "scatter", _.SimpleEos = "simpleos", _.TokenPocket = "tokenpocket", _.WalletConnect = "walletconnect", _.Web3 = "web3", _.WhaleVault = "whalevault", _.Wombat = "wombat", e.AuthProvider = void 0, (P = e.AuthProvider || (e.AuthProvider = {})).Custodial = "custodial", P.Apple = "apple", P.Email = "email", P.Facebook = "facebook", P.Github = "github", P.Google = "google", P.Instagram = "instagram", P.Kakao = "kakao", P.Line = "line", P.LinkedIn = "linkedin", P.Phone = "phone", P.Twitch = "twitch", P.Twitter = "twitter", P.AlgoSigner = "algosigner", P.Anchor = "anchor", P.Keycat = "keycat", P.Ledger = "ledger", P.Lynx = "lynx", P.Meetone = "meetone", P.Metro = "metro", P.Portis = "portis", P.Scatter = "scatter", P.SimpleEos = "simpleos", P.TokenPocket = "tokenpocket", P.WalletConnect = "walletconnect", P.Web3 = "web3", P.WhaleVault = "whalevault", P.Wombat = "wombat", P.OreId = "oreid", e.ApiKeyUsedFor = void 0, (C = e.ApiKeyUsedFor || (e.ApiKeyUsedFor = {})).AccountMigration = "accountMigration", C.Airdrop = "airdrop", C.AdminAccess = "adminAccess", C.AutoSigning = "autoSigning", C.ChangePassword = "changePassword", C.CreateUser = "createUser", C.ProxySigning = "proxySigning", C.TokenFunding = "tokenFunding", e.RecoverAccountAction = void 0, (e.RecoverAccountAction || (e.RecoverAccountAction = {})).Republic = "republic", e.ExternalWalletInterface = void 0, (E = e.ExternalWalletInterface || (e.ExternalWalletInterface = {})).Transit = "transit", E.Ual = "ual";
      var D, L;
      e.WebWidgetAction = void 0, (D = e.WebWidgetAction || (e.WebWidgetAction = {})).Auth = "auth", D.Logout = "logout", D.NewChainAccount = "newChainAccount", D.RecoverAccount = "recoverAccount", D.Sign = "sign", D.Buy = "buy", D.KeyExport = "keyExport", e.SignStringMethod = void 0, (L = e.SignStringMethod || (e.SignStringMethod = {})).EthereumPersonalSign = "ethereum.personal-sign", L.EthereumSignTypedData = "ethereum.sign-typed-data", L.EthereumSign = "ethereum.eth-sign";
      var q = function(e2, t2, r2) {
        return e2.replace(new RegExp(t2, "g"), r2);
      }, H = function() {
        function r2() {
        }
        return r2.isNullOrEmpty = function(e2) {
          return void 0 === e2 || (null === e2 || (!(!Array.isArray(e2) || 0 !== e2.length) || 0 === Object.keys(e2).length && e2.constructor === Object));
        }, r2.log = function(e2, t2) {
        }, r2.jwtDecodeSafe = function(e2) {
          var t2;
          if (this.isNullOrEmpty(e2))
            return null;
          try {
            t2 = h.default(e2);
          } catch (e3) {
          }
          return t2;
        }, r2.parseUrlParams = function(e2) {
          var t2, r3 = {};
          try {
            var n2 = new URL(e2);
            t2 = n2.hash ? n2.hash.slice(1) : n2.search;
          } catch (r4) {
            t2 = e2;
          }
          return new URLSearchParams(t2).forEach(function(e3, t3) {
            r3[t3] = decodeURIComponent(e3) || "true";
          }), r3;
        }, r2.tryParseJSON = function(e2, t2, n2) {
          void 0 === t2 && (t2 = false), void 0 === n2 && (n2 = false);
          var o2 = "";
          if (!e2 || !r2.isAString(e2) || "" === e2.trim())
            return null;
          try {
            t2 && (e2 = decodeURI(e2)), o2 = e2, n2 && (o2 = q(e2, "'", '"'), o2 = q(o2, "`", '"'));
            var i2 = JSON.parse(o2, r2.jsonParseComplexObjectReviver);
            if (i2 && "object" == typeof i2)
              return i2;
          } catch (e3) {
          }
          return null;
        }, r2.jsonParseComplexObjectReviver = function(e2, t2) {
          if (null !== t2 && "object" == typeof t2 && "type" in t2 && "Buffer" === t2.type && "data" in t2 && Array.isArray(t2.data))
            return Buffer.from(t2.data);
          if (null !== t2 && "object" == typeof t2 && !Array.isArray(t2) && "0" in t2 && r2.isANumber(t2[0])) {
            var n2 = Object.entries(t2).map(function(e3) {
              return O(e3, 2)[1];
            });
            if (n2.every(function(e3) {
              return r2.isANumber(e3) || e3 < 256;
            }))
              return new Uint8Array(n2);
          }
          return t2;
        }, r2.base64DecodeSafe = function(e2) {
          var t2 = {};
          if (this.isNullOrEmpty(e2))
            return null;
          try {
            t2 = o.Base64.decode(e2), r2.tryParseJSON(t2) && (t2 = JSON.parse(t2));
          } catch (e3) {
            return null;
          }
          return t2;
        }, r2.base64Encode = function(e2) {
          if (!e2)
            return null;
          var t2 = e2;
          return r2.isAnObject(t2) && (t2 = JSON.stringify(t2)), o.Base64.encode(t2);
        }, r2.sleep = function(e2) {
          return new Promise(function(t2) {
            return setTimeout(t2, e2);
          });
        }, r2.createGuid = function() {
          return t.v4();
        }, r2.isInEnum = function(e2, t2) {
          return Object.values(e2).includes(t2);
        }, r2.toEnumValue = function(e2, t2, r3) {
          if (void 0 === r3 && (r3 = false), this.isNullOrEmpty(t2))
            return null;
          if (this.isInEnum(e2, t2))
            return t2;
          var n2 = "Value ".concat(JSON.stringify(t2), " is not a valid member of enum ").concat(JSON.stringify(e2), ".");
          if (r3)
            throw new Error(n2);
          return null;
        }, r2.getErrorCodesFromParams = function(e2) {
          var t2, r3 = e2.error_code || e2.errorCode, n2 = e2.error_message || e2.errorMessage;
          return r3 && (t2 = r3.split(/[/?/$&]/)), (t2 || n2) && (t2 = t2 || []).push(n2), t2;
        }, r2.extractDataFromCallbackUrl = function(e2) {
          var t2 = {};
          if (e2) {
            t2 = this.parseUrlParams(e2);
            var r3 = this.getErrorCodesFromParams(t2);
            return x(x({}, t2), { errors: r3 });
          }
          return t2;
        }, r2.asyncForEach = function(e2, t2) {
          return N(this, void 0, void 0, function() {
            var n2;
            return W(this, function(o2) {
              switch (o2.label) {
                case 0:
                  if (r2.isNullOrEmpty(e2))
                    return [2];
                  n2 = 0, o2.label = 1;
                case 1:
                  return n2 < e2.length ? [4, t2(e2[n2], n2, e2)] : [3, 4];
                case 2:
                  o2.sent(), o2.label = 3;
                case 3:
                  return n2 += 1, [3, 1];
                case 4:
                  return [2];
              }
            });
          });
        }, r2.getClaimFromJwtTokenBySearchString = function(e2, t2) {
          var r3;
          return this.isAnObject(e2) ? (Object.keys(e2).forEach(function(n2) {
            n2.includes(t2) && (r3 = e2[n2]);
          }), r3) : null;
        }, r2.getErrorFromAxiosError = function(e2) {
          if ("network error" === (null == e2 ? void 0 : e2.message.toLowerCase()))
            throw new Error("Browser threw a Network Error. This is likely because of CORS error. Make sure that you are not sending an api-key in the header of the request.");
          if ("ECONNREFUSED" === (null == e2 ? void 0 : e2.code))
            throw new Error("Could not connect to ORE ID service. ".concat(e2.message, "."));
          if (!r2.isAxiosError(e2))
            return e2;
          var t2 = ((null == e2 ? void 0 : e2.response) || {}).data, n2 = void 0 === t2 ? {} : t2, o2 = n2.message, i2 = this.getErrorCodesFromParams(n2), s2 = i2 && (null == i2 ? void 0 : i2.length) > 1 ? i2.join(", ") : i2;
          return Error(s2 || o2 || "unknown error");
        }, r2.isAxiosError = function(e2) {
          return void 0 !== e2.isAxiosError;
        }, r2.isAString = function(e2) {
          return !!e2 && ("string" == typeof e2 || e2 instanceof String);
        }, r2.isADate = function(e2) {
          return e2 instanceof Date;
        }, r2.isABoolean = function(e2) {
          return "boolean" == typeof e2 || e2 instanceof Boolean;
        }, r2.isANumber = function(e2) {
          return !Number.isNaN(e2) && ("number" == typeof e2 || e2 instanceof Number);
        }, r2.isAnObject = function(e2) {
          return null !== e2 && "object" == typeof e2;
        }, r2.assertValidProvider = function(t2) {
          if (r2.isInEnum(e.AuthProvider, t2))
            return true;
          throw new Error("Auth provider ".concat(t2, " is not a valid option"));
        }, r2.mapAuthProviderToWalletType = function(t2) {
          return t2 ? r2.toEnumValue(e.ExternalWalletType, t2) : null;
        }, r2.isCustodial = function(t2) {
          return t2 === e.AuthProvider.Custodial;
        }, r2.isValidEmail = function(e2) {
          if (!e2)
            return false;
          return /^(([^<>()[]\\.,;:\s@]+(\.[^<>()[]\\.,;:\s@]+)*)|(.+))@(([[0-9]{1,3}\[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(e2);
        }, r2.sortJson = function(e2) {
          if (!e2)
            return e2;
          var t2 = p.default(e2);
          return JSON.parse(t2);
        }, r2.getUniqueValues = function(e2) {
          return Array.from(new Set(e2.map(function(e3) {
            return JSON.stringify(e3);
          }))).map(function(e3) {
            return JSON.parse(e3);
          });
        }, r2.runAtTime = function(e2, t2) {
          var r3 = Date.now(), n2 = Math.max(t2, r3);
          return setTimeout(e2, n2 - r3);
        }, r2.objectsAreEqual = function(e2, t2) {
          var n2, o2;
          if (e2 === t2)
            return true;
          if ("object" != typeof e2 || "object" != typeof t2 || null == e2 || null == t2)
            return false;
          var i2 = Object.keys(e2), s2 = Object.keys(t2);
          if (i2.length !== s2.length)
            return false;
          try {
            for (var a2 = function(e3) {
              var t3 = "function" == typeof Symbol && Symbol.iterator, r3 = t3 && e3[t3], n3 = 0;
              if (r3)
                return r3.call(e3);
              if (e3 && "number" == typeof e3.length)
                return { next: function() {
                  return e3 && n3 >= e3.length && (e3 = void 0), { value: e3 && e3[n3++], done: !e3 };
                } };
              throw new TypeError(t3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
            }(i2), c2 = a2.next(); !c2.done; c2 = a2.next()) {
              var u2 = c2.value;
              if (!s2.includes(u2))
                return false;
              if ("function" == typeof e2[u2] || "function" == typeof t2[u2]) {
                if (e2[u2].toString() !== t2[u2].toString())
                  return false;
              } else if (!r2.objectsAreEqual(e2[u2], t2[u2]))
                return false;
            }
          } catch (e3) {
            n2 = { error: e3 };
          } finally {
            try {
              c2 && !c2.done && (o2 = a2.return) && o2.call(a2);
            } finally {
              if (n2)
                throw n2.error;
            }
          }
          return true;
        }, r2.isInBrowser = "undefined" != typeof window, r2;
      }(), j = H.isNullOrEmpty;
      function R(e2, t2) {
        var r2;
        if (!e2.accessToken && !(null === (r2 = e2.options) || void 0 === r2 ? void 0 : r2.apiKey))
          throw new Error("Missing required header for API ".concat(t2, ": Must have a valid user accessToken or options.apiKey"));
      }
      function F(e2, t2, r2) {
        var n2;
        if (!(null === (n2 = e2.options) || void 0 === n2 ? void 0 : n2.apiKey)) {
          var o2 = t2 ? " - with ".concat(t2, " right.") : ".";
          throw new Error("Missing required header for API ".concat(r2, ": Must have an options.apiKey").concat(o2));
        }
      }
      function M(e2, t2, r2) {
        void 0 === e2 && (e2 = {});
        var n2 = [];
        if (t2.forEach(function(t3) {
          j(e2[t3]) && n2.push(t3);
        }), !j(n2))
          throw new Error("Missing required parameter(s) for API ".concat(r2, ": ").concat(n2.join(", ")));
      }
      function K(e2, t2, r2) {
        if (void 0 === e2 && (e2 = {}), t2.filter(function(t3) {
          return !j(e2[t3]);
        }).length > 1)
          throw new Error("You can only provide one of these parameter(s) for API ".concat(r2, ": ").concat(t2.join(", ")));
      }
      function V(e2) {
        var t2;
        return (null == e2 ? void 0 : e2.processId) && (t2 = e2.processId, delete e2.processId), { data: e2, processId: t2 };
      }
      function B(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2, i2, s2, a2, c2, u2;
          return W(this, function(l2) {
            switch (l2.label) {
              case 0:
                return n2 = e.ApiEndpoint.AddPermission, R(t2, n2), M(r2, ["account", "chainAccount", "chainNetwork", "permission", "publicKey"], n2), o2 = r2.account, i2 = r2.permission, s2 = r2.provider, a2 = r2.parentPermission, c2 = {}, s2 && (c2["wallet-type"] = s2), a2 && (c2["parent-permission"] = a2), u2 = x({ account: o2, "chain-account": r2.chainAccount, "chain-network": r2.chainNetwork, "public-key": r2.publicKey, permission: i2 }, c2), [4, t2.callOreIdApi(e.RequestType.Get, e.ApiEndpoint.AddPermission, u2, null)];
              case 1:
                return [2, l2.sent()];
            }
          });
        });
      }
      function z(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2;
          return W(this, function(i2) {
            switch (i2.label) {
              case 0:
                return n2 = e.ApiEndpoint.AppToken, o2 = r2.appAccessTokenMetadata, H.isNullOrEmpty(o2) ? F(t2, null, n2) : F(t2, e.ApiKeyUsedFor.CreateUser, n2), [4, t2.callOreIdApi(e.RequestType.Post, e.ApiEndpoint.AppToken, o2, null)];
              case 1:
                return [2, i2.sent().appAccessToken];
            }
          });
        });
      }
      function J(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2, i2, s2, a2, c2, u2, l2;
          return W(this, function(d2) {
            switch (d2.label) {
              case 0:
                return n2 = e.ApiEndpoint.CanAutoSign, o2 = r2.account, i2 = r2.chainAccount, s2 = r2.chainNetwork, a2 = r2.signedTransaction, c2 = r2.transaction, u2 = r2.transactionChainAccount, F(t2, e.ApiKeyUsedFor.AutoSigning, n2), M(r2, ["account", "chainNetwork", "chainAccount"], n2), K(r2, ["transaction", "signedTransaction"], n2), l2 = { account: o2, chain_account: i2, chain_network: s2 }, c2 && (l2.transaction = H.base64Encode(c2)), a2 && (l2.signed_transaction = H.base64Encode(a2)), c2 && (l2.transaction_chain_acccount = u2), [4, t2.callOreIdApi(e.RequestType.Post, e.ApiEndpoint.CanAutoSign, l2, null)];
              case 1:
                return [2, d2.sent()];
            }
          });
        });
      }
      function G(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2, i2, s2;
          return W(this, function(a2) {
            switch (a2.label) {
              case 0:
                return n2 = e.ApiEndpoint.ConvertOauthTokens, o2 = r2.accessToken, i2 = r2.idToken, R(t2, n2), M(r2, ["idToken"], n2), s2 = {}, o2 && (s2.access_token = o2), i2 && (s2.id_token = i2), [4, t2.callOreIdApi(e.RequestType.Post, e.ApiEndpoint.ConvertOauthTokens, s2, null)];
              case 1:
                return [2, a2.sent()];
            }
          });
        });
      }
      function Y(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2, i2, s2, a2, c2, u2, l2;
          return W(this, function(d2) {
            switch (d2.label) {
              case 0:
                return n2 = e.ApiEndpoint.CustodialMigrateAccount, o2 = r2.account, i2 = r2.chainAccount, s2 = r2.chainNetwork, a2 = r2.toType, c2 = r2.userPassword, u2 = r2.userPasswordEncrypted, l2 = { account: o2, chain_account: i2, chain_network: s2, to_type: a2, user_password: c2, user_password_encrypted: u2 }, F(t2, e.ApiKeyUsedFor.AccountMigration, n2), M(r2, ["account", "chainAccount", "chainNetwork", "toType"], n2), K(r2, ["user_password", "user_password_encrypted"], n2), [4, t2.callOreIdApi(e.RequestType.Post, e.ApiEndpoint.CustodialMigrateAccount, l2, null)];
              case 1:
                return [2, d2.sent()];
            }
          });
        });
      }
      function Z(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2, i2, s2, a2, c2, u2, l2, d2, p2, h2, v2, f3, g2;
          return W(this, function(y2) {
            switch (y2.label) {
              case 0:
                if (n2 = e.ApiEndpoint.CustodialNewAccount, o2 = r2.accountType, i2 = r2.delayWalletSetup, s2 = r2.email, a2 = r2.emailVerified, c2 = r2.idToken, u2 = r2.isTestUser, l2 = r2.name, d2 = r2.picture, p2 = r2.phone, h2 = r2.phoneVerified, v2 = r2.userName, f3 = r2.userPassword, g2 = { account_type: o2, delay_wallet_setup: i2, email: s2, email_verified: a2, id_token: c2, is_test_user: u2, name: l2, phone: p2, phone_verified: h2, picture: d2, user_name: v2, user_password: f3 }, F(t2, e.ApiKeyUsedFor.CreateUser, n2), M(r2, ["accountType"], n2), K(r2, ["user_password", "user_password_encrypted", "user_password_encrypted_backup"], n2), !(c2 || s2 && l2))
                  throw new Error("Missing required parameter(s) for API ".concat(n2, ": Must include email AND name or an idToken"));
                return [4, t2.callOreIdApi(e.RequestType.Post, e.ApiEndpoint.CustodialNewAccount, g2, null)];
              case 1:
                return [2, y2.sent()];
            }
          });
        });
      }
      function $(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2, i2, s2, a2, c2, u2, l2;
          return W(this, function(d2) {
            switch (d2.label) {
              case 0:
                return n2 = e.ApiEndpoint.CustodialSignString, o2 = r2.chainAccount, i2 = r2.chainNetwork, s2 = r2.permission, a2 = r2.stringToSign, c2 = r2.signMethod, u2 = r2.userPassword, l2 = { chain_account: o2, chain_network: i2, permission: s2, string_to_sign: a2, user_password: u2 }, c2 && (l2.sign_method = c2), F(t2, e.ApiKeyUsedFor.ProxySigning, n2), M(r2, ["chainAccount", "chainNetwork", "stringToSign"], n2), K(r2, ["user_password", "user_password_encrypted"], n2), [4, t2.callOreIdApi(e.RequestType.Post, e.ApiEndpoint.CustodialSignString, l2, null)];
              case 1:
                return [2, d2.sent()];
            }
          });
        });
      }
      function Q(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2, i2, s2;
          return W(this, function(a2) {
            switch (a2.label) {
              case 0:
                return n2 = e.ApiEndpoint.DeleteTestUser, o2 = r2.account, R(t2, n2), M(r2, ["account"], n2), i2 = { account: o2 }, [4, t2.callOreIdApi(e.RequestType.Post, e.ApiEndpoint.DeleteTestUser, i2)];
              case 1:
                return s2 = a2.sent(), [2, V(s2).data];
            }
          });
        });
      }
      function X(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2, i2;
          return W(this, function(s2) {
            switch (s2.label) {
              case 0:
                return n2 = e.ApiEndpoint.GetConfig, R(t2, n2), M(r2, ["configType"], n2), o2 = r2.configType, i2 = { type: o2 }, [4, t2.callOreIdApi(e.RequestType.Get, e.ApiEndpoint.GetConfig, i2, null)];
              case 1:
                return [2, s2.sent().values];
            }
          });
        });
      }
      function ee(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2, i2, s2;
          return W(this, function(a2) {
            switch (a2.label) {
              case 0:
                return n2 = e.ApiEndpoint.GetUser, o2 = r2.account, R(t2, n2), M(r2, ["account"], n2), i2 = { account: o2 }, [4, t2.callOreIdApi(e.RequestType.Get, e.ApiEndpoint.GetUser, i2)];
              case 1:
                return s2 = a2.sent(), [2, V(s2).data];
            }
          });
        });
      }
      function te(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2, i2, s2, a2;
          return W(this, function(c2) {
            switch (c2.label) {
              case 0:
                return n2 = e.ApiEndpoint.LoginUserWithToken, o2 = r2.accessToken, i2 = r2.idToken, s2 = r2.provider, K(r2, ["accessToken", "idToken"], n2), K(r2, ["idToken", "provider"], n2), o2 && !H.jwtDecodeSafe(o2) && (M(r2, ["provider"], n2), F(t2, null, "login-user-with-token")), a2 = {}, i2 ? a2.id_token = i2 : (a2.access_token = o2, a2.provider = s2), [4, t2.callOreIdApi(e.RequestType.Post, e.ApiEndpoint.LoginUserWithToken, a2, null)];
              case 1:
                return [2, c2.sent()];
            }
          });
        });
      }
      function re(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2, i2, s2, a2, c2, u2;
          return W(this, function(l2) {
            switch (l2.label) {
              case 0:
                return n2 = e.ApiEndpoint.NewUserWithToken, o2 = r2.accessToken, i2 = r2.delayWalletSetup, s2 = r2.isTestUser, a2 = r2.idToken, c2 = r2.provider, function(e2, t3, r3) {
                  if (void 0 === e2 && (e2 = {}), 0 === t3.filter(function(t4) {
                    return !j(e2[t4]);
                  }).length)
                    throw new Error("Missing at least one of these parameter(s) for API ".concat(r3, ": ").concat(t3.join(", ")));
                }(r2, ["idToken", "accessToken"], n2), K(r2, ["idToken", "provider"], n2), o2 && (M(r2, ["accessToken", "provider"], n2), F(t2, null, "new-user-with-token")), u2 = {}, a2 ? u2.id_token = a2 : (u2.access_token = o2, u2.provider = c2), true === s2 && (u2.is_test_user = true), true === i2 && (u2.delay_wallet_setup = true), [4, t2.callOreIdApi(e.RequestType.Post, e.ApiEndpoint.NewUserWithToken, u2, null)];
              case 1:
                return [2, l2.sent()];
            }
          });
        });
      }
      function ne(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2, i2, s2, a2;
          return W(this, function(c2) {
            switch (c2.label) {
              case 0:
                return n2 = e.ApiEndpoint.PasswordLessSendCode, R(t2, n2), M(r2, ["provider"], n2), K(r2, ["email", "phone"], n2), o2 = r2.email, i2 = r2.phone, s2 = r2.provider, a2 = { provider: s2 }, o2 && (a2.email = encodeURIComponent(o2)), i2 && (a2.phone = encodeURIComponent(i2)), [4, t2.callOreIdApi(e.RequestType.Get, e.ApiEndpoint.PasswordLessSendCode, a2, null)];
              case 1:
                return [2, c2.sent()];
            }
          });
        });
      }
      function oe(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2, i2, s2, a2, c2;
          return W(this, function(u2) {
            switch (u2.label) {
              case 0:
                return n2 = e.ApiEndpoint.PasswordLessVerifyCode, R(t2, n2), M(r2, ["code", "provider"], n2), K(r2, ["email", "phone"], n2), o2 = r2.code, i2 = r2.email, s2 = r2.phone, a2 = r2.provider, c2 = { code: o2, provider: a2 }, i2 && (c2.email = encodeURIComponent(i2)), s2 && (c2.phone = encodeURIComponent(s2)), [4, t2.callOreIdApi(e.RequestType.Get, e.ApiEndpoint.PasswordLessVerifyCode, c2, null)];
              case 1:
                return [2, u2.sent()];
            }
          });
        });
      }
      function ie(e2) {
        var t2, r2 = e2.transactionData || {}, n2 = r2.account, o2 = r2.chainAccount, i2 = r2.chainNetwork, s2 = r2.expireSeconds, a2 = r2.signedTransaction, c2 = r2.transaction, u2 = r2.transactionChainAccount, l2 = r2.transactionRecordId, d2 = (null === (t2 = e2.transactionData) || void 0 === t2 ? void 0 : t2.signOptions) || {}, p2 = d2.allowChainAccountSelection, h2 = d2.broadcast, v2 = d2.generateAutoSignCredential, f3 = d2.multiSigChainAccounts, g2 = d2.returnSignedTransaction, y2 = d2.userPassword, T2 = d2.userPasswordEncrypted, w2 = e2.autoSign, m2 = { account: n2, broadcast: h2, chain_account: o2, chain_network: i2 };
        return p2 && (m2.allow_chain_account_selection = p2), w2 && (m2.auto_sign = w2), s2 && (m2.expire_seconds = s2), v2 && (m2.generate_auto_sign_credential = v2), f3 && (m2.multisig_chain_accounts = f3), g2 && (m2.return_signed_transaction = g2), a2 && (m2.signed_transaction = H.base64Encode(a2)), u2 && (m2.transaction_chain_acccount = u2), c2 && (m2.transaction = H.base64Encode(c2)), l2 && (m2.transaction_record_id = l2), y2 && (m2.user_password = y2), T2 && (m2.user_password_encrypted = T2), m2;
      }
      function se(e2) {
        var t2 = e2.signed_transaction, r2 = e2.transaction_id, n2 = S(e2, ["signed_transaction", "transaction_id"]);
        return x({ signedTransaction: t2, transactionId: r2 }, n2);
      }
      function ae(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2;
          return W(this, function(i2) {
            switch (i2.label) {
              case 0:
                return n2 = e.ApiEndpoint.TransactionSign, (null == r2 ? void 0 : r2.autoSign) ? F(t2, e.ApiKeyUsedFor.AutoSigning, n2) : R(t2, n2), M(r2.transactionData, ["account", "chainNetwork", "chainAccount"], n2), K(r2.transactionData, ["transaction", "signedTransaction"], n2), o2 = ie(r2), [4, t2.callOreIdApi(e.RequestType.Post, e.ApiEndpoint.TransactionSign, o2, null)];
              case 1:
                return [2, se(i2.sent())];
            }
          });
        });
      }
      function ce(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2, i2;
          return W(this, function(s2) {
            switch (s2.label) {
              case 0:
                return n2 = e.ApiEndpoint.CustodialSign, o2 = (r2.transactionData || {}).signOptions, F(t2, e.ApiKeyUsedFor.ProxySigning, n2), M(r2.transactionData, ["account", "chainNetwork", "chainAccount"], n2), K(r2.transactionData, ["transaction", "signedTransaction"], n2), K(o2, ["userPassword", "userPasswordEncrypted"], n2), i2 = ie(r2), [4, t2.callOreIdApi(e.RequestType.Post, e.ApiEndpoint.CustodialSign, i2, null)];
              case 1:
                return [2, se(s2.sent())];
            }
          });
        });
      }
      var ue = H.isNullOrEmpty;
      function le(e2, t2) {
        return N(this, void 0, void 0, function() {
          var r2, n2, o2, i2, s2, a2, c2, u2, l2, d2, p2, h2, v2;
          return W(this, function(f3) {
            if (r2 = t2.account, n2 = t2.accountType, o2 = t2.chainNetwork, i2 = t2.accountOptions, s2 = t2.provider, a2 = t2.callbackUrl, c2 = t2.backgroundColor, u2 = t2.state, l2 = e2.options.oreIdUrl, d2 = { paramsNewAccount: { account: r2, accountType: n2, chainNetwork: o2, accountOptions: i2 } }, !(r2 && n2 && o2 && s2 && a2))
              throw new Error("Missing a required parameter");
            return p2 = "&oauth_access_token=".concat(e2.accessToken), h2 = u2 ? "&state=".concat(u2) : "", v2 = "".concat(l2, "/new-account#provider=").concat(s2, "&chain_network=").concat(o2) + "&callback_url=".concat(encodeURIComponent(a2), "&background_color=").concat(encodeURIComponent(c2)).concat(h2).concat(p2), [2, e2.addAccessTokenAndHmacToUrl(v2, d2)];
          });
        });
      }
      function de(e2, t2) {
        return N(this, void 0, void 0, function() {
          var r2, n2, o2, i2, s2, a2, c2, u2, l2, d2, p2, h2, v2, f3, g2, y2, T2, w2, m2;
          return W(this, function(k2) {
            if (r2 = t2.code, n2 = t2.email, o2 = t2.phone, i2 = t2.provider, s2 = t2.callbackUrl, a2 = t2.backgroundColor, c2 = t2.state, u2 = t2.linkToAccount, l2 = t2.returnAccessToken, d2 = t2.returnIdToken, p2 = e2.options.oreIdUrl, !i2 || !s2)
              throw new Error("Missing a required parameter");
            return h2 = c2 ? "&state=".concat(c2) : "", v2 = u2 ? "&link_to_account=".concat(u2) : "", f3 = r2 ? "&code=".concat(r2) : "", g2 = n2 ? "&email=".concat(encodeURIComponent(n2)) : "", y2 = o2 ? "&phone=".concat(encodeURIComponent(o2)) : "", T2 = l2 ? "&return_access_token=".concat(l2) : "", w2 = d2 ? "&return_id_token=".concat(d2) : "", m2 = "".concat(p2, "/auth#provider=").concat(i2) + "".concat(f3).concat(g2).concat(y2) + "&callback_url=".concat(encodeURIComponent(s2), "&background_color=").concat(encodeURIComponent(a2)).concat(v2).concat(h2).concat(T2).concat(w2), [2, e2.addAccessTokenAndHmacToUrl(m2, null)];
          });
        });
      }
      function pe(e2, t2) {
        return N(this, void 0, void 0, function() {
          var r2, n2, o2, i2, s2, a2, c2, u2, l2, d2, p2, h2, v2, f3, g2, y2, T2, w2, m2, k2;
          return W(this, function(b2) {
            if (r2 = t2.account, n2 = t2.chainNetwork, o2 = t2.expireSeconds, i2 = t2.signedTransaction, s2 = t2.transaction, a2 = t2.transactionRecordId, c2 = (null == t2 ? void 0 : t2.signOptions) || {}, u2 = c2.allowChainAccountSelection, l2 = c2.broadcast, d2 = c2.callbackUrl, p2 = c2.multiSigChainAccounts, h2 = c2.provider, v2 = c2.returnSignedTransaction, f3 = c2.state, g2 = t2.chainAccount, y2 = e2.options.oreIdUrl, !r2 || !d2 || !s2 && !i2)
              throw new Error("Missing a required parameter");
            return g2 || (g2 = r2), T2 = H.base64Encode(s2), w2 = H.base64Encode(i2), m2 = f3 ? "&state=".concat(f3) : "", m2 += ue(s2) ? "" : "&transaction=".concat(T2), m2 += ue(i2) ? "" : "&signed_transaction=".concat(w2), m2 += ue(u2) ? "" : "&allow_chain_account_selection=".concat(u2), m2 += ue(o2) ? "" : "&expire_seconds=".concat(o2), m2 += ue(p2) ? "" : "&multisig_chain_accounts=".concat(p2), m2 += ue(h2) ? "" : "&provider=".concat(h2), m2 += ue(v2) ? "" : "&return_signed_transaction=".concat(v2), m2 += ue(a2) ? "" : "&transaction_record_id=".concat(a2), m2 += "&oauth_access_token=".concat(e2.accessToken), k2 = "".concat(y2, "/sign#account=").concat(r2, "&broadcast=").concat(l2, "&callback_url=").concat(encodeURIComponent(d2), "&chain_account=").concat(g2, "&chain_network=").concat(encodeURIComponent(n2)).concat(m2), [2, e2.addAccessTokenAndHmacToUrl(k2, null)];
          });
        });
      }
      function he(e2) {
        var t2 = function(e3) {
          for (var t3 in e3)
            if (e3.hasOwnProperty(t3) && (!e3[t3] || 0 === e3[t3].length))
              return { containsEmpty: true, firstEmptyKey: t3 };
          return { containsEmpty: false, firstEmptyKey: void 0 };
        }(e2);
        if (t2.containsEmpty)
          throw new Error("The object contains empty or 0 values. First empty or 0 value encountered during encoding: " + t2.firstEmptyKey);
        return s.encode(e2, { sortKeys: true });
      }
      var ve = function(e2, t2) {
        t2(e2.keyToAccountMap);
      }, fe = [{ providerName: e.ExternalWalletType.AlgoSigner, chainType: e.ChainPlatformType.algorand, providerId: "algosigner", requiresLogin: false, supportsDiscovery: true, supportsSignArbitrary: false, requiresLogoutLoginToDiscover: false, requiresDiscoverToLogin: false, helpText: { login: "This wallet doesnt require you to login.", sign: "", discover: "", versionsRequired: "" }, discoveryKeyLookupFunc: function(e2, t2) {
        t2(e2.keys.map(function(e3) {
          var t3 = JSON.parse(e3.note);
          return { index: e3.index, key: e3.key, accounts: [{ account: null == t3 ? void 0 : t3.accountName, authorization: null == t3 ? void 0 : t3.permission }] };
        }));
      }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-algosigner-logo.png" }, { providerName: e.ExternalWalletType.Keycat, chainType: e.ChainPlatformType.eos, providerId: "Keycat", requiresLogin: true, supportsDiscovery: false, supportsSignArbitrary: true, requiresLogoutLoginToDiscover: true, requiresDiscoverToLogin: false, helpText: { login: "Keycat requires logging in through the Keycat app.", sign: "", discover: "", versionsRequired: "" }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-keycat-logo.png" }, { providerName: e.ExternalWalletType.Ledger, chainType: e.ChainPlatformType.eos, providerId: "ledger", requiresLogin: true, supportsDiscovery: true, supportsSignArbitrary: false, requiresLogoutLoginToDiscover: false, requiresDiscoverToLogin: true, defaultDiscoveryPathIndexList: [0, 1, 2], helpText: { login: "This wallet doesnt require you to login", sign: "Connect and unlock your Ledger with your PIN code. Launch the EOS app on the device.", discover: "Connect and unlock your Ledger with your PIN code. Launch the EOS app on the device.", versionsRequired: "You need to have recent versions of your browser, Ledger firmware, and the Ledger EOS app. Click here for more details." }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-ledger-logo.png" }, { providerName: e.ExternalWalletType.Lynx, chainType: e.ChainPlatformType.eos, providerId: "EOS Lynx", requiresLogin: true, supportsDiscovery: false, supportsSignArbitrary: true, requiresLogoutLoginToDiscover: true, requiresDiscoverToLogin: false, helpText: { login: "EOS Lynx requires logging in through the EOS Lynx app.", sign: "", discover: "", versionsRequired: "" }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-lynx-logo.png" }, { providerName: e.ExternalWalletType.Meetone, chainType: e.ChainPlatformType.eos, providerId: "meetone_provider", requiresLogin: false, supportsDiscovery: false, supportsSignArbitrary: true, requiresLogoutLoginToDiscover: true, requiresDiscoverToLogin: false, helpText: { login: "This wallet doesnt require you to login", sign: "", discover: "", versionsRequired: "" }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-meetone-logo.png" }, { providerName: e.ExternalWalletType.Metro, chainType: e.ChainPlatformType.eos, providerId: "metro", requiresLogin: false, supportsDiscovery: false, supportsSignArbitrary: false, requiresLogoutLoginToDiscover: false, requiresDiscoverToLogin: false, helpText: { login: "This wallet doesnt require you to login", sign: "", discover: "", versionsRequired: "" }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-generic-logo.png" }, { providerName: e.ExternalWalletType.Portis, chainType: e.ChainPlatformType.eos, providerId: "PortisProvider", requiresLogin: true, supportsDiscovery: false, supportsSignArbitrary: false, requiresLogoutLoginToDiscover: true, requiresDiscoverToLogin: false, helpText: { login: "Portis requires logging in through the Portis app.", sign: "", discover: "", versionsRequired: "" }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-portis-logo.png" }, { providerName: e.ExternalWalletType.Scatter, chainType: e.ChainPlatformType.eos, providerId: "scatter", requiresLogin: true, supportsDiscovery: false, supportsSignArbitrary: true, requiresLogoutLoginToDiscover: true, requiresDiscoverToLogin: false, helpText: { login: "Scatter requires logging in through the Scatter app.", sign: "", discover: "", versionsRequired: "" }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-scatter-logo.png" }, { providerName: e.ExternalWalletType.SimpleEos, chainType: e.ChainPlatformType.eos, providerId: "simpleos", requiresLogin: true, supportsDiscovery: false, supportsSignArbitrary: false, requiresLogoutLoginToDiscover: true, requiresDiscoverToLogin: false, helpText: { login: "Simpleos requires logging in through the Simpleos app.", sign: "", discover: "", versionsRequired: "" }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-simpleos-logo.png" }, { providerName: e.ExternalWalletType.TokenPocket, chainType: e.ChainPlatformType.eos, providerId: "TokenPocket", requiresLogin: true, supportsDiscovery: false, supportsSignArbitrary: true, requiresLogoutLoginToDiscover: true, requiresDiscoverToLogin: false, helpText: { login: "This wallet doesnt require you to login", sign: "", discover: "", versionsRequired: "" }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-generic-logo.png" }, { providerName: e.ExternalWalletType.WalletConnect, chainType: e.ChainPlatformType.ethereum, providerId: "walletconnect", requiresLogin: false, supportsDiscovery: true, supportsSignArbitrary: true, requiresLogoutLoginToDiscover: false, requiresDiscoverToLogin: false, helpText: { login: "This wallet doesnt require you to login.", sign: "", discover: "", versionsRequired: "" }, discoveryKeyLookupFunc: ve, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-walletconnect-logo.png" }, { providerName: e.ExternalWalletType.Web3, chainType: e.ChainPlatformType.ethereum, providerId: "web3", requiresLogin: false, supportsDiscovery: true, supportsSignArbitrary: true, requiresLogoutLoginToDiscover: false, requiresDiscoverToLogin: false, helpText: { login: "This wallet doesnt require you to login.", sign: "", discover: "", versionsRequired: "" }, discoveryKeyLookupFunc: ve, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-web3-logo.png" }, { providerName: e.ExternalWalletType.WhaleVault, chainType: e.ChainPlatformType.eos, providerId: "whalevault", requiresLogin: true, supportsDiscovery: false, supportsSignArbitrary: true, requiresLogoutLoginToDiscover: true, requiresDiscoverToLogin: false, helpText: { login: "Whalevault requires logging in through the Whalevault app.", sign: "", discover: "", versionsRequired: "" }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-whalevault-logo.png" }];
      function ge(e2) {
        return fe.find(function(t2) {
          return t2.providerName === e2.toString();
        });
      }
      var ye = fe.map(function(e2) {
        return e2.providerName;
      }), Te = function() {
        function t2(e2) {
          this._oreIdContext = e2.oreIdContext, this._user = e2.user, this.transitAccessContexts = {};
        }
        return t2.prototype.installTransitProviders = function(e2) {
          return N(this, void 0, void 0, function() {
            return W(this, function(t3) {
              return this._oreIdContext.transitProvidersInstalled = (e2 || []).map(function(e3) {
                try {
                  return e3(null);
                } catch (e4) {
                  return console.log("Couldn't initiate a wallet provider. ".concat(e4)), null;
                }
              }).filter(function(e3) {
                return e3 && true;
              }).map(function(e3) {
                return (t4 = e3.id, fe.find(function(e4) {
                  return e4.providerId === t4;
                })).providerName;
                var t4;
              }), [2];
            });
          });
        }, t2.prototype.setupTransitWallet = function(t3) {
          var r2 = t3.walletType, n2 = t3.chainNetwork;
          return N(this, void 0, void 0, function() {
            var t4, o2, i2, s2;
            return W(this, function(a2) {
              switch (a2.label) {
                case 0:
                  return this.assertHasProviderInstalled(r2, e.ExternalWalletInterface.Transit), this.assertProviderValidForChainNetwork(r2, n2), t4 = ge(r2).providerId, [4, this.getOrCreateTransitAccessContext(n2)];
                case 1:
                  return o2 = a2.sent(), i2 = o2.getWalletProviders().find(function(e2) {
                    return e2.id === t4;
                  }), [4, (s2 = o2.initWallet(i2)).connect()];
                case 2:
                  return a2.sent(), [4, this.waitWhileWalletIsBusy(s2, r2)];
                case 3:
                  return a2.sent(), [2, s2];
              }
            });
          });
        }, t2.prototype.getOrCreateTransitAccessContext = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3, r2, n2, o2, s2, a2, c2;
            return W(this, function(u2) {
              switch (u2.label) {
                case 0:
                  return t3 = this._oreIdContext.options, r2 = t3.appName, n2 = t3.eosTransitWalletProviders, o2 = void 0 === n2 ? [] : n2, this.transitAccessContexts[e2] ? [2, this.transitAccessContexts[e2]] : [4, this._oreIdContext.settings.getChainNetworkNextworkConfig(e2)];
                case 1:
                  return s2 = u2.sent(), [4, this._oreIdContext.settings.isNotEosNetwork(e2)];
                case 2:
                  return a2 = u2.sent(), c2 = i.initAccessContext({ appName: r2 || "missing appName", network: s2, walletProviders: o2, isNotEosNetwork: a2 }), this.transitAccessContexts[e2] = c2, [2, c2];
              }
            });
          });
        }, t2.prototype.connectToTransitProvider = function(t3) {
          var r2 = t3.walletType, n2 = t3.chainNetwork, o2 = t3.chainAccount, i2 = void 0 === o2 ? null : o2;
          return N(this, void 0, void 0, function() {
            var t4, o3, s2, a2, c2, u2, l2, d2, p2, h2, v2;
            return W(this, function(f3) {
              switch (f3.label) {
                case 0:
                  this.assertHasProviderInstalled(r2, e.ExternalWalletInterface.Transit), this.assertProviderValidForChainNetwork(r2, n2), f3.label = 1;
                case 1:
                  return f3.trys.push([1, 9, 10, 11]), [4, this.setupTransitWallet({ walletType: r2, chainNetwork: n2 })];
                case 2:
                  return o3 = f3.sent(), t4 = { transitWallet: o3 }, ge(r2).requiresLogin ? o3.authenticated ? [3, 4] : [4, this.loginToTransitProvider(o3, r2, n2, i2)] : [3, 4];
                case 3:
                  f3.sent(), f3.label = 4;
                case 4:
                  return o3.connected ? o3.authenticated && o3.auth ? [4, this.updateOreAccountPermissionsfromTransitWalletAuth(o3, r2)] : [3, 6] : [3, 7];
                case 5:
                  f3.sent(), s2 = o3.auth, a2 = s2.accountName, c2 = s2.permission, u2 = s2.publicKey, t4 = { isLoggedIn: true, chainAccount: a2, permissions: [{ name: c2, publicKey: u2 }], transitWallet: o3, provider: r2 }, f3.label = 6;
                case 6:
                  return [3, 8];
                case 7:
                  throw l2 = "".concat(r2, " not connected!"), d2 = o3.hasError, p2 = o3.errorMessage, d2 && (l2 += " Error: ".concat(p2)), new Error(l2);
                case 8:
                  return [3, 11];
                case 9:
                  throw h2 = f3.sent(), v2 = "Failed to connect to ".concat(r2, " on ").concat(n2, ". ").concat((null == h2 ? void 0 : h2.message) || ""), console.log("connectToTransitProvider:".concat(v2), h2), new Error(v2);
                case 10:
                  return this._oreIdContext.setIsBusy(false), [7];
                case 11:
                  return [2, t4];
              }
            });
          });
        }, t2.prototype.doTransitProviderLogin = function(t3, r2, n2, o2, i2) {
          return void 0 === i2 && (i2 = 0), N(this, void 0, void 0, function() {
            var s2, a2, c2, u2;
            return W(this, function(l2) {
              switch (l2.label) {
                case 0:
                  return this.assertHasProviderInstalled(o2, e.ExternalWalletInterface.Transit), this.assertProviderValidForChainNetwork(o2, n2), ge(o2).requiresDiscoverToLogin ? [4, t3.discover(this.discoverOptionsForProvider(o2))] : [3, 5];
                case 1:
                  return a2 = l2.sent(), (c2 = this.findAccountInDiscoverData(a2, r2)) ? [4, t3.login(r2, c2.authorization)] : [3, 3];
                case 2:
                  return s2 = l2.sent(), [3, 4];
                case 3:
                  throw new Error("Account ".concat(r2, " not found in wallet"));
                case 4:
                  return [3, 7];
                case 5:
                  return [4, t3.login(r2)];
                case 6:
                  s2 = l2.sent(), l2.label = 7;
                case 7:
                  return i2 > 2 ? [2, null] : (u2 = ((null == t3 ? void 0 : t3.auth) || {}).accountName, r2 && u2 !== r2 ? [4, t3.logout()] : [3, 9]);
                case 8:
                  l2.sent(), this.doTransitProviderLogin(t3, r2, n2, o2, i2 + 1), l2.label = 9;
                case 9:
                  return [2, s2];
              }
            });
          });
        }, t2.prototype.loginWithTransitProvider = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3, r2, n2, o2, i2, s2;
            return W(this, function(a2) {
              switch (a2.label) {
                case 0:
                  return t3 = e2.walletType, r2 = e2.chainAccount, n2 = e2.chainNetwork, o2 = H.mapAuthProviderToWalletType(t3), [4, this.connectToTransitProvider({ walletType: o2, chainAccount: r2, chainNetwork: n2 })];
                case 1:
                  return i2 = a2.sent(), (null == (s2 = null == i2 ? void 0 : i2.transitWallet) ? void 0 : s2.auth) ? [3, 4] : [4, this.loginToTransitProvider(s2, t3, n2, r2)];
                case 2:
                  return a2.sent(), [4, this.updateOreAccountPermissionsfromTransitWalletAuth(s2, t3)];
                case 3:
                  a2.sent(), a2.label = 4;
                case 4:
                  return [2, i2];
              }
            });
          });
        }, t2.prototype.loginToTransitProvider = function(t3, r2, n2, o2) {
          return void 0 === o2 && (o2 = null), N(this, void 0, void 0, function() {
            var i2, s2;
            return W(this, function(a2) {
              switch (a2.label) {
                case 0:
                  this.assertHasProviderInstalled(r2, e.ExternalWalletInterface.Transit), this.assertProviderValidForChainNetwork(r2, n2), a2.label = 1;
                case 1:
                  return a2.trys.push([1, 3, 4, 6]), [4, this.doTransitProviderLogin(t3, o2, n2, r2)];
                case 2:
                  return a2.sent(), [3, 6];
                case 3:
                  throw i2 = a2.sent(), s2 = i2.message, (void 0 === s2 ? "" : s2).includes("unknown key (boost::tuples::tuple") ? new Error("The account selected by the wallet for login isn't on the ".concat(n2, " chain")) : i2;
                case 4:
                  return [4, this.waitWhileWalletIsBusy(t3, r2)];
                case 5:
                  return a2.sent(), [7];
                case 6:
                  return [2];
              }
            });
          });
        }, t2.prototype.assertHasProviderInstalled = function(t3, r2) {
          if (r2 === e.ExternalWalletInterface.Transit && !this.hasTransitProvider(t3))
            throw Error('Transit provider:"'.concat(t3, '" not installed. Please pass it in via eosTransitWalletProviders.'));
        }, t2.prototype.discoverWithTransit = function(t3) {
          return N(this, void 0, void 0, function() {
            var r2, n2, o2, i2, s2, a2, c2;
            return W(this, function(u2) {
              switch (u2.label) {
                case 0:
                  return r2 = t3.walletType, n2 = t3.chainNetwork, o2 = void 0 === n2 ? e.ChainNetwork.EosMain : n2, i2 = t3.oreAccount, s2 = t3.discoveryPathIndexList, this.assertProviderValidForChainNetwork(r2, o2), a2 = null, this.canDiscover(r2) ? [4, this.discoverCredentialsInTransitWallet(o2, r2, i2, s2)] : [3, 2];
                case 1:
                  return a2 = u2.sent(), [3, 7];
                case 2:
                  return [4, this.setupTransitWallet({ walletType: r2, chainNetwork: o2 })];
                case 3:
                  return c2 = u2.sent(), this.requiresLogoutLoginToDiscover(r2) ? [4, c2.logout()] : [3, 6];
                case 4:
                  return u2.sent(), [4, c2.login()];
                case 5:
                  return u2.sent(), this.updateOreAccountPermissionsfromTransitWalletAuth(c2, r2), [3, 7];
                case 6:
                  console.log("Discover not working for walletType: ", r2), u2.label = 7;
                case 7:
                  return [2, a2];
              }
            });
          });
        }, t2.prototype.discoverCredentialsInTransitWallet = function(e2, t3, r2, n2) {
          return N(this, void 0, void 0, function() {
            var r3, o2, i2, s2, a2 = this;
            return W(this, function(c2) {
              switch (c2.label) {
                case 0:
                  r3 = [], c2.label = 1;
                case 1:
                  return c2.trys.push([1, , 5, 6]), [4, this.setupTransitWallet({ walletType: t3, chainNetwork: e2 })];
                case 2:
                  return o2 = c2.sent(), this._oreIdContext.setIsBusy(true), [4, o2.discover(this.discoverOptionsForProvider(t3, n2))];
                case 3:
                  return i2 = c2.sent(), s2 = i2.keyToAccountMap, [4, H.asyncForEach(s2, function(e3) {
                    return N(a2, void 0, void 0, function() {
                      var n3, i3, s3, a3, c3, u2, l2, d2, p2, h2;
                      return W(this, function(v2) {
                        switch (v2.label) {
                          case 0:
                            return n3 = e3.accounts, i3 = void 0 === n3 ? [] : n3, s3 = e3.key, i3.length > 0 && s3 ? (a3 = O(i3, 1), c3 = a3[0], u2 = c3.account, l2 = c3.authorization, d2 = [{ account: u2, publicKey: s3, name: l2, parent: null }], [4, this.getChainNetworkFromTransitWallet(o2)]) : [3, 3];
                          case 1:
                            return p2 = v2.sent(), [4, null === (h2 = this._user) || void 0 === h2 ? void 0 : h2.addWalletPermissionsToOreIdAccount({ chainAccount: u2, chainNetwork: p2, permissions: d2, walletType: t3 })];
                          case 2:
                            v2.sent(), r3 = r3.concat(d2), v2.label = 3;
                          case 3:
                            return [2];
                        }
                      });
                    });
                  })];
                case 4:
                  return c2.sent(), [3, 6];
                case 5:
                  return this._oreIdContext.setIsBusy(false), [7];
                case 6:
                  return [2, r3];
              }
            });
          });
        }, t2.prototype.discoverOptionsForProvider = function(e2, t3) {
          var r2, n2;
          void 0 === t3 && (t3 = null);
          var o2 = H.mapAuthProviderToWalletType(e2);
          if (this.hasTransitProvider(o2)) {
            var i2 = ge(H.mapAuthProviderToWalletType(e2)), s2 = i2.defaultDiscoveryPathIndexList;
            r2 = t3 || s2 || [], n2 = i2.discoveryKeyLookupFunc;
          }
          var a2 = { pathIndexList: r2 };
          return n2 && (a2.keyLookupFunc = n2), a2;
        }, t2.prototype.findAccountInDiscoverData = function(e2, t3) {
          var r2 = e2.keyToAccountMap.find(function(e3) {
            return e3.accounts.find(function(e4) {
              return e4.account === t3;
            });
          });
          if (r2) {
            var n2 = "active";
            if (!r2.accounts.find(function(e3) {
              return "active" === e3.authorization;
            })) {
              var o2 = O(r2.accounts, 1)[0];
              o2 && (n2 = o2.authorization);
            }
            return { index: r2.index, key: r2.key, authorization: n2 };
          }
          return null;
        }, t2.prototype.signWithTransitProvider = function(t3, r2) {
          return N(this, void 0, void 0, function() {
            var n2, o2, i2, s2, a2, c2;
            return W(this, function(u2) {
              switch (u2.label) {
                case 0:
                  return o2 = t3.chainNetwork, i2 = t3.chainAccount, this.assertHasProviderInstalled(r2, e.ExternalWalletInterface.Transit), this.assertProviderValidForChainNetwork(r2, o2), [4, this.connectToTransitProvider({ walletType: r2, chainNetwork: o2, chainAccount: i2 })];
                case 1:
                  s2 = u2.sent().transitWallet, u2.label = 2;
                case 2:
                  return u2.trys.push([2, 10, 11, 12]), this._oreIdContext.setIsBusy(true), (a2 = ge(r2).chainType) !== e.ChainPlatformType.eos ? [3, 4] : [4, this.signTransactionWithTransitAndEosSDK(t3, s2)];
                case 3:
                  return n2 = u2.sent(), [3, 9];
                case 4:
                  return a2 !== e.ChainPlatformType.algorand ? [3, 6] : [4, this.signTransactionWithTransitAndAlgorandSDK(t3, s2)];
                case 5:
                  return n2 = u2.sent(), [3, 9];
                case 6:
                  return a2 !== e.ChainPlatformType.ethereum ? [3, 8] : [4, this.signTransactionWithTransitAndEthereumSDK(t3, s2)];
                case 7:
                  return n2 = u2.sent(), [3, 9];
                case 8:
                  throw new Error("signWithTransitProvider doesnt support chain type: ".concat(a2));
                case 9:
                  return [3, 12];
                case 10:
                  throw c2 = u2.sent(), console.error(c2), c2;
                case 11:
                  return this._oreIdContext.setIsBusy(false), [7];
                case 12:
                  return n2.serializedTransaction && (n2.serializedTransaction = Buffer.from(n2.serializedTransaction)), [2, { signedTransaction: n2 }];
              }
            });
          });
        }, t2.prototype.signStringWithTransitProvider = function(t3) {
          var r2 = t3.walletType, n2 = t3.chainNetwork, o2 = t3.string, i2 = t3.message, s2 = t3.metadata;
          return N(this, void 0, void 0, function() {
            var t4, a2;
            return W(this, function(c2) {
              switch (c2.label) {
                case 0:
                  return this.assertHasProviderInstalled(r2, e.ExternalWalletInterface.Transit), this.assertProviderValidForChainNetwork(r2, n2), [4, this.connectToTransitProvider({ walletType: r2, chainNetwork: n2 })];
                case 1:
                  t4 = c2.sent().transitWallet, c2.label = 2;
                case 2:
                  return c2.trys.push([2, 4, 5, 6]), this._oreIdContext.setIsBusy(true), [4, t4.signArbitrary(o2, i2, s2)];
                case 3:
                  return [2, { signedString: c2.sent() }];
                case 4:
                  throw a2 = c2.sent(), console.error(a2), a2;
                case 5:
                  return this._oreIdContext.setIsBusy(false), [7];
                case 6:
                  return [2];
              }
            });
          });
        }, t2.prototype.signTransactionWithTransitAndEosSDK = function(e2, t3) {
          return N(this, void 0, void 0, function() {
            var r2, n2, o2, i2, s2, a2;
            return W(this, function(c2) {
              switch (c2.label) {
                case 0:
                  return r2 = e2.expireSeconds, n2 = e2.transaction, o2 = ((null == e2 ? void 0 : e2.signOptions) || {}).broadcast, [4, t3.eosApi.transact({ actions: [n2] }, { broadcast: o2, blocksBehind: 3, expireSeconds: r2 || 60 })];
                case 1:
                  return i2 = c2.sent(), s2 = i2.signatures, a2 = i2.serializedTransaction, [4, this.callDiscoverAfterSign(e2)];
                case 2:
                  return c2.sent(), [2, { signatures: s2, serializedTransaction: a2 }];
              }
            });
          });
        }, t2.prototype.signTransactionWithTransitAndAlgorandSDK = function(e2, t3) {
          return N(this, void 0, void 0, function() {
            var r2, n2, o2, i2, s2, a2, c2;
            return W(this, function(u2) {
              switch (u2.label) {
                case 0:
                  return r2 = e2.chainNetwork, n2 = e2.transaction, [4, this._oreIdContext.settings.getChainNetworkNextworkConfig(r2)];
                case 1:
                  return o2 = u2.sent(), i2 = { chainId: o2.chainId, requiredKeys: null, serializedTransaction: he(n2), abis: null }, [4, t3.provider.signatureProvider.sign(i2)];
                case 2:
                  return s2 = u2.sent(), a2 = s2.signatures, c2 = s2.serializedTransaction, [4, this.callDiscoverAfterSign(e2)];
                case 3:
                  return u2.sent(), [2, { signatures: a2, serializedTransaction: c2 }];
              }
            });
          });
        }, t2.prototype.signTransactionWithTransitAndEthereumSDK = function(e2, t3) {
          return N(this, void 0, void 0, function() {
            var r2, n2, o2, i2, s2, a2, c2;
            return W(this, function(u2) {
              switch (u2.label) {
                case 0:
                  return r2 = e2.chainNetwork, n2 = e2.transaction, [4, this._oreIdContext.settings.getChainNetworkNextworkConfig(r2)];
                case 1:
                  return o2 = u2.sent(), i2 = { chainId: o2.chainId, requiredKeys: null, serializedTransaction: he(n2), abis: null }, [4, t3.provider.signatureProvider.sign(i2)];
                case 2:
                  return s2 = u2.sent(), a2 = s2.signatures, c2 = s2.serializedTransaction, [4, this.callDiscoverAfterSign(e2)];
                case 3:
                  return u2.sent(), [2, { signatures: a2, serializedTransaction: c2 }];
              }
            });
          });
        }, t2.prototype.getChainNetworkFromTransitWallet = function(e2) {
          var t3, r2;
          return N(this, void 0, void 0, function() {
            var n2, o2;
            return W(this, function(i2) {
              switch (i2.label) {
                case 0:
                  return (n2 = ((null === (t3 = null == e2 ? void 0 : e2.ctx) || void 0 === t3 ? void 0 : t3.network) || {}).chainId) ? [4, this._oreIdContext.settings.getAllChainNetworkSettings()] : [2, null];
                case 1:
                  return o2 = i2.sent(), [2, null === (r2 = o2.find(function(e3) {
                    return e3.hosts.find(function(e4) {
                      return e4.chainId === n2;
                    });
                  })) || void 0 === r2 ? void 0 : r2.network];
              }
            });
          });
        }, t2.prototype.updateOreAccountPermissionsfromTransitWalletAuth = function(e2, t3) {
          var r2;
          return N(this, void 0, void 0, function() {
            var n2, o2, i2, s2, a2, c2;
            return W(this, function(u2) {
              switch (u2.label) {
                case 0:
                  return (null == e2 ? void 0 : e2.connected) && (null == e2 ? void 0 : e2.auth) ? (n2 = e2.auth, o2 = n2.accountName, i2 = n2.permission, s2 = n2.publicKey, o2 && i2 && s2 ? (a2 = [{ name: i2, publicKey: s2 }], [4, this.getChainNetworkFromTransitWallet(e2)]) : [2]) : [2];
                case 1:
                  return (c2 = u2.sent()) ? [4, null === (r2 = this._user) || void 0 === r2 ? void 0 : r2.updatePermissionsIfNecessary({ chainAccount: o2, chainNetwork: c2, permissions: a2, walletType: t3 })] : [3, 3];
                case 2:
                  u2.sent(), u2.label = 3;
                case 3:
                  return [2];
              }
            });
          });
        }, t2.prototype.isTransitProvider = function(e2) {
          var t3 = H.mapAuthProviderToWalletType(e2);
          return !!t3 && ye.includes(t3);
        }, t2.prototype.hasTransitProvider = function(e2) {
          return this._oreIdContext.transitProvidersInstalled.includes(e2);
        }, t2.prototype.assertProviderValidForChainNetwork = function(e2, t3) {
          return N(this, void 0, void 0, function() {
            var r2, n2;
            return W(this, function(o2) {
              switch (o2.label) {
                case 0:
                  return r2 = ge(e2).chainType, [4, this._oreIdContext.settings.getAllChainNetworkSettings()];
                case 1:
                  if (n2 = o2.sent(), !!!n2.find(function(e3) {
                    return e3.network === t3 && e3.type === r2;
                  }))
                    throw Error("External Wallet Type: ".concat(e2, " doesnt support chainNetwork ").concat(t3, ". Hint: It supports networks of type ").concat(r2, "."));
                  return [2];
              }
            });
          });
        }, t2.prototype.waitWhileWalletIsBusy = function(e2, t3) {
          return N(this, void 0, void 0, function() {
            return W(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return e2.inProgress ? (this._oreIdContext.setIsBusy(true), [4, H.sleep(250)]) : [3, 2];
                case 1:
                  return r2.sent(), console.log("connecting to ".concat(t3, " via eos-transit wallet in progress:"), e2.inProgress), [3, 0];
                case 2:
                  return this._oreIdContext.setIsBusy(false), [2];
              }
            });
          });
        }, t2.prototype.discover = function(e2) {
          return N(this, void 0, void 0, function() {
            return W(this, function(t3) {
              return [2, this.discoverWithTransit(e2)];
            });
          });
        }, t2.prototype.callDiscoverAfterSign = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3, r2, n2, o2, i2;
            return W(this, function(s2) {
              switch (s2.label) {
                case 0:
                  return t3 = e2.chainNetwork, r2 = e2.account, n2 = ((null == e2 ? void 0 : e2.signOptions) || {}).provider, o2 = H.mapAuthProviderToWalletType(n2), i2 = { walletType: o2, chainNetwork: t3, oreAccount: r2 }, [4, this.discover(i2)];
                case 1:
                  return s2.sent(), [2];
              }
            });
          });
        }, t2.prototype.canDiscover = function(e2) {
          return !!this.hasTransitProvider(e2) && ge(e2).supportsDiscovery;
        }, t2.prototype.canSignString = function(e2) {
          return !!this.hasTransitProvider(e2) && ge(e2).supportsSignArbitrary;
        }, t2.prototype.requiresDiscoverToLogin = function(e2) {
          return !!this.hasTransitProvider(e2) && ge(e2).requiresDiscoverToLogin;
        }, t2.prototype.requiresLogoutLoginToDiscover = function(e2) {
          return !!this.hasTransitProvider(e2) && ge(e2).requiresLogoutLoginToDiscover;
        }, t2.prototype.defaultDiscoveryPathIndexList = function(e2) {
          var t3;
          return this.hasTransitProvider(e2) ? null === (t3 = ge(e2)) || void 0 === t3 ? void 0 : t3.defaultDiscoveryPathIndexList : null;
        }, t2.prototype.helpTextForProvider = function(e2) {
          return this.hasTransitProvider(e2) ? ge(e2).helpText : null;
        }, t2;
      }(), we = [{ providerName: e.ExternalWalletType.Anchor, providerId: "Anchor", chainType: e.ChainPlatformType.eos, requiresLogin: true, supportsSignArbitrary: false, requiresLogoutLoginToDiscover: false, requiresDiscoverToLogin: false, supportsDiscovery: false, helpText: { login: "This wallet doesnt require you to login", sign: "", discover: "", versionsRequired: "" }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-generic-logo.png" }, { providerName: e.ExternalWalletType.Ledger, providerId: "Ledger", chainType: e.ChainPlatformType.eos, requiresLogin: true, supportsSignArbitrary: false, requiresLogoutLoginToDiscover: false, requiresDiscoverToLogin: false, supportsDiscovery: false, helpText: { login: "This wallet doesnt require you to login", sign: "Connect and unlock your Ledger with your PIN code. Launch the EOS app on the device.", discover: "Connect and unlock your Ledger with your PIN code. Launch the EOS app on the device.", versionsRequired: "You need to have recent versions of your browser, Ledger firmware, and the Ledger EOS app. Click here for more details." }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-ledger-logo.png" }, { providerName: e.ExternalWalletType.Lynx, providerId: "Lynx", chainType: e.ChainPlatformType.eos, requiresLogin: false, supportsSignArbitrary: true, requiresLogoutLoginToDiscover: false, requiresDiscoverToLogin: false, supportsDiscovery: false, helpText: { login: "This wallet doesnt require you to login", sign: "", discover: "", versionsRequired: "" }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-lynx-logo.png" }, { providerName: e.ExternalWalletType.Scatter, providerId: "Scatter", chainType: e.ChainPlatformType.eos, requiresLogin: true, supportsSignArbitrary: true, requiresLogoutLoginToDiscover: false, requiresDiscoverToLogin: false, supportsDiscovery: false, helpText: { login: "Scatter requires logging in through the Scatter app.", sign: "", discover: "", versionsRequired: "" }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-scatter-logo.png" }, { providerName: e.ExternalWalletType.TokenPocket, providerId: "Token Pocket", chainType: e.ChainPlatformType.eos, requiresLogin: false, supportsSignArbitrary: true, requiresLogoutLoginToDiscover: false, requiresDiscoverToLogin: false, supportsDiscovery: false, helpText: { login: "This wallet doesnt require you to login", sign: "", discover: "", versionsRequired: "" }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-generic-logo.png" }, { providerName: e.ExternalWalletType.Wombat, providerId: "Wombat", chainType: e.ChainPlatformType.eos, requiresLogin: true, supportsSignArbitrary: true, requiresLogoutLoginToDiscover: false, requiresDiscoverToLogin: false, supportsDiscovery: false, helpText: { login: "This wallet doesnt require you to login", sign: "", discover: "", versionsRequired: "" }, logoUrl: "https://storage.googleapis.com/oreid-files/partners/wallet-wombat-logo.png" }];
      function me(e2) {
        return we.find(function(t2) {
          return t2.providerName === e2.toString().toLowerCase();
        });
      }
      var ke = we.map(function(e2) {
        return e2.providerName;
      }), be = function() {
        function t2(e2) {
          this._oreIdContext = e2.oreIdContext, this._user = e2.user;
        }
        return t2.prototype.installUalProviders = function(e2) {
          return N(this, void 0, void 0, function() {
            return W(this, function(t3) {
              return this._oreIdContext.ualProvidersInstalled = (e2 || []).map(function(e3) {
                var t4, r2;
                return null === (r2 = null == e3 ? void 0 : e3.name, t4 = we.find(function(e4) {
                  return e4.providerName === r2.toLowerCase();
                })) || void 0 === t4 ? void 0 : t4.providerName;
              }), [2];
            });
          });
        }, t2.prototype.loginToUalProvider = function(t3, r2, n2, o2) {
          return N(this, void 0, void 0, function() {
            var i2, s2, a2, c2, u2 = this;
            return W(this, function(l2) {
              switch (l2.label) {
                case 0:
                  this.assertHasProviderInstalled(t3, e.ExternalWalletInterface.Ual), this.assertProviderValidForChainNetwork(t3, n2), l2.label = 1;
                case 1:
                  return l2.trys.push([1, 4, , 5]), [4, r2.login(o2)];
                case 2:
                  return i2 = l2.sent(), H.isNullOrEmpty(i2) ? [2, null] : (s2 = [], [4, H.asyncForEach(i2, function(e2) {
                    return N(u2, void 0, void 0, function() {
                      var t4;
                      return W(this, function(r3) {
                        switch (r3.label) {
                          case 0:
                            return [4, this.getAccountAndPermissionsFromUalUser(e2)];
                          case 1:
                            return t4 = r3.sent(), s2.push({ user: e2, userPermissions: t4 }), [2];
                        }
                      });
                    });
                  })]);
                case 3:
                  return l2.sent(), [2, s2.find(function(e2) {
                    return e2.userPermissions.chainNetwork === n2;
                  })];
                case 4:
                  throw a2 = l2.sent(), c2 = a2.message, (void 0 === c2 ? "" : c2).includes("unknown key (boost::tuples::tuple") ? new Error("The account selected by the wallet for login isn't on the ".concat(n2, " chain")) : a2;
                case 5:
                  return [2];
              }
            });
          });
        }, t2.prototype.connectToUalProvider = function(t3) {
          var r2 = t3.walletType, n2 = t3.chainNetwork, o2 = t3.chainAccount, i2 = void 0 === o2 ? null : o2;
          return N(this, void 0, void 0, function() {
            var t4, o3, s2, a2, c2, u2, l2, d2, p2;
            return W(this, function(h2) {
              switch (h2.label) {
                case 0:
                  this.assertHasProviderInstalled(r2, e.ExternalWalletInterface.Ual), this.assertProviderValidForChainNetwork(r2, n2), t4 = this._oreIdContext.options, o3 = t4.ualAuthenticators.find(function(e2) {
                    return e2.name.toLowerCase() === r2;
                  }), h2.label = 1;
                case 1:
                  return h2.trys.push([1, 10, , 11]), [4, this._oreIdContext.settings.getChainNetworkNextworkConfig(n2)];
                case 2:
                  return s2 = h2.sent(), a2 = { chainId: s2.chainId, rpcEndpoints: [x({}, s2)] }, c2 = new o3([a2], { appName: t4.appName }), this._oreIdContext.setIsBusy(true), [4, c2.init()];
                case 3:
                  return h2.sent(), [4, this.waitWhileWalletIsBusy(c2, r2)];
                case 4:
                  if (h2.sent(), c2.isErrored())
                    throw u2 = c2.getError(), console.log("Error connecting to UAL wallet type: ".concat(u2.name), u2.cause), u2.cause;
                  return [4, this.loginToUalProvider(r2, c2, n2, i2)];
                case 5:
                  if (!(l2 = h2.sent()))
                    return console.log("User doesn't have an account for the chainNetwork: ".concat(n2, " in wallet type: ").concat(r2)), [2, null];
                  h2.label = 6;
                case 6:
                  return h2.trys.push([6, 8, , 9]), [4, this.updateOreAccountPermissionsfromUalUser(l2.user, r2)];
                case 7:
                  return h2.sent(), [3, 9];
                case 8:
                  return d2 = h2.sent(), console.log("Failed to add newly discovered chain accounts in connectToUalProvider for chainNetwork: ".concat(n2, " in wallet type: ").concat(r2), d2), [3, 9];
                case 9:
                  return [2, { isLoggedIn: true, chainAccount: l2.userPermissions.chainAccount, chainNetwork: l2.userPermissions.chainNetwork, permissions: l2.userPermissions.permissions, walletType: r2, authenticator: c2, ualUser: l2.user }];
                case 10:
                  throw p2 = h2.sent(), console.log("Failed to connect to ".concat(r2, " wallet:"), p2), p2;
                case 11:
                  return [2];
              }
            });
          });
        }, t2.prototype.getAccountAndPermissionsFromUalUser = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3, r2, n2, o2, i2;
            return W(this, function(s2) {
              switch (s2.label) {
                case 0:
                  return [4, e2.getChainId()];
                case 1:
                  return t3 = s2.sent(), [4, this._oreIdContext.settings.getChainNetworkByChainId(t3)];
                case 2:
                  return r2 = s2.sent(), [4, e2.getAccountName()];
                case 3:
                  return n2 = s2.sent(), [4, this.getKeys(e2)];
                case 4:
                  return o2 = s2.sent(), i2 = o2.map(function(e3) {
                    return { account: n2, publicKey: e3, name: "active" };
                  }), [2, { chainAccount: n2, chainNetwork: r2, permissions: i2 }];
              }
            });
          });
        }, t2.prototype.loginWithUalProvider = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3, r2, n2, o2, i2, s2;
            return W(this, function(a2) {
              switch (a2.label) {
                case 0:
                  return t3 = e2.walletType, r2 = e2.chainAccount, n2 = e2.chainNetwork, [4, this.connectToUalProvider({ walletType: t3, chainAccount: r2, chainNetwork: n2 })];
                case 1:
                  return o2 = a2.sent(), i2 = o2.authenticator, o2.isLoggedIn ? [3, 4] : [4, this.loginToUalProvider(t3, i2, n2, r2)];
                case 2:
                  return (s2 = a2.sent()) ? [4, this.updateOreAccountPermissionsfromUalUser(s2.user, t3)] : [3, 4];
                case 3:
                  a2.sent(), a2.label = 4;
                case 4:
                  return [2, o2];
              }
            });
          });
        }, t2.prototype.assertHasProviderInstalled = function(t3, r2) {
          if (r2 === e.ExternalWalletInterface.Ual && !this.hasUalProvider(t3))
            throw Error('UAL authenticator:"'.concat(t3, '" not installed. Please pass it in via ualAuthenticators.'));
        }, t2.prototype.signWithUalProvider = function(t3, r2) {
          return N(this, void 0, void 0, function() {
            var n2, o2, i2, s2, a2, c2, u2, l2, d2;
            return W(this, function(p2) {
              switch (p2.label) {
                case 0:
                  return n2 = t3.chainNetwork, o2 = t3.transaction, i2 = t3.chainAccount, (s2 = t3.signOptions).provider, a2 = s2.broadcast, this.assertHasProviderInstalled(r2, e.ExternalWalletInterface.Ual), this.assertProviderValidForChainNetwork(r2, n2), [4, this.connectToUalProvider({ walletType: r2, chainNetwork: n2, chainAccount: i2 })];
                case 1:
                  c2 = p2.sent().ualUser, p2.label = 2;
                case 2:
                  return p2.trys.push([2, 4, 5, 6]), this._oreIdContext.setIsBusy(true), [4, c2.signTransaction(o2, { broadcast: a2 })];
                case 3:
                  return u2 = p2.sent(), (l2 = u2.transaction.serializedTransaction) && (u2.transaction.serializedTransaction = Buffer.from(l2)), [2, { signedTransaction: u2.transaction }];
                case 4:
                  throw d2 = p2.sent(), console.error(d2), d2;
                case 5:
                  return this._oreIdContext.setIsBusy(false), [7];
                case 6:
                  return [2];
              }
            });
          });
        }, t2.prototype.signStringWithUalProvider = function(t3) {
          var r2 = t3.walletType, n2 = t3.chainNetwork, o2 = t3.string, i2 = t3.chainAccount, s2 = t3.message;
          return N(this, void 0, void 0, function() {
            var t4, a2, c2;
            return W(this, function(u2) {
              switch (u2.label) {
                case 0:
                  return this.assertHasProviderInstalled(r2, e.ExternalWalletInterface.Ual), this.assertProviderValidForChainNetwork(r2, n2), [4, this.connectToUalProvider({ walletType: r2, chainNetwork: n2, chainAccount: i2 })];
                case 1:
                  t4 = u2.sent().ualUser, u2.label = 2;
                case 2:
                  return u2.trys.push([2, 5, 6, 7]), this._oreIdContext.setIsBusy(true), [4, this.getKeys(t4)];
                case 3:
                  return a2 = u2.sent(), [4, t4.signArbitrary(a2[0], o2, s2)];
                case 4:
                  return [2, { signedString: u2.sent() }];
                case 5:
                  throw c2 = u2.sent(), console.error(c2), c2;
                case 6:
                  return this._oreIdContext.setIsBusy(false), [7];
                case 7:
                  return [2];
              }
            });
          });
        }, t2.prototype.updateOreAccountPermissionsfromUalUser = function(e2, t3) {
          var r2;
          return N(this, void 0, void 0, function() {
            var n2, o2, i2, s2;
            return W(this, function(a2) {
              switch (a2.label) {
                case 0:
                  return e2 ? [4, this.getAccountAndPermissionsFromUalUser(e2)] : [2];
                case 1:
                  return n2 = a2.sent(), o2 = n2.chainAccount, i2 = n2.chainNetwork, s2 = n2.permissions, o2 && s2 && i2 ? [4, null === (r2 = this._user) || void 0 === r2 ? void 0 : r2.updatePermissionsIfNecessary({ chainAccount: o2, chainNetwork: i2, permissions: s2, walletType: t3 })] : [2];
                case 2:
                  return a2.sent(), [2];
              }
            });
          });
        }, t2.prototype.isUalProvider = function(e2) {
          var t3 = H.mapAuthProviderToWalletType(e2);
          return !!t3 && ke.includes(t3);
        }, t2.prototype.hasUalProvider = function(e2) {
          return this._oreIdContext.ualProvidersInstalled.includes(e2);
        }, t2.prototype.getKeys = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3;
            return W(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return r2.trys.push([0, 2, , 3]), [4, e2.getKeys()];
                case 1:
                  return t3 = r2.sent(), [3, 3];
                case 2:
                  return r2.sent(), t3 = [], [3, 3];
                case 3:
                  return [2, t3];
              }
            });
          });
        }, t2.prototype.assertProviderValidForChainNetwork = function(e2, t3) {
          return N(this, void 0, void 0, function() {
            var r2, n2;
            return W(this, function(o2) {
              switch (o2.label) {
                case 0:
                  return r2 = me(e2).chainType, [4, this._oreIdContext.settings.getAllChainNetworkSettings()];
                case 1:
                  if (n2 = o2.sent(), !!!n2.find(function(e3) {
                    return e3.network === t3 && e3.type === r2;
                  }))
                    throw Error("External Wallet Type: ".concat(e2, " doesnt support chainNetwork ").concat(t3, ". Hint: It supports networks of type ").concat(r2, "."));
                  return [2];
              }
            });
          });
        }, t2.prototype.waitWhileWalletIsBusy = function(e2, t3) {
          return N(this, void 0, void 0, function() {
            return W(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return e2.isLoading() ? (this._oreIdContext.setIsBusy(true), [4, H.sleep(250)]) : [3, 2];
                case 1:
                  return r2.sent(), console.log("connecting to ".concat(t3, " via UAL wallet in progress:"), e2.isLoading()), [3, 0];
                case 2:
                  return this._oreIdContext.setIsBusy(false), [2];
              }
            });
          });
        }, t2.prototype.canDiscover = function(e2) {
          return !!this.hasUalProvider(e2) && me(e2).supportsDiscovery;
        }, t2.prototype.canSignString = function(e2) {
          return !!this.hasUalProvider(e2) && me(e2).supportsSignArbitrary;
        }, t2.prototype.requiresDiscoverToLogin = function(e2) {
          return !!this.hasUalProvider(e2) && me(e2).requiresDiscoverToLogin;
        }, t2.prototype.requiresLogoutLoginToDiscover = function(e2) {
          return !!this.hasUalProvider(e2) && me(e2).requiresLogoutLoginToDiscover;
        }, t2.prototype.defaultDiscoveryPathIndexList = function(e2) {
          var t3;
          return this.hasUalProvider(e2) ? null === (t3 = me(e2)) || void 0 === t3 ? void 0 : t3.defaultDiscoveryPathIndexList : null;
        }, t2.prototype.helpTextForProvider = function(e2) {
          return this.hasUalProvider(e2) ? me(e2).helpText : null;
        }, t2;
      }(), Ae = function() {
        function e2() {
          this._subscribers = [];
        }
        return e2.prototype.subscribe = function(e3) {
          var t2 = this._subscribers.find(function(t3) {
            return t3 === e3;
          });
          e3 && !t2 && (e3(this), this._subscribers.push(e3));
        }, e2.prototype.unsubscribe = function(e3) {
          this._subscribers = this._subscribers.filter(function(t2) {
            return t2 !== e3;
          });
        }, e2.prototype.callSubscribers = function() {
          var e3 = this;
          this._subscribers.forEach(function(t2) {
            return t2(e3);
          });
        }, e2;
      }();
      function Ie(t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2, i2, s2;
          return W(this, function(a2) {
            switch (a2.label) {
              case 0:
                return n2 = e.ApiEndpoint.UpdateDelayWalletSetup, o2 = r2.account, i2 = r2.delayWalletSetup, R(t2, n2), M(r2, ["account", "delayWalletSetup"], n2), s2 = { account: o2, delay_wallet_setup: i2 }, [4, t2.callOreIdApi(e.RequestType.Post, e.ApiEndpoint.UpdateDelayWalletSetup, s2, null)];
              case 1:
                return [2, a2.sent()];
            }
          });
        });
      }
      var _e = H.isNullOrEmpty, Pe = function(t2) {
        function r2(e2) {
          var r3 = t2.call(this) || this;
          return r3.onUpdateAccessTokenHelper = function(e3) {
            r3._accountName = e3.accountName, t2.prototype.callSubscribers.call(r3);
          }, r3._oreIdContext = e2.oreIdContext, r3._accessTokenHelper = e2.accessTokenHelper, r3._accountName = e2.accountName, r3._accessTokenHelper.subscribe(r3.onUpdateAccessTokenHelper), r3;
        }
        return T(r2, t2), Object.defineProperty(r2.prototype, "accessToken", { get: function() {
          return this._accessTokenHelper.accessToken;
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "accountName", { get: function() {
          return this._accountName;
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "data", { get: function() {
          this.assertUserHasData();
          var e2 = this._userSourceData;
          e2.permissions;
          var t3 = S(e2, ["permissions"]);
          return x(x({}, t3), { chainAccounts: this.getChainAccounts() });
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "hasData", { get: function() {
          return !_e(null == this ? void 0 : this._userSourceData);
        }, enumerable: false, configurable: true }), r2.prototype.setUserSourceData = function(e2) {
          this._userSourceData = e2, t2.prototype.callSubscribers.call(this);
        }, r2.prototype.getChainAccounts = function() {
          var e2 = this;
          this.assertUserHasData();
          var t3 = (this._userSourceData.permissions || []).map(function(t4) {
            var r3 = O(e2.getDefaultPermissionForChainAccount(t4.chainAccount, t4.chainNetwork), 1)[0];
            return { chainAccount: t4.chainAccount, chainNetwork: t4.chainNetwork, defaultPermission: r3, permissions: e2.getPermissionForChainAccount(t4.chainAccount, t4.chainNetwork) };
          });
          return H.getUniqueValues(t3);
        }, Object.defineProperty(r2.prototype, "isLoggedIn", { get: function() {
          return !!this.accessToken;
        }, enumerable: false, configurable: true }), r2.prototype.assertUserHasData = function() {
          if (!this.hasData)
            throw new Error("User data hasnt been retrieved. Call user.getData() first.");
        }, r2.prototype.assertUserHasValidEmail = function() {
          this.assertUserHasData();
          var e2 = ((null == this ? void 0 : this.data) || {}).email;
          if (!H.isValidEmail(e2))
            throw new Error("User doesnt have a valid email");
        }, r2.prototype.getData = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3, r3, n2;
            return W(this, function(o2) {
              switch (o2.label) {
                case 0:
                  if (this.hasData && !e2)
                    return [2, this.data];
                  if (!this.accessToken)
                    throw new Error("AccessToken is missing or has expired");
                  return t3 = null == this ? void 0 : this._accountName, r3 = { account: t3 }, [4, ee(this._oreIdContext, r3)];
                case 1:
                  return n2 = o2.sent(), this._accountName = t3, this.setUserSourceData(n2), [2, this.data];
              }
            });
          });
        }, r2.prototype.logout = function() {
          this._oreIdContext.logout();
        }, r2.prototype.getNewChainAccountUrl = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3, r3, n2, o2, i2, s2, a2, c2, u2, l2, d2;
            return W(this, function(p2) {
              switch (p2.label) {
                case 0:
                  return r3 = (t3 = e2 || {}).account, n2 = t3.accountType, o2 = t3.chainNetwork, i2 = t3.accountOptions, s2 = t3.provider, a2 = t3.state, c2 = this._oreIdContext.options, u2 = c2.newAccountCallbackUrl, l2 = c2.backgroundColor, d2 = { account: r3, accountType: n2, backgroundColor: l2, chainNetwork: o2, accountOptions: i2, provider: s2, callbackUrl: u2, state: a2 }, [4, le(this._oreIdContext, d2)];
                case 1:
                  return [2, { newAccountUrl: p2.sent(), errors: null }];
              }
            });
          });
        }, r2.prototype.deleteTestUser = function() {
          return N(this, void 0, void 0, function() {
            return W(this, function(e2) {
              switch (e2.label) {
                case 0:
                  if (!(null == this ? void 0 : this.accountName))
                    throw new Error("User not authenticated. Must be logged-in (or have set an accessToken).");
                  return [4, Q(this._oreIdContext, { account: this.accountName })];
                case 1:
                  return [2, e2.sent()];
              }
            });
          });
        }, r2.prototype.disableDelayedWalletSetup = function() {
          return N(this, void 0, void 0, function() {
            var e2;
            return W(this, function(t3) {
              switch (t3.label) {
                case 0:
                  if (!(null == this ? void 0 : this.accountName))
                    throw new Error("User not authenticated. Must be logged-in (or have set an accessToken).");
                  return [4, Ie(this._oreIdContext, { account: this.accountName, delayWalletSetup: false })];
                case 1:
                  return e2 = t3.sent(), [4, this.getData(true)];
                case 2:
                  return t3.sent(), [2, e2];
              }
            });
          });
        }, r2.prototype.sendVerificationCodeToEmail = function() {
          var t3;
          return N(this, void 0, void 0, function() {
            return W(this, function(r3) {
              switch (r3.label) {
                case 0:
                  return this.assertUserHasValidEmail(), [4, ne(this._oreIdContext, { email: null === (t3 = null == this ? void 0 : this.data) || void 0 === t3 ? void 0 : t3.email, provider: e.AuthProvider.Email })];
                case 1:
                  return [2, r3.sent()];
              }
            });
          });
        }, r2.prototype.checkVerificationCodeForEmail = function(t3) {
          var r3, n2 = t3.code;
          return N(this, void 0, void 0, function() {
            return W(this, function(t4) {
              switch (t4.label) {
                case 0:
                  return this.assertUserHasValidEmail(), [4, oe(this._oreIdContext, { code: n2, email: null === (r3 = null == this ? void 0 : this.data) || void 0 === r3 ? void 0 : r3.email, provider: e.AuthProvider.Email })];
                case 1:
                  return [2, t4.sent()];
              }
            });
          });
        }, r2.prototype.mapUserPermission = function(e2) {
          if (_e(e2))
            return null;
          e2.chainNetwork, e2.chainAccount;
          var t3 = e2.permission, r3 = S(e2, ["chainNetwork", "chainAccount", "permission"]);
          return x(x({}, r3), { name: t3 });
        }, r2.prototype.getPermissionForChainAccount = function(e2, t3) {
          return this._userSourceData.permissions.filter(function(r3) {
            return r3.chainAccount === e2 && r3.chainNetwork === t3;
          }).map(this.mapUserPermission);
        }, r2.prototype.getDefaultPermissionForChainAccount = function(e2, t3) {
          var r3 = this.getPermissionForChainAccount(e2, t3), n2 = r3.filter(function(e3) {
            return true === e3.isDefault;
          });
          return _e(n2) && 1 === (null == r3 ? void 0 : r3.length) && (n2 = r3), n2;
        }, r2.prototype.updatePermissionsIfNecessary = function(e2) {
          return N(this, void 0, void 0, function() {
            return W(this, function(t3) {
              switch (t3.label) {
                case 0:
                  return [4, this.addWalletPermissionsToOreIdAccount(e2)];
                case 1:
                  return t3.sent(), [2];
              }
            });
          });
        }, r2.prototype.addWalletPermissionsToOreIdAccount = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3, r3, n2, o2, i2 = this;
            return W(this, function(s2) {
              switch (s2.label) {
                case 0:
                  return [4, this.getData()];
                case 1:
                  return s2.sent(), t3 = e2.chainAccount, r3 = e2.chainNetwork, n2 = e2.permissions, o2 = e2.walletType, !this.accountName || _e(n2) || _e(r3) ? [2] : [4, H.asyncForEach(n2, function(e3) {
                    return N(i2, void 0, void 0, function() {
                      var n3, i3, s3;
                      return W(this, function(a2) {
                        switch (a2.label) {
                          case 0:
                            return n3 = e3.name, (i3 = e3.parent) || (i3 = "active", "owner" === n3 ? i3 = "" : "active" === n3 && (i3 = "owner")), true === this._userSourceData.permissions.some(function(e4) {
                              return e4.chainAccount === t3 && e4.chainNetwork === r3 && e4.permission === n3 || "owner" === n3;
                            }) ? [3, 2] : (s3 = e3.publicKey, [4, B(this._oreIdContext, { account: this.accountName, chainAccount: t3, chainNetwork: r3, publicKey: s3, parentPermission: i3, permission: n3, provider: o2 })]);
                          case 1:
                            a2.sent(), a2.label = 2;
                          case 2:
                            return [2];
                        }
                      });
                    });
                  })];
                case 2:
                  return s2.sent(), [4, this.getData()];
                case 3:
                  return s2.sent(), [2];
              }
            });
          });
        }, r2;
      }(Ae), Ce = function(e2) {
        function t2(t3, r2) {
          void 0 === r2 && (r2 = false);
          var n2 = e2.call(this) || this;
          return n2._ignoreIssuer = r2, n2.setAccessToken(t3), n2;
        }
        return T(t2, e2), Object.defineProperty(t2.prototype, "accessToken", { get: function() {
          return this._accessToken;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "decodedAccessToken", { get: function() {
          return this.accessToken ? this._decodedAccessToken : null;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "idToken", { get: function() {
          return this._idToken;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "decodedIdToken", { get: function() {
          return this._decodedIdToken;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "accountName", { get: function() {
          return this.accessToken ? (t2.assertIsTokenValid(this.decodedAccessToken), H.getClaimFromJwtTokenBySearchString(this.decodedAccessToken, "https://oreid.aikon.com/account")) : null;
        }, enumerable: false, configurable: true }), t2.prototype.clearAccessToken = function() {
          this.setAccessToken(null);
        }, t2.prototype.clearIdToken = function() {
          this.setIdToken(null);
        }, t2.prototype.hasExpired = function(e3) {
          return !this._decodedAccessToken || !t2.isTokenDateValidNow(this._decodedAccessToken, e3);
        }, t2.prototype.setAccessToken = function(r2) {
          var n2 = this;
          if (r2) {
            var o2 = H.jwtDecodeSafe(r2);
            if (!o2)
              throw Error("Can't set accessToken. Value provided: ".concat(r2));
            t2.assertIsTokenValid(o2, this._ignoreIssuer), t2.assertIdTokenMatchesAccessToken(o2, this.decodedIdToken), this._decodedAccessToken = o2, this._accessToken = r2, H.runAtTime(function() {
              n2.clearAccessToken(), console.log("accessToken has expired and has been cleared");
            }, 1e3 * this._decodedAccessToken.exp);
          } else
            this._accessToken = null;
          e2.prototype.callSubscribers.call(this);
        }, t2.prototype.setIdToken = function(r2) {
          var n2 = this;
          if (r2) {
            var o2 = H.jwtDecodeSafe(r2);
            if (!o2)
              throw Error("Can't set IdToken. Value provided: ".concat(r2));
            t2.assertIsTokenValid(o2, this._ignoreIssuer), t2.assertIdTokenMatchesAccessToken(this.decodedAccessToken, o2), this._decodedIdToken = o2, this._idToken = r2, H.runAtTime(function() {
              n2.clearIdToken(), console.log("idToken has expired and has been cleared");
            }, 1e3 * this._decodedIdToken.exp);
          } else
            this._decodedIdToken = null;
          e2.prototype.callSubscribers.call(this);
        }, t2.prototype.assertHasAccessToken = function() {
          if (!this.accessToken)
            throw Error("AccessToken not set. Login first.");
        }, t2.isTokenValid = function(e3, r2) {
          void 0 === r2 && (r2 = false);
          try {
            return t2.assertIsTokenValid(e3, r2), true;
          } catch (e4) {
            return false;
          }
        }, t2.assertIsTokenValid = function(e3, r2) {
          void 0 === r2 && (r2 = false);
          var n2 = /* @__PURE__ */ new Date();
          if (!e3)
            throw Error("JWT (access or id) token is invalid, or expired)");
          if (!r2 && !e3.iss.includes("oreid.io"))
            throw Error("Access token not issued by ORE ID");
          if (!t2.isTokenDateValidNow(e3, n2))
            throw Error("Access token has expired");
        }, t2.assertIdTokenMatchesAccessToken = function(e3, t3) {
          if (e3 && t3) {
            if (e3.iss !== t3.iss)
              throw Error("AccessToken and IdToken mismatch - not issued by the same issuer");
            if (e3.sub !== t3.sub)
              throw Error("AccessToken and IdToken mismatch - not for the same user");
          }
        }, t2.isTokenDateValidNow = function(e3, t3) {
          var r2 = (t3 || /* @__PURE__ */ new Date()).getTime() / 1e3;
          return !(void 0 !== e3.exp && (null == e3 ? void 0 : e3.exp) < r2) && !(void 0 !== (null == e3 ? void 0 : e3.nbf) && (null == e3 ? void 0 : e3.nbf) > r2);
        }, t2;
      }(Ae), Ee = function(e2) {
        function t2(t3) {
          var r2 = e2.call(this) || this;
          return r2.onUpdateAccessTokenHelper = function(e3) {
            r2.saveAccessTokenAndNotifySubscribers(r2._accessTokenHelper.accessToken);
          }, r2._oreIdContext = t3.oreIdContext, r2._localState = r2._oreIdContext.localState, r2._transitHelper = new Te({ oreIdContext: r2._oreIdContext, user: r2._user }), r2._ualHelper = new be({ oreIdContext: r2._oreIdContext, user: r2._user }), r2.initAccessTokenHelper(), r2;
        }
        return T(t2, e2), Object.defineProperty(t2.prototype, "accessTokenHelper", { get: function() {
          return this._accessTokenHelper;
        }, enumerable: false, configurable: true }), t2.prototype.initAccessTokenHelper = function() {
          var e3;
          this._accessTokenHelper = new Ce();
          var t3 = null === (e3 = this._localState) || void 0 === e3 ? void 0 : e3.accessToken;
          this.accessToken = t3, this.saveAccessTokenAndNotifySubscribers(t3), this._accessTokenHelper.subscribe(this.onUpdateAccessTokenHelper);
        }, Object.defineProperty(t2.prototype, "accountName", { get: function() {
          var e3, t3;
          return (null === (e3 = this._accessTokenHelper) || void 0 === e3 ? void 0 : e3.accessToken) ? null === (t3 = this._accessTokenHelper) || void 0 === t3 ? void 0 : t3.accountName : null;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "idToken", { get: function() {
          var e3;
          return null === (e3 = this._accessTokenHelper) || void 0 === e3 ? void 0 : e3.idToken;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "accessToken", { get: function() {
          var e3;
          return null === (e3 = this._accessTokenHelper) || void 0 === e3 ? void 0 : e3.accessToken;
        }, set: function(e3) {
          try {
            this._accessTokenHelper.setAccessToken(e3);
          } catch (e4) {
            console.log("Cant set accessToken.", e4.message);
          }
        }, enumerable: false, configurable: true }), t2.prototype.saveAccessTokenAndNotifySubscribers = function(t3) {
          var r2;
          (null === (r2 = this._localState) || void 0 === r2 ? void 0 : r2.accessToken) !== t3 && (this._localState.saveAccessToken(t3), this._user = null), e2.prototype.callSubscribers.call(this);
        }, Object.defineProperty(t2.prototype, "user", { get: function() {
          return this._user || (this._user = new Pe({ oreIdContext: this._oreIdContext, accessTokenHelper: this._accessTokenHelper, accountName: this.accountName })), this._user;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "isLoggedIn", { get: function() {
          return !!this.accessToken;
        }, enumerable: false, configurable: true }), t2.prototype.clearAccessToken = function() {
          this._localState.clearAccessToken(), this._accessTokenHelper.clearAccessToken(), e2.prototype.callSubscribers.call(this);
        }, t2.prototype.connectWithWallet = function(e3) {
          return N(this, void 0, void 0, function() {
            var t3;
            return W(this, function(r2) {
              if (t3 = e3.walletType, !this._oreIdContext.walletHelper.isAValidExternalWalletType(t3))
                throw new Error("loginWithWallet not supported for external wallet type: ".concat(t3));
              return [2, this.connectToWalletProvider(e3)];
            });
          });
        }, t2.prototype.connectToWalletProvider = function(e3) {
          return N(this, void 0, void 0, function() {
            return W(this, function(t3) {
              return [2, this._oreIdContext.walletHelper.connectToWalletProvider(e3)];
            });
          });
        }, t2.prototype.convertOauthTokens = function(e3) {
          return N(this, void 0, void 0, function() {
            return W(this, function(t3) {
              return [2, G(this._oreIdContext, e3)];
            });
          });
        }, t2.prototype.loginWithToken = function(e3) {
          return N(this, void 0, void 0, function() {
            var t3, r2, n2, o2;
            return W(this, function(i2) {
              switch (i2.label) {
                case 0:
                  if (!(null == e3 ? void 0 : e3.idToken) && !(null == e3 ? void 0 : e3.accessToken))
                    throw new Error("Cant loginWithToken - missing required parameter: accessToken OR idToken");
                  return [4, this.loginWithAccessOrIdTokenToken(e3)];
                case 1:
                  return t3 = i2.sent(), r2 = t3.accessToken, n2 = t3.error, o2 = t3.processId, n2 ? [3, 3] : (this.accessToken = r2, [4, this.user.getData()]);
                case 2:
                  i2.sent(), i2.label = 3;
                case 3:
                  return [2, { accessToken: r2, errors: n2, processId: o2 }];
              }
            });
          });
        }, t2.prototype.newUserWithToken = function(e3) {
          return N(this, void 0, void 0, function() {
            var t3, r2, n2, o2;
            return W(this, function(i2) {
              switch (i2.label) {
                case 0:
                  return [4, this.newAccountWithIdToken(e3)];
                case 1:
                  return t3 = i2.sent(), r2 = t3.accessToken, n2 = t3.error, o2 = t3.processId, n2 ? [3, 3] : (this.accessToken = r2, [4, this.user.getData()]);
                case 2:
                  i2.sent(), i2.label = 3;
                case 3:
                  return [2, { accessToken: r2, errors: n2, processId: o2 }];
              }
            });
          });
        }, t2.checkJwtTokenAndReturnError = function(e3) {
          try {
            new Ce(e3, true);
          } catch (e4) {
            return { error: "token_invalid", message: "token invalid or corrupt - must be a JWT Oauth2 token" };
          }
          return null;
        }, t2.prototype.loginWithAccessOrIdTokenToken = function(e3) {
          return N(this, void 0, void 0, function() {
            var r2, n2, o2, i2;
            return W(this, function(s2) {
              switch (s2.label) {
                case 0:
                  return r2 = e3.accessToken, n2 = e3.idToken, (o2 = r2 && H.jwtDecodeSafe(r2) ? r2 ? t2.checkJwtTokenAndReturnError(r2) : null : n2 ? t2.checkJwtTokenAndReturnError(n2) : null) ? [2, x({ accessToken: null }, o2)] : [4, te(this._oreIdContext, e3)];
                case 1:
                  return (null == (i2 = s2.sent()) ? void 0 : i2.errorCode) || this.setAuthResult({ accessToken: null == i2 ? void 0 : i2.accessToken }), [2, { accessToken: i2.accessToken, error: null == i2 ? void 0 : i2.errorCode, message: null == i2 ? void 0 : i2.errorMessage, processId: null == i2 ? void 0 : i2.processId }];
              }
            });
          });
        }, t2.prototype.newAccountWithIdToken = function(e3) {
          return N(this, void 0, void 0, function() {
            var r2, n2, o2;
            return W(this, function(i2) {
              switch (i2.label) {
                case 0:
                  return r2 = e3.idToken, (n2 = r2 ? t2.checkJwtTokenAndReturnError(r2) : null) ? [2, x({ accessToken: null }, n2)] : [4, re(this._oreIdContext, e3)];
                case 1:
                  return (null == (o2 = i2.sent()) ? void 0 : o2.errorCode) || this.setAuthResult({ accessToken: null == o2 ? void 0 : o2.accessToken }), [2, { accessToken: o2.accessToken, error: null == o2 ? void 0 : o2.errorCode, message: null == o2 ? void 0 : o2.errorMessage, processId: null == o2 ? void 0 : o2.processId }];
              }
            });
          });
        }, t2.prototype.logout = function() {
          this.clearAccessToken(), this._user = null;
        }, t2.prototype.getLoginUrl = function(e3) {
          return N(this, void 0, void 0, function() {
            var t3, r2, n2, o2, i2, s2, a2, c2, u2, l2, d2, p2, h2, v2;
            return W(this, function(f3) {
              switch (f3.label) {
                case 0:
                  return r2 = (t3 = e3 || {}).code, n2 = t3.email, o2 = t3.idToken, i2 = t3.phone, s2 = t3.provider, a2 = t3.state, c2 = t3.linkToAccount, u2 = t3.returnAccessToken, l2 = t3.returnIdToken, d2 = this._oreIdContext.options, p2 = d2.authCallbackUrl, h2 = d2.backgroundColor, v2 = { code: r2, email: n2, idToken: o2, phone: i2, provider: s2, backgroundColor: h2, callbackUrl: p2, state: a2, linkToAccount: c2, returnAccessToken: !!H.isNullOrEmpty(u2) || u2, returnIdToken: l2 }, [4, de(this._oreIdContext, v2)];
                case 1:
                  return [2, { loginUrl: f3.sent(), errors: null }];
              }
            });
          });
        }, t2.prototype.handleAuthCallback = function(e3) {
          var t3 = H.extractDataFromCallbackUrl(e3), r2 = t3.access_token, n2 = t3.account, o2 = t3.id_token, i2 = t3.errors, s2 = t3.process_id, a2 = t3.state, c2 = { account: n2 };
          return i2 && (c2.errors = i2), s2 && (c2.processId = s2), a2 && (c2.state = a2), r2 && (c2.accessToken = r2), o2 && (c2.idToken = o2), i2 || this.setAuthResult(c2), this._oreIdContext.setIsBusy(false), c2;
        }, t2.prototype.setAuthResult = function(e3) {
          var t3 = e3.accessToken, r2 = e3.idToken;
          if (!t3)
            throw Error("Cant setAuthResult. accessToken is missing");
          this._accessTokenHelper.setIdToken(null), this.accessToken = t3, r2 && this._accessTokenHelper.setIdToken(r2);
        }, t2;
      }(Ae), xe = ["metro"], Se = "4.7.2", Ne = [e.ApiEndpoint.LoginUserWithToken, e.ApiEndpoint.NewUserWithToken], We = function() {
        function t2(e2) {
          this._oreIdContext = e2.oreIdContext, this._user = e2.user, this.assertValidTransactionAndSetData(e2.data), this._transitHelper = new Te({ oreIdContext: this._oreIdContext, user: this._user }), this._ualHelper = new be({ oreIdContext: this._oreIdContext, user: this._user });
        }
        return Object.defineProperty(t2.prototype, "data", { get: function() {
          return this._data;
        }, enumerable: false, configurable: true }), t2.prototype.assertValidTransactionAndSetData = function(e2) {
          var t3 = e2 || {}, r2 = t3.chainNetwork, n2 = t3.transaction, o2 = t3.signedTransaction, i2 = [], s2 = [];
          if (!this._user || !this._user.hasData)
            throw new Error("Make sure that a user has been authenticated and that youve called user.getData()");
          if (r2 || i2.push("chainNetwork"), n2 || o2 || i2.push("transaction OR signedTransaction"), this._user.accountName || s2.push("Transaction Data error - Expecting a user.accountName - is the user logged-in in?"), n2 && o2 && s2.push("Only provide one: transaction OR signedTransaction"), !H.isNullOrEmpty(i2))
            throw new Error("Transaction parameter(s) missing: ".concat(i2.join(", ")));
          if (!H.isNullOrEmpty(s2))
            throw new Error("Transaction parameter error: ".concat(s2.join(", ")));
          this.setTransactionData(e2);
        }, t2.prototype.setTransactionData = function(e2) {
          this._data = x({ account: this._user.accountName }, e2), (null == e2 ? void 0 : e2.transaction) && (this._data.encodedTransaction = H.base64Encode(JSON.stringify(e2.transaction))), (null == e2 ? void 0 : e2.signedTransaction) && (this._data.encodedSignedTransaction = H.base64Encode(JSON.stringify(e2.signedTransaction)));
        }, t2.prototype.assertTransactionAccountValidForUser = function() {
          var e2, t3, r2, n2, o2, i2, s2 = this._data, a2 = s2.chainAccount, c2 = s2.chainNetwork, u2 = this._user.accountName, l2 = null === (r2 = null === (t3 = null === (e2 = this._user) || void 0 === e2 ? void 0 : e2.data) || void 0 === t3 ? void 0 : t3.chainAccounts) || void 0 === r2 ? void 0 : r2.find(function(e3) {
            return e3.chainNetwork === c2 && e3.chainAccount === a2;
          }), d2 = null === (n2 = null == l2 ? void 0 : l2.permissions) || void 0 === n2 ? void 0 : n2.every(function(e3) {
            return true === e3.privateKeyStoredExterally;
          }), p2 = null === (i2 = null === (o2 = null == l2 ? void 0 : l2.permissions) || void 0 === o2 ? void 0 : o2.find(function(e3) {
            return true === e3.privateKeyStoredExterally;
          })) || void 0 === i2 ? void 0 : i2.externalWalletType;
          if (!l2)
            throw new Error("Can't find a chainAccount: ".concat(a2, " for chainNetwork: ").concat(c2, " in user's oreId account: ").concat(u2));
          if (d2)
            throw new Error("ChainAccount: ".concat(a2, " for chainNetwork: ").concat(c2, " appears to be in a wallet app (type: ").concat(p2, ") - use signWithWallet() to sign"));
        }, t2.prototype.validate = function() {
          return N(this, void 0, void 0, function() {
            return W(this, function(e2) {
              throw new Error("Not Implemented");
            });
          });
        }, t2.prototype.getSignUrl = function() {
          return N(this, void 0, void 0, function() {
            var e2, t3;
            return W(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return this.assertTransactionAccountValidForUser(), e2 = this.data, t3 = this._oreIdContext.options.signCallbackUrl, (null == e2 ? void 0 : e2.signOptions) || (e2.signOptions = {}), e2.signOptions.callbackUrl = t3, [4, pe(this._oreIdContext, e2)];
                case 1:
                  return [2, { signUrl: r2.sent(), errors: null }];
              }
            });
          });
        }, t2.prototype.checkCanAutoSign = function() {
          return N(this, void 0, void 0, function() {
            var t3;
            return W(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return r2.trys.push([0, 2, , 3]), F(this._oreIdContext, e.ApiKeyUsedFor.AutoSigning, ""), [4, J(this._oreIdContext, this._data)];
                case 1:
                  return t3 = r2.sent().autoSignCredentialsExist, [3, 3];
                case 2:
                  return r2.sent(), [2, false];
                case 3:
                  return [2, t3];
              }
            });
          });
        }, t2.prototype.autoSign = function() {
          return N(this, void 0, void 0, function() {
            var e2, t3, r2, n2, o2, i2, s2;
            return W(this, function(a2) {
              switch (a2.label) {
                case 0:
                  return this.assertTransactionAccountValidForUser(), e2 = this.data, [4, ae(this._oreIdContext, { transactionData: e2, autoSign: true })];
                case 1:
                  if (t3 = a2.sent(), r2 = t3.processId, n2 = t3.signedTransaction, o2 = t3.transactionId, i2 = t3.errorCode, s2 = t3.errorMessage, i2 || s2)
                    throw new Error(s2);
                  return [2, { processId: r2, signedTransaction: n2, transactionId: o2 }];
              }
            });
          });
        }, t2.prototype.signWithPassword = function(e2, t3) {
          return N(this, void 0, void 0, function() {
            var r2, n2, o2, i2, s2, a2, c2;
            return W(this, function(u2) {
              switch (u2.label) {
                case 0:
                  if (this.assertTransactionAccountValidForUser(), (null == (r2 = this.data) ? void 0 : r2.signOptions) || (r2.signOptions = {}), e2 && (r2.signOptions.userPassword = e2), t3 && (r2.signOptions.userPasswordEncrypted = t3), r2.signOptions.userPassword && r2.signOptions.userPasswordEncrypted)
                    throw new Error("Provide either a userPassword OR userPasswordEncrypted param. Both were provided.");
                  return [4, ce(this._oreIdContext, { transactionData: r2, autoSign: false })];
                case 1:
                  if (n2 = u2.sent(), o2 = n2.processId, i2 = n2.signedTransaction, s2 = n2.transactionId, a2 = n2.errorCode, c2 = n2.errorMessage, a2 || c2)
                    throw new Error(c2);
                  return [2, { processId: o2, signedTransaction: i2, transactionId: s2 }];
              }
            });
          });
        }, t2.prototype.signWithWallet = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3;
            return W(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return t3 = this.data, [4, this._oreIdContext.walletHelper.signWithWallet(e2, t3)];
                case 1:
                  return [2, r2.sent()];
              }
            });
          });
        }, t2;
      }();
      function Oe(e2, t2) {
        return f2.default(t2, e2).toString();
      }
      function Ue(e2, t2, r2) {
        var n2;
        return N(this, void 0, void 0, function() {
          var o2, i2, s2;
          return W(this, function(a2) {
            switch (a2.label) {
              case 0:
                if (!e2 && H.isNullOrEmpty(t2))
                  throw new Error("Cant generate hmac. apiKey missing or empty - its required if not using a proxy server");
                if (!e2)
                  return [3, 5];
                a2.label = 1;
              case 1:
                return a2.trys.push([1, 3, , 4]), [4, v.default.post("/oreid/hmac", JSON.stringify({ data: r2 }), { headers: { "Content-Type": "application/json" } })];
              case 2:
                return i2 = a2.sent(), o2 = null === (n2 = null == i2 ? void 0 : i2.data) || void 0 === n2 ? void 0 : n2.hmac, [3, 4];
              case 3:
                throw s2 = a2.sent(), this.getErrorFromAxiosError(s2);
              case 4:
                return [3, 6];
              case 5:
                o2 = Oe(t2, r2), a2.label = 6;
              case 6:
                return [2, o2];
            }
          });
        });
      }
      function De(e2, t2, r2) {
        return N(this, void 0, void 0, function() {
          var n2, o2;
          return W(this, function(i2) {
            switch (i2.label) {
              case 0:
                if (H.isNullOrEmpty(r2))
                  throw new Error("Cant generate hmac. url missing or empty");
                return [4, Ue(e2, t2, r2)];
              case 1:
                return n2 = i2.sent(), o2 = encodeURIComponent(n2), r2.includes("&hmac=".concat(o2)) ? [2, r2] : [2, "".concat(r2, "&hmac=").concat(o2)];
            }
          });
        });
      }
      var Le = function() {
        function e2(e3, t2) {
          this.appId = e3, this.cachedaccessToken = null, this.cachedUser = null, this.storage = t2;
        }
        return e2.prototype.accessTokenKey = function() {
          return "oreid.".concat(this.appId, ".accessToken");
        }, Object.defineProperty(e2.prototype, "accessToken", { get: function() {
          return this.cachedaccessToken || this.loadAccessToken(), this.cachedaccessToken;
        }, enumerable: false, configurable: true }), e2.prototype.loadAccessToken = function() {
          this.cachedaccessToken = this.storage.getItem(this.accessTokenKey());
        }, e2.prototype.saveAccessToken = function(e3) {
          e3 ? (this.cachedaccessToken = e3, this.storage.setItem(this.accessTokenKey(), e3)) : this.clearAccessToken();
        }, e2.prototype.clearAccessToken = function() {
          this.cachedaccessToken = null, this.storage.removeItem(this.accessTokenKey());
        }, e2.prototype.clear = function() {
          this.clearAccessToken();
        }, e2;
      }(), qe = function() {
        function e2() {
        }
        return e2.prototype.getItem = function(e3) {
          return g.get(e3);
        }, e2.prototype.removeItem = function(e3) {
          g.remove(e3);
        }, e2.prototype.setItem = function(e3, t2, r2) {
          var n2 = x({ expires: 1 }, r2);
          return g.set(e3, t2, n2);
        }, e2;
      }(), He = function() {
        function e2() {
          window ? this.storage = window.localStorage : H.log("Not running in Browser. Using CookieStorage instead.");
        }
        return e2.prototype.getItem = function(e3) {
          return this.storage ? this.storage.getItem(e3) : null;
        }, e2.prototype.removeItem = function(e3) {
          this.storage && this.storage.removeItem(e3);
        }, e2.prototype.setItem = function(e3, t2, r2) {
          this.storage && this.storage.setItem(e3, t2);
        }, e2;
      }(), je = function() {
        function e2() {
        }
        return e2.prototype.getItem = function(e3) {
          return null;
        }, e2.prototype.removeItem = function(e3) {
        }, e2.prototype.setItem = function(e3, t2, r2) {
        }, e2;
      }(), Re = function() {
        function e2() {
          this.memoryCache = {};
        }
        return e2.prototype.getItem = function(e3) {
          return e3 in this.memoryCache ? this.memoryCache[e3] : null;
        }, e2.prototype.removeItem = function(e3) {
          this.getItem(e3) && delete this.memoryCache[e3];
        }, e2.prototype.setItem = function(e3, t2, r2) {
          this.memoryCache[e3] = t2;
        }, e2;
      }(), Fe = function() {
        function e2(e3) {
          if (void 0 === e3 && (e3 = { tryLocalStorageFirst: true }), this.triedLocalStorage = false, this.triedCookieStorage = false, true === e3.tryLocalStorageFirst) {
            this.triedLocalStorage = true;
            try {
              var t2 = new He();
              t2 && t2.storage && (this.storage = t2);
            } catch (t3) {
              H.log("Cant use localStorage. Using CookieStorage instead.", e3);
            }
          }
          this.storage || (this.storage = new qe(), this.triedCookieStorage = true);
        }
        return e2.prototype.failover = function() {
          if (!(this.storage instanceof je)) {
            var e3 = false;
            this.storage instanceof He ? this.triedCookieStorage || (this.storage = new qe(), this.triedCookieStorage = true, e3 = true) : this.storage instanceof qe && (this.triedLocalStorage || (this.storage = new He(), this.triedLocalStorage = true, e3 = true)), e3 || (this.storage = new je());
          }
        }, e2.prototype.getItem = function(e3) {
          try {
            return this.storage.getItem(e3);
          } catch (t2) {
            return H.log("Cant getItem in storage.", t2), this.failover(), this.storage.getItem(e3);
          }
        }, e2.prototype.removeItem = function(e3) {
          try {
            return void this.storage.removeItem(e3);
          } catch (t2) {
            H.log("Cant removeItem in storage.", t2), this.failover(), this.storage.removeItem(e3);
          }
        }, e2.prototype.setItem = function(e3, t2, r2) {
          try {
            return this.storage.setItem(e3, t2, r2);
          } catch (n2) {
            return H.log("Cant setItem in storage.", n2), this.failover(), this.storage.setItem(e3, t2, r2);
          }
        }, e2;
      }(), Me = function() {
        function t2(e2) {
          this._cachedChainNetworks = [], this._oreIdContext = e2.oreIdContext, this._cachedChainNetworks = null;
        }
        return t2.prototype.getAllChainNetworkSettings = function() {
          return N(this, void 0, void 0, function() {
            var t3;
            return W(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return H.isNullOrEmpty(this._cachedChainNetworks) ? [4, this.getConfigFromApi(e.ConfigType.Chains)] : [3, 2];
                case 1:
                  t3 = r2.sent(), this._cachedChainNetworks = t3.chains, r2.label = 2;
                case 2:
                  return [2, this._cachedChainNetworks];
              }
            });
          });
        }, t2.prototype.getChainNetworkSettings = function(e2) {
          return N(this, void 0, void 0, function() {
            return W(this, function(t3) {
              switch (t3.label) {
                case 0:
                  return [4, this.getAllChainNetworkSettings()];
                case 1:
                  return [2, t3.sent().find(function(t4) {
                    return t4.network === e2;
                  })];
              }
            });
          });
        }, t2.prototype.getConfig = function(e2) {
          return N(this, void 0, void 0, function() {
            return W(this, function(t3) {
              return [2, this.getConfigFromApi(e2)];
            });
          });
        }, t2.prototype.getConfigFromApi = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3;
            return W(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return [4, X(this._oreIdContext, { configType: e2 })];
                case 1:
                  if (t3 = r2.sent(), H.isNullOrEmpty(t3))
                    throw new Error("Not able to retrieve config values for ".concat(e2));
                  return [2, t3];
              }
            });
          });
        }, t2.prototype.getChainNetworkNextworkConfig = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3, r2, n2, o2, i2, s2;
            return W(this, function(a2) {
              switch (a2.label) {
                case 0:
                  return [4, this.getChainNetworkSettings(e2)];
                case 1:
                  if (!(t3 = a2.sent()))
                    throw new Error("Invalid chain network: ".concat(e2, "."));
                  return r2 = (null == t3 ? void 0 : t3.hosts[0]) || {}, n2 = r2.chainId, o2 = r2.host, i2 = r2.port, s2 = r2.protocol, [2, { host: o2, port: i2, protocol: s2, chainId: n2 }];
              }
            });
          });
        }, t2.prototype.getChainNetworkByChainId = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3, r2;
            return W(this, function(n2) {
              switch (n2.label) {
                case 0:
                  return [4, this.getAllChainNetworkSettings()];
                case 1:
                  return t3 = n2.sent(), r2 = t3.find(function(t4) {
                    return t4.hosts.find(function(t5) {
                      return t5.chainId === e2;
                    });
                  }), H.isNullOrEmpty(r2) ? [2, null] : [2, r2.network];
              }
            });
          });
        }, t2.prototype.isNotEosNetwork = function(t3) {
          return N(this, void 0, void 0, function() {
            var r2;
            return W(this, function(n2) {
              switch (n2.label) {
                case 0:
                  return [4, this._oreIdContext.settings.getChainNetworkSettings(t3)];
                case 1:
                  return [2, !((r2 = n2.sent()).type === e.ChainPlatformType.eos || r2.type === e.ChainPlatformType.ore)];
              }
            });
          });
        }, t2;
      }(), Ke = function() {
        function t2(e2) {
          this._oreIdContext = e2.oreIdContext, this._transitHelper = e2.transitHelper, this._ualHelper = e2.ualHelper;
        }
        return Object.defineProperty(t2.prototype, "transitHelper", { get: function() {
          return this._transitHelper;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "ualHelper", { get: function() {
          return this._ualHelper;
        }, enumerable: false, configurable: true }), t2.prototype.isAValidExternalWalletType = function(e2) {
          return (this._transitHelper.isTransitProvider(e2) || this._ualHelper.isUalProvider(e2)) && !xe.includes(e2);
        }, t2.prototype.getExternalWalletInfo = function(t3, r2) {
          if (!this.isAValidExternalWalletType(t3))
            throw new Error("Not a valid external wallet type: ".concat(t3));
          return this._transitHelper.hasTransitProvider(t3) || r2 === e.ExternalWalletInterface.Transit ? ge(t3) : this._ualHelper.hasUalProvider(t3) || r2 === e.ExternalWalletInterface.Ual ? me(t3) : null;
        }, t2.prototype.getExternalWalletInfoByChain = function(e2) {
          var t3 = this, r2 = fe.filter(function(e3) {
            return t3._oreIdContext.transitProvidersInstalled.includes(e3.providerName);
          }), n2 = we.filter(function(e3) {
            return t3._oreIdContext.ualProvidersInstalled.includes(e3.providerName);
          });
          return U(U([], O(r2), false), O(n2), false).filter(function(t4) {
            return t4.chainType === e2;
          });
        }, t2.prototype.connectToWalletProvider = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3;
            return W(this, function(r2) {
              if (t3 = e2.walletType, !this.isAValidExternalWalletType(t3))
                throw new Error("Not a valid external wallet type: ".concat(t3));
              if (this._transitHelper.hasTransitProvider(t3))
                return [2, this._transitHelper.loginWithTransitProvider(e2)];
              if (this._ualHelper.hasUalProvider(t3))
                return [2, this._ualHelper.loginWithUalProvider(e2)];
              throw new Error("Wallet type ".concat(t3, " invalid or not installed"));
            });
          });
        }, t2.prototype.signWithWallet = function(t3, r2) {
          return N(this, void 0, void 0, function() {
            var n2, o2, i2, s2;
            return W(this, function(a2) {
              switch (a2.label) {
                case 0:
                  if (!this._oreIdContext.walletHelper.isAValidExternalWalletType(t3))
                    throw new Error("signWithWallet not supported for external wallet type: ".concat(t3));
                  return o2 = H.toEnumValue(e.AuthProvider, t3), this._transitHelper.hasTransitProvider(t3) ? [4, this._transitHelper.signWithTransitProvider(r2, t3)] : [3, 3];
                case 1:
                  return n2 = a2.sent(), i2 = r2.account, s2 = r2.chainNetwork, [4, this._transitHelper.callDiscoverAfterSign({ account: i2, chainNetwork: s2, signOptions: { provider: o2 } })];
                case 2:
                  return a2.sent(), [3, 5];
                case 3:
                  return this._ualHelper.hasUalProvider(t3) ? [4, this._ualHelper.signWithUalProvider(r2, t3)] : [3, 5];
                case 4:
                  n2 = a2.sent(), a2.label = 5;
                case 5:
                  return [2, n2];
              }
            });
          });
        }, t2.prototype.signStringWithWallet = function(t3) {
          return N(this, void 0, void 0, function() {
            var r2, n2, o2, i2, s2;
            return W(this, function(a2) {
              switch (a2.label) {
                case 0:
                  if (r2 = t3.account, n2 = t3.walletType, o2 = t3.chainNetwork, !this.isAValidExternalWalletType(n2))
                    throw new Error("signStringWithWallet not supported for external wallet type: ".concat(n2));
                  if (s2 = H.toEnumValue(e.AuthProvider, n2), !this._transitHelper.hasTransitProvider(n2))
                    return [3, 3];
                  if (!this._transitHelper.canSignString(n2))
                    throw Error("The walletType ".concat(n2, " does not support signString"));
                  return [4, this._transitHelper.signStringWithTransitProvider(t3)];
                case 1:
                  return i2 = a2.sent(), [4, this._transitHelper.callDiscoverAfterSign({ account: r2, chainNetwork: o2, signOptions: { provider: s2 } })];
                case 2:
                  return a2.sent(), [3, 5];
                case 3:
                  if (!this._ualHelper.hasUalProvider(n2))
                    return [3, 5];
                  if (!this._ualHelper.canSignString(n2))
                    throw Error("The walletType ".concat(n2, " does not support signString"));
                  return [4, this._ualHelper.signStringWithUalProvider(t3)];
                case 4:
                  i2 = a2.sent(), a2.label = 5;
                case 5:
                  return [2, i2];
              }
            });
          });
        }, t2.prototype.assertWalletTypeValidForChainNetwork = function(e2, t3, r2) {
          return N(this, void 0, void 0, function() {
            var n2, o2;
            return W(this, function(i2) {
              switch (i2.label) {
                case 0:
                  return n2 = this.getExternalWalletInfo(e2, r2).chainType, [4, this._oreIdContext.settings.getAllChainNetworkSettings()];
                case 1:
                  if (o2 = i2.sent(), !!!o2.find(function(e3) {
                    return e3.network === t3 && e3.type === n2;
                  }))
                    throw Error("External Wallet Type: ".concat(e2, " doesnt support chainNetwork ").concat(t3, ". Hint: It supports networks of type ").concat(n2, "."));
                  return [2];
              }
            });
          });
        }, t2.prototype.canDiscover = function(e2, t3) {
          var r2;
          return (null === (r2 = this.getExternalWalletInfo(e2, t3)) || void 0 === r2 ? void 0 : r2.supportsDiscovery) || false;
        }, t2.prototype.canSignString = function(e2, t3) {
          var r2;
          return (null === (r2 = this.getExternalWalletInfo(e2, t3)) || void 0 === r2 ? void 0 : r2.supportsSignArbitrary) || false;
        }, t2.prototype.requiresDiscoverToLogin = function(e2, t3) {
          var r2;
          return (null === (r2 = this.getExternalWalletInfo(e2, t3)) || void 0 === r2 ? void 0 : r2.requiresDiscoverToLogin) || false;
        }, t2.prototype.requiresLogoutLoginToDiscover = function(e2, t3) {
          var r2;
          return (null === (r2 = this.getExternalWalletInfo(e2, t3)) || void 0 === r2 ? void 0 : r2.requiresLogoutLoginToDiscover) || false;
        }, t2.prototype.defaultDiscoveryPathIndexList = function(e2, t3) {
          var r2;
          return (null === (r2 = this.getExternalWalletInfo(e2, t3)) || void 0 === r2 ? void 0 : r2.defaultDiscoveryPathIndexList) || null;
        }, t2.prototype.helpTextForProvider = function(e2, t3) {
          var r2;
          return (null === (r2 = this.getExternalWalletInfo(e2, t3)) || void 0 === r2 ? void 0 : r2.helpText) || null;
        }, t2;
      }(), Ve = H.isNullOrEmpty, Be = function() {
        function t2(e2) {
          var t3, r2, n2, o2;
          this.transitProvidersInstalled = [], this.ualProvidersInstalled = [], this._options = null, this.validateAndSetOptions(e2);
          var i2 = (null === (t3 = this.options) || void 0 === t3 ? void 0 : t3.storageHandler) || new Fe();
          this._localState = new Le(null === (r2 = this.options) || void 0 === r2 ? void 0 : r2.appId, i2), this._settings = new Me({ oreIdContext: this }), this._auth = new Ee({ oreIdContext: this }), this._transitHelper = new Te({ oreIdContext: this, user: this._auth.user }), this._transitHelper.installTransitProviders(null === (n2 = this.options) || void 0 === n2 ? void 0 : n2.eosTransitWalletProviders), this._ualHelper = new be({ oreIdContext: this, user: this._auth.user }), this._ualHelper.installUalProviders(null === (o2 = this.options) || void 0 === o2 ? void 0 : o2.ualAuthenticators), this._walletHelper = new Ke({ oreIdContext: this, transitHelper: this._transitHelper, ualHelper: this._ualHelper }), this._initializerPlugins = e2.plugins || {}, this._isInitialized = false;
        }
        return Object.defineProperty(t2.prototype, "accessToken", { get: function() {
          return this.auth.accessToken;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "accessTokenHelper", { get: function() {
          return this.auth.accessTokenHelper;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "auth", { get: function() {
          return this._auth;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "isDemoApp", { get: function() {
          var e2, t3;
          return (null === (t3 = null === (e2 = this.options) || void 0 === e2 ? void 0 : e2.appId) || void 0 === t3 ? void 0 : t3.toLowerCase().startsWith("demo")) || false;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "isInitialized", { get: function() {
          return this._isInitialized;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "localState", { get: function() {
          return this._localState;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "options", { get: function() {
          return this._options;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "popup", { get: function() {
          return this.assertIsInitialized(), this._popup;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "requiresProxyServer", { get: function() {
          var e2, t3;
          return !!(null === (e2 = null == this ? void 0 : this.options) || void 0 === e2 ? void 0 : e2.isUsingProxyServer) || !!(null === (t3 = null == this ? void 0 : this.options) || void 0 === t3 ? void 0 : t3.apiKey) && (H.isInBrowser && !this.isDemoApp);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "settings", { get: function() {
          return this._settings;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "walletHelper", { get: function() {
          return this._walletHelper;
        }, enumerable: false, configurable: true }), t2.prototype.init = function() {
          var e2, t3, r2;
          return N(this, void 0, void 0, function() {
            var n2;
            return W(this, function(o2) {
              switch (o2.label) {
                case 0:
                  return this.isInitialized ? [2] : (null === (e2 = this._initializerPlugins) || void 0 === e2 ? void 0 : e2.popup) ? (n2 = this, [4, null === (r2 = null === (t3 = this._initializerPlugins) || void 0 === t3 ? void 0 : t3.popup) || void 0 === r2 ? void 0 : r2.init(this)]) : [3, 2];
                case 1:
                  n2._popup = o2.sent(), o2.label = 2;
                case 2:
                  return this._isInitialized = true, [2];
              }
            });
          });
        }, t2.prototype.assertIsInitialized = function() {
          if (!this.isInitialized)
            throw new Error("OreId is not initialized - call init() first");
        }, t2.prototype.logout = function() {
          this.auth.logout();
        }, t2.prototype.signStringWithWallet = function(e2) {
          return N(this, void 0, void 0, function() {
            return W(this, function(t3) {
              return [2, this.walletHelper.signStringWithWallet(e2)];
            });
          });
        }, t2.prototype.custodialSignString = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3;
            return W(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return [4, $(this, e2)];
                case 1:
                  if ((null == (t3 = r2.sent()) ? void 0 : t3.errorCode) || (null == t3 ? void 0 : t3.errorMessage))
                    throw new Error(t3.errorMessage);
                  return [2, t3];
              }
            });
          });
        }, t2.prototype.custodialNewAccount = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3;
            return W(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return [4, Z(this, e2)];
                case 1:
                  if ((null == (t3 = r2.sent()) ? void 0 : t3.errorCode) || (null == t3 ? void 0 : t3.errorMessage))
                    throw new Error(t3.errorMessage);
                  return [2, t3];
              }
            });
          });
        }, t2.prototype.custodialMigrateAccount = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3;
            return W(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return [4, Y(this, e2)];
                case 1:
                  if ((null == (t3 = r2.sent()) ? void 0 : t3.errorCode) || (null == t3 ? void 0 : t3.errorMessage))
                    throw new Error(t3.errorMessage);
                  return [2, t3];
              }
            });
          });
        }, t2.prototype.getExternalWalletInfo = function(e2) {
          return this.walletHelper.getExternalWalletInfo(e2);
        }, t2.prototype.createTransaction = function(e2) {
          return N(this, void 0, void 0, function() {
            return W(this, function(t3) {
              switch (t3.label) {
                case 0:
                  return this._auth.user.hasData ? [3, 2] : [4, this._auth.user.getData()];
                case 1:
                  t3.sent(), t3.label = 2;
                case 2:
                  return [2, new We({ oreIdContext: this, user: this.auth.user, data: e2 })];
              }
            });
          });
        }, t2.prototype.setIsBusy = function(e2) {
          this.isBusy !== e2 && (this.isBusy = e2, this.options.setBusyCallback && this.options.setBusyCallback(e2));
        }, t2.prototype.validateAndSetOptions = function(e2) {
          var t3 = e2 || {}, r2 = t3.appId, n2 = t3.apiKey, o2 = t3.oreIdUrl, i2 = "";
          if (this._options = e2, e2 && (this.options.oreIdUrl = o2 || "https://service.oreid.io"), r2 || (i2 += "\n --> Missing required parameter - appId. You can get an appId when you register your app with ORE ID."), this.requiresProxyServer && n2 && (i2 += "\n --> You cant include the apiKey when creating an instance of OreId that runs in the browser. This is to prevent your key from being visible in the browser. If this app runs solely in the browser (like a Create React App), you need to set-up a proxy server to protect your keys. Refer to https://github.com/TeamAikon/ore-id-docs. Note: You wont get this error when using the appId and apiKey for a demo app (appId starts with demo_)."), "" !== i2)
            throw new Error("Options are missing or invalid. ".concat(i2));
        }, t2.prototype.getAppAccessToken = function(e2) {
          return N(this, void 0, void 0, function() {
            return W(this, function(t3) {
              return [2, z(this, e2)];
            });
          });
        }, t2.prototype.handleNewAccountResponse = function(e2) {
          var t3 = H.extractDataFromCallbackUrl(e2), r2 = t3.chain_account, n2 = t3.process_id, o2 = t3.state, i2 = t3.errors;
          return this.setIsBusy(false), { chainAccount: r2, processId: n2, state: o2, errors: i2 };
        }, t2.prototype.handleSignCallback = function(e2) {
          var t3, r2 = H.extractDataFromCallbackUrl(e2), n2 = r2.signed_transaction, o2 = r2.process_id, i2 = r2.state, s2 = r2.transaction_id, a2 = r2.errors;
          return a2 || (t3 = H.base64DecodeSafe(n2)), this.setIsBusy(false), { signedTransaction: t3, processId: o2, state: i2, transactionId: s2, errors: a2 };
        }, t2.prototype.appendTimestampAndSignatureToWidgetProps = function(e2) {
          return N(this, void 0, void 0, function() {
            var t3, r2, n2;
            return W(this, function(o2) {
              switch (o2.label) {
                case 0:
                  if ((null == e2 ? void 0 : e2.timestamp) && (null == e2 ? void 0 : e2.signature))
                    return [2, e2];
                  t3 = x({}, e2), r2 = (null == e2 ? void 0 : e2.timestamp) || (/* @__PURE__ */ new Date()).getTime(), t3.origin = (null == e2 ? void 0 : e2.origin) || (null === window || void 0 === window ? void 0 : window.location.origin), t3.timestamp = r2, o2.label = 1;
                case 1:
                  return o2.trys.push([1, 3, , 4]), n2 = t3, [4, Ue(this.requiresProxyServer, this.options.apiKey, JSON.stringify(H.sortJson(e2)))];
                case 2:
                  return n2.signature = o2.sent(), [3, 4];
                case 3:
                  return o2.sent(), [3, 4];
                case 4:
                  return [2, t3];
              }
            });
          });
        }, t2.prototype.callOreIdApi = function(t3, r2, n2, o2, i2) {
          return void 0 === n2 && (n2 = {}), void 0 === i2 && (i2 = null), N(this, void 0, void 0, function() {
            var s2, a2, c2, u2, l2, d2, p2, h2, f3, g2, y2, T2;
            return W(this, function(w2) {
              switch (w2.label) {
                case 0:
                  if (c2 = {}, u2 = this.options, l2 = u2.apiKey, d2 = u2.oreIdUrl, p2 = this.requiresProxyServer ? "/oreid" : d2, h2 = "".concat(p2, "/api/").concat(r2), f3 = o2 || this.accessToken, !l2 && !f3 && !Ne.includes(r2))
                    throw new Error("OreId API request requires either apiKey or accessToken");
                  l2 && (c2["api-key"] = l2), f3 && (c2.Authorization = "Bearer ".concat(f3)), Ve(i2) || (c2["process-id"] = i2), c2["sdk-version"] = "oreidjs/".concat(Se), w2.label = 1;
                case 1:
                  return w2.trys.push([1, 6, , 7]), t3 !== e.RequestType.Get ? [3, 3] : (Ve(n2) || (s2 = Object.keys(n2).map(function(e2) {
                    return "".concat(e2, "=").concat(n2[e2]);
                  }).join("&")), g2 = s2 ? "".concat(h2, "?").concat(s2) : h2, [4, v.default.get(g2, { headers: c2 })]);
                case 2:
                  a2 = w2.sent(), w2.label = 3;
                case 3:
                  return t3 !== e.RequestType.Post ? [3, 5] : (y2 = Ve(n2) ? null : JSON.stringify(n2), [4, v.default.post(h2, y2, { headers: x({ "Content-Type": "application/json" }, c2) })]);
                case 4:
                  a2 = w2.sent(), w2.label = 5;
                case 5:
                  return [3, 7];
                case 6:
                  throw T2 = w2.sent(), H.getErrorFromAxiosError(T2);
                case 7:
                  return [2, null == a2 ? void 0 : a2.data];
              }
            });
          });
        }, t2.prototype.addAccessTokenAndHmacToUrl = function(e2, t3, r2) {
          var n2, o2, i2;
          return N(this, void 0, void 0, function() {
            var s2, a2, c2, u2, l2;
            return W(this, function(d2) {
              switch (d2.label) {
                case 0:
                  return s2 = this.options.appId, this.requiresProxyServer ? [4, v.default.post("/oreid/prepare-url", { appAccessTokenMetadata: t3, urlString: e2 })] : [3, 2];
                case 1:
                  return a2 = d2.sent(), [2, null === (n2 = null == a2 ? void 0 : a2.data) || void 0 === n2 ? void 0 : n2.urlString];
                case 2:
                  return c2 = "".concat(e2, "&app_id=").concat(s2), Ve(t3) ? [3, 5] : (l2 = r2) ? [3, 4] : [4, this.getAppAccessToken({ appAccessTokenMetadata: t3 })];
                case 3:
                  l2 = d2.sent(), d2.label = 4;
                case 4:
                  u2 = l2, c2 = "".concat(c2, "&app_access_token=").concat(u2), d2.label = 5;
                case 5:
                  return (null === (o2 = this.options) || void 0 === o2 ? void 0 : o2.apiKey) ? [4, De(false, null === (i2 = this.options) || void 0 === i2 ? void 0 : i2.apiKey, c2)] : [3, 7];
                case 6:
                  c2 = d2.sent(), d2.label = 7;
                case 7:
                  return [2, c2];
              }
            });
          });
        }, t2;
      }();
      e.PluginType = void 0, (e.PluginType || (e.PluginType = {})).Popup = "popup", e.Auth = Ee, e.DummyStorage = je, e.Helpers = H, e.MemoryStorage = Re, e.OreId = Be, e.Transaction = We, e.User = Pe, e.WidgetVersion = "1", e.appendHmacToUrl = De, e.generateHmac = Oe, e.generateHmacWithApiKeyOrProxyServer = Ue, Object.defineProperty(e, "__esModule", { value: true });
    });
  }
});

export {
  require_dist2 as require_dist
};
/*! Bundled license information:

js-cookie/src/js.cookie.js:
  (*!
   * JavaScript Cookie v2.2.1
   * https://github.com/js-cookie/js-cookie
   *
   * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
   * Released under the MIT license
   *)
*/
//# sourceMappingURL=chunk-IIF7FQUX.js.map
