import {
  require_dist
} from "./chunk-IIF7FQUX.js";
import {
  __commonJS
} from "./chunk-6NOISVLF.js";

// node_modules/oreid-webpopup/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/oreid-webpopup/dist/index.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_dist()) : typeof define === "function" && define.amd ? define(["exports", "oreid-js"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.oreidJsWebPopup = {}, global.oreidJs));
    })(exports, function(exports2, oreidJs) {
      "use strict";
      var __assign = function() {
        __assign = Object.assign || function __assign2(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      function __rest(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      }
      function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      }
      typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
      };
      const version = "3.7.5";
      const VERSION = version;
      const _hasatob = typeof atob === "function";
      const _hasbtoa = typeof btoa === "function";
      const _hasBuffer = typeof Buffer === "function";
      const _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
      const _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
      const b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      const b64chs = Array.prototype.slice.call(b64ch);
      const b64tab = ((a) => {
        let tab = {};
        a.forEach((c, i) => tab[c] = i);
        return tab;
      })(b64chs);
      const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
      const _fromCC = String.fromCharCode.bind(String);
      const _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
      const _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
      const _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
      const btoaPolyfill = (bin) => {
        let u32, c0, c1, c2, asc = "";
        const pad = bin.length % 3;
        for (let i = 0; i < bin.length; ) {
          if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
            throw new TypeError("invalid character found");
          u32 = c0 << 16 | c1 << 8 | c2;
          asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
        }
        return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
      };
      const _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
      const _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
        const maxargs = 4096;
        let strs = [];
        for (let i = 0, l = u8a.length; i < l; i += maxargs) {
          strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
        }
        return _btoa(strs.join(""));
      };
      const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
      const cb_utob = (c) => {
        if (c.length < 2) {
          var cc = c.charCodeAt(0);
          return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        } else {
          var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
          return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        }
      };
      const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
      const utob = (u) => u.replace(re_utob, cb_utob);
      const _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
      const encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
      const encodeURI = (src) => encode(src, true);
      const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
      const cb_btou = (cccc) => {
        switch (cccc.length) {
          case 4:
            var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
            return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
          case 3:
            return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
          default:
            return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
        }
      };
      const btou = (b) => b.replace(re_btou, cb_btou);
      const atobPolyfill = (asc) => {
        asc = asc.replace(/\s+/g, "");
        if (!b64re.test(asc))
          throw new TypeError("malformed base64.");
        asc += "==".slice(2 - (asc.length & 3));
        let u24, bin = "", r1, r2;
        for (let i = 0; i < asc.length; ) {
          u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
          bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
        }
        return bin;
      };
      const _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
      const _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a).split("").map((c) => c.charCodeAt(0)));
      const toUint8Array = (a) => _toUint8Array(_unURI(a));
      const _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
      const _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
      const decode = (src) => _decode(_unURI(src));
      const isValid = (src) => {
        if (typeof src !== "string")
          return false;
        const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
        return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
      };
      const _noEnum = (v) => {
        return {
          value: v,
          enumerable: false,
          writable: true,
          configurable: true
        };
      };
      const extendString = function() {
        const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
        _add("fromBase64", function() {
          return decode(this);
        });
        _add("toBase64", function(urlsafe) {
          return encode(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return encode(this, true);
        });
        _add("toBase64URL", function() {
          return encode(this, true);
        });
        _add("toUint8Array", function() {
          return toUint8Array(this);
        });
      };
      const extendUint8Array = function() {
        const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
        _add("toBase64", function(urlsafe) {
          return fromUint8Array(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return fromUint8Array(this, true);
        });
        _add("toBase64URL", function() {
          return fromUint8Array(this, true);
        });
      };
      const extendBuiltins = () => {
        extendString();
        extendUint8Array();
      };
      const gBase64 = {
        version,
        VERSION,
        atob: _atob,
        atobPolyfill,
        btoa: _btoa,
        btoaPolyfill,
        fromBase64: decode,
        toBase64: encode,
        encode,
        encodeURI,
        encodeURL: encodeURI,
        utob,
        btou,
        decode,
        isValid,
        fromUint8Array,
        toUint8Array,
        extendString,
        extendUint8Array,
        extendBuiltins
      };
      var getOreIdOptions = function(oreId) {
        var oreIdOptions = __assign({}, oreId.options);
        oreIdOptions.accessToken = oreId.accessToken;
        oreIdOptions.idToken = oreId.auth.idToken;
        delete oreIdOptions.apiKey;
        delete oreIdOptions.setBusyCallback;
        return oreIdOptions;
      };
      var WebWidgetCoreHandler = (
        /** @class */
        function() {
          function WebWidgetCoreHandler2(_a) {
            var _this = this;
            var oreId = _a.oreId, webWidget = _a.webWidget, container = _a.container;
            this.willCloseListener = function(event) {
              var _a2;
              var oreIdUrl = getOreIdOptions(_this.oreId).oreIdUrl;
              if (event.origin === oreIdUrl && event.data && event.data === ((_a2 = _this.webWidget) === null || _a2 === void 0 ? void 0 : _a2.closeMessage)) {
                _this.willClose = true;
              }
            };
            this.close = function() {
              _this.isBusy = false;
              _this.container.hide();
              _this.webWidget.closeWebWidget(_this.container.window, !_this.willClose);
              _this.container.window.removeEventListener("message", _this.willCloseListener);
              _this.willClose = false;
            };
            this.oreId = oreId;
            this.webWidget = webWidget;
            this.container = container;
            this.isBusy = false;
            this.willClose = false;
          }
          WebWidgetCoreHandler2.prototype.open = function() {
            this.container.window.addEventListener("message", this.willCloseListener);
            var windowType = this.webWidget.getWindowTypeForProps(this._widgetProps);
            this.container.show(windowType === this.webWidget.WindowType.Iframe);
          };
          WebWidgetCoreHandler2.prototype.getWebWidgetCoreProps = function(webWidgetActionProps) {
            return __awaiter(this, void 0, void 0, function() {
              var _a;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    _a = this;
                    return [4, this.oreId.appendTimestampAndSignatureToWidgetProps({
                      action: webWidgetActionProps.action,
                      onError: webWidgetActionProps.onError,
                      onSuccess: webWidgetActionProps.onSuccess,
                      oreIdOptions: getOreIdOptions(this.oreId),
                      origin: this.container.window.location.origin
                    })];
                  case 1:
                    _a._widgetProps = _b.sent();
                    this._widgetProps.onClose = this.close;
                    return [2, this._widgetProps];
                }
              });
            });
          };
          WebWidgetCoreHandler2.prototype.render = function(webWidgetActionProps) {
            return __awaiter(this, void 0, void 0, function() {
              var _this = this;
              return __generator(this, function(_a) {
                if (this.isBusy)
                  throw new Error("WebWidget is busy. Wait for it to finish");
                this.isBusy = true;
                return [2, new Promise(function(resolve, reject) {
                  var onError = function(reason) {
                    _this.isBusy = false;
                    console.debug("WebWidget Results (Error): ", reason);
                    reject(reason);
                  };
                  var onSuccess = function(value) {
                    _this.isBusy = false;
                    var response = __assign({}, value.data);
                    if (response.accessToken) {
                      response.accessToken = response.accessToken.slice(0, 2) + "...";
                    }
                    if (response.idToken) {
                      response.idToken = response.idToken.slice(0, 2) + "...";
                    }
                    console.debug("WebWidget Results (Success): ", response);
                    resolve(value === null || value === void 0 ? void 0 : value.data);
                  };
                  _this.getWebWidgetCoreProps({
                    action: webWidgetActionProps,
                    onSuccess,
                    onError
                  }).then(function(webWidgetCoreProps) {
                    _this.isBusy = false;
                    _this.open();
                    _this.webWidget.renderWebWidget(webWidgetCoreProps, _this.container.iframeSelector);
                  }).catch(onError);
                })];
              });
            });
          };
          return WebWidgetCoreHandler2;
        }()
      );
      function assign(obj, props) {
        for (const key in props) {
          Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true
          });
        }
        return obj;
      }
      function createError(err, code, props) {
        if (!err || typeof err === "string") {
          throw new TypeError("Please pass an Error to err-code");
        }
        if (!props) {
          props = {};
        }
        if (typeof code === "object") {
          props = code;
          code = void 0;
        }
        if (code != null) {
          props.code = code;
        }
        try {
          return assign(err, props);
        } catch (_) {
          props.message = err.message;
          props.stack = err.stack;
          const ErrClass = function() {
          };
          ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
          return assign(new ErrClass(), props);
        }
      }
      var errCode = createError;
      var retry$2 = {};
      function RetryOperation(timeouts, options) {
        if (typeof options === "boolean") {
          options = { forever: options };
        }
        this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
        this._timeouts = timeouts;
        this._options = options || {};
        this._maxRetryTime = options && options.maxRetryTime || Infinity;
        this._fn = null;
        this._errors = [];
        this._attempts = 1;
        this._operationTimeout = null;
        this._operationTimeoutCb = null;
        this._timeout = null;
        this._operationStart = null;
        if (this._options.forever) {
          this._cachedTimeouts = this._timeouts.slice(0);
        }
      }
      var retry_operation = RetryOperation;
      RetryOperation.prototype.reset = function() {
        this._attempts = 1;
        this._timeouts = this._originalTimeouts;
      };
      RetryOperation.prototype.stop = function() {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
        this._timeouts = [];
        this._cachedTimeouts = null;
      };
      RetryOperation.prototype.retry = function(err) {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
        if (!err) {
          return false;
        }
        var currentTime = (/* @__PURE__ */ new Date()).getTime();
        if (err && currentTime - this._operationStart >= this._maxRetryTime) {
          this._errors.unshift(new Error("RetryOperation timeout occurred"));
          return false;
        }
        this._errors.push(err);
        var timeout = this._timeouts.shift();
        if (timeout === void 0) {
          if (this._cachedTimeouts) {
            this._errors.splice(this._errors.length - 1, this._errors.length);
            this._timeouts = this._cachedTimeouts.slice(0);
            timeout = this._timeouts.shift();
          } else {
            return false;
          }
        }
        var self2 = this;
        var timer = setTimeout(function() {
          self2._attempts++;
          if (self2._operationTimeoutCb) {
            self2._timeout = setTimeout(function() {
              self2._operationTimeoutCb(self2._attempts);
            }, self2._operationTimeout);
            if (self2._options.unref) {
              self2._timeout.unref();
            }
          }
          self2._fn(self2._attempts);
        }, timeout);
        if (this._options.unref) {
          timer.unref();
        }
        return true;
      };
      RetryOperation.prototype.attempt = function(fn, timeoutOps) {
        this._fn = fn;
        if (timeoutOps) {
          if (timeoutOps.timeout) {
            this._operationTimeout = timeoutOps.timeout;
          }
          if (timeoutOps.cb) {
            this._operationTimeoutCb = timeoutOps.cb;
          }
        }
        var self2 = this;
        if (this._operationTimeoutCb) {
          this._timeout = setTimeout(function() {
            self2._operationTimeoutCb();
          }, self2._operationTimeout);
        }
        this._operationStart = (/* @__PURE__ */ new Date()).getTime();
        this._fn(this._attempts);
      };
      RetryOperation.prototype.try = function(fn) {
        console.log("Using RetryOperation.try() is deprecated");
        this.attempt(fn);
      };
      RetryOperation.prototype.start = function(fn) {
        console.log("Using RetryOperation.start() is deprecated");
        this.attempt(fn);
      };
      RetryOperation.prototype.start = RetryOperation.prototype.try;
      RetryOperation.prototype.errors = function() {
        return this._errors;
      };
      RetryOperation.prototype.attempts = function() {
        return this._attempts;
      };
      RetryOperation.prototype.mainError = function() {
        if (this._errors.length === 0) {
          return null;
        }
        var counts = {};
        var mainError = null;
        var mainErrorCount = 0;
        for (var i = 0; i < this._errors.length; i++) {
          var error = this._errors[i];
          var message = error.message;
          var count = (counts[message] || 0) + 1;
          counts[message] = count;
          if (count >= mainErrorCount) {
            mainError = error;
            mainErrorCount = count;
          }
        }
        return mainError;
      };
      (function(exports3) {
        var RetryOperation2 = retry_operation;
        exports3.operation = function(options) {
          var timeouts = exports3.timeouts(options);
          return new RetryOperation2(timeouts, {
            forever: options && options.forever,
            unref: options && options.unref,
            maxRetryTime: options && options.maxRetryTime
          });
        };
        exports3.timeouts = function(options) {
          if (options instanceof Array) {
            return [].concat(options);
          }
          var opts = {
            retries: 10,
            factor: 2,
            minTimeout: 1 * 1e3,
            maxTimeout: Infinity,
            randomize: false
          };
          for (var key in options) {
            opts[key] = options[key];
          }
          if (opts.minTimeout > opts.maxTimeout) {
            throw new Error("minTimeout is greater than maxTimeout");
          }
          var timeouts = [];
          for (var i = 0; i < opts.retries; i++) {
            timeouts.push(this.createTimeout(i, opts));
          }
          if (options && options.forever && !timeouts.length) {
            timeouts.push(this.createTimeout(i, opts));
          }
          timeouts.sort(function(a, b) {
            return a - b;
          });
          return timeouts;
        };
        exports3.createTimeout = function(attempt, opts) {
          var random = opts.randomize ? Math.random() + 1 : 1;
          var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
          timeout = Math.min(timeout, opts.maxTimeout);
          return timeout;
        };
        exports3.wrap = function(obj, options, methods) {
          if (options instanceof Array) {
            methods = options;
            options = null;
          }
          if (!methods) {
            methods = [];
            for (var key in obj) {
              if (typeof obj[key] === "function") {
                methods.push(key);
              }
            }
          }
          for (var i = 0; i < methods.length; i++) {
            var method = methods[i];
            var original = obj[method];
            obj[method] = (function retryWrapper(original2) {
              var op = exports3.operation(options);
              var args = Array.prototype.slice.call(arguments, 1);
              var callback = args.pop();
              args.push(function(err) {
                if (op.retry(err)) {
                  return;
                }
                if (err) {
                  arguments[0] = op.mainError();
                }
                callback.apply(this, arguments);
              });
              op.attempt(function() {
                original2.apply(obj, args);
              });
            }).bind(obj, original);
            obj[method].options = options;
          }
        };
      })(retry$2);
      var retry$1 = retry$2;
      var errcode = errCode;
      var retry = retry$1;
      var hasOwn = Object.prototype.hasOwnProperty;
      function isRetryError(err) {
        return err && err.code === "EPROMISERETRY" && hasOwn.call(err, "retried");
      }
      function promiseRetry(fn, options) {
        var temp;
        var operation;
        if (typeof fn === "object" && typeof options === "function") {
          temp = options;
          options = fn;
          fn = temp;
        }
        operation = retry.operation(options);
        return new Promise(function(resolve, reject) {
          operation.attempt(function(number) {
            Promise.resolve().then(function() {
              return fn(function(err) {
                if (isRetryError(err)) {
                  err = err.retried;
                }
                throw errcode(new Error("Retrying"), "EPROMISERETRY", { retried: err });
              }, number);
            }).then(resolve, function(err) {
              if (isRetryError(err)) {
                err = err.retried;
                if (operation.retry(err || new Error())) {
                  return;
                }
              }
              reject(err);
            });
          });
        });
      }
      var promiseRetry_1 = promiseRetry;
      var addContainerStyle = function(container) {
        container.style.position = "fixed";
        container.style.flexDirection = "column";
        container.style.display = "none";
        container.style.backgroundColor = "rgba(0,0,0,0.3)";
        container.style.height = "100vh";
        container.style.width = "100vw";
        container.style.top = "0";
        container.style.left = "0px";
        container.style.justifyContent = "center";
        container.style.zIndex = "999999999";
      };
      var addIframeContainerStyle = function(container) {
        container.style.backgroundColor = "#fafafa";
        container.style.borderRadius = "8px";
        container.style.maxHeight = "740px";
        container.style.maxWidth = "420px";
        container.style.boxShadow = "0px 10px 13px -7px #000000, 5px 5px 15px 5px rgba(0,0,0,0)";
        container.style.position = "relative";
        container.style.alignSelf = "center";
        container.style.overflow = "hidden";
      };
      var addCloseBtnStyle = function(container) {
        container.style.display = "none";
        container.style.backgroundColor = "white";
        container.style.borderRadius = "50%";
        container.style.border = "0";
        container.style.height = "33px";
        container.style.width = "33px";
        container.style.cursor = "pointer";
        container.style.alignSelf = "center";
        container.style.marginBottom = "10px";
      };
      var createHtmlContainer = function(_a) {
        var _b;
        var webWindow = _a.webWindow, containerId = _a.containerId, closeBtnId = _a.closeBtnId, iframeId = _a.iframeId, webWidget = _a.webWidget, hideContainer = _a.hideContainer;
        if (webWindow.document.getElementById(containerId))
          throw new Error('This element "' + containerId + '" is already present in the document');
        if (webWindow.document.getElementById(iframeId))
          throw new Error('This element "' + iframeId + '" is already present in the document');
        if (webWindow.document.getElementById(closeBtnId))
          throw new Error('This element "' + closeBtnId + '" is already present in the document');
        var container = webWindow.document.createElement("div");
        container.id = containerId;
        addContainerStyle(container);
        var closeBtn = webWindow.document.createElement("button");
        closeBtn.id = closeBtnId;
        closeBtn.textContent = "❌";
        addCloseBtnStyle(closeBtn);
        closeBtn.onclick = function(event) {
          var _a2, _b2;
          event.preventDefault();
          event.stopPropagation();
          (_b2 = (_a2 = webWidget.webWidgetCoreProps) === null || _a2 === void 0 ? void 0 : _a2.onClose) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
          hideContainer();
        };
        var iframeContainer = webWindow.document.createElement("div");
        iframeContainer.id = iframeId;
        addIframeContainerStyle(iframeContainer);
        var onClick = function(event) {
          var _a2;
          if (((_a2 = webWidget.webWidgetCoreProps) === null || _a2 === void 0 ? void 0 : _a2.windowType) === webWidget.WindowType.Popup) {
            event.preventDefault();
            event.stopPropagation();
            webWidget.focusWebWidget(webWindow);
          }
        };
        iframeContainer.onclick = onClick;
        container.onclick = onClick;
        container.appendChild(closeBtn);
        container.appendChild(iframeContainer);
        (_b = webWindow.document.querySelector("body")) === null || _b === void 0 ? void 0 : _b.appendChild(container);
      };
      var getElementById = function(_a) {
        var webWindow = _a.webWindow, elementId = _a.elementId;
        var element = webWindow.document.getElementById(elementId);
        if (!element) {
          throw new Error('This elementId "' + elementId + '" is not present in the document');
        }
        return element;
      };
      var Container = (
        /** @class */
        function() {
          function Container2(_a) {
            var _this = this;
            var containerId = _a.containerId, iframeId = _a.iframeId, webWindow = _a.webWindow, webWidget = _a.webWidget;
            this.show = function(withCloseBtn) {
              if (withCloseBtn === void 0) {
                withCloseBtn = false;
              }
              var containerElem = getElementById({ webWindow: _this.webWindow, elementId: _this.containerId });
              containerElem.style.display = "flex";
              if (withCloseBtn) {
                var closeBtnElem = getElementById({ webWindow: _this.webWindow, elementId: _this.closeBtnId });
                closeBtnElem.style.display = "block";
              }
            };
            this.hide = function() {
              var element = getElementById({ webWindow: _this.webWindow, elementId: _this.containerId });
              element.style.display = "none";
            };
            this.containerId = containerId;
            this.iframeId = iframeId;
            this.webWindow = webWindow;
            createHtmlContainer({
              containerId: this.containerId,
              iframeId: this.iframeId,
              closeBtnId: this.closeBtnId,
              webWindow: this.webWindow,
              hideContainer: this.hide,
              webWidget
            });
          }
          Object.defineProperty(Container2.prototype, "closeBtnId", {
            get: function() {
              return "" + this.containerId + this.iframeId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Container2.prototype, "window", {
            get: function() {
              return this.webWindow;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Container2.prototype, "containerElement", {
            get: function() {
              return this.webWindow.document.querySelector("#" + this.containerId);
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Container2.prototype, "iframeSelector", {
            get: function() {
              return "#" + this.iframeId;
            },
            enumerable: false,
            configurable: true
          });
          return Container2;
        }()
      );
      var DEFAULT_OREID_URL = "https://service.oreid.io";
      var SUPPORTED_VERSION = "1";
      var WIDGET_DOWNLOAD_PATH = "dist/v" + SUPPORTED_VERSION + "/oreid-web-widget-core.js";
      var WIDGET_SCRIPT_ID = "oreid-web-popup_widget--core";
      var getWebWidgetCoreFromWindow = function(_a) {
        var webWindow = _a.webWindow;
        var webWidgetCore = webWindow.oreidWebWidgetCore;
        if (!webWidgetCore) {
          throw new Error("webWidget not found on webWindow");
        }
        if (SUPPORTED_VERSION !== webWidgetCore.version) {
          throw new Error("webWidget " + SUPPORTED_VERSION + " is no longer supported. Please upgrade to: " + webWidgetCore.version);
        }
        return webWidgetCore;
      };
      var returnWebWidgetCoreFromWindow = function(resolve, reject, webWindow) {
        try {
          var webWidgetCore = getWebWidgetCoreFromWindow({ webWindow });
          resolve(webWidgetCore);
        } catch (err) {
          reject(err);
        }
      };
      var loadWebWidgetCore = function(oreId, webWindow) {
        if (webWindow.document.querySelector("#" + WIDGET_SCRIPT_ID)) {
          return new Promise(function(resolve, reject) {
            return returnWebWidgetCoreFromWindow(resolve, reject, webWindow);
          });
        }
        var script = webWindow.document.createElement("script");
        script.async = true;
        script.defer = true;
        script.src = (oreId.options.oreIdUrl || DEFAULT_OREID_URL) + "/" + WIDGET_DOWNLOAD_PATH;
        script.id = WIDGET_SCRIPT_ID;
        webWindow.document.querySelector("body").appendChild(script);
        return new Promise(function(resolve, reject) {
          script.addEventListener("error", function() {
            return reject(new Error("Problem downloading ORE ID WebWidget - Server might be temporarily unavailable"));
          }, { once: true });
          script.addEventListener("load", function() {
            return returnWebWidgetCoreFromWindow(resolve, reject, webWindow);
          }, { once: true });
        });
      };
      var createWebWidgetCoreHandler = function(_a) {
        var webWindow = _a.webWindow, oreId = _a.oreId, containerId = _a.containerId, iframeId = _a.iframeId;
        return __awaiter(void 0, void 0, void 0, function() {
          var webWidget, container;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, promiseRetry_1(function(retry2) {
                  return loadWebWidgetCore(oreId, webWindow).catch(retry2);
                }, {
                  retries: 3
                })];
              case 1:
                webWidget = _b.sent();
                container = new Container({ containerId, iframeId, webWindow, webWidget });
                return [2, new WebWidgetCoreHandler({
                  oreId,
                  container,
                  webWidget
                })];
            }
          });
        });
      };
      var autoSign = function(_a) {
        var transaction = _a.transaction;
        return __awaiter(void 0, void 0, void 0, function() {
          var canAuto;
          var _b, _c;
          return __generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if ((_c = (_b = transaction === null || transaction === void 0 ? void 0 : transaction.data) === null || _b === void 0 ? void 0 : _b.signOptions) === null || _c === void 0 ? void 0 : _c.preventAutosign) {
                  return [2, void 0];
                }
                return [4, transaction.checkCanAutoSign()];
              case 1:
                canAuto = _d.sent();
                if (!canAuto)
                  return [2, void 0];
                return [2, transaction.autoSign()];
            }
          });
        });
      };
      var OreIdWebPopup = (
        /** @class */
        function() {
          function OreIdWebPopup2(_a) {
            var _this = this;
            var oreId = _a.oreId, webWidgetCore = _a.webWidgetCore;
            var _b;
            this.auth = function(params) {
              return __awaiter(_this, void 0, void 0, function() {
                var result, user;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      return [4, this.webWidgetCore.render({
                        name: oreidJs.WebWidgetAction.Auth,
                        params
                      })];
                    case 1:
                      result = _a2.sent();
                      if (!result.accessToken) {
                        throw new Error("Access Token was not returned");
                      }
                      this.oreId.auth.setAuthResult(result);
                      return [4, this.oreId.auth.user.getData()];
                    case 2:
                      user = _a2.sent();
                      return [2, __assign(__assign({}, result), { user })];
                  }
                });
              });
            };
            this.buy = function(params) {
              return __awaiter(_this, void 0, void 0, function() {
                var result;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      if (!this.oreId.auth.accountName) {
                        throw new Error("user not logged in");
                      }
                      return [
                        4,
                        this.webWidgetCore.render({
                          name: oreidJs.WebWidgetAction.Buy,
                          params
                        })
                        // eslint-disable-next-line no-console
                      ];
                    case 1:
                      result = _a2.sent();
                      if (!result)
                        console.error("result was not returned.");
                      return [2, result];
                  }
                });
              });
            };
            this.sign = function(params) {
              return __awaiter(_this, void 0, void 0, function() {
                var isSigningTransaction, isSigningString, transaction, wasAutoSigned, widgetParams, _a2, transactionData, _b2, string, signMethod, otherParams, _c, signatures, apiResult, result;
                var _d;
                return __generator(this, function(_e) {
                  switch (_e.label) {
                    case 0:
                      isSigningTransaction = !!params.transaction;
                      isSigningString = !!params.signString;
                      if (!isSigningTransaction)
                        return [3, 2];
                      transaction = { transaction: params.transaction };
                      return [4, autoSign(transaction)];
                    case 1:
                      wasAutoSigned = _e.sent();
                      if (wasAutoSigned) {
                        return [2, wasAutoSigned];
                      }
                      _e.label = 2;
                    case 2:
                      widgetParams = {};
                      if (isSigningTransaction) {
                        _a2 = ((_d = params === null || params === void 0 ? void 0 : params.transaction) === null || _d === void 0 ? void 0 : _d.data) || {}, _a2.signedTransaction, transactionData = __rest(_a2, ["signedTransaction"]);
                        widgetParams = __assign({}, transactionData);
                      } else if (isSigningString) {
                        _b2 = (params === null || params === void 0 ? void 0 : params.signString) || {}, string = _b2.string, signMethod = _b2.signMethod, otherParams = __rest(_b2, ["string", "signMethod"]);
                        widgetParams = __assign({ stringToSign: string }, otherParams);
                        if (signMethod)
                          widgetParams.signStringMethod = signMethod;
                      } else {
                        throw new Error("signString or transaction must be provided");
                      }
                      return [4, this.webWidgetCore.render({
                        name: oreidJs.WebWidgetAction.Sign,
                        params: widgetParams
                      })];
                    case 3:
                      _c = _e.sent(), signatures = _c.signatures, apiResult = __rest(_c, ["signatures"]);
                      result = __assign({}, apiResult);
                      if (signatures)
                        result.signatures = JSON.parse(gBase64.decode(signatures));
                      return [2, result];
                  }
                });
              });
            };
            this.newChainAccount = function(params) {
              return __awaiter(_this, void 0, void 0, function() {
                var paramsDefault, result;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      if (!this.oreId.auth.accountName) {
                        throw new Error("user not logged in");
                      }
                      paramsDefault = __assign(__assign({}, params), { chainNetwork: params.chainNetwork || "", accountType: params.accountType || "native", account: this.oreId.auth.accountName });
                      return [4, this.webWidgetCore.render({
                        name: oreidJs.WebWidgetAction.NewChainAccount,
                        params: paramsDefault
                      })];
                    case 1:
                      result = _a2.sent();
                      if (!(result === null || result === void 0 ? void 0 : result.chainAccount)) {
                        throw new Error("chainAccount was not returned.");
                      }
                      return [4, this.oreId.auth.user.getData()];
                    case 2:
                      _a2.sent();
                      return [2, { chainAccount: result.chainAccount, chainNetwork: params.chainNetwork || "" }];
                  }
                });
              });
            };
            this.recoverAccount = function(params) {
              return __awaiter(_this, void 0, void 0, function() {
                var paramsWithAccount, result;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      paramsWithAccount = __assign(__assign({}, params), { account: this.oreId.auth.accountName });
                      return [4, this.webWidgetCore.render({
                        name: oreidJs.WebWidgetAction.RecoverAccount,
                        params: paramsWithAccount
                      })];
                    case 1:
                      result = _a2.sent();
                      return [2, result];
                  }
                });
              });
            };
            this.keyExport = function(params) {
              return __awaiter(_this, void 0, void 0, function() {
                var paramsWithAccount, result;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      paramsWithAccount = __assign(__assign({}, params), { account: this.oreId.auth.accountName, name: oreidJs.WebWidgetAction.KeyExport });
                      return [4, this.webWidgetCore.render({
                        name: oreidJs.WebWidgetAction.KeyExport,
                        params: paramsWithAccount
                      })];
                    case 1:
                      result = _a2.sent();
                      return [2, result];
                  }
                });
              });
            };
            if (((_b = oreId === null || oreId === void 0 ? void 0 : oreId.constructor) === null || _b === void 0 ? void 0 : _b.name) !== oreidJs.OreId.name) {
              throw new Error("oreId should be an instance of OreId");
            }
            if (!(webWidgetCore instanceof WebWidgetCoreHandler)) {
              throw new Error("webWidgetCore should be an instance of WebWidgetCoreHandler");
            }
            this.oreId = oreId;
            this.webWidgetCore = webWidgetCore;
          }
          return OreIdWebPopup2;
        }()
      );
      var initializeOreIdWebPopup = function(options) {
        return function(oreId) {
          return __awaiter(void 0, void 0, void 0, function() {
            var webWindow, random, containerId, iframeId, webWidgetCore;
            var _a;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (typeof window === "undefined") {
                    throw new Error("The window is required");
                  }
                  webWindow = window;
                  if (((_a = oreId === null || oreId === void 0 ? void 0 : oreId.constructor) === null || _a === void 0 ? void 0 : _a.name) !== oreidJs.OreId.name) {
                    throw new Error("oreId should be an instance of OreId");
                  }
                  random = Math.round(Math.random() * 1e5);
                  containerId = "webwidget-oreid-container-" + random;
                  iframeId = "webwidget-oreid-iframe-" + random;
                  return [4, createWebWidgetCoreHandler({ oreId, webWindow, containerId, iframeId })];
                case 1:
                  webWidgetCore = _b.sent();
                  return [2, new OreIdWebPopup({ oreId, webWidgetCore })];
              }
            });
          });
        };
      };
      var WebPopup = function(options) {
        return {
          init: initializeOreIdWebPopup(),
          type: oreidJs.PluginType.Popup,
          description: "OREID Web Popup"
        };
      };
      exports2.WebPopup = WebPopup;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});
export default require_dist2();
//# sourceMappingURL=oreid-webpopup.js.map
