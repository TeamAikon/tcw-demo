"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var eosjs_1 = require("eosjs");
var stateContainer_1 = require("./stateContainer");
var wallet_1 = require("./wallet");
var util_1 = require("./util");
var DEFAULT_CONTEXT_STATE = {
    wallets: []
};
function findProviderById(walletProviders, providerId) {
    if (!walletProviders.length)
        return void 0;
    return walletProviders.find(function (wp) { return wp.id === providerId; });
}
function initAccessContext(options) {
    var appName = options.appName, network = options.network, isNotEosNetwork = options.isNotEosNetwork;
    var _makeWalletProviderFns = options.walletProviders;
    var walletProviders = _makeWalletProviderFns.map(function (makeWalletProvider) { return makeWalletProvider(network); });
    var _stateContainer = stateContainer_1.makeStateContainer(DEFAULT_CONTEXT_STATE);
    var _listeners = [];
    function _handleUpdate() {
        for (var _i = 0, _listeners_1 = _listeners; _i < _listeners_1.length; _i++) {
            var listener = _listeners_1[_i];
            listener(ctx);
        }
    }
    var _walletUnsubscribeFns = new Map();
    var stateUnsubscribe = _stateContainer.subscribe(_handleUpdate);
    var eosRpc;
    if (!isNotEosNetwork) {
        var eosRpcUrl = util_1.getNetworkUrl(network);
        eosRpc = new eosjs_1.JsonRpc(eosRpcUrl);
    }
    var ctx = {
        appName: appName,
        eosRpc: eosRpc,
        network: network,
        initWallet: function (walletProvider) {
            var _walletProvider = typeof walletProvider === 'string' ? findProviderById(walletProviders, walletProvider) : walletProvider;
            if (!_walletProvider) {
                throw new Error("\n          Cannot initiate a session, invalid wallet provider\n          or wallet provider ID was passed\n        ");
            }
            var newWallet = wallet_1.initWallet(_walletProvider, ctx);
            _stateContainer.updateState(function (state) { return ({
                wallets: ((state && state.wallets) || []).concat([newWallet])
            }); });
            // Subscribe to a new wallet updates immediately
            _walletUnsubscribeFns.set(newWallet._instanceId, newWallet.subscribe(_handleUpdate));
            return newWallet;
        },
        addWalletProvider: function (walletProvider) {
            walletProviders.push(walletProvider(network));
        },
        getWalletProviders: function () {
            return walletProviders;
        },
        getWallets: function () {
            var state = _stateContainer.getState();
            if (!state)
                return [];
            return state.wallets || [];
        },
        getActiveWallets: function () {
            return ctx.getWallets().filter(function (wallet) { return wallet.connected && wallet.authenticated; });
        },
        detachWallet: function (wallet) {
            _stateContainer.updateState(function (state) { return ({
                wallets: ((state && state.wallets) || []).filter(function (w) { return w !== wallet; })
            }); });
            var _instanceId = wallet._instanceId;
            if (_walletUnsubscribeFns.has(_instanceId)) {
                var unsubscribe = _walletUnsubscribeFns.get(_instanceId);
                if (typeof unsubscribe === 'function')
                    unsubscribe();
            }
        },
        logoutAll: function () {
            return Promise.all(ctx.getWallets().map(function (wallet) { return wallet.logout(); })).then(function () { return true; });
        },
        disconnectAll: function () {
            return Promise.all(ctx.getWallets().map(function (wallet) { return wallet.disconnect(); })).then(function () { return true; });
        },
        terminateAll: function () {
            return Promise.all(ctx.getWallets().map(function (wallet) { return wallet.terminate(); })).then(function () { return true; });
        },
        destroy: function () {
            return ctx.terminateAll().then(function () {
                stateUnsubscribe();
                _walletUnsubscribeFns.forEach(function (unsubscribeFn) {
                    if (typeof unsubscribeFn === 'function')
                        unsubscribeFn();
                });
                _listeners = [];
            });
        },
        subscribe: function (listener) {
            _listeners = _listeners.concat([listener]);
            return function unsubscribe() {
                _listeners = _listeners.filter(function (l) { return l !== listener; });
            };
        }
    };
    return ctx;
}
exports.initAccessContext = initAccessContext;
//# sourceMappingURL=walletAccessContext.js.map