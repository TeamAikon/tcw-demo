"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var eosjs_1 = require("eosjs");
var v4_1 = __importDefault(require("uuid/v4"));
var stateContainer_1 = require("./stateContainer");
var util_1 = require("./util");
var DEFAULT_STATE = {
    connecting: false,
    connected: false,
    connectionError: false,
    connectionErrorMessage: void 0,
    auth: void 0,
    authenticating: false,
    authenticated: false,
    authenticationConfirmed: false,
    authenticationError: false,
    authenticationErrorMessage: void 0,
    accountInfo: void 0,
    accountFetching: false,
    accountFetchError: false,
    accountFetchErrorMessage: void 0
};
function initWallet(walletProvider, ctx) {
    var _instanceId = v4_1.default();
    var _stateContainer = stateContainer_1.makeStateContainer(__assign({}, DEFAULT_STATE));
    //let discoverData: DiscoveryData = { keyToAccountMap: [], keys: [] };
    var discoverData = { keyToAccountMap: [] };
    var counter = 0;
    var getState = _stateContainer.getState;
    var eosApi = new eosjs_1.Api({
        // Api() constructor requires a JsonRpc - even if we dont want one for non-eos, so create empty JsonRpc here
        rpc: ctx.eosRpc ? ctx.eosRpc : new eosjs_1.JsonRpc(''),
        chainId: ctx.network.chainId,
        signatureProvider: walletProvider.signatureProvider
    });
    // Account helpers
    function fetchAccountInfo(accountName) {
        if (!accountName) {
            return Promise.reject('No `accountName` was passed in order to fetch the account info');
        }
        _stateContainer.updateState(function (state) { return (__assign({}, state, { accountFetching: true, accountFetchError: false, accountFetchErrorMessage: void 0 })); });
        // NonEOS Support: if ctx.eosRpc is undefined,
        // return AccountInfo with just accountName
        if (!ctx.eosRpc) {
            var accountInfo_1 = { name: accountName };
            _stateContainer.updateState(function (state) { return (__assign({}, state, { accountFetching: false, accountInfo: accountInfo_1 })); });
            return Promise.resolve(accountInfo_1);
        }
        return ctx.eosRpc
            .get_account(accountName)
            .then(function (accountData) {
            var accountInfo = __assign({}, accountData);
            _stateContainer.updateState(function (state) { return (__assign({}, state, { accountFetching: false, accountInfo: accountInfo })); });
            return accountInfo;
        })
            .catch(function (error) {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { accountFetching: false, accountInfo: void 0, accountFetchError: true, accountFetchErrorMessage: util_1.getErrorMessage(error) })); });
            return Promise.reject(error);
        });
    }
    // Connection
    function connect() {
        _stateContainer.updateState(function (state) { return (__assign({}, state, { connected: false, connecting: true, connectionError: false, connectionErrorMessage: void 0 })); });
        return walletProvider
            .connect(ctx.appName)
            .then(function () {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { connecting: false, connected: true })); });
            return true;
        })
            .catch(function (error) {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { connecting: false, connectionError: true, connectionErrorMessage: util_1.getErrorMessage(error) })); });
            return Promise.reject(error);
        });
    }
    function discover(discoveryOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var accountsDataObjToMerge, discoverResult;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        accountsDataObjToMerge = { keyToAccountMap: [] };
                        return [4 /*yield*/, walletProvider.discover(discoveryOptions).then(function (walletDiscoveryData) { return __awaiter(_this, void 0, void 0, function () {
                                var modifiedData, promises, _loop_1, _i, _a, keyData;
                                var _this = this;
                                return __generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0:
                                            console.log('walletDiscoveryData');
                                            console.log(walletDiscoveryData);
                                            //Merge any properties that were returned from the wallets specific discovery process. This allows the wallet to add custom properties to the response if needed.
                                            accountsDataObjToMerge = __assign({}, accountsDataObjToMerge, walletDiscoveryData);
                                            delete accountsDataObjToMerge.keys;
                                            // let keys: string[] = []; // If the discover fuction in the wallet doesn't return any keys we know the login function is going to have to prompt the user to select one.
                                            // if (walletDiscoveryData.keys) {
                                            // 	keys = walletDiscoveryData.keys;
                                            // }
                                            // A callback of this kind can be supplied to the discover function, which will allow the caller to modify the list of keys before the account lookup process happens. 
                                            // The feature was added so that key returned from the Ledger device can be modified to have a ENU prefix when in use with the the enumivo chain 
                                            if (discoveryOptions.keyModifierFunc !== undefined) {
                                                modifiedData = discoveryOptions.keyModifierFunc(walletDiscoveryData);
                                                walletDiscoveryData = modifiedData;
                                            }
                                            if (!(discoveryOptions.keyLookupFunc !== undefined)) return [3 /*break*/, 1];
                                            // discoveryOptions.keyLookupFunc(walletDiscoveryData);
                                            discoveryOptions.keyLookupFunc(walletDiscoveryData, function (discoveredAccounts) {
                                                accountsDataObjToMerge.keyToAccountMap = discoveredAccounts;
                                                console.log('accountsDataObjToMerge(keyLookupFunc)');
                                                console.log({ accountsDataObjToMerge: accountsDataObjToMerge });
                                                return Promise.resolve({ accountsDataObjToMerge: accountsDataObjToMerge });
                                            });
                                            return [3 /*break*/, 3];
                                        case 1:
                                            promises = [];
                                            _loop_1 = function (keyData) {
                                                var key = keyData.key;
                                                var keyIndex = keyData.index;
                                                var cached = false;
                                                if (discoverData.keyToAccountMap) {
                                                    var foundInCache = discoverData.keyToAccountMap.findIndex(function (y) { return y.index == keyIndex; });
                                                    if (foundInCache > -1)
                                                        cached = true;
                                                }
                                                if (key && !cached && ctx.eosRpc) {
                                                    var p = ctx.eosRpc.history_get_key_accounts(key).then(function (accountData) { return __awaiter(_this, void 0, void 0, function () {
                                                        var accountEntry, _loop_2, _i, _a, account;
                                                        var _this = this;
                                                        return __generator(this, function (_b) {
                                                            switch (_b.label) {
                                                                case 0:
                                                                    accountEntry = {
                                                                        index: keyIndex,
                                                                        key: key,
                                                                        accounts: []
                                                                    };
                                                                    if (!(accountData.account_names.length > 0)) return [3 /*break*/, 4];
                                                                    _loop_2 = function (account) {
                                                                        return __generator(this, function (_a) {
                                                                            switch (_a.label) {
                                                                                case 0: return [4 /*yield*/, ctx.eosRpc.get_account(account).then(function (accountInfo) { return __awaiter(_this, void 0, void 0, function () {
                                                                                        var _i, _a, permission, _b, _c, permissionKey;
                                                                                        return __generator(this, function (_d) {
                                                                                            for (_i = 0, _a = accountInfo.permissions; _i < _a.length; _i++) {
                                                                                                permission = _a[_i];
                                                                                                for (_b = 0, _c = permission.required_auth.keys; _b < _c.length; _b++) {
                                                                                                    permissionKey = _c[_b];
                                                                                                    if (permissionKey.key == key) {
                                                                                                        accountEntry.accounts.push({
                                                                                                            account: account,
                                                                                                            authorization: permission.perm_name
                                                                                                        });
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            return [2 /*return*/];
                                                                                        });
                                                                                    }); })];
                                                                                case 1:
                                                                                    _a.sent();
                                                                                    return [2 /*return*/];
                                                                            }
                                                                        });
                                                                    };
                                                                    _i = 0, _a = accountData.account_names;
                                                                    _b.label = 1;
                                                                case 1:
                                                                    if (!(_i < _a.length)) return [3 /*break*/, 4];
                                                                    account = _a[_i];
                                                                    return [5 /*yield**/, _loop_2(account)];
                                                                case 2:
                                                                    _b.sent();
                                                                    _b.label = 3;
                                                                case 3:
                                                                    _i++;
                                                                    return [3 /*break*/, 1];
                                                                case 4: return [2 /*return*/, accountEntry];
                                                            }
                                                        });
                                                    }); });
                                                    promises.push(p);
                                                }
                                            };
                                            for (_i = 0, _a = walletDiscoveryData.keys; _i < _a.length; _i++) {
                                                keyData = _a[_i];
                                                _loop_1(keyData);
                                            }
                                            return [4 /*yield*/, Promise.all(promises).then(function (results) {
                                                    accountsDataObjToMerge.keyToAccountMap = results || [];
                                                    console.log('accountsDataObjToMerge');
                                                    console.log({ accountsDataObjToMerge: accountsDataObjToMerge });
                                                    return Promise.resolve({ accountsDataObjToMerge: accountsDataObjToMerge });
                                                })];
                                        case 2:
                                            _b.sent();
                                            _b.label = 3;
                                        case 3: return [2 /*return*/];
                                    }
                                });
                            }); })];
                    case 1:
                        discoverResult = _a.sent();
                        counter++;
                        if (discoverData.keyToAccountMap.length == 0) {
                            discoverData = __assign({}, discoverData, accountsDataObjToMerge);
                        }
                        else {
                            accountsDataObjToMerge.keyToAccountMap.forEach(function (newKey) {
                                discoverData.keyToAccountMap.push(newKey);
                                // discoverData.keys = accountsDataObjToMerge.keys;
                            });
                        }
                        // console.log(discoverData);
                        return [2 /*return*/, Promise.resolve(discoverData)];
                }
            });
        });
    }
    function disconnect() {
        return walletProvider.disconnect().then(function () {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { connecting: false, connected: false, connectionError: false, connectionErrorMessage: void 0 })); });
            return true;
        });
    }
    // Authentication
    function login(accountName, authorization) {
        _stateContainer.updateState(function (state) { return (__assign({}, state, { accountInfo: void 0, authenticated: false, authenticationConfirmed: false, authenticating: true, authenticationError: false, authenticationErrorMessage: void 0 })); });
        var index = -1;
        var key = undefined;
        //If we've done discovery then we should be able to find the account trying to login in the discoverData
        if (discoverData.keyToAccountMap.length > 0) {
            // console.log('see if we can find ' + accountName + ' ' + authorization);
            if (accountName && authorization) {
                discoverData.keyToAccountMap.forEach(function (indexObj) {
                    var found = indexObj.accounts.find(function (account) {
                        return account.account == accountName && account.authorization == authorization;
                    });
                    if (found) {
                        index = indexObj.index;
                        key = indexObj.key;
                    }
                });
            }
            if (!key) {
                throw 'Loging was not able to determine the Key and Index for ' + authorization + '@' + accountName;
            }
        }
        return walletProvider
            .login(accountName, authorization, index, key)
            .then(function (walletAuth) {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { auth: walletAuth, authenticated: true, authenticating: false })); });
            return fetchAccountInfo(walletAuth.accountName);
        })
            .then(function (accountInfo) {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { accountInfo: accountInfo })); });
            return accountInfo;
        })
            .catch(function (error) {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { authenticating: false, authenticationError: true, authenticationErrorMessage: util_1.getErrorMessage(error) })); });
            return Promise.reject(error);
        });
    }
    function logout() {
        return walletProvider.logout().then(function () {
            _stateContainer.updateState(function (state) { return (__assign({}, state, { accountInfo: void 0, authenticating: false, authenticated: false, authenticationError: false, authenticationErrorMessage: void 0 })); });
            return true;
        });
    }
    function signArbitrary(data, userMessage, metadata) {
        return walletProvider.signArbitrary(data, userMessage, metadata);
    }
    var wallet = {
        _instanceId: _instanceId,
        ctx: ctx,
        provider: walletProvider,
        eosApi: eosApi,
        get state() {
            return getState() || __assign({}, DEFAULT_STATE);
        },
        // Shortcut state accessors
        get auth() {
            var state = getState();
            return (state && state.auth) || void 0;
        },
        get accountInfo() {
            var state = getState();
            return (state && state.accountInfo) || void 0;
        },
        get connected() {
            var state = getState();
            return (state && state.connected) || false;
        },
        get authenticated() {
            var state = getState();
            return (state && state.authenticated) || false;
        },
        get inProgress() {
            var state = getState();
            if (!state)
                return false;
            var connecting = state.connecting, authenticating = state.authenticating, accountFetching = state.accountFetching;
            return !!(connecting || authenticating || accountFetching);
        },
        get active() {
            var state = getState();
            if (!state)
                return false;
            var connected = state.connected, authenticated = state.authenticated, accountInfo = state.accountInfo;
            return !!(connected && authenticated && accountInfo);
        },
        get hasError() {
            var state = getState();
            if (!state)
                return false;
            var connectionError = state.connectionError, authenticationError = state.authenticationError, accountFetchError = state.accountFetchError;
            return !!(connectionError || authenticationError || accountFetchError);
        },
        get errorMessage() {
            var state = getState();
            if (!state)
                return void 0;
            if (!wallet.hasError)
                return void 0;
            var connectionErrorMessage = state.connectionErrorMessage, authenticationErrorMessage = state.authenticationErrorMessage, accountFetchErrorMessage = state.accountFetchErrorMessage;
            return (connectionErrorMessage ||
                authenticationErrorMessage ||
                accountFetchErrorMessage ||
                'Wallet connection error');
        },
        connect: connect,
        discover: discover,
        disconnect: disconnect,
        login: login,
        logout: logout,
        fetchAccountInfo: fetchAccountInfo,
        terminate: function () {
            return logout().then(disconnect).then(function () {
                ctx.detachWallet(wallet);
                return true;
            });
        },
        subscribe: function (listener) {
            return _stateContainer.subscribe(listener);
        },
        signArbitrary: signArbitrary
    };
    return wallet;
}
exports.initWallet = initWallet;
//# sourceMappingURL=wallet.js.map