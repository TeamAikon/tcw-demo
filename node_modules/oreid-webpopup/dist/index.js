(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('oreid-js')) :
  typeof define === 'function' && define.amd ? define(['exports', 'oreid-js'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.oreidJsWebPopup = {}, global.oreidJs));
})(this, (function (exports, oreidJs) { 'use strict';

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
  };

  function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
  }

  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }

  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
  }

  typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };

  /**
   *  base64.ts
   *
   *  Licensed under the BSD 3-Clause License.
   *    http://opensource.org/licenses/BSD-3-Clause
   *
   *  References:
   *    http://en.wikipedia.org/wiki/Base64
   *
   * @author Dan Kogai (https://github.com/dankogai)
   */
  const version = '3.7.5';
  /**
   * @deprecated use lowercase `version`.
   */
  const VERSION = version;
  const _hasatob = typeof atob === 'function';
  const _hasbtoa = typeof btoa === 'function';
  const _hasBuffer = typeof Buffer === 'function';
  const _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
  const _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
  const b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  const b64chs = Array.prototype.slice.call(b64ch);
  const b64tab = ((a) => {
      let tab = {};
      a.forEach((c, i) => tab[c] = i);
      return tab;
  })(b64chs);
  const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
  const _fromCC = String.fromCharCode.bind(String);
  const _U8Afrom = typeof Uint8Array.from === 'function'
      ? Uint8Array.from.bind(Uint8Array)
      : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
  const _mkUriSafe = (src) => src
      .replace(/=/g, '').replace(/[+\/]/g, (m0) => m0 == '+' ? '-' : '_');
  const _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, '');
  /**
   * polyfill version of `btoa`
   */
  const btoaPolyfill = (bin) => {
      // console.log('polyfilled');
      let u32, c0, c1, c2, asc = '';
      const pad = bin.length % 3;
      for (let i = 0; i < bin.length;) {
          if ((c0 = bin.charCodeAt(i++)) > 255 ||
              (c1 = bin.charCodeAt(i++)) > 255 ||
              (c2 = bin.charCodeAt(i++)) > 255)
              throw new TypeError('invalid character found');
          u32 = (c0 << 16) | (c1 << 8) | c2;
          asc += b64chs[u32 >> 18 & 63]
              + b64chs[u32 >> 12 & 63]
              + b64chs[u32 >> 6 & 63]
              + b64chs[u32 & 63];
      }
      return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
  };
  /**
   * does what `window.btoa` of web browsers do.
   * @param {String} bin binary string
   * @returns {string} Base64-encoded string
   */
  const _btoa = _hasbtoa ? (bin) => btoa(bin)
      : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')
          : btoaPolyfill;
  const _fromUint8Array = _hasBuffer
      ? (u8a) => Buffer.from(u8a).toString('base64')
      : (u8a) => {
          // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
          const maxargs = 0x1000;
          let strs = [];
          for (let i = 0, l = u8a.length; i < l; i += maxargs) {
              strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
          }
          return _btoa(strs.join(''));
      };
  /**
   * converts a Uint8Array to a Base64 string.
   * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 ยง5
   * @returns {string} Base64 string
   */
  const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
  // This trick is found broken https://github.com/dankogai/js-base64/issues/130
  // const utob = (src: string) => unescape(encodeURIComponent(src));
  // reverting good old fationed regexp
  const cb_utob = (c) => {
      if (c.length < 2) {
          var cc = c.charCodeAt(0);
          return cc < 0x80 ? c
              : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))
                  + _fromCC(0x80 | (cc & 0x3f)))
                  : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))
                      + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                      + _fromCC(0x80 | (cc & 0x3f)));
      }
      else {
          var cc = 0x10000
              + (c.charCodeAt(0) - 0xD800) * 0x400
              + (c.charCodeAt(1) - 0xDC00);
          return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))
              + _fromCC(0x80 | ((cc >>> 12) & 0x3f))
              + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
              + _fromCC(0x80 | (cc & 0x3f)));
      }
  };
  const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
  /**
   * @deprecated should have been internal use only.
   * @param {string} src UTF-8 string
   * @returns {string} UTF-16 string
   */
  const utob = (u) => u.replace(re_utob, cb_utob);
  //
  const _encode = _hasBuffer
      ? (s) => Buffer.from(s, 'utf8').toString('base64')
      : _TE
          ? (s) => _fromUint8Array(_TE.encode(s))
          : (s) => _btoa(utob(s));
  /**
   * converts a UTF-8-encoded string to a Base64 string.
   * @param {boolean} [urlsafe] if `true` make the result URL-safe
   * @returns {string} Base64 string
   */
  const encode = (src, urlsafe = false) => urlsafe
      ? _mkUriSafe(_encode(src))
      : _encode(src);
  /**
   * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 ยง5.
   * @returns {string} Base64 string
   */
  const encodeURI = (src) => encode(src, true);
  // This trick is found broken https://github.com/dankogai/js-base64/issues/130
  // const btou = (src: string) => decodeURIComponent(escape(src));
  // reverting good old fationed regexp
  const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
  const cb_btou = (cccc) => {
      switch (cccc.length) {
          case 4:
              var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                  | ((0x3f & cccc.charCodeAt(1)) << 12)
                  | ((0x3f & cccc.charCodeAt(2)) << 6)
                  | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;
              return (_fromCC((offset >>> 10) + 0xD800)
                  + _fromCC((offset & 0x3FF) + 0xDC00));
          case 3:
              return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)
                  | ((0x3f & cccc.charCodeAt(1)) << 6)
                  | (0x3f & cccc.charCodeAt(2)));
          default:
              return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)
                  | (0x3f & cccc.charCodeAt(1)));
      }
  };
  /**
   * @deprecated should have been internal use only.
   * @param {string} src UTF-16 string
   * @returns {string} UTF-8 string
   */
  const btou = (b) => b.replace(re_btou, cb_btou);
  /**
   * polyfill version of `atob`
   */
  const atobPolyfill = (asc) => {
      // console.log('polyfilled');
      asc = asc.replace(/\s+/g, '');
      if (!b64re.test(asc))
          throw new TypeError('malformed base64.');
      asc += '=='.slice(2 - (asc.length & 3));
      let u24, bin = '', r1, r2;
      for (let i = 0; i < asc.length;) {
          u24 = b64tab[asc.charAt(i++)] << 18
              | b64tab[asc.charAt(i++)] << 12
              | (r1 = b64tab[asc.charAt(i++)]) << 6
              | (r2 = b64tab[asc.charAt(i++)]);
          bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)
              : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)
                  : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
      }
      return bin;
  };
  /**
   * does what `window.atob` of web browsers do.
   * @param {String} asc Base64-encoded string
   * @returns {string} binary string
   */
  const _atob = _hasatob ? (asc) => atob(_tidyB64(asc))
      : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')
          : atobPolyfill;
  //
  const _toUint8Array = _hasBuffer
      ? (a) => _U8Afrom(Buffer.from(a, 'base64'))
      : (a) => _U8Afrom(_atob(a).split('').map(c => c.charCodeAt(0)));
  /**
   * converts a Base64 string to a Uint8Array.
   */
  const toUint8Array = (a) => _toUint8Array(_unURI(a));
  //
  const _decode = _hasBuffer
      ? (a) => Buffer.from(a, 'base64').toString('utf8')
      : _TD
          ? (a) => _TD.decode(_toUint8Array(a))
          : (a) => btou(_atob(a));
  const _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));
  /**
   * converts a Base64 string to a UTF-8 string.
   * @param {String} src Base64 string.  Both normal and URL-safe are supported
   * @returns {string} UTF-8 string
   */
  const decode = (src) => _decode(_unURI(src));
  /**
   * check if a value is a valid Base64 string
   * @param {String} src a value to check
    */
  const isValid = (src) => {
      if (typeof src !== 'string')
          return false;
      const s = src.replace(/\s+/g, '').replace(/={0,2}$/, '');
      return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
  };
  //
  const _noEnum = (v) => {
      return {
          value: v, enumerable: false, writable: true, configurable: true
      };
  };
  /**
   * extend String.prototype with relevant methods
   */
  const extendString = function () {
      const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
      _add('fromBase64', function () { return decode(this); });
      _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });
      _add('toBase64URI', function () { return encode(this, true); });
      _add('toBase64URL', function () { return encode(this, true); });
      _add('toUint8Array', function () { return toUint8Array(this); });
  };
  /**
   * extend Uint8Array.prototype with relevant methods
   */
  const extendUint8Array = function () {
      const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
      _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });
      _add('toBase64URI', function () { return fromUint8Array(this, true); });
      _add('toBase64URL', function () { return fromUint8Array(this, true); });
  };
  /**
   * extend Builtin prototypes with relevant methods
   */
  const extendBuiltins = () => {
      extendString();
      extendUint8Array();
  };
  const gBase64 = {
      version: version,
      VERSION: VERSION,
      atob: _atob,
      atobPolyfill: atobPolyfill,
      btoa: _btoa,
      btoaPolyfill: btoaPolyfill,
      fromBase64: decode,
      toBase64: encode,
      encode: encode,
      encodeURI: encodeURI,
      encodeURL: encodeURI,
      utob: utob,
      btou: btou,
      decode: decode,
      isValid: isValid,
      fromUint8Array: fromUint8Array,
      toUint8Array: toUint8Array,
      extendString: extendString,
      extendUint8Array: extendUint8Array,
      extendBuiltins: extendBuiltins,
  };

  var getOreIdOptions = function (oreId) {
      var oreIdOptions = __assign({}, oreId.options);
      oreIdOptions.accessToken = oreId.accessToken;
      oreIdOptions.idToken = oreId.auth.idToken;
      delete oreIdOptions.apiKey; // remove apiKey for securoty reasons
      delete oreIdOptions.setBusyCallback; // remove functions, pass data field values only
      return oreIdOptions;
  };

  var WebWidgetCoreHandler = /** @class */ (function () {
      function WebWidgetCoreHandler(_a) {
          var _this = this;
          var oreId = _a.oreId, webWidget = _a.webWidget, container = _a.container;
          this.willCloseListener = function (event) {
              var _a;
              var oreIdUrl = getOreIdOptions(_this.oreId).oreIdUrl;
              // emitted by oreid-service
              if (event.origin === oreIdUrl && event.data && event.data === ((_a = _this.webWidget) === null || _a === void 0 ? void 0 : _a.closeMessage)) {
                  _this.willClose = true;
              }
          };
          // invoked to clear state at onClose event
          this.close = function () {
              _this.isBusy = false;
              _this.container.hide();
              _this.webWidget.closeWebWidget(_this.container.window, !_this.willClose);
              _this.container.window.removeEventListener('message', _this.willCloseListener);
              _this.willClose = false;
          };
          this.oreId = oreId;
          this.webWidget = webWidget;
          this.container = container;
          this.isBusy = false;
          this.willClose = false;
      }
      WebWidgetCoreHandler.prototype.open = function () {
          this.container.window.addEventListener('message', this.willCloseListener);
          var windowType = this.webWidget.getWindowTypeForProps(this._widgetProps);
          this.container.show(windowType === this.webWidget.WindowType.Iframe);
      };
      WebWidgetCoreHandler.prototype.getWebWidgetCoreProps = function (webWidgetActionProps) {
          return __awaiter(this, void 0, void 0, function () {
              var _a;
              return __generator(this, function (_b) {
                  switch (_b.label) {
                      case 0:
                          _a = this;
                          return [4 /*yield*/, this.oreId.appendTimestampAndSignatureToWidgetProps({
                                  action: webWidgetActionProps.action,
                                  onError: webWidgetActionProps.onError,
                                  onSuccess: webWidgetActionProps.onSuccess,
                                  oreIdOptions: getOreIdOptions(this.oreId),
                                  origin: this.container.window.location.origin,
                              })];
                      case 1:
                          _a._widgetProps = _b.sent();
                          this._widgetProps.onClose = this.close;
                          return [2 /*return*/, this._widgetProps];
                  }
              });
          });
      };
      WebWidgetCoreHandler.prototype.render = function (webWidgetActionProps) {
          return __awaiter(this, void 0, void 0, function () {
              var _this = this;
              return __generator(this, function (_a) {
                  if (this.isBusy)
                      throw new Error('WebWidget is busy. Wait for it to finish');
                  this.isBusy = true;
                  return [2 /*return*/, new Promise(function (resolve, reject) {
                          var onError = function (reason) {
                              _this.isBusy = false;
                              // eslint-disable-next-line no-console
                              console.debug('WebWidget Results (Error): ', reason); // This console.log is deliberate to provide developer diagnostic info
                              reject(reason);
                          };
                          var onSuccess = function (value) {
                              _this.isBusy = false;
                              var response = __assign({}, value.data);
                              // redact oAuth tokens
                              if (response.accessToken) {
                                  response.accessToken = response.accessToken.slice(0, 2) + "...";
                              }
                              if (response.idToken) {
                                  response.idToken = response.idToken.slice(0, 2) + "...";
                              }
                              // eslint-disable-next-line no-console
                              console.debug('WebWidget Results (Success): ', response); // This console.log is deliberate to provide developer diagnostic info
                              resolve(value === null || value === void 0 ? void 0 : value.data);
                          };
                          _this.getWebWidgetCoreProps({
                              action: webWidgetActionProps,
                              onSuccess: onSuccess,
                              onError: onError,
                          })
                              .then(function (webWidgetCoreProps) {
                              _this.isBusy = false;
                              _this.open();
                              _this.webWidget.renderWebWidget(webWidgetCoreProps, _this.container.iframeSelector);
                          })
                              .catch(onError);
                      })];
              });
          });
      };
      return WebWidgetCoreHandler;
  }());

  function assign(obj, props) {
      for (const key in props) {
          Object.defineProperty(obj, key, {
              value: props[key],
              enumerable: true,
              configurable: true,
          });
      }

      return obj;
  }

  function createError(err, code, props) {
      if (!err || typeof err === 'string') {
          throw new TypeError('Please pass an Error to err-code');
      }

      if (!props) {
          props = {};
      }

      if (typeof code === 'object') {
          props = code;
          code = undefined;
      }

      if (code != null) {
          props.code = code;
      }

      try {
          return assign(err, props);
      } catch (_) {
          props.message = err.message;
          props.stack = err.stack;

          const ErrClass = function () {};

          ErrClass.prototype = Object.create(Object.getPrototypeOf(err));

          return assign(new ErrClass(), props);
      }
  }

  var errCode = createError;

  var retry$2 = {};

  function RetryOperation(timeouts, options) {
    // Compatibility for the old (timeouts, retryForever) signature
    if (typeof options === 'boolean') {
      options = { forever: options };
    }

    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options || {};
    this._maxRetryTime = options && options.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;

    if (this._options.forever) {
      this._cachedTimeouts = this._timeouts.slice(0);
    }
  }
  var retry_operation = RetryOperation;

  RetryOperation.prototype.reset = function() {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts;
  };

  RetryOperation.prototype.stop = function() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }

    this._timeouts       = [];
    this._cachedTimeouts = null;
  };

  RetryOperation.prototype.retry = function(err) {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }

    if (!err) {
      return false;
    }
    var currentTime = new Date().getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
      this._errors.unshift(new Error('RetryOperation timeout occurred'));
      return false;
    }

    this._errors.push(err);

    var timeout = this._timeouts.shift();
    if (timeout === undefined) {
      if (this._cachedTimeouts) {
        // retry forever, only keep last error
        this._errors.splice(this._errors.length - 1, this._errors.length);
        this._timeouts = this._cachedTimeouts.slice(0);
        timeout = this._timeouts.shift();
      } else {
        return false;
      }
    }

    var self = this;
    var timer = setTimeout(function() {
      self._attempts++;

      if (self._operationTimeoutCb) {
        self._timeout = setTimeout(function() {
          self._operationTimeoutCb(self._attempts);
        }, self._operationTimeout);

        if (self._options.unref) {
            self._timeout.unref();
        }
      }

      self._fn(self._attempts);
    }, timeout);

    if (this._options.unref) {
        timer.unref();
    }

    return true;
  };

  RetryOperation.prototype.attempt = function(fn, timeoutOps) {
    this._fn = fn;

    if (timeoutOps) {
      if (timeoutOps.timeout) {
        this._operationTimeout = timeoutOps.timeout;
      }
      if (timeoutOps.cb) {
        this._operationTimeoutCb = timeoutOps.cb;
      }
    }

    var self = this;
    if (this._operationTimeoutCb) {
      this._timeout = setTimeout(function() {
        self._operationTimeoutCb();
      }, self._operationTimeout);
    }

    this._operationStart = new Date().getTime();

    this._fn(this._attempts);
  };

  RetryOperation.prototype.try = function(fn) {
    console.log('Using RetryOperation.try() is deprecated');
    this.attempt(fn);
  };

  RetryOperation.prototype.start = function(fn) {
    console.log('Using RetryOperation.start() is deprecated');
    this.attempt(fn);
  };

  RetryOperation.prototype.start = RetryOperation.prototype.try;

  RetryOperation.prototype.errors = function() {
    return this._errors;
  };

  RetryOperation.prototype.attempts = function() {
    return this._attempts;
  };

  RetryOperation.prototype.mainError = function() {
    if (this._errors.length === 0) {
      return null;
    }

    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;

    for (var i = 0; i < this._errors.length; i++) {
      var error = this._errors[i];
      var message = error.message;
      var count = (counts[message] || 0) + 1;

      counts[message] = count;

      if (count >= mainErrorCount) {
        mainError = error;
        mainErrorCount = count;
      }
    }

    return mainError;
  };

  (function (exports) {
  var RetryOperation = retry_operation;

  exports.operation = function(options) {
    var timeouts = exports.timeouts(options);
    return new RetryOperation(timeouts, {
        forever: options && options.forever,
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
    });
  };

  exports.timeouts = function(options) {
    if (options instanceof Array) {
      return [].concat(options);
    }

    var opts = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1000,
      maxTimeout: Infinity,
      randomize: false
    };
    for (var key in options) {
      opts[key] = options[key];
    }

    if (opts.minTimeout > opts.maxTimeout) {
      throw new Error('minTimeout is greater than maxTimeout');
    }

    var timeouts = [];
    for (var i = 0; i < opts.retries; i++) {
      timeouts.push(this.createTimeout(i, opts));
    }

    if (options && options.forever && !timeouts.length) {
      timeouts.push(this.createTimeout(i, opts));
    }

    // sort the array numerically ascending
    timeouts.sort(function(a,b) {
      return a - b;
    });

    return timeouts;
  };

  exports.createTimeout = function(attempt, opts) {
    var random = (opts.randomize)
      ? (Math.random() + 1)
      : 1;

    var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
    timeout = Math.min(timeout, opts.maxTimeout);

    return timeout;
  };

  exports.wrap = function(obj, options, methods) {
    if (options instanceof Array) {
      methods = options;
      options = null;
    }

    if (!methods) {
      methods = [];
      for (var key in obj) {
        if (typeof obj[key] === 'function') {
          methods.push(key);
        }
      }
    }

    for (var i = 0; i < methods.length; i++) {
      var method   = methods[i];
      var original = obj[method];

      obj[method] = function retryWrapper(original) {
        var op       = exports.operation(options);
        var args     = Array.prototype.slice.call(arguments, 1);
        var callback = args.pop();

        args.push(function(err) {
          if (op.retry(err)) {
            return;
          }
          if (err) {
            arguments[0] = op.mainError();
          }
          callback.apply(this, arguments);
        });

        op.attempt(function() {
          original.apply(obj, args);
        });
      }.bind(obj, original);
      obj[method].options = options;
    }
  };
  }(retry$2));

  var retry$1 = retry$2;

  var errcode = errCode;
  var retry = retry$1;

  var hasOwn = Object.prototype.hasOwnProperty;

  function isRetryError(err) {
      return err && err.code === 'EPROMISERETRY' && hasOwn.call(err, 'retried');
  }

  function promiseRetry(fn, options) {
      var temp;
      var operation;

      if (typeof fn === 'object' && typeof options === 'function') {
          // Swap options and fn when using alternate signature (options, fn)
          temp = options;
          options = fn;
          fn = temp;
      }

      operation = retry.operation(options);

      return new Promise(function (resolve, reject) {
          operation.attempt(function (number) {
              Promise.resolve()
              .then(function () {
                  return fn(function (err) {
                      if (isRetryError(err)) {
                          err = err.retried;
                      }

                      throw errcode(new Error('Retrying'), 'EPROMISERETRY', { retried: err });
                  }, number);
              })
              .then(resolve, function (err) {
                  if (isRetryError(err)) {
                      err = err.retried;

                      if (operation.retry(err || new Error())) {
                          return;
                      }
                  }

                  reject(err);
              });
          });
      });
  }

  var promiseRetry_1 = promiseRetry;

  /* eslint-disable no-param-reassign */
  var addContainerStyle = function (container) {
      container.style.position = 'fixed';
      // container.style.display = "flex";
      container.style.flexDirection = 'column';
      container.style.display = 'none';
      container.style.backgroundColor = 'rgba(0,0,0,0.3)';
      container.style.height = '100vh';
      container.style.width = '100vw';
      container.style.top = '0';
      container.style.left = '0px';
      container.style.justifyContent = 'center';
      container.style.zIndex = '999999999';
  };

  /* eslint-disable no-param-reassign */
  var addIframeContainerStyle = function (container) {
      container.style.backgroundColor = '#fafafa';
      container.style.borderRadius = '8px';
      container.style.maxHeight = '740px';
      container.style.maxWidth = '420px';
      container.style.boxShadow = '0px 10px 13px -7px #000000, 5px 5px 15px 5px rgba(0,0,0,0)';
      container.style.position = 'relative';
      container.style.alignSelf = 'center';
      container.style.overflow = 'hidden';
  };

  /* eslint-disable no-param-reassign */
  var addCloseBtnStyle = function (container) {
      container.style.display = 'none';
      container.style.backgroundColor = 'white';
      container.style.borderRadius = '50%';
      container.style.border = '0';
      container.style.height = '33px';
      container.style.width = '33px';
      container.style.cursor = 'pointer';
      container.style.alignSelf = 'center';
      container.style.marginBottom = '10px';
  };

  var createHtmlContainer = function (_a) {
      var _b;
      var webWindow = _a.webWindow, containerId = _a.containerId, closeBtnId = _a.closeBtnId, iframeId = _a.iframeId, webWidget = _a.webWidget, hideContainer = _a.hideContainer;
      if (webWindow.document.getElementById(containerId))
          throw new Error("This element \"" + containerId + "\" is already present in the document");
      if (webWindow.document.getElementById(iframeId))
          throw new Error("This element \"" + iframeId + "\" is already present in the document");
      if (webWindow.document.getElementById(closeBtnId))
          throw new Error("This element \"" + closeBtnId + "\" is already present in the document");
      var container = webWindow.document.createElement('div');
      container.id = containerId;
      addContainerStyle(container);
      var closeBtn = webWindow.document.createElement('button');
      closeBtn.id = closeBtnId;
      closeBtn.textContent = 'โ';
      addCloseBtnStyle(closeBtn);
      closeBtn.onclick = function (event) {
          var _a, _b;
          event.preventDefault();
          event.stopPropagation();
          (_b = (_a = webWidget.webWidgetCoreProps) === null || _a === void 0 ? void 0 : _a.onClose) === null || _b === void 0 ? void 0 : _b.call(_a);
          hideContainer();
      };
      var iframeContainer = webWindow.document.createElement('div');
      iframeContainer.id = iframeId;
      addIframeContainerStyle(iframeContainer);
      var onClick = function (event) {
          var _a;
          if (((_a = webWidget.webWidgetCoreProps) === null || _a === void 0 ? void 0 : _a.windowType) === webWidget.WindowType.Popup) {
              event.preventDefault();
              event.stopPropagation();
              webWidget.focusWebWidget(webWindow);
          }
      };
      iframeContainer.onclick = onClick;
      container.onclick = onClick;
      container.appendChild(closeBtn);
      container.appendChild(iframeContainer);
      (_b = webWindow.document.querySelector('body')) === null || _b === void 0 ? void 0 : _b.appendChild(container);
  };

  var getElementById = function (_a) {
      var webWindow = _a.webWindow, elementId = _a.elementId;
      var element = webWindow.document.getElementById(elementId);
      if (!element) {
          throw new Error("This elementId \"" + elementId + "\" is not present in the document");
      }
      return element;
  };

  var Container = /** @class */ (function () {
      function Container(_a) {
          var _this = this;
          var containerId = _a.containerId, iframeId = _a.iframeId, webWindow = _a.webWindow, webWidget = _a.webWidget;
          this.show = function (withCloseBtn) {
              if (withCloseBtn === void 0) { withCloseBtn = false; }
              var containerElem = getElementById({ webWindow: _this.webWindow, elementId: _this.containerId });
              containerElem.style.display = 'flex';
              if (withCloseBtn) {
                  var closeBtnElem = getElementById({ webWindow: _this.webWindow, elementId: _this.closeBtnId });
                  closeBtnElem.style.display = 'block';
              }
          };
          this.hide = function () {
              var element = getElementById({ webWindow: _this.webWindow, elementId: _this.containerId });
              element.style.display = 'none';
          };
          this.containerId = containerId;
          this.iframeId = iframeId;
          this.webWindow = webWindow;
          createHtmlContainer({
              containerId: this.containerId,
              iframeId: this.iframeId,
              closeBtnId: this.closeBtnId,
              webWindow: this.webWindow,
              hideContainer: this.hide,
              webWidget: webWidget,
          });
      }
      Object.defineProperty(Container.prototype, "closeBtnId", {
          get: function () {
              return "" + this.containerId + this.iframeId;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Container.prototype, "window", {
          get: function () {
              return this.webWindow;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Container.prototype, "containerElement", {
          get: function () {
              return this.webWindow.document.querySelector("#" + this.containerId);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Container.prototype, "iframeSelector", {
          get: function () {
              return "#" + this.iframeId;
          },
          enumerable: false,
          configurable: true
      });
      return Container;
  }());

  var DEFAULT_OREID_URL = 'https://service.oreid.io';
  var SUPPORTED_VERSION = '1';
  var WIDGET_DOWNLOAD_PATH = "dist/v" + SUPPORTED_VERSION + "/oreid-web-widget-core.js";
  var WIDGET_SCRIPT_ID = 'oreid-web-popup_widget--core';

  var getWebWidgetCoreFromWindow = function (_a) {
      var webWindow = _a.webWindow;
      //@ts-ignore
      var webWidgetCore = webWindow.oreidWebWidgetCore;
      if (!webWidgetCore) {
          throw new Error('webWidget not found on webWindow');
      }
      if (SUPPORTED_VERSION !== webWidgetCore.version) {
          throw new Error("webWidget " + SUPPORTED_VERSION + " is no longer supported. Please upgrade to: " + webWidgetCore.version);
      }
      return webWidgetCore;
  };

  var returnWebWidgetCoreFromWindow = function (resolve, reject, webWindow) {
      try {
          var webWidgetCore = getWebWidgetCoreFromWindow({ webWindow: webWindow });
          resolve(webWidgetCore);
      }
      catch (err) {
          reject(err);
      }
  };
  var loadWebWidgetCore = function (oreId, webWindow) {
      // return core if already loaded
      if (webWindow.document.querySelector("#" + WIDGET_SCRIPT_ID)) {
          return new Promise(function (resolve, reject) { return returnWebWidgetCoreFromWindow(resolve, reject, webWindow); });
      }
      // download webwidget script then create and return core
      var script = webWindow.document.createElement('script');
      script.async = true;
      script.defer = true;
      script.src = (oreId.options.oreIdUrl || DEFAULT_OREID_URL) + "/" + WIDGET_DOWNLOAD_PATH;
      script.id = WIDGET_SCRIPT_ID;
      webWindow.document.querySelector('body').appendChild(script);
      return new Promise(function (resolve, reject) {
          script.addEventListener('error', function () { return reject(new Error('Problem downloading ORE ID WebWidget - Server might be temporarily unavailable')); }, { once: true });
          script.addEventListener('load', function () { return returnWebWidgetCoreFromWindow(resolve, reject, webWindow); }, { once: true });
      });
  };

  var createWebWidgetCoreHandler = function (_a) {
      var webWindow = _a.webWindow, oreId = _a.oreId, containerId = _a.containerId, iframeId = _a.iframeId;
      return __awaiter(void 0, void 0, void 0, function () {
          var webWidget, container;
          return __generator(this, function (_b) {
              switch (_b.label) {
                  case 0: return [4 /*yield*/, promiseRetry_1(function (retry) { return loadWebWidgetCore(oreId, webWindow).catch(retry); }, {
                          retries: 3,
                      })];
                  case 1:
                      webWidget = _b.sent();
                      container = new Container({ containerId: containerId, iframeId: iframeId, webWindow: webWindow, webWidget: webWidget });
                      return [2 /*return*/, new WebWidgetCoreHandler({
                              oreId: oreId,
                              container: container,
                              webWidget: webWidget,
                          })];
              }
          });
      });
  };

  /** Attempt to autosign the transaction by calling the api (with no user popup)
   * Return:
   *  Sign result - auto signed sucessfully
   *  undefined - could not autosign
   */
  var autoSign = function (_a) {
      var transaction = _a.transaction;
      return __awaiter(void 0, void 0, void 0, function () {
          var canAuto;
          var _b, _c;
          return __generator(this, function (_d) {
              switch (_d.label) {
                  case 0:
                      if ((_c = (_b = transaction === null || transaction === void 0 ? void 0 : transaction.data) === null || _b === void 0 ? void 0 : _b.signOptions) === null || _c === void 0 ? void 0 : _c.preventAutosign) {
                          return [2 /*return*/, undefined];
                      }
                      return [4 /*yield*/, transaction.checkCanAutoSign()];
                  case 1:
                      canAuto = _d.sent();
                      if (!canAuto)
                          return [2 /*return*/, undefined];
                      return [2 /*return*/, transaction.autoSign()];
              }
          });
      });
  };

  var OreIdWebPopup = /** @class */ (function () {
      /**
       * * WARNING: This class should only be created using createOreIdWebWidget() never via new OreIdWebWidget()
       */
      function OreIdWebPopup(_a) {
          var _this = this;
          var oreId = _a.oreId, webWidgetCore = _a.webWidgetCore;
          var _b;
          /** Present Authentication login flow user experience */
          this.auth = function (params) { return __awaiter(_this, void 0, void 0, function () {
              var result, user;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this.webWidgetCore.render({
                              name: oreidJs.WebWidgetAction.Auth,
                              params: params,
                          })];
                      case 1:
                          result = _a.sent();
                          if (!result.accessToken) {
                              throw new Error('Access Token was not returned');
                          }
                          this.oreId.auth.setAuthResult(result);
                          return [4 /*yield*/, this.oreId.auth.user.getData()];
                      case 2:
                          user = _a.sent();
                          return [2 /*return*/, __assign(__assign({}, result), { user: user })];
                  }
              });
          }); };
          /** Present Buy flow user experience */
          this.buy = function (params) { return __awaiter(_this, void 0, void 0, function () {
              var result;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (!this.oreId.auth.accountName) {
                              throw new Error('user not logged in');
                          }
                          return [4 /*yield*/, this.webWidgetCore.render({
                                  name: oreidJs.WebWidgetAction.Buy,
                                  params: params,
                              })
                              // eslint-disable-next-line no-console
                          ];
                      case 1:
                          result = _a.sent();
                          // eslint-disable-next-line no-console
                          if (!result)
                              console.error('result was not returned.');
                          return [2 /*return*/, result];
                  }
              });
          }); };
          /** Present Sign transaction user experience */
          this.sign = function (params) { return __awaiter(_this, void 0, void 0, function () {
              var isSigningTransaction, isSigningString, transaction, wasAutoSigned, widgetParams, _a, transactionData, _b, string, signMethod, otherParams, _c, signatures, apiResult, result;
              var _d;
              return __generator(this, function (_e) {
                  switch (_e.label) {
                      case 0:
                          isSigningTransaction = !!params.transaction;
                          isSigningString = !!params.signString;
                          if (!isSigningTransaction) return [3 /*break*/, 2];
                          transaction = { transaction: params.transaction };
                          return [4 /*yield*/, autoSign(transaction)];
                      case 1:
                          wasAutoSigned = _e.sent();
                          if (wasAutoSigned) {
                              return [2 /*return*/, wasAutoSigned];
                          }
                          _e.label = 2;
                      case 2:
                          widgetParams = {};
                          // continue if not autosigned
                          if (isSigningTransaction) {
                              _a = ((_d = params === null || params === void 0 ? void 0 : params.transaction) === null || _d === void 0 ? void 0 : _d.data) || {}, _a.signedTransaction, transactionData = __rest(_a, ["signedTransaction"]);
                              // TODO: The data is compatible, but the declaration is not compatible ("strictNullChecks": true)
                              //@ts-ignore
                              widgetParams = __assign({}, transactionData);
                          }
                          else if (isSigningString) {
                              _b = (params === null || params === void 0 ? void 0 : params.signString) || {}, string = _b.string, signMethod = _b.signMethod, otherParams = __rest(_b, ["string", "signMethod"]);
                              widgetParams = __assign({ stringToSign: string }, otherParams);
                              if (signMethod)
                                  widgetParams.signStringMethod = signMethod;
                          }
                          else {
                              throw new Error('signString or transaction must be provided');
                          }
                          return [4 /*yield*/, this.webWidgetCore.render({
                                  name: oreidJs.WebWidgetAction.Sign,
                                  params: widgetParams,
                              })];
                      case 3:
                          _c = _e.sent(), signatures = _c.signatures, apiResult = __rest(_c, ["signatures"]);
                          result = __assign({}, apiResult);
                          // convert the signatures in result *base64 decoded* to JSON (an array of strings)
                          if (signatures)
                              result.signatures = JSON.parse(gBase64.decode(signatures));
                          return [2 /*return*/, result];
                  }
              });
          }); };
          /** Present New Chain Account user experience */
          this.newChainAccount = function (params) { return __awaiter(_this, void 0, void 0, function () {
              var paramsDefault, result;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (!this.oreId.auth.accountName) {
                              throw new Error('user not logged in');
                          }
                          paramsDefault = __assign(__assign({}, params), { chainNetwork: params.chainNetwork || '', accountType: params.accountType || 'native', account: this.oreId.auth.accountName });
                          return [4 /*yield*/, this.webWidgetCore.render({
                                  name: oreidJs.WebWidgetAction.NewChainAccount,
                                  params: paramsDefault,
                              })];
                      case 1:
                          result = _a.sent();
                          if (!(result === null || result === void 0 ? void 0 : result.chainAccount)) {
                              throw new Error('chainAccount was not returned.');
                          }
                          return [4 /*yield*/, this.oreId.auth.user.getData()];
                      case 2:
                          _a.sent();
                          return [2 /*return*/, { chainAccount: result.chainAccount, chainNetwork: params.chainNetwork || '' }];
                  }
              });
          }); };
          /** Present Recover Account (e.g. Reset Password) user experience */
          this.recoverAccount = function (params) { return __awaiter(_this, void 0, void 0, function () {
              var paramsWithAccount, result;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          paramsWithAccount = __assign(__assign({}, params), { account: this.oreId.auth.accountName });
                          return [4 /*yield*/, this.webWidgetCore.render({
                                  name: oreidJs.WebWidgetAction.RecoverAccount,
                                  params: paramsWithAccount,
                              })];
                      case 1:
                          result = _a.sent();
                          return [2 /*return*/, result];
                  }
              });
          }); };
          this.keyExport = function (params) { return __awaiter(_this, void 0, void 0, function () {
              var paramsWithAccount, result;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          paramsWithAccount = __assign(__assign({}, params), { account: this.oreId.auth.accountName, name: oreidJs.WebWidgetAction.KeyExport });
                          return [4 /*yield*/, this.webWidgetCore.render({
                                  name: oreidJs.WebWidgetAction.KeyExport,
                                  params: paramsWithAccount,
                              })];
                      case 1:
                          result = _a.sent();
                          return [2 /*return*/, result];
                  }
              });
          }); };
          if (((_b = oreId === null || oreId === void 0 ? void 0 : oreId.constructor) === null || _b === void 0 ? void 0 : _b.name) !== oreidJs.OreId.name) {
              throw new Error('oreId should be an instance of OreId');
          }
          if (!(webWidgetCore instanceof WebWidgetCoreHandler)) {
              throw new Error('webWidgetCore should be an instance of WebWidgetCoreHandler');
          }
          this.oreId = oreId;
          this.webWidgetCore = webWidgetCore;
      }
      return OreIdWebPopup;
  }());

  // ! This object "options" is here to allow configuration options in the future
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  var initializeOreIdWebPopup = function (options) {
      return function (oreId) { return __awaiter(void 0, void 0, void 0, function () {
          var webWindow, random, containerId, iframeId, webWidgetCore;
          var _a;
          return __generator(this, function (_b) {
              switch (_b.label) {
                  case 0:
                      // window is required only for initialization
                      if (typeof window === 'undefined') {
                          throw new Error('The window is required');
                      }
                      webWindow = window;
                      if (((_a = oreId === null || oreId === void 0 ? void 0 : oreId.constructor) === null || _a === void 0 ? void 0 : _a.name) !== oreidJs.OreId.name) {
                          throw new Error('oreId should be an instance of OreId');
                      }
                      random = Math.round(Math.random() * 100000);
                      containerId = "webwidget-oreid-container-" + random;
                      iframeId = "webwidget-oreid-iframe-" + random;
                      return [4 /*yield*/, createWebWidgetCoreHandler({ oreId: oreId, webWindow: webWindow, containerId: containerId, iframeId: iframeId })];
                  case 1:
                      webWidgetCore = _b.sent();
                      return [2 /*return*/, new OreIdWebPopup({ oreId: oreId, webWidgetCore: webWidgetCore })];
              }
          });
      }); };
  };

  // ! This object "options" is here to allow configuration options in the future
  /** ORE ID Popup User Experience for Web (including Vanilla HTML/JS, React, Vue, etc.) */
  var WebPopup = function (options) {
      return {
          init: initializeOreIdWebPopup(),
          type: oreidJs.PluginType.Popup,
          description: 'OREID Web Popup',
      };
  };

  exports.WebPopup = WebPopup;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.js.map
